## Что такое Собеседование по System Design?

**System Design** — это процесс архитектурного планирования и создания (часто интенсивно использующих **данные**) приложений, который включает в себя тщательный выбор и интеграцию различных **данных** для эффективной обработки и хранения. Этот процесс подразумевает понимание требований к приложению, выявление подходящих **data systems** для управления разнообразными задачами и использование **кода приложения (application code)** для объединения этих различных **инструментов (tools)**, чтобы они работали согласованно.

При интеграции нескольких **инструментов (tools)** для предоставления **service**, **interface** или **API** этой **service** обычно скрывает специфику реализации от **клиентов**. Таким образом, вы фактически создали новую, специализированную **data system (data system)** из меньших, универсальных **компонентов**. Эта объединенная **data system** может предоставлять определенные гарантии, такие как поддержание **cache consistency** посредством надлежащей **invalidation** или **updates**, гарантируя, что внешние **клиенты** получают согласованные **результаты**.

---

## System Design против OOP Design

|                                                            | **OOP Design** | **System Design** |
|:-----------------------------------------------------------| :---------------------------------------------------------------- | :------------------------------------------------------------------------- |
| **Пример**                                                 | Проектирование парковки, проектирование торгового автомата      | Проектирование WhatsApp, Проектирование Uber                               |
| **Проверяемые навыки (Skills tested)**                     | Написание хорошо структурированного **ООП-кода (OOP code)**, наследование классов (**class inheritance**) | **Архитектура (Architecture)**, **поток данных (dataflow)**, **масштабируемость (scalability)**, компромиссы в проектировании (**design tradeoffs**) |
| **Что просят сделать на интервью (Interviewees asked to)** | Написать **ООП-код (OOP code)**, **интерфейс класса (class interface)** и наследование (**inheritance**) и т.д. | **Архитектурные диаграммы (Architecture diagrams)**, **проектирование хранилища (storage design)**, **оценка ресурсов (resource estimates)**, обсуждение **проекта (design discussion)**, компромиссы (**tradeoffs**), глубокое погружение (**deep dive**) и т.д. |

---

## Кому необходимо проходить собеседования по System Design?

Собеседования по **System Design** являются неотъемлемой частью для различных **ролей** в области **software engineering**. Они становятся все более важными по мере того, как **инженеры** продвигаются по карьерной лестнице и берутся за более сложные **проекты (projects)** или занимают руководящие **позиции (positions)**. Следующие **специалисты (professionals)**, скорее всего, столкнутся с собеседованиями по **System Design**:

* **Опытный Инженер по Разработке Программного Обеспечения (Experienced Software Development Engineer (SDE) или Software Engineer (SWE))**: По мере накопления **опыта (experience)**, **инженеры** часто сталкиваются с задачами по проектированию и **архитектуре** сложных **систем**, что делает **навыки** **System Design** крайне важными. Эти собеседования оценивают их **способность** разбивать **проблемы**, выбирать подходящие **технологии** и создавать **масштабируемые (scalable)** и **эффективные (efficient)** **решения (solutions)**. На этом **уровне (level)**, **техническое собеседование (tech interview)** часто представляет собой комбинацию вопросов в стиле **LeetCode** и вопросов по **System Design**.
* **Инженерный Менеджер (Engineering Manager (EM, SDM))**: **Инженерные менеджеры (Engineering Managers)** отвечают за руководство **командами (teams)** **инженеров** в разработке и выполнении **программных проектов (software projects)**. Они должны обладать глубоким пониманием **принципов (principles)** **System Design**, чтобы принимать обоснованные **решения (decisions)** и обеспечивать успешную реализацию **проектов (projects)**. Собеседования по **System Design** помогают оценить их **технические знания (technical knowledge)** и **лидерские качества (leadership skills)**.
* **Технический Менеджер Проекта (Technical Program Manager (TPM))**: **TPM** отвечают за надзор за планированием, выполнением и реализацией **технических проектов (technical projects)**. Они должны понимать тонкости **System Design**, чтобы эффективно координировать **ресурсы (resources)** и управлять **проектными рисками (project risks)**. Собеседования по **System Design** могут помочь оценить их **техническую экспертизу (technical expertise)** и **способность** управлять сложными **проектами (projects)**.

---

## Что мы Проектируем и Какие Навыки Мне Нужны?

**System Design** — это процесс проектирования сложной **системы** для удовлетворения конкретных **требований** и **целей (goals)**, обычно направленных на предоставление **service** **конечному пользователю (end user)**. Для достижения этой цели мы собираем различные **технологии** и **компоненты** для создания согласованной и функциональной **системы**.

Когда мы занимаемся **System Design**, мы фокусируемся на проектировании следующих аспектов:

* **Services**: Это включает различные **компоненты**, **приложения** и **API**, которые предоставляют определенную **функциональность** или **возможности обработки**. **Services** могут быть спроектированы как **монолиты (monoliths)** или, что чаще, как **микросервисы (microservices)** для обеспечения лучшей **масштабируемости (scalability)**, **удобства обслуживания (maintainability)** и **гибкости (flexibility)**.
* **Поток данных (Dataflow)**: Проектирование **потока данных (dataflow)** внутри и между **services** имеет решающее значение для обеспечения эффективной **processing**, своевременной **связи** и точных **результатов**. Это включает понимание **форматов данных**, **протоколов** и **шаблонов связи**, используемых между **services**.
* **Хранение (Storage)**: **Проектирование хранилища (storage design)** включает **базы данных (databases)**, **кэши (caches)** и **файловые системы (file systems)**, необходимые для хранения и управления **данными** по всей **системы**. Это включает выбор подходящих **технологий хранения (storage technologies)**, **моделирования данных (data modeling)** и обеспечения **согласованности (consistency)** и **долговечности данных (data durability)**.

### Функциональные Требования (Functional Requirements)

**Функциональные требования (Functional requirements)** — это **функции** и **возможности**, которыми должна обладать **система** для выполнения своего предназначения. Они описывают, что **система** должна делать, и сосредоточены на конкретных **задачах** или **функциональных возможностях**, которые **система** должна выполнять. **Функциональные требования (Functional requirements)** часто выводятся из **потребностей пользователя**, **бизнес-целей (business objectives)** или **спецификаций системы (system specifications)**.

Примеры **функциональных требований (functional requirements)** включают:

* **Действия пользователя (User actions)**: Описание **действий**, которые **пользователь** может выполнять в **системы**, таких как создание **учетной записи**, вход в **систему** или отправка **формы**.
* **Ввод и обработка данных (Data input and processing)**: Определение того, как **система** должна обрабатывать, **манипулировать (manipulate)** или **преобразовывать (transform)** **данные** на основе **ввода пользователя** или других **источников**.

**Функциональные требования (Functional requirements)** обычно документируются и доводятся до **разработчиков** и **заинтересованных сторон** в различных **форматах**, таких как **документы с требованиями проекта**. Эти **требования** помогают направлять **процесс разработки** и гарантировать, что конечный **продукт ** соответствует намеченным **целям** и обеспечивает желаемую **функциональность**.

### Нефункциональные Требования (Non-functional Requirements)

Помимо обеспечения **функциональной работы (functionally work)**, мы также должны убедиться, что **система** удовлетворяет **нефункциональным требованиям (non-functional requirements)**, наиболее заметными из которых являются:

* **Масштабируемость (Scalability)**: Хорошо спроектированная **система** должна быть способна обрабатывать возрастающие **объемы работы (amounts of work)** или **пользователей** без ущерба для **производительности **. Это включает **проектирование** для **горизонтального (horizontal)** и **вертикального масштабирования (vertical scaling)**, оптимизацию **использования ресурсов (resource usage)** и планирование **будущего роста (future growth)**.
* **Доступность (Availability)**: **Высокая доступность (High availability)** необходима для обеспечения того, чтобы **система** могла продолжать **функционировать** даже перед лицом **сбоев**, таких как **проблемы с оборудованием (hardware)** или **сетью (network issues)**. Это требует **проектирования** для **избыточности (redundancy)**, **механизмов аварийного переключения (failover mechanisms)** и **мониторинга работоспособности системы**.
* **Производительность (Performance) (задержка (latency) и пропускная способность (throughput))**: **Задержка (Latency)** относится ко времени, затрачиваемому на ответ на **запросы**, тогда как **пропускная способность (throughput)** — это объем **работы** или **транзакций**, которые **система** может обработать за определенный промежуток **времени**.

Помимо этих основных **нефункциональных требований (non-functional requirements)**, существуют также **надежность (reliability)** (**service** возвращает правильные **результаты**), **согласованность (consistency)** (**данные** согласованы между **services**) и **эффективность (efficiency)** (**service** должна иметь минимальные избыточные **операции (operations)**).


