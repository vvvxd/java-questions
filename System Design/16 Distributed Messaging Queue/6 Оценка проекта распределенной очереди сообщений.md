# Оценка проекта распределенной очереди сообщений

Оцените предложенную систему на основе функциональных и нефункциональных требований к распределенной очереди сообщений.

Мы завершили процесс проектирования распределенной очереди сообщений. Теперь давайте проанализируем, соответствует ли наш проект
функциональным и нефункциональным требованиям к распределенной очереди сообщений.

## <a id="функциональные-требования"></a>Функциональные требования

* **Создание и удаление очереди:**
  Когда запрос на создание очереди поступает на front-end, очередь создается со всеми необходимыми деталями, предоставленными клиентом,
  после прохождения некоторых обязательных проверок. Соответствующий менеджер кластера назначает серверы для вновь созданной очереди и
  обновляет информацию в хранилищах метаданных и кэшах через сервис метаданных.

  Аналогичным образом, очередь удаляется, когда клиент в ней больше не нуждается. Ответственный менеджер кластера освобождает пространство,
  занимаемое очередью, и, следовательно, удаляет данные из всех хранилищ метаданных и кэшей.

> **Вопрос на размышление**
> 1. Как мы обрабатываем сообщения, которые не могут быть обработаны (то есть потреблены) после максимального количества попыток со стороны
     потребителя?
> <details>
>  <summary><b>Показать</b></summary>
> Для обработки сообщений, которые не были использованы после того, как потребителем было предпринято максимальное количество попыток обработки, может быть предусмотрен специальный тип очереди, называемый "отложенной очередью" (dead-letter queue). Этот тип очереди также используется для хранения сообщений, которые не могут быть успешно обработаны из-за следующих факторов:
>
> Сообщения, предназначенные для очереди, которой больше не существует.
>
> Превышен лимит длины очереди, хотя это редко случается при нашем текущем дизайне.
>
> Срок действия сообщения истекает из-за времени ожидания для каждого сообщения (TTL).
> Наличие очереди с отложенными заявками также важно для определения причины сбоя и выявления неисправностей в системе.
>  </details>

* **Отправка и получение сообщений:**
  Производители могут доставлять сообщения в определенные очереди после их создания. На back-end поступающие сообщения сортируются по
  временным меткам для сохранения их порядка и помещаются в очередь. Аналогично, потребитель может извлекать сообщения из указанной очереди.

  Когда от производителя поступает сообщение для определенной очереди, front-end определяет основной хост или кластер (в зависимости от
  модели репликации), где находится очередь. Затем запрос перенаправляется соответствующей сущности и помещается в очередь.

* **Удаление сообщений:** В основном для удаления сообщения из очереди используются два варианта.

    1. Первый вариант — не удалять сообщение после его потребления. Однако в этом случае потребитель сам отвечает за отслеживание того, что
       было потреблено. Для этого нам нужно поддерживать порядок сообщений в очереди и отслеживать конкретное сообщение в ней. Специальная
       задача (job) может затем удалить сообщение, когда истекут условия его хранения. Этот подход в основном используется в Apache Kafka,
       где одно сообщение может быть потреблено несколькими процессами.

    2. Второй подход также не удаляет сообщение после его потребления. Однако оно делается невидимым на некоторое время с помощью атрибута,
       например, `visibility_timeout`. Таким образом, другие потребители не могут получить уже потребленные сообщения. Сообщение затем
       удаляется потребителем через вызов API.

  В обоих случаях сообщение, полученное потребителем, удаляется только им самим. Причина этого — обеспечение высокой долговечности на
  случай, если потребитель не сможет обработать сообщение из-за какого-либо сбоя. В таком случае, при отсутствии вызова на удаление,
  потребитель сможет снова получить сообщение, когда вернется в рабочее состояние.

  Более того, этот подход также обеспечивает семантику доставки **«как минимум один раз» (at-least-once delivery)**. Например, когда один
  воркер не может обработать сообщение, другой воркер может получить его после того, как оно снова станет видимым в очереди.

> **Вопрос на размышление**
> 1. Что произойдет, если таймаут видимости конкретного сообщения истечет, а потребитель все еще занят его обработкой?
> <details>
>  <summary><b>Показать</b></summary>
> Сообщение становится видимым, и другой worker может получить сообщение, тем самым дублируя обработку. Чтобы избежать такой ситуации, мы гарантируем, что приложение установит безопасный порог для тайм-аута видимости.
>  </details>

## <a id="нефункциональные-требования"></a>Нефункциональные требования

* **Долговечность (Durability):** Для достижения долговечности метаданные очередей реплицируются на разных узлах. Аналогично, когда
  сообщение получено, оно реплицируется в очередях, находящихся на разных узлах. Таким образом, если один узел выйдет из строя, для доставки
  или извлечения сообщений можно использовать другие узлы.

* **Масштабируемость (Scalability):** Компоненты нашего проекта, такие как front-end серверы, серверы метаданных, кэши, back-end кластеры и
  другие, являются горизонтально масштабируемыми. Мы можем добавлять или удалять их мощности в соответствии с нашими потребностями.
  Масштабируемость можно разделить на два аспекта:

    1. **Увеличение количества сообщений:** Когда количество сообщений достигает определенного предела — скажем, 80% — указанная очередь
       расширяется. Аналогично, очередь сжимается, когда количество сообщений падает ниже определенного порога.

    2. **Увеличение количества очередей:** С ростом числа очередей возрастает и потребность в большем количестве серверов, и в этом случае
       менеджер кластера отвечает за добавление дополнительных серверов. Мы выделяем узлы таким образом, чтобы обеспечить изоляцию
       производительности между различными очередями. Увеличение нагрузки на одну очередь не должно влиять на другие очереди.

* **Доступность (Availability):** Наши компоненты данных, метаданные и фактические сообщения, должным образом реплицируются внутри или вне
  центра обработки данных, а балансировщик нагрузки направляет трафик в обход вышедших из строя узлов. Вместе эти механизмы гарантируют, что
  наша система остается доступной для обслуживания при сбоях.

* **Производительность (Performance):** Для повышения производительности мы используем кэши, репликацию данных и партиционирование, что
  сокращает время чтения и записи данных. Кроме того, для увеличения пропускной способности и снижения задержки при необходимости можно
  использовать стратегию упорядочивания сообщений по принципу "наилучших усилий" (best effort). В случае строгого упорядочивания мы также
  предлагаем сортировку на основе временных окон для потенциального снижения задержки.

> 1. Как можно использовать распределенную очередь обмена сообщениями в онлайн-играх?
> <details>
>  <summary><b>Показать</b></summary>
>  В многопользовательской онлайн-игре распределенная очередь сообщений используется для управления действиями игроков в режиме реального времени путем сбора данных о таких действиях, как перемещение и атаки, и преобразования их в сообщения. Эти сообщения помещаются в очередь и затем рассылаются соответствующим игровым серверам или клиентам, гарантируя, что каждый компонент получает необходимые обновления. Серверы или клиенты обрабатывают эти сообщения в режиме FIFO, чтобы обновить состояние игры, поддерживая согласованность во всем игровом мире.
>
>  Важнейшие требования к этому сценарию включают низкую задержку для обеспечения оперативности реагирования в режиме реального времени, высокую доступность, чтобы игра могла работать плавно и без перебоев, способность обрабатывать пакеты сообщений в часы пик и надежную доставку сообщений для предотвращения потери важных действий.
>
>  Кроме того, очереди обмена сообщениями помогают разделить компоненты, повысить устойчивость и поддерживать правильную последовательность действий, что жизненно важно для бесперебойной работы в многопользовательском режиме
>  </details>


## <a id="заключение"></a>Заключение

Мы обсудили множество тонкостей при проектировании FIFO-очереди в распределенной среде. Мы увидели, что существует компромисс между строгим
порядком создания и извлечения сообщений и достижимой пропускной способностью и задержкой. Ослабленный порядок дает нам более высокую
пропускную способность и меньшую задержку. Требование строгого порядка заставляет систему выполнять дополнительную работу для обеспечения
упорядочивания на основе реального времени (wall-clock) или причинно-следственных связей. Мы используем различные хранилища данных с
соответствующей репликацией и партиционированием для масштабирования данных. Это упражнение по проектированию подчеркивает, что структура,
простая для реализации в системе на базе одной ОС, такая как очередь производитель-потребитель, становится гораздо сложнее в распределенной
среде.