### Проектирование хранилища «ключ-значение»

Узнайте о функциональных и нефункциональных требованиях и проектировании API хранилища «ключ-значение».

### Требования

Давайте перечислим требования к проектированию хранилища «ключ-значение», чтобы преодолеть проблемы традиционных баз данных.

### Функциональные требования

Обычно от хранилищ «ключ-значение» ожидают наличия таких функций, как `get` (получить) и `put` (поместить). Однако то, что отличает эту конкретную систему хранилища «ключ-значение», — это ее особые характеристики, которые объясняются ниже:

*   **Настраиваемый сервис:** Некоторые приложения могут предпочесть пожертвовать строгой согласованностью ради более высокой доступности. Нам необходимо предоставить настраиваемый сервис, чтобы разные приложения могли использовать различные модели согласованности. Нам нужен строгий контроль над компромиссами между доступностью, согласованностью, экономической эффективностью и производительностью.

    **Примечание:** Такие настройки могут быть выполнены только при создании нового экземпляра хранилища «ключ-значение» и не могут быть изменены динамически во время работы системы.

*   **Возможность записи в любое время (когда мы выбираем «A» вместо «C» в контексте теоремы CAP):** Приложения должны всегда иметь возможность производить запись в хранилище «ключ-значение». Если пользователю требуется строгая согласованность, это требование не всегда может быть выполнено из-за ограничений теоремы CAP.

    **Примечание:** Контекст задачи определяет, что будет классифицировано как функциональное требование, а что — как нефункциональное. Например, возможность записи в любое время (высокая доступность) является функциональным требованием для приложения корзины покупок Amazon, в то время как в других случаях высокая доступность может считаться нефункциональным требованием. Вдохновляясь хранилищем «ключ-значение» Dynamo от Amazon, мы можем классифицировать возможность записи в любое время как функциональное требование.

*   **Гетерогенность оборудования:** Мы хотим бесшовно добавлять в наш кластер новые серверы с иными и более высокими мощностями, не изменяя и не обновляя существующие серверы. Наша система должна уметь адаптироваться к серверам разной мощности и использовать их преимущества, обеспечивая правильную работу основных функций (`get` и `put`) и сбалансированное распределение нагрузки в соответствии с мощностью каждого сервера. Это требует одноранговой (peer-to-peer) архитектуры без выделенных узлов.

### Нефункциональные требования

Нефункциональные требования следующие:

*   **Масштабируемость:** Хранилища «ключ-значение» должны работать на десятках тысяч серверов, распределенных по всему миру. Крайне желательна инкрементальная масштабируемость. Мы должны иметь возможность добавлять или удалять серверы по мере необходимости с минимальными или нулевыми перебоями в доступности сервиса. Кроме того, наша система должна быть способна обслуживать огромное количество пользователей хранилища «ключ-значение».

*   **Отказоустойчивость:** Хранилище «ключ-значение» должно работать без перебоев, несмотря на сбои в серверах или их компонентах.


> Теперь, когда вы понимаете функциональные и нефункциональные требования к хранилищу «ключ-значение», как вы думаете, каковы ключевые различия между хранилищами «ключ-значение» и традиционными базами данных?

 В каких сценариях хранилища «ключ-значение» особенно выгодны?

<details>
    <summary>Ответ</summary>

Хранилища ключ-значение - это базы данных, которые хранят данные в виде набора пар ключ-значение, ориентируясь на простой поиск по ключу. Обычно в них отсутствуют сложные языки запросов, и часто приоритет отдается доступности и масштабируемости, а не строгой согласованности, особенно в распределенных системах. Хранимые данные обычно неструктурированы или полуструктурированы частично.

Традиционные реляционные базы данных, с другой стороны, организуют данные в таблицы с предопределенными схемами, поддерживая сложные запросы, объединения и транзакции с надежными гарантиями согласованности.

Хранилища ключей и значений особенно полезны в сценариях, требующих высокоскоростного поиска, обработки больших объемов данных или когда структура данных является гибкой или не полностью известна заранее. В качестве примеров можно привести кэширование, управление сеансами и аналитику в режиме реального времени.
</details>


 Почему нам нужно запускать хранилища «ключ-значение» на нескольких серверах?
<details>
    <summary>Ответ</summary>
Хэш-таблица на основе одного узла может не работать по одной или нескольким из следующих причин:

Независимо от того, насколько большой у нас сервер, он не может соответствовать требованиям к хранилищу данных и запросам.

Выход из строя этого единственного мегасервера приведет к простою обслуживания для всех.

Таким образом, хранилища ключей и значений должны использовать множество серверов для хранения и извлечения данных.

</details>

### Допущения

Чтобы упростить наш проект, мы сделаем следующие допущения:

*   Центры обработки данных, на которых размещен сервис, считаются доверенными (не враждебными).
*   Вся необходимая аутентификация и авторизация уже выполнены.
*   Запросы и ответы пользователей передаются по протоколу HTTPS.

### Проектирование API

Хранилища «ключ-значение», как и обычные хеш-таблицы, предоставляют две основные функции: `get` (получить) и `put` (поместить).

Давайте рассмотрим дизайн API.

### Функция `get`

Вызов API для получения значения должен выглядеть так:
`get(key)`

Мы возвращаем связанное значение на основе параметра `key`. Когда данные реплицированы, система находит реплику объекта, связанную с определенным ключом, что скрыто от конечного пользователя. Это делается системой, если хранилище настроено на более слабую модель согласованности данных. Например, при согласованности в конечном счете (eventual consistency) для одного ключа может быть возвращено более одного значения.

| Параметр | Описание                                             |
| :------- | :--------------------------------------------------- |
| `key`    | Ключ, по которому мы хотим получить значение.        |

### Функция `put`

Вызов API для помещения значения в систему должен выглядеть так:
`put(key, value)`

Эта функция сохраняет значение, связанное с ключом. Система автоматически определяет, куда следует поместить данные. Кроме того, система часто хранит метаданные о сохраненном объекте. Такие метаданные могут включать версию объекта.

| Параметр | Описание                                             |
| :------- | :--------------------------------------------------- |
| `key`    | Ключ, по которому мы должны сохранить значение.      |
| `value`  | Объект, который нужно сохранить по указанному ключу. |


Мы часто храним хеши значения (а иногда и значения + связанного с ним ключа) в качестве метаданных для проверки целостности данных. Следует ли вычислять такой хеш после сжатия или шифрования данных, или же до этих операций?

<details>
    <summary>Ответ</summary>

Правильный ответ может зависеть от конкретного приложения. Тем не менее, мы можем использовать хэши как до, так и после любого сжатия или шифрования. Но нам нужно будет делать это последовательно для операций put и get.
</details>

### Тип данных

Ключ в хранилище «ключ-значение» часто является первичным ключом, в то время как значением могут быть любые произвольные двоичные данные.

**Примечание:** Dynamo использует хеши MD5 от ключа для генерации 128-битного идентификатора. Эти идентификаторы помогают системе определить, какой узел сервера будет отвечать за данный конкретный ключ.

В следующем уроке мы узнаем, как проектировать наше хранилище «ключ-значение». Сначала мы сосредоточимся на добавлении в нашу систему масштабируемости, репликации и версионирования данных. Затем мы обеспечим выполнение функциональных требований и сделаем нашу систему отказоустойчивой. Мы сначала выполним некоторые из наших нефункциональных требований, потому что реализация функциональных требований зависит от метода, выбранного для обеспечения масштабируемости.

**Примечание:** Эта глава основана на Dynamo, которая является влиятельной работой в области хранилищ «ключ-значение».