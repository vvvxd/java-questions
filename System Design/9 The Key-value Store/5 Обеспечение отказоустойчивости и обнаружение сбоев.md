### Обеспечение отказоустойчивости и обнаружения сбоев

Узнайте, как сделать хранилище «ключ-значение» отказоустойчивым и способным обнаруживать сбои.

### Обработка временных сбоев

Как правило, распределенные системы используют подход, основанный на кворуме, для обработки сбоев. Кворум — это минимальное количество
голосов, необходимое для выполнения операции распределенной транзакции. Если сервер, участвующий в консенсусе, не работает, то мы не можем
выполнить требуемую операцию. Это влияет на доступность и долговечность нашей системы.

Мы будем использовать гибкий кворум вместо строгого кворума. Обычно лидер управляет коммуникацией между участниками консенсуса. Участники
отправляют подтверждение после успешного выполнения записи. Получив эти подтверждения, лидер отвечает клиенту. Однако недостатком является
то, что участники легко подвержены сбоям в сети. Если лидер временно недоступен и участники не могут до него добраться, они объявляют
лидера "мертвым". Теперь необходимо переизбрать нового лидера. Такие частые выборы негативно сказываются на производительности, поскольку
система тратит больше времени на выбор лидера, чем на выполнение реальной работы.

При гибком кворуме первые `n` работоспособных узлов из списка предпочтений обрабатывают все операции чтения и записи. `n` работоспособных
узлов не всегда могут быть первыми `n` узлами, найденными при движении по часовой стрелке в кольце согласованного хеширования.

Рассмотрим следующую конфигурацию с `n = 3`. Если узел `A` временно недоступен во время операции записи, запрос отправляется следующему
работоспособному узлу из списка предпочтений, которым в данном случае является узел `D`. Это обеспечивает желаемую доступность и
долговечность. После обработки запроса узел `D` включает подсказку о том, какой узел был предполагаемым получателем (в данном случае, `A`).
Как только узел `A` снова заработает, узел `D` отправляет информацию о запросе узлу `A`, чтобы тот мог обновить свои данные. По завершении
передачи `D` удаляет этот элемент из своего локального хранилища, не влияя на общее количество реплик в системе.

1) Предположим, у нас есть семь узлов в нашем кольце и список предпочтений этих
   узлов
![Image 1](img/image_41edd911-c238-44d4-b706-500b11bbf64b.svg)


2) Поступает запрос, и узел A обрабатывает его, поскольку он является следующим узлом в кольце. Узел обрабатывается при движении по часовой стрелке

![Image 2](img/image_a9b43de4-e4ef-4061-ac14-a18d4bd47de0.svg)


3) Узел A выходит из строя из-за некоторого сбоя
![Image 3](img/image_e300ad7f-35b4-4844-8a49-ed8adb3607f9.svg)


4) Поступает запрос. Узел A должен обработать его, но не может, поэтому мы проверяем следующий узел в списке предпочтений
![Image 4](img/image_5dbeff13-646a-4040-aea0-ea3a0092462a.svg)


5) Запрос отправляется узлу D, когда узел A не работает
![Image 5](img/image_ee352ca0-a5db-439b-8b9f-731b6485909b.svg)

Этот подход называется **передача с подсказкой (hinted handoff)**. Используя его, мы можем гарантировать выполнение операций чтения и записи
в случае временного сбоя узла.

> **Примечание**: Высокодоступная система хранения должна справляться со сбоями центров обработки данных из-за отключения электроэнергии,
> сбоев охлаждения, сбоев в сети или стихийных бедствий. Для этого мы должны обеспечить репликацию между центрами обработки данных. Таким
> образом, если один центр обработки данных выйдет из строя, мы сможем восстановить данные из другого.

> 
> Каковы ограничения использования передачи с подсказкой?
><details>
>    <summary>Ответ</summary>
>    Минимальный отток участников системы и временные сбои узлов идеально подходят для передачи данных с подсказками. Однако при определенных обстоятельствах реплики с подсказками могут стать недоступными до восстановления на исходном узле-реплике.
></details>
---

<h2 id="handle-permanent-failures">Обработка постоянных сбоев</h2>

В случае постоянных сбоев узлов мы должны поддерживать синхронизацию наших реплик, чтобы сделать систему более долговечной. Нам необходимо
ускорить обнаружение несоответствий между репликами и уменьшить объем передаваемых данных. Для этого мы будем использовать деревья Меркла.

В **дереве Меркла** значения отдельных ключей хешируются и используются в качестве листьев дерева. В родительских узлах, расположенных выше
по дереву, находятся хеши их дочерних узлов. Каждая ветвь дерева Меркла может быть проверена независимо, без необходимости загружать все
дерево или весь набор данных. При проверке несоответствий между копиями деревья Меркла уменьшают объем данных, которые необходимо
обменивать. Синхронизация не требуется, если, например, хеш-значения корней двух деревьев одинаковы и их листовые узлы также одинаковы. Пока
процесс не дойдет до листьев дерева, хосты могут определять ключи, которые не синхронизированы, когда узлы обмениваются хеш-значениями
дочерних узлов. Дерево Меркла — это механизм для реализации анти-энтропии, то есть для поддержания согласованности всех данных. Это
сокращает передачу данных для синхронизации и количество обращений к дискам в процессе анти-энтропии.

Следующие слайды объясняют, как работают деревья Меркла:

1) Рассчитайте хэши для всех ключей. Хэши будут листовыми узлами![Изображение 1](img/image_8a786d71-2584-48ef-a311-38a1cc72ce2f.svg)
2) Хэши узлов H1 и H2 рассчитываются и сохраняются как их родительский узел![Изображение 2](img/image_f54d1f80-a478-48d5-87fa-9613503d97f7.svg)
3) Хэши узлов H3 и H4 рассчитываются и сохраняются как их родительский узел![Изображение 3](img/image_1c6200fa-9865-4603-9bf7-e35a4bb58c20.svg)
4) Хэши всех остальных узлов рассчитываются и сохраняются как их родительский узел![Изображение 4](img/image_80921b7e-568e-47a5-bc6a-298cb2cb11b0.svg)
5) Хэши узлов H1-2 и H3-4 рассчитываются и сохраняются как их родительский узел. То же самое делается для H5-6 и H7-8![Изображение 5](img/image_f7e101bc-6c00-4914-8a6b-d003575d2c52.svg)
6) Мы дублируем нечетный узел![Изображение 6](img/image_0d3b8fc3-6cb4-48d9-8ba4-045c366d79fa.svg)
7) Рассчитайте хэш обоих узлов (оригинального и его дубликата) и сохраните его как родительский узел![Изображение 7](img/image_011407a9-c5fe-4ad7-bc44-fd1bf82676dc.svg)
8) Рассчитайте хэш узлов и сохраните его как родительский узел![Изображение 8](img/image_aded84cc-37de-4778-9dac-f69a99fd11f5.svg)
9) Рассчитайте хэш последних двух узлов и сохраните его как корневой узел![Изображение 9](img/image_dcd2236f-9492-40b5-b183-95195cc5469e.svg)
10) Предположим, значение K2 обновлено. Его хэш будет пересчитан![Изображение 10](img/image_d5e35c5a-6182-4557-9571-5b3488338210.svg)
11) Хэш родительского узла также будет пересчитан и обновлен![Изображение 11](img/image_f7b4b0d6-ca66-411b-bb61-2e67feb07d81.svg)
12) Хэш родительского узла также будет пересчитан и обновлен![Изображение 12](img/image_2f8f9518-72a1-4480-812a-b2c060d2a59e.svg)
13) Хэш родительского узла также будет пересчитан и обновлен![Изображение 13](img/image_df1b80c7-ff72-43f8-90e0-d59221de6908.svg)
14) Хэш корневого узла также будет пересчитан и обновлен![Изображение 14](img/image_c9216071-4b43-49c5-98bc-b221192ae1a5.svg)


<h3 id="anti-entropy-with-merkle-trees">Анти-энтропия с использованием деревьев Меркла</h3>

Каждый узел поддерживает отдельное дерево Меркла для диапазона ключей, которые он хранит для каждого виртуального узла. Узлы могут
определить, верны ли ключи в заданном диапазоне. Между двумя узлами происходит обмен корнем дерева Меркла, соответствующего общим диапазонам
ключей. Мы выполним следующее сравнение:

1. Сравнить хеши корневого узла деревьев Меркла.
2. Если они одинаковы, не продолжать.
3. Рекурсивно обойти левых и правых дочерних узлов. Узлы определяют, есть ли у них какие-либо различия, и выполняют необходимую
   синхронизацию.

Следующие слайды более подробно объясняют, как работают деревья Меркла.

> **Примечание**: Мы предполагаем, что определенные диапазоны являются гипотетическими для целей иллюстрации.

1) Предположим, у нас есть виртуальные узлы A и B в кольце  
   ![Изображение 1](img/image_ba7a3195-436f-4540-b99e-aa7705ca4435.svg)

2) Диапазоны, которые покрывает каждый виртуальный узел, определены  
   ![Изображение 2](img/image_8fee40f8-d746-47e6-be82-8ff6cc4e3087.svg)

3) Диапазоны, которые покрывает каждый виртуальный узел, определены в виде таблицы  
   ![Изображение 3](img/image_ea5f6f15-b136-446e-86bd-df46fda92db2.svg)

4) Дерево Меркла для узла A  
   ![Изображение 4](img/image_3be248dd-a226-404d-abea-7735e4f2f8e2.svg)

5) Дерево Меркла для узла B  
   ![Изображение 5](img/image_193d58d6-8cd0-4348-a607-94070039fad0.svg)

6) Предположим, добавлен новый виртуальный узел N8 для узла A, и диапазоны соответственно обновлены  
   ![Изображение 6](img/image_ff641124-5eba-4db9-9c09-44a5b791f981.svg)

7) Обновленные диапазоны, которые покрывает каждый виртуальный узел, определены в виде таблицы  
   ![Изображение 7](img/image_69291e13-2138-45cb-b26e-ae3847b1e527.svg)

8) Обновленное дерево Меркла для узла A  
   ![Изображение 8](img/image_eadfa7b8-7954-45a0-9ecd-a1ad400c2911.svg)

9) Обновленное дерево Меркла для узла B  
   ![Изображение 9](img/image_cef90194-ad5f-4847-991e-9ceb8ba96b5f.svg)

Преимущество использования деревьев Меркла заключается в том, что каждая ветвь дерева может быть проверена независимо, без необходимости
загрузки узлами всего дерева или полного набора данных. Это уменьшает объем данных, которые необходимо обменивать для синхронизации, и
количество обращений к диску, необходимых в процессе анти-энтропии.

Недостатком является то, что при присоединении или уходе узла из системы хеши дерева пересчитываются, поскольку затрагиваются несколько
диапазонов ключей.

Мы хотим, чтобы наши узлы могли обнаруживать сбои других узлов в кольце, так что давайте посмотрим, как мы можем добавить это в наш
предлагаемый дизайн.

> Обсудите последствия для масштабируемости и отказоустойчивости при использовании согласованного хеширования в распределенных хранилищах
> «ключ-значение».

---

<h2 id="promote-membership-in-the-ring-to-detect-failures">Использование членства в кольце для обнаружения сбоев</h2>

Узлы могут быть в офлайне на короткие периоды, но они также могут уйти в офлайн на неопределенный срок. Мы не должны перебалансировать
назначения разделов или исправлять недоступные реплики, когда выходит из строя один узел, потому что это редко является постоянным уходом.
Поэтому добавление и удаление узлов из кольца следует производить осторожно.

Плановый ввод в эксплуатацию и вывод из эксплуатации узлов приводит к изменениям в членстве. Эти изменения формируют историю. Они постоянно
записываются в хранилище каждого узла и согласовываются между членами кольца с помощью gossip-протокола. **Gossip-протокол** также
поддерживает в конечном итоге согласованное представление о членстве. Когда два узла случайно выбирают друг друга в качестве пиров, оба узла
могут эффективно синхронизировать свои сохраненные истории членства.

Давайте узнаем, как работает gossip-протокол, на следующем примере. Допустим, узел `A` запускается впервые, и он случайным образом добавляет
узлы `B` и `E` в свой набор токенов. Набор токенов содержит виртуальные узлы в пространстве согласованного хеширования и сопоставляет узлы с
их соответствующими наборами токенов. Эта информация хранится локально на дисковом пространстве узла.

Теперь узел `A` обрабатывает запрос, который приводит к изменению, и сообщает об этом узлам `B` и `E`. Другой узел, `D`, имеет в своем
наборе токенов `C` и `E`. Он вносит изменение и сообщает об этом `C` и `E`. Другие узлы выполняют тот же процесс. Таким образом, каждый узел
в конечном итоге узнает информацию о каждом другом узле. Это эффективный способ асинхронного обмена информацией, который не занимает много
пропускной способности.

1) Набор узлов в кольце  
   ![Изображение 1](img/image_f0c859cd-4186-46e9-a162-587c0da11740.svg)

2) Узел A обрабатывает запрос. Его набор токенов включает B и E  
   ![Изображение 2](img/image_a866aa10-b4ef-4b2e-a34d-9efc66114f65.svg)

3) Узел A передает информацию о членстве узлам B и E после нескольких запросов  
   ![Изображение 3](img/image_2b0632e4-f17e-44e7-bb11-3c9e9c0eaada.svg)

4) Узел D обрабатывает запрос. Его набор токенов включает C и E  
   ![Изображение 4](img/image_432c568d-84d7-4690-b01f-05a53ba44bbe.svg)

5) Узел D передает информацию о членстве узлам C и E после нескольких запросов  
   ![Изображение 5](img/image_7e2a551a-bb45-4447-9222-16149f5a6581.svg)

> ### Темы для размышления
> 1. Учитывая наш подход с согласованным хешированием, может ли gossip-протокол дать сбой?
> <details>
>     <summary>Ответ</summary>
> Да, протокол на основе слухов может дать сбой. Например, виртуальный узел N1N1 узла AA хочет быть добавленным в кольцо. Администратор спрашивает N2N2, который также является виртуальным узлом AA. В таком случае оба узла считают себя частью кольца и не будут знать, что они являются одним и тем же сервером. Если будет сделано какое-либо изменение, оно будет продолжать обновлять само себя, что является неправильным. Это называется логическим разделением.
>
> Протокол на основе слухов работает, когда все узлы в кольце соединены в одном графе (то есть имеют одну связную компоненту в графе). Это подразумевает, что существует путь от любого узла к любому другому узлу (возможно, через различные промежуточные узлы). Различные проблемы, такие как высокая текучесть (появление и исчезновение узлов), проблемы с сопоставлением виртуальных узлов физическим узлам и т.д., могут создать ситуацию, аналогичную той, когда реальная сеть разделила некоторые узлы от остальных, и теперь обновления из одного набора не будут достигать другого. Поэтому одного лишь наличия протокола на основе слухов недостаточно для правильного распространения информации; также необходимо поддерживать топологию в хорошем, связанном состоянии.
> </details>

Децентрализованные протоколы обнаружения сбоев используют gossip-протокол, который позволяет каждому узлу узнавать о добавлении или удалении
других узлов. Методы `join` и `leave` прибывающих или уходящих узлов явно уведомляют другие узлы о постоянных добавлениях и удалениях узлов.
Отдельные узлы обнаруживают временные сбои узлов, когда им не удается связаться с другим узлом. Если узел не может связаться ни с одним из
узлов, присутствующих в его наборе токенов, в течение установленного времени, он сообщает администраторам, что узел "мертв".

---

<h2 id="conclusion">Заключение</h2>

Хранилище «ключ-значение» обеспечивает гибкость и позволяет нам масштабировать приложения с неструктурированными данными. Веб-приложения
могут использовать хранилища «ключ-значение» для хранения информации о сессии пользователя и его предпочтениях. При использовании ключа
пользователя все данные доступны, и хранилища «ключ-значение» идеально подходят для быстрых операций чтения и записи. Хранилища
«ключ-значение» могут использоваться для поддержки рекомендаций и рекламы в реальном времени, поскольку они могут быстро получать доступ и
представлять новые рекомендации.