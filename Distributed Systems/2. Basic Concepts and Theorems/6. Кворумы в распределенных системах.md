# Кворумы в распределенных системах
Рассмотрим концепцию кворумов и выясним, как они решают проблемы низкой доступности при синхронной репликации.

Основная схема, которую мы видели до сих пор, такова: записи выполняются на всех узлах-репликах, а чтения выполняются на одном из них. Когда мы гарантируем, что записи выполняются на всех из них синхронно перед ответом клиенту, мы гарантируем, что последующие чтения увидят все предыдущие записи — независимо от узла, который обрабатывает операцию чтения.

> Обратите внимание, что в предыдущем абзаце мы использовали термин «выполнено». В то время как один узел получает запрос на запись в любом из алгоритмов репликации, обсуждавшихся ранее, данные обновляются на всех узлах в результате этого запроса. Аналогично, когда узел получает запрос на чтение, он считывает его из своего локального хранилища, а не выполняет чтение на всех узлах. В случае многопервичной репликации чтения могут выполняться на всех узлах для обработки конфликтов записи, но это одно из возможных решений, и его нельзя обобщить как шаблон.

# Проблема в синхронной репликации
Доступность операций записи довольно низкая, поскольку отказ одного узла делает систему неспособной обрабатывать записи до тех пор, пока узел не восстановится.

# Возможное решение
Для решения этой проблемы можно использовать обратную стратегию. То есть, мы записываем данные только в тот узел, который отвечает за обработку операции записи, а операции чтения обрабатываем, считывая данные со всех узлов и возвращая последнее значение.

Это значительно увеличивает доступность записи , но в то же время снижает доступность чтения . Итак, у нас есть компромисс, который требует механизма для достижения баланса. Давайте рассмотрим этот механизм.

# Кворумы
Полезным механизмом достижения баланса в этом компромиссе является использование кворумов .

Давайте рассмотрим пример. В системе из трех реплик можно сказать, что записи должны быть завершены в двух узлах (как кворум из двух), в то время как чтения должны извлекать данные из двух узлов. Таким образом, мы можем быть уверены, что чтения будут считывать последнее значение. Это потому, что по крайней мере один из узлов в кворуме чтения также будет включен в последний кворум записи .

> Это основано на том факте, что в наборе из трех элементов два подмножества из двух элементов должны иметь по крайней мере один общий элемент.

В предыдущей статье эта технология была представлена ​​как протокол голосования на основе кворума для управления репликами.

В общем, в системе, которая имеет в общей сложности В реплики, каждая операция чтения должна получить кворум чтения
Вг реплики. Между тем, операция записи должна получить кворум записи Вж реплики. Значения этих кворумов должны подчиняться следующим свойствам:
Вг + Вж > В
Вж >В/2

Первое правило гарантирует, что элемент данных не будет считываться и записываться двумя операциями одновременно.

Второе правило гарантирует, что по крайней мере один узел получает обе из двух операций записи и налагает на них порядок. Это означает, что две операции записи из двух разных операций не могут происходить одновременно на одном и том же элементе данных.

Оба правила вместе гарантируют, что связанная распределенная база данных ведет себя как централизованная система баз данных с одной репликой.

Концепция кворума действительно полезна в распределенных системах, имеющих несколько узлов.

>Концепция кворума широко используется и в других областях, таких как распределенные транзакции или протоколы консенсуса.