# Справочник по Nginx

## 1. Основы Nginx

### 1.1. Принцип работы и архитектура

**Nginx** — это высокопроизводительный веб-сервер, который принимает HTTP-запросы от клиентов (браузеров), обрабатывает их и отправляет
ответы. Он может как отдавать статические файлы (HTML, CSS, изображения), так и выступать в роли **обратного прокси-сервера (reverse proxy)
**, перенаправляя запросы на другие приложения (бэкенды).

Ключ к скорости Nginx — его архитектура:

* **Главный процесс (Master):** Запускается от `root`, читает конфигурацию, управляет рабочими процессами и открывает порты (например, 80,
  443). **Не обрабатывает запросы клиентов.**
* **Рабочие процессы (Workers):** Запускаются от непривилегированного пользователя (`nginx`, `www-data`), что повышает безопасность. Именно
  они обрабатывают тысячи одновременных соединений. Их количество обычно равно числу ядер CPU (`worker_processes auto;`).

Nginx использует **неблокирующую, управляемую событиями (event-driven) модель**. Один рабочий процесс не "зависает" в ожидании ответа от
диска или сети, а постоянно обрабатывает события (новое соединение, поступление данных), эффективно обслуживая множество клиентов
одновременно с минимальным потреблением ресурсов.

### 1.2. Модульная структура

Nginx состоит из ядра и набора **модулей**. Почти вся функциональность, включая обработку HTTP, реализована через модули. Это позволяет
собирать Nginx только с нужными функциями, делая его легковесным и быстрым. Директивы в конфигурации (например, `proxy_pass` или `gzip`)
предоставляются соответствующими модулями.

## 2. Управление и Конфигурация

### 2.1. Управление службой

В большинстве современных дистрибутивов Linux Nginx управляется через `systemd`.

* `sudo systemctl start | stop | restart nginx`: Запуск, остановка, полный перезапуск.
* `sudo systemctl status nginx`: Проверка статуса, просмотр ошибок.
* `sudo systemctl enable | disable nginx`: Включение/отключение автозагрузки.
* `sudo systemctl reload nginx`: **"Мягкая" перезагрузка** для применения новой конфигурации без разрыва текущих соединений.

### 2.2. Работа с файлами конфигурации

* **Основной файл:** `/etc/nginx/nginx.conf` (содержит глобальные настройки).
* **Конфигурации сайтов:** В Debian/Ubuntu принято хранить файлы конфигураций для каждого сайта в `/etc/nginx/sites-available/` и
  активировать их, создавая символические ссылки в `/etc/nginx/sites-enabled/`.

**Рабочий процесс с конфигурацией:**

1. **Редактирование:** Внесите изменения в `.conf` файл (`sudo nano /etc/nginx/sites-available/default`).
2. **Проверка:** Перед применением всегда проверяйте синтаксис: `sudo nginx -t`.
3. **Применение:** Если синтаксис верен, примените изменения: `sudo systemctl reload nginx`.

### 2.3. Структура конфигурации: Директивы и Контексты

Конфигурация состоит из **директив** и **блоков (контекстов)**.

* **Директива:** Команда, заканчивающаяся точкой с запятой `;` (например, `worker_processes auto;`).
* **Контекст:** Группа директив в фигурных скобках `{...}`. Настройки наследуются от родительского контекста к дочернему.

**Основные контексты:**

1. **`http`:** Глобальный блок для всех настроек HTTP/HTTPS.
2. **`server`:** Описывает один виртуальный сервер (сайт). Ключевые директивы:
    * `listen`: Порт для прослушивания (например, `listen 80;` или `listen 443 ssl;`).
    * `server_name`: Доменные имена сайта (например, `server_name example.com www.example.com;`).
3. **`location`:** Определяет, как обрабатывать запросы в зависимости от их URI (часть URL после домена).

### 2.4. Логирование

Nginx ведет два основных типа логов, обычно в `/var/log/nginx/`:

* **`access.log`:** Записывает информацию о каждом запросе клиента.
* **`error.log`:** Записывает ошибки в работе самого сервера. Это первый файл, который нужно проверять при проблемах.

Для анализа логов используйте `tail -f`, `grep`, `less`. В системах с `systemd` также доступна команда `journalctl -u nginx.service -f`.

## 3. Основные Сценарии Использования

### 3.1. Раздача статического контента

Nginx феноменально быстро отдает статические файлы.

* **`root`**: Указывает корневой каталог для файлов сайта.
* **`index`**: Задает файл по умолчанию (например, `index.html`).
* **`try_files`**: Пытается найти файл по указанным путям.

```nginx
server {
    listen 80;
    server_name example.com;
    root /var/www/my-site;
    index index.html;

    location / {
        try_files $uri $uri/ =404;
    }
}
```

### 3.2. Реверс-прокси (Reverse Proxy)

Одна из главных функций Nginx. Он принимает запросы и перенаправляет их на бэкенд-приложения.

* **`proxy_pass`**: Ключевая директива, указывающая адрес бэкенда.
* **`proxy_set_header`**: Передает на бэкенд важные заголовки, чтобы приложение знало реальные данные о клиенте.

```nginx
location /api/ {
    proxy_pass http://127.0.0.1:8000;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
}
```

### 3.3. Балансировка нагрузки

Nginx может распределять трафик между несколькими бэкенд-серверами для производительности и отказоустойчивости.

1. В контексте `http` создается блок `upstream`, где перечисляются серверы.
2. В `proxy_pass` указывается имя `upstream`-блока.

```nginx
http {
    upstream my_backend {
        # least_conn; # Алгоритм: на сервер с наименьшим числом соединений
        # ip_hash;    # Алгоритм: привязка клиента к серверу по IP
        server backend1.example.com;
        server backend2.example.com weight=2; # Будет получать в 2 раза больше запросов
    }

    server {
        # ...
        location / {
            proxy_pass http://my_backend;
        }
    }
}
```

По умолчанию используется алгоритм **Round-Robin** (циклический перебор).

### 3.4. Проксирование WebSocket

Для проксирования WebSocket-соединений необходимо "обновить" протокол с HTTP.

```nginx
location /ws/ {
    proxy_pass http://my_websocket_backend;
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "upgrade";
}
```

## 4. Оптимизация и Производительность

### 4.1. Тюнинг процессов и передачи данных

Эти директивы обычно размещают в `nginx.conf` и блоке `http`.

* `worker_processes auto;`: Автоматически устанавливает число рабочих процессов равным числу ядер CPU.
* `worker_connections 1024;`: (в блоке `events`) Максимальное число соединений на один рабочий процесс.
* `sendfile on;`: Позволяет отправлять файлы напрямую, минуя приложение, что снижает нагрузку на CPU.
* `tcp_nopush on;`: Отправляет HTTP-заголовки и начало файла в одном пакете.
* `tcp_nodelay on;`: Отправляет данные без задержек, не дожидаясь заполнения буфера.

### 4.2. Кэширование

#### Браузерное кэширование (для статики)

Указывает браузеру, как долго хранить копии файлов. Реализуется через директиву `expires`.

```nginx
# Для CSS и JS файлов устанавливаем кэш на 1 год
location ~* \.(css|js)$ {
    expires 1y;
}
# Для изображений и шрифтов - на 1 месяц
location ~* \.(jpg|jpeg|png|svg|woff|woff2)$ {
    expires 1M;
}
```

#### Прокси-кэширование (для ответов бэкенда)

Nginx сохраняет ответы от бэкенда и отдает их из кэша, снижая нагрузку.

```nginx
http {
    # 1. Определяем зону кэша на диске
    proxy_cache_path /var/cache/nginx levels=1:2 keys_zone=my_cache:10m max_size=10g inactive=60m;
}
server {
    location / {
        # 2. Включаем кэш
        proxy_cache my_cache;
        proxy_pass http://my_backend;

        # Указываем, какие ответы и на какой срок кэшировать
        proxy_cache_valid 200 10m;
        proxy_cache_valid 404 1m;

        # Для отладки добавляем заголовок со статусом кэша (HIT, MISS, EXPIRED)
        add_header X-Proxy-Cache $upstream_cache_status;
    }
}
```

## 5. Безопасность

### 5.1. Настройка HTTPS (SSL/TLS)

Использование HTTPS обязательно для современных сайтов. Для этого нужен SSL-сертификат.

* `listen 443 ssl http2;`: Прослушивать порт 443 с SSL и поддержкой HTTP/2.
* `ssl_certificate`: Путь к файлу сертификата (fullchain.pem).
* `ssl_certificate_key`: Путь к файлу приватного ключа (privkey.pem).

Самый простой способ получить бесплатный сертификат — использовать **Let's Encrypt** и утилиту **Certbot**, которая может автоматически
настроить Nginx.

### 5.2. Ограничение доступа и частоты запросов

#### Ограничение по IP (`allow`/`deny`)

Позволяет создать "белые" и "черные" списки IP-адресов.

```nginx
location /admin/ {
    allow 192.168.1.0/24; # Разрешить доступ из локальной сети
    deny all;             # Запретить всем остальным
    # ...
}
```

#### Ограничение частоты запросов (`limit_req`)

Защищает от brute-force атак и HTTP-флуда.

```nginx
http {
    # Зона для хранения состояний клиентов (1 запрос в секунду)
    limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s;
}
server {
    location /login {
        # Применяем правило, разрешая "всплеск" до 5 запросов
        limit_req zone=one burst=5;
        # ...
    }
}
```

### 5.3. Web Application Firewall (WAF)

WAF анализирует содержимое HTTP-запросов и блокирует атаки на приложение (SQL-инъекции, XSS и др.). Для Nginx стандартом является связка *
*ModSecurity** (движок) и **OWASP Core Rule Set** (набор правил). WAF работает как "виртуальный патч", защищая приложение даже при наличии в
нем уязвимостей.

## 6. Расширение Функциональности

### 6.1. Скрипты: Lua и njs (JavaScript)

Позволяют выполнять сложную логику прямо в Nginx, превращая его в API-шлюз.

* **Lua (`ngx_http_lua_module`):** Очень мощный и зрелый модуль для сложной логики, взаимодействия с базами данных и т.д.
* **njs (`ngx_http_js_module`):** Нативная реализация JavaScript от разработчиков Nginx, быстрая и легкая, отлично подходит для манипуляций
  с заголовками и переменными.

### 6.2. Делегирование авторизации (`auth_request`)

Позволяет вынести логику авторизации в отдельный микросервис. Перед обработкой запроса Nginx делает внутренний подзапрос к сервису
авторизации. Если сервис отвечает кодом `2xx`, доступ разрешается. Если `401` или `403` — запрещается.

### 6.3. Мониторинг

* **`stub_status`**: Встроенный модуль для получения базовой статистики (активные соединения, обработанные запросы). Доступ к нему следует
  ограничивать.
* **Инструменты для тестирования нагрузки**: `ab` (ApacheBench), `wrk`, `siege` используются для проверки производительности сервера под
  нагрузкой.