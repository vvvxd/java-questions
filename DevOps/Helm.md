

### 1. Базовые концепции Helm

### 1.1. Что такое Helm?

Helm — это инструмент, который помогает автоматизировать и упростить развертывание приложений в кластере Kubernetes. Вместо того чтобы вручную писать и управлять десятками или сотнями YAML-файлов для описания ресурсов Kubernetes (таких как Deployment, Service, ConfigMap и других), Helm позволяет упаковать все это в единый **чарт** — шаблон приложения. Чарт содержит все необходимые инструкции и настройки для развертывания приложения, а Helm управляет процессом их применения в кластере.

**Зачем нужен Helm?**
- **Упрощение**: Вместо написания множества YAML-файлов вы работаете с одним чартом.
- **Повторное использование**: Чарты можно использовать многократно с разными конфигурациями.
- **Автоматизация**: Helm автоматизирует установку, обновление и удаление приложений.
- **Гибкость**: Вы можете легко кастомизировать чарт для разных окружений (например, dev, prod).
- **Экосистема**: Доступ к готовым чартам в репозиториях (например, Artifact Hub) для быстрого развертывания популярных приложений, таких как Nginx, MySQL или WordPress.

---

### 1.2. Основные компоненты Helm

Helm состоит из нескольких ключевых понятий, которые важно понять:

#### 2.1. Chart
**Чарт** — это основная единица работы в Helm. Это пакет, который содержит:
- **Chart.yaml**: Метаданные чарта (название, версия, описание, зависимости).
- **values.yaml**: Файл с параметрами по умолчанию для конфигурации приложения (например, порт сервиса, количество реплик).
- **templates/**: Папка с шаблонами YAML-файлов, которые Helm заполняет значениями из values.yaml или пользовательскими настройками.
- **charts/**: Папка для хранения зависимостей (других чартов, если они есть).
- Дополнительные файлы: Например, README.md или вспомогательные скрипты.

Чарт можно сравнить с "чертежом" приложения, который описывает, как оно должно быть развернуто в Kubernetes.

#### 2.2. Release
**Релиз** — это конкретный экземпляр чарта, развернутый в кластере Kubernetes с определенными настройками. Например, если вы установили чарт MySQL с именем релиза `my-mysql-prod` и указали свои параметры (например, пароль базы данных), это будет отдельный релиз. Один чарт может быть установлен несколько раз в разных релизах с разными конфигурациями.

#### 2.3. Repository
**Репозиторий** — это хранилище чартов, где они публикуются и откуда их можно скачать. Самый известный репозиторий — **Artifact Hub**, где доступны тысячи готовых чартов для популярных приложений. Вы можете добавлять свои репозитории в Helm с помощью команды `helm repo add` и искать чарты с помощью `helm search`.

#### 2.4. Tiller (устарел)
В Helm 2 использовался компонент **Tiller** — серверная часть, которая работала внутри кластера Kubernetes и взаимодействовала с его API. Tiller был ответственен за применение чартов и управление релизами. Однако он вызывал проблемы с безопасностью (например, из-за широких прав доступа), и в **Helm 3** Tiller был полностью исключен. Теперь Helm работает напрямую с API Kubernetes через ваш локальный `kubectl` контекст, что делает его более безопасным и простым.

#### 2.5. Helm CLI
**Helm CLI** — это основной интерфейс взаимодействия с Helm. Вы устанавливаете его на свой компьютер и используете команды для работы с чартами и релизами. Helm CLI взаимодействует с Kubernetes API, используя ваши учетные данные (`kubectl` конфигурацию). Вот основные возможности CLI:
- Управление чартами (установка, обновление, удаление).
- Работа с репозиториями (добавление, обновление, поиск).
- Инспекция чартов (просмотр их структуры и значений).
- Тестирование и отладка (например, с флагом `--dry-run`).

---

### 1.3. Основные команды Helm

Helm предоставляет множество команд для управления чартами и релизами. Вот самые важные из них:

#### 3.1. Установка чарта
```bash
helm install <release-name> <chart> [flags]
```
- Устанавливает чарт в кластер Kubernetes.
- Пример: `helm install my-app stable/nginx` (установка чарта Nginx с именем релиза `my-app` из репозитория `stable`).
- Флаги:
  - `--set key=value`: Переопределение значений из `values.yaml`.
  - `--values file.yaml`: Указание пользовательского файла с настройками.
  - `--dry-run`: Тестирование установки без реального применения.
  - `--namespace`: Указание namespace для установки.

#### 3.2. Обновление релиза
```bash
helm upgrade <release-name> <chart> [flags]
```
- Обновляет существующий релиз до новой версии чарта или с новыми настройками.
- Пример: `helm upgrade my-app stable/nginx --set replicas=3`.
- Флаг `--atomic`: Если обновление не удалось, Helm автоматически откатит изменения.

#### 3.3. Откат изменений
```bash
helm rollback <release-name> <revision>
```
- Откатывает релиз к указанной версии (ревизии). Helm хранит историю изменений релиза, что позволяет вернуться к предыдущему состоянию.
- Пример: `helm rollback my-app 1`.

#### 3.4. Удаление релиза
```bash
helm uninstall <release-name>
```
- Удаляет релиз из кластера.
- Флаг `--keep-history`: Сохраняет историю релиза для возможного отката.

#### 3.5. Управление репозиториями
- `helm repo add <name> <url>`: Добавляет новый репозиторий.
  - Пример: `helm repo add bitnami https://charts.bitnami.com/bitnami`.
- `helm repo update`: Обновляет локальный кэш чартов из репозиториев.
- `helm repo list`: Показывает список добавленных репозиториев.

#### 3.6. Поиск и инспекция чартов
- `helm search repo <keyword>`: Ищет чарты в репозиториях.
  - Пример: `helm search repo nginx`.
- `helm show chart <chart>`: Показывает метаданные чарта (Chart.yaml).
- `helm show values <chart>`: Показывает значения по умолчанию (values.yaml).

#### 3.7. Полезные флаги
- `--dry-run`: Симулирует выполнение команды без реальных изменений.
- `--atomic`: Обеспечивает атомарность операций (откат при сбое).
- `--namespace`: Указывает namespace для работы с чартом.
- `--timeout`: Устанавливает время ожидания операции.

---

### 1.4. Как работает Helm?

1. **Создание или выбор чарта**:
  - Вы либо используете готовый чарт из репозитория (например, Artifact Hub), либо создаете свой собственный с помощью `helm create <chart-name>`.
  - Чарт содержит шаблоны (YAML-файлы в папке `templates/`), которые используют синтаксис шаблонов Go для динамической генерации ресурсов.

2. **Конфигурация**:
  - Вы задаете параметры через `values.yaml` или переопределяете их с помощью флага `--set` или пользовательского YAML-файла (`--values`).
  - Helm подставляет эти значения в шаблоны, генерируя итоговые манифесты Kubernetes.

3. **Развертывание**:
  - Команда `helm install` отправляет сгенерированные манифесты в Kubernetes API, создавая ресурсы (поды, сервисы и т.д.).
  - Helm сохраняет информацию о релизе в кластере (в виде ConfigMap или Secret в namespace).

4. **Обновление и управление**:
  - С помощью `helm upgrade` можно обновить релиз (например, изменить версию чарта или настройки).
  - `helm rollback` позволяет откатиться к предыдущей версии.
  - `helm uninstall` удаляет ресурсы и релиз.


---

### 2. Архитектура и внутренняя механика Helm

### 1. Шаблонизатор Go Template

Helm использует **Go Template** — язык шаблонов из Go, чтобы динамически генерировать манифесты Kubernetes (YAML-файлы) на основе конфигураций и пользовательских значений. Это ключевая часть, которая делает Helm гибким, позволяя создавать универсальные чарты, которые можно адаптировать под разные окружения.

#### 1.1. Основы Go Template
Go Template — это текстовый шаблонизатор, встроенный в Go, который Helm использует для обработки файлов в папке `templates/`. Шаблоны содержат статические части YAML и динамические вставки, обозначенные двойными фигурными скобками `{{ }}`.

**Основные элементы синтаксиса:**
- **Переменные**:
  - Переменные задаются с помощью `{{ .Values.someKey }}`, где `.Values` ссылается на значения из `values.yaml` или переданные через `--set` или `--values`.
  - Пример: `{{ .Values.replicaCount }}` подставит количество реплик из `values.yaml`.

- **Условия**:
  - Используются для включения/исключения частей манифеста:
    ```yaml
    {{ if .Values.enableService }}
    apiVersion: v1
    kind: Service
    ...
    {{ end }}
    ```
  - Здесь сервис создается, только если `enableService: true` в `values.yaml`.

- **Циклы**:
  - Используются для обработки списков или словарей:
    ```yaml
    {{ range .Values.ports }}
    - port: {{ .port }}
      protocol: {{ .protocol }}
    {{ end }}
    ```
  - Если `ports` в `values.yaml` содержит список портов, цикл создаст соответствующие секции в манифесте.

- **Встроенные функции**:
  - Helm добавляет свои функции к стандартным Go Template, например:
    - `default`: Задает значение по умолчанию, если переменная не определена:
      ```yaml
      replicas: {{ .Values.replicaCount | default 1 }}
      ```
    - `quote`: Оборачивает строку в кавычки:
      ```yaml
      name: {{ .Values.name | quote }}
      ```
    - `toYaml`: Преобразует объект в YAML-формат:
      ```yaml
      data:
        {{ toYaml .Values.config | indent 2 }}
      ```
  - Другие полезные функции: `nindent`, `b64enc`, `lookup` и т.д.

- **Объекты Helm**:
  - Helm предоставляет встроенные объекты для работы в шаблонах:
    - `.Values`: Доступ к значениям из `values.yaml` или пользовательских настроек.
    - `.Release`: Информация о релизе (например, `.Release.Name`, `.Release.Namespace`).
    - `.Chart`: Метаданные чарта из `Chart.yaml` (например, `.Chart.Name`, `.Chart.Version`).
    - `.Capabilities`: Информация о кластере Kubernetes (например, `.Capabilities.KubeVersion` для версии Kubernetes).

#### 1.2. Практика написания шаблонов
Чтобы освоить шаблоны, начните с простого чарта:
1. Создайте чарт: `helm create my-chart`.
2. Откройте `templates/deployment.yaml` и добавьте динамику, например:
   ```yaml
   apiVersion: apps/v1
   kind: Deployment
   metadata:
     name: {{ .Release.Name }}-app
   spec:
     replicas: {{ .Values.replicaCount | default 1 }}
     template:
       spec:
         containers:
         - name: {{ .Chart.Name }}
           image: {{ .Values.image.repository }}:{{ .Values.image.tag | default "latest" }}
   ```
3. В `values.yaml` задайте значения:
   ```yaml
   replicaCount: 2
   image:
     repository: nginx
     tag: 1.21
   ```
4. Проверьте результат с помощью `helm template my-chart` — это покажет сгенерированный манифест.

**Совет**: Используйте `helm lint` для проверки чарта на ошибки и `helm template --debug` для отладки шаблонов.

---

### 2. Файл `values.yaml`

Файл `values.yaml` — это сердце конфигурации чарта. Он содержит значения по умолчанию, которые подставляются в шаблоны. Пользователь может переопределять их, чтобы кастомизировать развертывание.

#### 2.1. Структура и иерархия
- `values.yaml` организован в формате YAML с иерархической структурой:
  ```yaml
  replicaCount: 1
  image:
    repository: nginx
    tag: latest
    pullPolicy: IfNotPresent
  service:
    type: ClusterIP
    port: 80
  ```
- Иерархия позволяет группировать связанные настройки (например, `image.repository`, `service.port`).

- Доступ к значениям в шаблонах осуществляется через `.Values`, например:
  ```yaml
  image: {{ .Values.image.repository }}:{{ .Values.image.tag }}
  ```

#### 2.2. Переопределение значений
Helm поддерживает несколько способов переопределения значений из `values.yaml` (в порядке приоритета, от высшего к низшему):
1. **Флаг `--set`**:
   ```bash
   helm install my-release my-chart --set replicaCount=3
   ```
   Переопределяет конкретные значения.
2. **Флаг `--values` (или `-f`)**:
   ```bash
   helm install my-release my-chart -f custom-values.yaml
   ```
   Указывает пользовательский файл YAML с настройками.
3. **Значения по умолчанию** в `values.yaml`.

**Пример**:
Если в `values.yaml` указано `replicaCount: 1`, а вы используете:
```bash
helm install my-release my-chart --set replicaCount=5
```
то в шаблоне будет использовано `replicaCount: 5`.

#### 2.3. Вложенные значения
Для сложных приложений `values.yaml` может содержать вложенные структуры:
```yaml
database:
  enabled: true
  config:
    maxConnections: 100
    timeout: 30s
```
Доступ в шаблоне:
```yaml
{{ if .Values.database.enabled }}
  maxConnections: {{ .Values.database.config.maxConnections }}
{{ end }}
```

**Совет**: Для управления разными окружениями создавайте отдельные файлы `values-dev.yaml`, `values-prod.yaml` и используйте их с `-f`.

---

### 3. Жизненный цикл релиза

Релиз — это экземпляр чарта, развернутый в кластере с конкретными настройками. Helm управляет жизненным циклом релиза, включая создание, обновление, откат и удаление.

#### 3.1. Создание релиза
1. Пользователь выполняет `helm install my-release my-chart`.
2. Helm:
  - Читает `values.yaml` и пользовательские настройки (`--set`, `--values`).
  - Обрабатывает шаблоны в `templates/`, подставляя значения.
  - Генерирует итоговые манифесты Kubernetes.
  - Отправляет их в Kubernetes API для создания ресурсов (подов, сервисов и т.д.).
3. Helm сохраняет информацию о релизе в кластере:
  - В виде объекта `Secret` (по умолчанию) или `ConfigMap` в namespace релиза.
  - Содержит метаданные релиза, историю и сгенерированные манифесты.

#### 3.2. Обновление релиза
1. Пользователь выполняет `helm upgrade my-release my-chart --set replicaCount=3`.
2. Helm:
  - Генерирует новые манифесты с обновленными значениями.
  - Сравнивает их с текущими ресурсами в кластере.
  - Применяет изменения через Kubernetes API (используя механизм "patch" или "apply").
3. Сохраняет новую версию релиза в истории (увеличивая номер ревизии).

#### 3.3. Откат релиза
1. Пользователь выполняет `helm rollback my-release 1` для возврата к ревизии 1.
2. Helm:
  - Извлекает манифесты из истории релиза (хранятся в `Secret`/`ConfigMap`).
  - Применяет их через Kubernetes API.
  - Обновляет историю, создавая новую ревизию.

#### 3.4. Удаление релиза
1. Пользователь выполняет `helm uninstall my-release`.
2. Helm:
  - Удаляет все ресурсы, связанные с релизом, через Kubernetes API.
  - По умолчанию удаляет историю релиза, но с флагом `--keep-history` история сохраняется.

#### 3.5. Хранение истории
- История релиза хранится в объектах `Secret` (или `ConfigMap`, если указано в настройках) в namespace релиза.
- Имя объекта: `sh.helm.release.v1.<release-name>.v<revision>`.
- Проверять историю можно с помощью:
  ```bash
  helm history my-release
  ```
- Это позволяет отслеживать изменения и выполнять откаты.

---

### 4. Взаимодействие с Kubernetes API

Helm 3 напрямую взаимодействует с Kubernetes API, без посредников (в отличие от Helm 2 с Tiller). Вот как это работает:

#### 4.1. Отправка манифестов
1. Helm генерирует манифесты из шаблонов и значений.
2. Использует текущий `kubectl` контекст (файл `~/.kube/config`) для аутентификации.
3. Отправляет манифесты в Kubernetes API через HTTP-запросы (обычно с использованием метода `apply` для создания/обновления ресурсов).
4. Kubernetes API создает или обновляет ресурсы (поды, сервисы и т.д.) в кластере.

#### 4.2. Роль RBAC
- Helm использует учетные данные пользователя `kubectl`, поэтому права доступа определяются **RBAC** (Role-Based Access Control) в кластере.
- Для успешной работы Helm нужны права на:
  - Создание, обновление, удаление ресурсов (Deployment, Service, ConfigMap и т.д.).
  - Чтение/запись `Secret` или `ConfigMap` для хранения истории релизов.
- Пример минимальной роли RBAC для Helm:
  ```yaml
  apiVersion: rbac.authorization.k8s.io/v1
  kind: Role
  metadata:
    namespace: my-namespace
    name: helm-role
  rules:
  - apiGroups: ["", "apps", "extensions"]
    resources: ["deployments", "services", "configmaps", "secrets"]
    verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]
  ```
- Если доступ ограничен, вы увидите ошибки вроде `Error: permission denied`.

#### 4.3. Обработка ошибок
- **Ошибки доступа**: Если RBAC не настроен, Helm выдаст ошибку. Проверьте права с помощью `kubectl auth can-i`.
- **Некорректные манифесты**: Если шаблон содержит ошибки (например, неверный синтаксис YAML), Helm покажет их при выполнении `helm template` или `helm install --dry-run`.
- **Сетевые проблемы**: Если Kubernetes API недоступен, Helm сообщит об ошибке подключения.

**Совет**: Всегда используйте `--dry-run` перед реальной установкой, чтобы проверить манифесты:
```bash
helm install my-release my-chart --dry-run --debug
```

---

### 3. Создание и управление чартами
Давайте углубимся в создание и управление чартами в Helm, рассмотрев их структуру, процесс создания, лучшие практики и тестирование. Я объясню всё подробно, но простым языком, чтобы было понятно даже без глубокого опыта работы с Helm.

---

### 1. Структура чарта

Чарт в Helm — это структурированный набор файлов, который описывает приложение или сервис для развертывания в Kubernetes. Чарт можно представить как "пакет", содержащий всё необходимое для установки приложения. Вот основные компоненты чарта:

#### 1.1. `Chart.yaml`
- **Описание**: Файл с метаданными чарта.
- **Содержимое**:
  - `apiVersion`: Версия API Helm (например, `v2` для Helm 3).
  - `name`: Имя чарта.
  - `version`: Версия чарта (должна следовать SemVer 2).
  - `description`: Краткое описание чарта.
  - `dependencies`: Список зависимостей (других чартов), если они есть.
  - Дополнительные поля: `maintainers`, `keywords`, `home` и т.д.
- **Пример**:
  ```yaml
  apiVersion: v2
  name: my-app
  description: A Helm chart for my application
  version: 0.1.0
  dependencies:
    - name: redis
      version: "17.3.2"
      repository: "https://charts.bitnami.com/bitnami"
  ```

#### 1.2. `values.yaml`
- **Описание**: Файл с параметрами по умолчанию, которые используются в шаблонах.
- **Содержимое**: Иерархическая структура в формате YAML, задающая настройки, такие как количество реплик, образы контейнеров, порты и т.д.
- **Пример**:
  ```yaml
  replicaCount: 1
  image:
    repository: nginx
    tag: latest
    pullPolicy: IfNotPresent
  service:
    type: ClusterIP
    port: 80
  ```

#### 1.3. Папка `templates/`
- **Описание**: Содержит шаблоны манифестов Kubernetes в формате YAML с использованием Go Template.
- **Содержимое**: Файлы вроде `deployment.yaml`, `service.yaml`, `ingress.yaml`, `configmap.yaml` и т.д.
- **Пример** (`templates/deployment.yaml`):
  ```yaml
  apiVersion: apps/v1
  kind: Deployment
  metadata:
    name: {{ .Release.Name }}-app
  spec:
    replicas: {{ .Values.replicaCount }}
    selector:
      matchLabels:
        app: {{ .Release.Name }}
    template:
      metadata:
        labels:
          app: {{ .Release.Name }}
      spec:
        containers:
        - name: {{ .Chart.Name }}
          image: {{ .Values.image.repository }}:{{ .Values.image.tag }}
  ```

#### 1.4. Папка `charts/`
- **Описание**: Содержит зависимости чарта (другие чарты, указанные в `Chart.yaml`).
- **Использование**: Зависимости автоматически загружаются при выполнении `helm dependency update`.
- **Пример**: Если чарт зависит от Redis, папка `charts/` будет содержать чарт `redis`.

#### 1.5. Дополнительные файлы
- **`README.md`**: Документация чарта, описывающая его назначение, параметры и инструкции по установке.
- **`LICENSE`**: Лицензия чарта.
- **`NOTES.txt`**: Текстовый файл, отображаемый после установки чарта, с полезной информацией (например, как подключиться к приложению).
  - **Пример** (`NOTES.txt`):
    ```text
    Thank you for installing {{ .Chart.Name }}!

    Your application is running at:
    http://{{ .Release.Name }}-app.{{ .Release.Namespace }}.svc.cluster.local:{{ .Values.service.port }}
    ```
- **`.helmignore`**: Файл, аналогичный `.gitignore`, указывающий, какие файлы не включать в чарт.

---

### 2. Создание чарта

Создание чарта — это процесс настройки шаблонов и конфигураций для вашего приложения. Helm предоставляет команду `helm create` для генерации базовой структуры.

#### 2.1. Использование `helm create`
- **Команда**:
  ```bash
  helm create my-chart
  ```
- **Результат**: Создается папка `my-chart` с базовой структурой:
  ```
  my-chart/
  ├── .helmignore
  ├── Chart.yaml
  ├── values.yaml
  ├── charts/
  ├── templates/
  │   ├── deployment.yaml
  │   ├── service.yaml
  │   ├── ingress.yaml
  │   ├── _helpers.tpl
  │   ├── NOTES.txt
  │   └── tests/
  ```
- Базовый чарт настроен для развертывания простого приложения (например, Nginx).

#### 2.2. Настройка шаблонов
1. **Отредактируйте `values.yaml`**:
   Настройте параметры, например:
   ```yaml
   replicaCount: 2
   image:
     repository: my-app
     tag: v1.0.0
   service:
     type: ClusterIP
     port: 8080
   ```

2. **Настройте шаблоны в `templates/`**:
  - Модифицируйте `deployment.yaml`, `service.yaml` или добавьте новые ресурсы, такие как `configmap.yaml` или `secret.yaml`.
  - Пример добавления ConfigMap:
    ```yaml
    apiVersion: v1
    kind: ConfigMap
    metadata:
      name: {{ .Release.Name }}-config
    data:
      app.conf: |-
        {{ .Values.config.appSettings | indent 4 }}
    ```
  - В `values.yaml` добавьте:
    ```yaml
    config:
      appSettings: |
        setting1: value1
        setting2: value2
    ```

3. **Добавьте зависимости**:
  - В `Chart.yaml` укажите зависимости:
    ```yaml
    dependencies:
      - name: redis
        version: "17.3.2"
        repository: "https://charts.bitnami.com/bitnami"
    ```
  - Выполните:
    ```bash
    helm dependency update
    ```
    Это загрузит зависимости в папку `charts/`.

#### 2.3. Управление зависимостями
- В Helm 3 зависимости указываются в `Chart.yaml` (в Helm 2 использовался `requirements.yaml`, который устарел).
- Зависимости можно обновлять или удалять:
  - `helm dependency update`: Загружает зависимости.
  - `helm dependency build`: Пересобирает зависимости.
  - `helm dependency list`: Показывает список зависимостей.

---

### 3. Лучшие практики написания чартов

Чтобы чарты были удобными, переиспользуемыми и надежными, следуйте этим рекомендациям:

#### 3.1. Модульность и переиспользуемость
- Разбивайте шаблоны на логические части (например, отдельные файлы для Deployment, Service, ConfigMap).
- Используйте общие параметры в `values.yaml`, чтобы минимизировать дублирование в шаблонах.
- Создавайте универсальные чарты, которые можно адаптировать под разные окружения (dev, prod) с помощью `values.yaml`.

#### 3.2. Использование помощников (`_helpers.tpl`)
- Файл `_helpers.tpl` в папке `templates/` содержит вспомогательные шаблоны (функции), которые можно переиспользовать.
- Пример:
  ```yaml
  {{- define "my-chart.labels" -}}
  app: {{ .Release.Name }}
  chart: {{ .Chart.Name }}-{{ .Chart.Version }}
  {{- end -}}
  ```
- Использование в шаблоне:
  ```yaml
  metadata:
    labels:
      {{- include "my-chart.labels" . | nindent 4 }}
  ```
- Это уменьшает дублирование кода и упрощает поддержку.

#### 3.3. Обеспечение идемпотентности
- Чарт должен быть идемпотентным, то есть многократное применение (`helm install` или `helm upgrade`) не должно создавать конфликты.
- Используйте уникальные имена ресурсов с помощью `.Release.Name`:
  ```yaml
  metadata:
    name: {{ .Release.Name }}-app
  ```
- Проверяйте существование ресурсов с помощью функции `lookup` (например, для ConfigMap):
  ```yaml
  {{- if not (lookup "v1" "ConfigMap" .Release.Namespace "my-config") }}
  apiVersion: v1
  kind: ConfigMap
  ...
  {{- end }}
  ```

#### 3.4. Документирование
- **README.md**:
  - Опишите назначение чарта, инструкции по установке и доступные параметры `values.yaml`.
  - Пример:
    ```markdown
    # My Chart
    A Helm chart for deploying My App.

    ## Installation
    ```bash
    helm install my-release ./my-chart
    ```

    ## Configuration
    | Parameter | Description | Default |
        |-----------|-------------|---------|
    | `replicaCount` | Number of replicas | 1 |
    | `image.repository` | Image repository | nginx |
    ```
- **NOTES.txt**:
  - Добавьте полезную информацию, которая отображается после установки:
    ```text
    Your application is available at:
    http://{{ .Release.Name }}.{{ .Release.Namespace }}:{{ .Values.service.port }}
    ```

---

### 4. Тестирование чартов

Тестирование чартов важно для обеспечения их качества и предотвращения ошибок в продакшене.

#### 4.1. Использование `helm lint`
- **Команда**:
  ```bash
  helm lint ./my-chart
  ```
- **Назначение**: Проверяет чарт на синтаксические ошибки, соответствие стандартам и потенциальные проблемы.
- **Пример вывода**:
  ```
  ==> Linting ./my-chart
  [INFO] Chart.yaml: version is valid
  [ERROR] templates/deployment.yaml: invalid YAML syntax at line 10
  ```

#### 4.2. Тестирование шаблонов с `helm template` и `--dry-run`
- **Команда**:
  ```bash
  helm template my-chart
  ```
  или
  ```bash
  helm install my-release ./my-chart --dry-run --debug
  ```
- **Назначение**:
  - `helm template`: Генерирует манифесты, не отправляя их в кластер.
  - `--dry-run`: Симулирует установку, показывая, какие ресурсы будут созданы.
  - `--debug`: Выводит подробную информацию, включая сгенерированные манифесты.
- **Пример**:
  ```bash
  helm template my-chart --set replicaCount=3
  ```
  Показывает итоговые манифесты с `replicaCount: 3`.

#### 4.3. Автоматизация тестирования с CI/CD
- Интегрируйте тестирование чартов в CI/CD-пайплайн:
  1. **Проверка синтаксиса**:
     ```bash
     helm lint ./my-chart
     ```
  2. **Генерация манифестов**:
     ```bash
     helm template ./my-chart > output.yaml
     ```
     Проверяйте `output.yaml` на корректность с помощью инструментов, таких как `kubeval`.
  3. **Тестирование установки**:
     Используйте `helm install --dry-run` или развертывайте чарт в тестовом кластере.
  4. **Функциональные тесты**:
    - В папке `templates/tests/` создайте тесты (например, `test-connection.yaml`) для проверки работоспособности приложения.
    - Пример теста:
      ```yaml
      apiVersion: v1
      kind: Pod
      metadata:
        name: {{ .Release.Name }}-test
        annotations:
          "helm.sh/hook": test
      spec:
        containers:
        - name: test
          image: busybox
          command: ["wget", "{{ .Release.Name }}-app:{{ .Values.service.port }}"]
        restartPolicy: Never
      ```
    - Запустите тесты:
      ```bash
      helm test my-release
      ```

---

### 4. Управление зависимостями
Понимание работы с зависимостями в Helm критично для сложных приложений:

- **Объявление зависимостей**:
    - Добавление зависимостей в `Chart.yaml` (секция `dependencies`).
    - Указание условий для включения/отключения зависимостей (`condition`, `tags`).
    - Управление версиями зависимостей.

- **Обновление зависимостей**:
    - Использование `helm dependency update` для загрузки зависимостей.
    - Работа с локальными и удаленными репозиториями.

- **Кэширование и управление**:
    - Понимание, как Helm кэширует зависимости и как обновлять их.
    - Решение конфликтов между зависимостями.

---

### 5. Продвинутые возможности Helm
Для углубленного понимания изучите продвинутые функции и сценарии использования:

- **Hooks**:
    - Использование аннотаций `helm.sh/hook` для выполнения задач на определенных стадиях жизненного цикла релиза (например, `pre-install`, `post-upgrade`).
    - Примеры: создание базы данных перед установкой или очистка ресурсов после удаления.

- **Секреты и безопасность**:
    - Хранение чувствительных данных в `Secrets` вместо `ConfigMap`.
    - Использование плагинов, таких как `helm-secrets`, для шифрования `values.yaml`.
    - Настройка RBAC для ограничения доступа Helm к кластеру.

- **Плагины Helm**:
    - Установка и создание собственных плагинов для расширения функциональности Helm.
    - Примеры популярных плагинов: `helm-diff`, `helm-secrets`, `helm-git`.

- **Кастомизация через `post-renderer`**:
    - Использование флага `--post-renderer` для модификации сгенерированных манифестов перед отправкой в Kubernetes.
    - Примеры: добавление аннотаций или патчей через Kustomize.

- **Helm в CI/CD**:
    - Интеграция Helm в пайплайны CI/CD (например, GitHub Actions, Jenkins, ArgoCD).
    - Автоматизация развертывания чартов, обновления зависимостей и тестирования.

  
--


### 10. Проблемы и ограничения Helm
Для углубленного понимания важно знать ограничения Helm и как их обходить:

- **Ограничения шаблонов**:
    - Go Template может быть сложным для сложной логики. Решение: использовать Lua в Helm (через плагин `helm-lua`) или Kustomize.

- **Управление состоянием**:
    - Helm не управляет состоянием ресурсов, созданных вне чарта. Решение: использование операторов или ручная синхронизация.

- **Конфликты зависимостей**:
    - Проблемы с версиями зависимостей. Решение: точное указание версий и тестирование.

- **Безопасность**:
    - Уязвимости в публичных чартах. Решение: проверка чартов и использование доверенных источников.

