Что такое Helm?

Helm — один из самых популярных пакетных менеджеров для Kubernetes.
Современное приложение — сложный продукт с множеством внутренних компонентов и внешних связей. При этом чаще всего у нас есть несколько рабочих окружений, которые могут достаточно сильно отличаться друг от друга и по количеству компонентов и связей, и по их качеству. Кроме того, в современном мире микросервисов и распиленных монолитов у нас может быть гораздо больше одного проекта. Управлять этим сложным хозяйством хочется максимально простым, универсальным и наименее затратным способом. Поэтому отношение к выбору подходящего инструмента для деплоя и построение технической дисциплины на его основе варируется от хорошей практики до необходимого условия выживания. Таким тулингом для многих стал Helm Package Manager.

--------------------------------------------------------------------------------------------------------------------

Расскажите про архитектуру Helm?

Работает же Helm следующим образом:

Получает на вход Chart (локально или из репозитория, при этом чарты могут использовать друг друга) и генерирует манифест релиза.

Получает текст предыдущего релиза.

Получает текущее стостояние примитивов из namespace-релиза.

Сравнивает эти три вещи, делает patch и передает его в KubeAPI.

Дожидается выката релиза (опциональный шаг).

Эта схема называется 3-way merge. Таким образом Helm приведет конфигурацию приложения к состоянию, которое описано в git, но не тронет другие изменения. Т. е., если у вас в кластере есть какая-то сущность, которая трансформирует ваши примитивы (например, Service Mesh), то Helm отнесется к ним бережно.

--------------------------------------------------------------------------------------------------------------------

Что такое Helm chart?

Фактически, папка определенной структуры с текстовыми файлами внутри. По команде helm create [chartname] будет создана заготовка, которую вы сможете развить нужным вам образом.Файлы имеют разную структуру и назначение. Например, в Chart.yaml описаны основные параметры чарта. В нем много произвольных описательных полей, однако необходимое и достаточное условие — указать только name и version.

--------------------------------------------------------------------------------------------------------------------

Что такое Репозиторий чартов?

Достаточно простая сущность, фактически веб-сервер, в корне которого лежит index.yaml с описанием чартов и сами запакованные .tgz-чарты.
В принципе, управлять репозиторием можно вручную, используя команды Helm. Хотя существует и ПО, обеспечиващее быстрый старт и визуальные интерфейсы для облегчения работы. Например:
Chart museum;
Jfrog Artifactory;
Harbour.

--------------------------------------------------------------------------------------------------------------------

Что такое Helm Release, Helm Values?

Helm Release генерируется из чарта (Chart) с использованием входных значений (Values):
Chart + Values = Release
При помощи команды helm list мы можем просмотреть релизы, установленные в конкретном Kubernetes Namespace.
С релизами связано понятие Release backend — места, в котором Helm хранит и версионирует переданные на деплой релизы.
Это может быть configmap/secret/SQL. По умолчанию это secret — Helm создает объект этого типа (в котором хранится JSON, завернутый в gzip + Base64) на каждый релиз в Namespace, куда его и устанавливает. Хотя он может сделать это и, например, в SQL-базе.

--------------------------------------------------------------------------------------------------------------------

Типовые задачи «YAML-девелопера»?

Перейдем к задачам, которые наиболее часто возникают в процессе деплоя приложений в Kubernetes, и их реализции с помощью Helm. У меня получился вот такой короткий список:

Кастомизация приложения в разрезе окружений.
Переиспользвание кода.
Управление блоками кода по условию.
Модульная разработка.
Трекинг выката.
Установка очередности запуска подов.
Отладка.
Релизный цикл.
Расширение функциональности Helm.

--------------------------------------------------------------------------------------------------------------------

Кастомизация приложения в разрезе окружений с помощью Helm?

У нас может быть достаточно много окружений, похожих в целом, но, в то же время, имеющих несколько важных отличий.
Среди последних можно выделить два типа:

Отличия, связанные с параметрами работы приложений (например, данные внешних систем, имена баз, очередей и т. п.).

Отличия в инфраструктуре (адреса ингрессов, количество реплик, включение или отключение инфраструктурных компонентов).

Согласно лучшим практикам, мы должны уметь передавать рабочие параметры в приложение как можно ближе к деплою. Если вы до сих пор устанавливаете их при сборке имиджа или запекаете в образ, не делайте так — этот подход чреват многими проблемами. Хороший способ управления рабочими параметрами — передавать их через переменные окружения или configmap, которые монтируются в под.
Управление инфраструктурными изменениями концептуально сходно с управлением рабочими параметрами приложения: в рамках Helm это изменение текстовых файлов в зависимости от набора входных значений.
Чтобы управлять входными значениями, в Helm есть механизм Values, расположенный в файле values.yaml, Мы можем использовать values в templates. Values.yaml представляет собой иерархическую древовидную структуру «ключ — значение». С ее помощью мы можем создавать нужную группировку и мнемонику для наших входных величин.
Но values.yaml — статический способ задания величин. Очевидно, что нам нужно менять некоторые values при деплое в конкретное окружение.

--------------------------------------------------------------------------------------------------------------------