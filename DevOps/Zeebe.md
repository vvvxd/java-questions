### 1. Фундаментальная база (Без этого никак)

#### **BPMN 2.0: Язык, на котором "думает" Zeebe**и

Для движка Zeebe диаграмма BPMN — это не просто визуальное представление, а строгая программа. Движок управляет "токенами" — маркерами
состояния, которые перемещаются по элементам диаграммы, запуская определенные действия.

---

#### Задачи (Tasks): Точки выполнения логики

Задачи — это шаги процесса, где выполняется какая-либо работа. Метод выполнения кардинально отличается.

* **Service Task (Сервисная задача) и User Task (Пользовательская задача):**
    * **Принцип:** **Делегирование работы.** Zeebe не выполняет бизнес-логику сам.
    * **Механизм:**
        1. Когда токен процесса достигает задачи, Zeebe создает **задание (Job)**. Это запись, содержащая тип задачи, все переменные
           процесса и уникальный ID.
        2. Токен процесса **"замирает"** на этом шаге, переходя в состояние ожидания.
        3. Внешний обработчик (**Job Worker**) — ваш микросервис — запрашивает у Zeebe задания своего типа.
        4. Получив Job, воркер выполняет необходимую бизнес-логику (например, обращается к базе данных, вызывает другой API).
        5. После завершения воркер отправляет Zeebe команду `complete job`. Только после этого Zeebe "пробуждает" токен, и он движется
           дальше по процессу.
    * **Ключевая идея:** Этот паттерн обеспечивает слабую связанность и отказоустойчивость. Движок оркестрирует, а микросервисы выполняют
      работу. Для `User Task` механизм тот же, но предполагается, что задание выполняет человек через пользовательский интерфейс.

* **Script Task (Скриптовая задача):**
    * **Принцип:** **Мгновенное выполнение внутри движка.**
    * **Механизм:** Код, написанный в задаче (обычно на языке FEEL), исполняется **синхронно** в том же потоке, который обрабатывает
      процесс.
    * **Назначение и ограничения:** Идеально подходит для простых, быстрых манипуляций с переменными процесса (`result = a + b`).
      Категорически **нельзя** использовать для долгих операций или сетевых вызовов, так как это напрямую замедлит производительность всего
      движка.

---

#### Шлюзы (Gateways): Управление логикой потока

Шлюзы — это точки принятия решений, которые направляют токены.

* **Exclusive (XOR) Gateway («Исключающий ИЛИ»):**
    * Направляет токен **только по одному пути**. Zeebe оценивает условия на исходящих ветках (например, `orderValue > 1000`) и выбирает
      первую, условие которой истинно. Если ни одно не подходит, используется "путь по умолчанию", иначе возникает ошибка (инцидент).

* **Parallel (AND) Gateway («Параллельный И»):**
    * Используется для распараллеливания и синхронизации.
    * **Разделяющий шлюз:** **Копирует токен** для каждой исходящей ветки, запуская их выполнение одновременно.
    * **Объединяющий шлюз:** **Ждет прибытия всех токенов**, созданных соответствующим разделяющим шлюзом. Процесс не пойдет дальше, пока
      все параллельные ветки не завершатся.

* **Inclusive (OR) Gateway («Включающий ИЛИ»):**
    * Гибкий, но сложный вариант. Zeebe оценивает условия на всех ветках и **активирует каждую, чье условие истинно**. Токен может пойти по
      одному, двум или более путям одновременно. Объединяющий шлюз будет ждать завершения всех активированных веток.

---

#### События (Events): Реакция на внешние и внутренние стимулы

События позволяют процессу реагировать на время, сообщения и ошибки.

* **Timer Events (События-таймеры):**
    * **Промежуточное событие:** Ставит процесс на паузу на заданное время ("подождать 1 час").
    * **Граничное событие (Boundary Event):** Прикрепляется к задаче и реализует **таймауты**. Таймер запускается вместе с задачей. Если
      задача завершается раньше — таймер отменяется. Если таймер срабатывает раньше — он **прерывает** выполнение задачи и направляет токен
      по альтернативному пути.

* **Message Events (События-сообщения):**
    * Ключевой механизм для асинхронной межпроцессной коммуникации. Когда процесс достигает такого события, он "подписывается" на сообщение
      с определенным **именем** и **корреляционным ключом** (например, `orderId = "123"`). Процесс замирает и ждет. Когда внешняя система
      отправляет в Zeebe сообщение с таким же именем и ключом, Zeebe находит нужный экземпляр процесса и "пробуждает" его.

* **Error Events (События-ошибки):**
    * Предназначены для обработки **предсказуемых бизнес-ошибок**, а не технических сбоев. Например, "недостаточно средств на счете".
    * Job Worker, столкнувшись с такой ситуацией, не просто падает, а отправляет в Zeebe команду `throw error` с кодом ошибки. Zeebe
      перехватывает ее и, если на диаграмме есть соответствующее граничное событие ошибки, направляет токен по пути обработки этого
      исключения.

---

#### **Оркестрация vs. Хореография: Роль Zeebe в мире микросервисов**

* **Оркестрация (модель Zeebe):**
    * **Что это:** Существует центральный компонент (оркестратор, в нашем случае Zeebe), который знает весь бизнес-процесс от начала до
      конца. Он не выполняет бизнес-логику сам, а **управляет потоком**, последовательно вызывая нужные микросервисы (через создание Jobs).
      Микросервисы выполняют свою узкую задачу и отчитываются перед оркестратором. Они не знают о существовании друг друга и о процессе в
      целом.
    * **Когда и почему выбирать:**
        1. **Сложные, долгоживущие процессы:** Если бизнес-транзакция включает 5-10 шагов, которые могут длиться часами или днями (например,
           обработка заказа: проверка, резервирование, оплата, доставка).
        2. **Нужна прозрачность и наблюдаемость:** BPMN-диаграмма в Zeebe — это "живая" документация и панель мониторинга. Вы всегда можете
           видеть, на каком шаге находится каждый заказ.
        3. **Централизованное управление состоянием и ошибками:** Zeebe берет на себя всю сложность отслеживания состояния ("оплачен ли
           заказ?"), тайм-аутов ("что делать, если оплата не пришла за 15 минут?"), компенсаций.
    * **Итог:** Zeebe — это "мозг" операции, который координирует "руки" (микросервисы).

* **Хореография:**
    * **Что это:** Нет центрального координатора. Сервисы общаются друг с другом через события (например, через брокер сообщений типа Kafka
      или RabbitMQ). Сервис А публикует событие "Заказ создан". Сервис Б подписывается на это событие, проверяет склад и публикует событие "
      Товар зарезервирован". Сервис В подписывается на него и инициирует оплату.
    * **Отличие:** Каждый сервис автономен, но и ответственен за знание того, на какие события ему реагировать. Общая картина процесса "
      размазана" по всем сервисам. Понять end-to-end поток и найти ошибку становится очень сложно (это называют "process spaghetti").

Zeebe был создан именно для того, чтобы решить проблемы хореографии в сложных сценариях, предоставив инструмент для явной, видимой и
управляемой оркестрации.

---

#### **gRPC: "Нервная система" Zeebe**

gRPC — это не просто выбор технологии, это фундаментальное архитектурное решение, которое обеспечивает производительность и надежность
Zeebe.

* **Что это такое:** Это современный фреймворк для удаленного вызова процедур (RPC), разработанный Google. Он используется для всего
  взаимодействия между клиентами (вашими приложениями, воркерами) и брокером Zeebe.

* **Protobuf (Protocol Buffers):**
    * Вместо текстового JSON, gRPC использует бинарный формат Protobuf. Вы описываете структуру данных (команды, события) в
      специальном `.proto` файле. Это строгий контракт между клиентом и сервером.
    * **Почему это важно для Zeebe:**
        1. **Производительность:** Бинарный формат гораздо компактнее и быстрее для сериализации/десериализации, чем текст. Это снижает
           сетевой трафик и нагрузку на CPU, что критично для высоконагруженной системы, какой является Zeebe.
        2. **Строгая типизация:** Контракт в `.proto` файле гарантирует, что клиент и сервер "говорят на одном языке". Это исключает целые
           классы ошибок, связанных с опечатками в полях JSON или неверными типами данных.

* **Стриминг (Streaming): Ключевая особенность для воркеров.**
    * gRPC поддерживает двунаправленную потоковую передачу данных по одному TCP-соединению. Zeebe использует это в самом важном месте: в
      команде `ActivateJobs`.
    * **Как это работает:**
        1. Ваш Job Worker отправляет брокеру Zeebe один запрос `ActivateJobs` для определенного типа задач.
        2. Этот запрос открывает **долгоживущее соединение**.
        3. Теперь, как только в Zeebe появляется новый Job нужного типа, брокер **сам** отправляет (push) его воркеру по этому открытому
           соединению.
    * **Почему это кардинально лучше, чем HTTP Polling:** В классическом подходе (например, REST API), воркеру пришлось бы постоянно
      опрашивать сервер: "Есть работа? А сейчас? А теперь?". Это создает огромный лишний трафик и задержки. gRPC streaming позволяет Zeebe
      эффективно "раздавать" работу по мере ее поступления, что обеспечивает низкую задержку и высокую пропускную способность.

---

### 2. Ключевые концепции и архитектура Zeebe (Сердце системы)

#### **Архитектура Broker & Gateway: Разделяй и властвуй**

Представьте Zeebe-кластер не как монолит, а как систему из двух разных типов узлов с четким разделением обязанностей.

* **Broker (Брокер): Мозг и Память (Stateful)**
    * **Что это:** Это основной рабочий компонент. Именно брокер **выполняет** логику BPMN-процессов.
    * **Что он хранит:** Каждый брокер несет ответственность за хранение данных (состояния) для определенного набора процессов. Эти данные —
      это лог событий и текущее состояние (о них ниже). Поэтому он называется **stateful** (с состоянием). Он должен помнить, на каком шаге
      находится каждый процесс, какие у него переменные и т.д.
    * **Его задача:** Обрабатывать команды (`создать экземпляр`, `завершить задачу`), продвигать токены по диаграмме, управлять таймерами и
      записывать все происходящее в свой лог. Это тяжелая, ответственная работа.

* **Gateway (Шлюз): Привратник и Маршрутизатор (Stateless)**
    * **Что это:** Это точка входа для всех внешних клиентов (ваших приложений, воркеров).
    * **Что он хранит:** **Ничего.** Шлюз не хранит состояние процессов. Он не знает, на каком шаге находится заказ #123. Поэтому он *
      *stateless** (без состояния). Его можно перезапустить или заменить в любой момент без потери данных.
    * **Его задача:**
        1. **Принять запрос** от клиента (например, `создать процесс заказа`).
        2. **Аутентифицировать** и **авторизовать** запрос.
        3. **Определить**, какой именно брокер (и какая партиция на нем) должен обработать этот запрос.
        4. **Перенаправить** запрос на нужный брокер.
        5. Получить ответ от брокера и вернуть его клиенту.
    * **Зачем это разделение?** Для **масштабируемости и гибкости**. Брокеры — "тяжелые" компоненты. Шлюзы — "легкие". Вы можете запустить
      много легковесных шлюзов за стандартным балансировщиком нагрузки (load balancer), чтобы обрабатывать огромное количество входящих
      клиентских соединений. А количество "тяжелых" брокеров вы будете наращивать по мере роста реальной нагрузки на исполнение процессов.
      Шлюз скрывает от клиента всю сложность внутреннего устройства кластера.

---

#### **Партиции (Partitions) и Репликация (Replication): Масштаб и Безопасность**

Это два механизма, которые позволяют Zeebe быть одновременно очень большим и очень надежным.

* **Партиционирование: Ключ к горизонтальному масштабированию**
    * **Что это:** Весь объем работы и данных в кластере делится на независимые части, называемые **партициями**. Каждая партиция — это, по
      сути, автономный движок процессов со своим собственным логом и состоянием.
    * **Как это работает:** Когда создается новый экземпляр процесса, Zeebe назначает его одной конкретной партиции (обычно по кругу,
      round-robin). С этого момента и до самого завершения этот экземпляр процесса будет "жить" и обрабатываться **только на этой партиции
      **. Все команды, касающиеся этого экземпляра (завершение задачи, обновление переменных), будут направляться именно на нее.
    * **Зачем это нужно:** Чтобы преодолеть ограничения одного сервера. Один сервер может обработать N процессов в секунду. Чтобы обработать
      10*N, вы не покупаете сервер в 10 раз мощнее (это дорого и имеет пределы), а запускаете кластер с 10 партициями. Нагрузка
      распределяется, и общая пропускная способность системы растет линейно с добавлением новых партиций (и брокеров для их размещения).

* **Репликация и консенсус (Raft): Ключ к отказоустойчивости**
    * **Что это:** Каждая партиция физически существует не в одном, а в нескольких экземплярах (копиях), называемых **репликами**. Эти
      реплики обычно размещаются на разных физических серверах (брокерах).
    * **Как это работает (протокол Raft):**
        1. В группе реплик одной партиции всегда есть один **Лидер (Leader)** и несколько **Последователей (Followers)**.
        2. **Только Лидер** имеет право записывать новые данные (команды и события) в лог партиции.
        3. Когда Лидер получает команду, он сначала записывает ее себе, а затем **отправляет копию всем своим Последователям**.
        4. Операция считается успешно выполненной (**committed**) только тогда, когда Лидер получил подтверждение от **большинства** (
           кворума) Последователей.
        5. **Если Лидер падает** (сервер выключился), оставшиеся Последователи проводят между собой выборы и выбирают нового Лидера из тех,
           у кого самая полная и актуальная копия лога.
    * **Зачем это нужно:** Чтобы **не терять данные**. Благодаря этому механизму, даже если сервер, на котором находился Лидер партиции,
      сгорает, данные не теряются. Система автоматически "лечит" себя, выбирая нового Лидера, и продолжает работать. Процессы, которые были
      на этой партиции, просто продолжат выполняться.

---

#### **Append-only Log: Неизменяемая правда**

Это самая фундаментальная концепция хранения данных в Zeebe.

* **Что это:** Это журнал, в который можно **только дописывать** в конец. Нельзя изменять или удалять уже существующие записи. Представьте
  бухгалтерскую книгу: вы не стираете старую транзакцию, а делаете новую, корректирующую.
* **Что в него пишется:** Все, что происходит в системе, записывается в лог как последовательность записей двух типов:
    * **Команды (Commands):** Намерение что-то изменить. "Создать экземпляр процесса", "Завершить задачу", "Отправить сообщение".
    * **События (Events):** Факт того, что что-то произошло в результате выполнения команды. "Экземпляр процесса создан", "Задача
      завершена", "Сообщение отправлено".
* **Почему это основа всего:**
    1. **Производительность:** Последовательная запись на диск — одна из самых быстрых дисковых операций.
    2. **Надежность:** В случае сбоя не нужно разбираться со сложным состоянием в памяти. Нужно просто перечитать лог с последнего
       известного места и восстановить состояние.
    3. **Аудит и отладка:** Лог является идеальным, полным и неизменяемым следом всего, что происходило в системе.
    4. **Источник для всего остального:** И текущее состояние (State), и данные для мониторинга (Exporters) строятся путем чтения этого
       единого источника правды.

---

#### **State & RocksDB: Мгновенный снимок состояния**

* **Проблема:** Лог — это история. Чтобы узнать текущие переменные процесса, перечитывать всю его историю с самого начала — очень медленно.
* **Решение:** Zeebe в реальном времени строит и поддерживает **актуальное состояние (State)**. Это, по сути, "снимок" или "индекс" системы
  на текущий момент: какие процессы активны, на каких они шагах, какие у них переменные, какие таймеры ждут своего часа.
* **Как это работает:** Специальный внутренний компонент брокера постоянно читает append-only log. Когда он видит
  событие `PROCESS_INSTANCE_CREATED`, он добавляет запись в State. Когда видит `VARIABLES_UPDATED`, он обновляет переменные для нужного
  процесса в State.
* **Где хранится:** Это состояние хранится не в оперативной памяти (она энергозависима), а во встраиваемой key-value базе данных **RocksDB
  **.
* **Почему RocksDB:** Это высокопроизводительная СУБД от Facebook, оптимизированная для работы с быстрыми SSD-накопителями. Она встраивается
  прямо в процесс брокера, что исключает сетевые задержки при доступе к состоянию. Она обеспечивает персистентность (данные сохраняются
  между перезапусками) и очень быстрый доступ по ключу (например, "дай мне все данные для process instance ID 12345").

---

#### **Job Workers & Long-Polling: Эффективный опрос**

* **Как воркер получает работу:** Zeebe использует модель "вытягивания" (pull), а не "проталкивания" (push). Воркеры сами активно
  запрашивают работу у брокера (через шлюз).
* **Механизм Long-Polling (Длинный опрос):** Это умный способ опроса, который решает проблему постоянных пустых запросов.
    1. Воркер отправляет шлюзу запрос: "Привет, есть для меня работа типа `payment-service`? Я готов взять до 10 штук".
    2. Шлюз смотрит в бэклог. Если работа есть — он **немедленно** отдает ее воркеру.
    3. Если работы **нет**, шлюз **не отвечает** "ничего нет". Вместо этого он удерживает TCP-соединение открытым в течение некоторого
       времени (например, 30 секунд).
    4. Если в течение этих 30 секунд в Zeebe появляется подходящая задача, шлюз тут же отправляет ее по этому открытому соединению воркеру.
    5. Если за 30 секунд ничего не появилось, шлюз отвечает пустым списком, и воркер немедленно открывает новый такой же "длинный" запрос.
* **Почему это так эффективно:**
    * **Реактивность:** Работа доставляется воркеру почти мгновенно, как только она появляется. Задержка минимальна.
    * **Нет лишней нагрузки:** Воркер не "долбит" брокер сотнями запросов в секунду. В периоды простоя сетевой трафик почти нулевой.
    * **Обратное давление (Backpressure):** Воркеры забирают работу с той скоростью, с которой могут ее обработать. Если воркеры
      перегружены, они просто перестают запрашивать новую работу. Это не дает брокеру "завалить" их задачами и защищает всю систему от
      перегрузки. Вы можете безопасно добавлять и убирать воркеры, и система сама найдет баланс.

---

#### **Exporters: Окно во внешний мир**

* **Проблема:** Данные внутри Zeebe (в логе) находятся в бинарном, внутреннем формате. Как их увидеть и использовать для мониторинга,
  аналитики, бизнес-анализа?
* **Решение: Экспортеры.**
* **Что это:** Это плагины, которые работают внутри брокера. Их единственная задача — **читать append-only log** в реальном времени и
  отправлять эти данные во внешние системы в понятном им формате.
* **Как это работает:** Экспортер подписывается на поток событий из лога. Как только в лог пишется новое событие (
  например, `JOB_COMPLETED`), брокер передает его экспортеру. Экспортер форматирует его (например, в JSON) и отправляет по назначению.
* **Примеры:**
    * **Elasticsearch Exporter:** Отправляет все события в Elasticsearch. На этих данных работает Camunda Operate, показывая вам красивые
      диаграммы и состояния процессов.
    * **Prometheus Exporter:** Не отправляет каждое событие, а агрегирует их в
      метрики (`количество_активных_процессов`, `число_ошибок_в_минуту`) и предоставляет их для сбора системой мониторинга Prometheus.
    * **Собственные экспортеры:** Вы можете написать свой экспортер для отправки данных в Kafka, реляционную базу данных или любую другую
      систему.
* **Зачем это нужно:** Это элегантный способ **отделить исполнение процессов от их наблюдения**. Основной движок занят только своей главной
  задачей — быстрым и надежным выполнением. А задача выгрузки данных полностью делегирована сменным модулям-экспортерам.

### 3. Практическое применение и паттерны проектирования

#### 1. Идемпотентность воркеров: Защита от двойного выполнения

* **Проблема:** Zeebe гарантирует доставку задания **как минимум один раз**. Если воркер выполнил работу, но упал до отправки подтверждения,
  Zeebe предложит это задание снова, что может привести к двойному списанию денег.
* **Решение:** Воркер должен быть идемпотентным (повторный вызов дает тот же результат, что и первый).
* **Как реализовать:**
    1. Используйте уникальный идентификатор (например, бизнес-ключ процесса `orderId`).
    2. **Перед выполнением работы** проверьте во внешнем хранилище (БД, Redis), был ли этот ID уже обработан.
    3. Если да — ничего не делайте, просто завершите задание.
    4. Если нет — выполните работу и **в одной транзакции** с ней сохраните ID как обработанный.

#### 2. Обработка ошибок: Технические vs. Бизнес-проблемы

* **Технические ошибки (временные сбои):**
    * **Что это:** Сбой сети, недоступность сервиса. Есть шанс, что повторная попытка будет успешной.
    * **Как обрабатывать:** В коде воркера ловите исключение и вызывайте команду **`fail`**, уменьшая счетчик попыток. Zeebe вернет задачу
      позже. Если все попытки исчерпаны, создается **Инцидент** для ручного вмешательства.
* **Бизнес-ошибки (ожидаемые негативные исходы):**
    * **Что это:** "Недостаточно средств", "Товар не найден". Повторять бессмысленно.
    * **Как обрабатывать:** В BPMN-модели прикрепите к задаче **Error Boundary Event** с кодом ошибки. В коде воркера, обнаружив такую
      ситуацию, вызывайте команду **`throw error`** с этим кодом. Zeebe перенаправит процесс по альтернативному, заранее смоделированному
      пути.

#### 3. Паттерн Saga: Управление распределенными транзакциями

* **Проблема:** Как обеспечить консистентность операции, затрагивающей несколько микросервисов, без ACID-транзакций?
* **Решение:** Zeebe — идеальный **оркестратор для паттерна Saga**.
* **Как реализовать:**
    * **Прямой путь:** Последовательность `Service Task` для выполнения операций ("Забронировать отель", "Купить билет").
    * **Компенсация:** Если шаг провалился (например, через бизнес-ошибку), токен направляется по пути, на котором стоят
      другие `Service Task` для выполнения **компенсирующих действий** ("Отменить бронь отеля", "Вернуть деньги за билет").

#### 4. Управление данными: Паттерн "Claim Check" ("Гардеробный номерок")

* **Проблема:** Хранение больших данных (файлов, мегабайтных JSON) в переменных процесса "раздувает" состояние и замедляет Zeebe.
* **Решение:** Не храните большие данные в Zeebe.
* **Как реализовать:**
    1. Сохраните большой файл во внешнее хранилище (S3, MinIO).
    2. В переменные процесса положите **только ссылку/идентификатор** этого файла (тот самый "гардеробный номерок").
    3. Следующие воркеры используют эту ссылку, чтобы получить данные напрямую из внешнего хранилища.

#### 5. Версионирование процессов: Эволюция без хаоса

* **Как работает:** Развертывание BPMN-файла с уже существующим `processId` не перезаписывает старую версию, а создает **новую**.
* **Ключевые правила:**
    1. **Запущенные экземпляры** продолжают выполняться и завершаются по логике **своей старой версии**.
    2. **Новые экземпляры** всегда запускаются на **самой последней** развернутой версии.
* **Миграция:** Zeebe намеренно **не предоставляет** автоматической "горячей" миграции запущенного экземпляра на новую версию. Для зависших
  процессов рекомендуется либо завершить их на старой версии, либо отменить и запустить новый экземпляр вручную.

### Zeebe + Spring: Идеальный союз

Почему эта комбинация так удачна?

1. **Декларативный подход:** Вместо того чтобы вручную создавать и настраивать клиент Zeebe, открывать воркеры и управлять их жизненным
   циклом, вы просто используете аннотации Spring. Это делает код чище, понятнее и ближе к идиоматике Spring.
2. **Автоконфигурация:** Spring Boot берет на себя всю "черновую" работу по настройке соединения с Zeebe. Вам нужно лишь указать адрес
   брокера в `application.yml`, и все остальное заработает "из коробки".
3. **Интеграция с экосистемой Spring:** Вы получаете все преимущества Spring: внедрение зависимостей (DI), управление транзакциями,
   фреймворки для тестирования, метрики (Micrometer) и т.д. Ваш воркер — это обычный Spring Bean.

### Ключевой компонент: `spring-boot-starter-camunda-zeebe`

Это "магический клей", который соединяет ваш Spring Boot-проект с Zeebe. Когда вы добавляете эту зависимость в свой `pom.xml`
или `build.gradle`, она делает две главные вещи:

1. **Создает `ZeebeClient` Bean:** Она автоматически конфигурирует и предоставляет готовый к использованию бин `ZeebeClient` в контексте
   вашего приложения. Вы можете просто внедрить (`@Autowired`) его в любой свой сервис или контроллер.
2. **Сканирует аннотации:** Она ищет в вашем коде специальные аннотации (в первую очередь `@ZeebeWorker`) и на их основе автоматически
   создает, настраивает и запускает воркеры.

### Camunda 8: Экосистема для Production

#### 1. Operate: Приборная панель и центр управления

* **Что это:** Специализированный веб-интерфейс для **визуализации, мониторинга и оперативного управления** бизнес-процессами. Это основной
  инструмент для DevOps, службы поддержки и бизнес-аналитиков.

* **Почему это важно:** Без Operate движок Zeebe является "черным ящиком". Operate делает процессы прозрачными, позволяя ответить на
  критические вопросы:
    * **Обзор:** "Сколько заказов сейчас в обработке и на каких этапах?"
    * **Отладка:** "Почему заказ №12345 'завис' и какие у него были переменные в момент сбоя?"
    * **Управление:** "Как исправить ошибку и возобновить выполнение процесса?"

* **Как это работает (под капотом):** Архитектура разделяет сбор данных и их отображение для максимальной производительности.
    1. **Экспорт данных:** Zeebe в реальном времени записывает все события процесса (создан, задача активирована, ошибка возникла) в
       специальный компонент — **Elasticsearch Exporter**.
    2. **Хранение:** Экспортер отправляет эти данные в кластер **Elasticsearch**, где они индексируются для быстрого поиска и агрегации.
    3. **Визуализация:** Operate — это веб-приложение, которое читает данные **не из Zeebe напрямую, а из Elasticsearch**. Это позволяет
       строить сложные дашборды и выполнять поиск без нагрузки на сам движок процессов.
    4. **Обратная связь:** Когда вы выполняете действие в Operate (например, "Повторить попытку" для инцидента), интерфейс отправляет
       соответствующую **gRPC-команду** обратно в Zeebe, чтобы внести изменения в состояние процесса.

#### 2. Tasklist: Интерфейс для человека

* **Что это:** Готовое к использованию веб-приложение, которое предоставляет пользователям **персональный список дел** (`User Tasks`).

* **Почему это важно:** Если в процессе есть шаги, требующие ручного вмешательства ("Утвердить кредит", "Проверить документы"), Tasklist
  предоставляет стандартный, удобный интерфейс. Это избавляет команды от необходимости разрабатывать собственный UI для человеческих задач.

* **Как это работает (под капотом):** Архитектура очень похожа на Operate.
    1. **Экспорт данных:** Zeebe через Elasticsearch Exporter отправляет информацию о созданных `User Tasks` в специальные индексы
       Elasticsearch.
    2. **Отображение:** Tasklist читает эти индексы и показывает пользователю список назначенных ему задач, позволяя фильтровать их по
       группам или статусу.
    3. **Взаимодействие:** Когда пользователь заполняет форму и нажимает "Завершить задачу", Tasklist формирует и отправляет в Zeebe
       команду `complete job`, передавая введенные данные как переменные процесса.

#### 3. Connectors: Готовые строительные блоки для интеграций

* **Что это:** Переиспользуемые, готовые к работе **Job Workers**, предназначенные для интеграции с популярными внешними системами (
  например, вызов REST API, отправка сообщений в Kafka, работа с Google Drive).

* **Почему это важно:** Коннекторы радикально **ускоряют разработку и снижают количество шаблонного кода**. Вместо того чтобы писать код для
  HTTP-клиента, сериализации JSON и обработки ошибок, вы просто настраиваете готовый компонент. Они инкапсулируют лучшие практики
  интеграции.

* **Как это работает:**
    1. **Моделирование:** В BPMN-диаграмме вы используете Service Task со специальным типом, указывающим на нужный коннектор (
       например, `io.camunda:http-json:1`).
    2. **Конфигурация:** Параметры интеграции (URL, метод, тело запроса, заголовки аутентификации) задаются прямо в свойствах задачи в
       Modeler, а не в коде.
    3. **Исполнение:** Вы разворачиваете **Connector Runtime** — отдельное приложение, которое работает как универсальный Job Worker. Оно
       опрашивает Zeebe, забирает задачи для коннекторов, читает их конфигурацию из свойств задачи и выполняет соответствующую логику (
       например, делает REST-вызов).

    

