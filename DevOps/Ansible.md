# 1. **Понимание основ Ansible**

## 1.1 **Концепции**

### Что такое Ansible?

**Ansible** — это инструмент для **автоматизации IT-задач**, таких как:

- **Управление конфигурациями**: настройка серверов (установка пакетов, изменение файлов конфигурации).
- **Развертывание приложений**: автоматизация деплоя кода или сервисов.
- **Оркестрация**: координация работы нескольких серверов для выполнения сложных задач.

Ansible популярен благодаря своей **простоте**, **гибкости** и **легкости в использовании**. Он не требует сложной настройки, как другие
инструменты (например, Puppet или Chef), и подходит как для небольших, так и для крупных инфраструктур.

Основные черты Ansible:

- Написан на **Python**.
- Использует **YAML** для описания задач (простой и читаемый формат).
- Работает по модели **"push"** (без агентов) через **SSH**.
- Идемпотентен (повторное выполнение задач не ломает систему, если ничего не изменилось).

### Архитектура Ansible: Agentless и Push-based

#### 1. **Agentless (безагентная архитектура)**

Ansible не требует установки специального программного обеспечения (агентов) на управляемых узлах (серверах). Это делает его легким и
удобным в использовании.

- **Как это работает?**  
  Ansible подключается к узлам (серверам) через **SSH** (для Linux/Unix) или **WinRM** (для Windows). Вместо того чтобы устанавливать
  агенты, Ansible использует уже существующие протоколы и инструменты на сервере. Это означает:
  - Никакой дополнительной нагрузки на серверы.
  - Меньше точек отказа (нет агентов, которые могут сломаться).
  - Простая настройка: достаточно, чтобы на узле был SSH и Python (для Linux).

- **Почему это круто?**
  - Не нужно обновлять или поддерживать агентов.
  - Легко начать работу даже на старых системах.
  - Меньше проблем с безопасностью, так как нет дополнительного ПО.

#### 2. **Push-based (модель "толкания")**

Ansible работает по модели "push", то есть управляющий сервер (где установлен Ansible, так называемый **control node**) "толкает" команды и
конфигурации на управляемые узлы.

- **Как это работает?**
  - Вы запускаете команду или плейбук с управляющего узла.
  - Ansible через SSH передает инструкции (задачи) на целевые узлы.
  - Узлы выполняют задачи и возвращают результат (успех или ошибка) обратно на управляющий узел.

- **Сравнение с pull-моделью**:
  - В pull-модели (как у Puppet или Chef) узлы сами периодически запрашивают конфигурации у центрального сервера. Это требует установки
    агентов и постоянного соединения.
  - В push-модели Ansible сам инициирует изменения, что проще для разовых задач и не требует постоянного соединения.

- **Преимущества push-модели**:
  - Мгновенное выполнение задач (не нужно ждать, пока узел "проснется").
  - Подходит для динамических сред, где узлы могут часто меняться (например, в облаке).
  - Меньше зависимостей, так как не требуется центральный сервер для хранения конфигураций.

- **Недостатки**:
  - Если узел недоступен (например, выключен), Ansible не сможет выполнить задачу.
  - При большом количестве узлов SSH-соединения могут создавать нагрузку (но это решается настройкой параллелизма).

### Как Ansible использует SSH для управления узлами?

SSH (Secure Shell) — это основа работы Ansible для Linux/Unix-систем. Давай разберем, как это происходит шаг за шагом:

#### 1. **Подготовка к использованию SSH**

Чтобы Ansible мог управлять узлами через SSH, нужно выполнить несколько условий:

- На **управляющем узле** (где установлен Ansible) должен быть SSH-клиент.
- На **управляемых узлах** должен быть:
  - Установлен SSH-сервер (`sshd`).
  - Доступен Python (обычно версия 2.7 или 3.x, так как большинство модулей Ansible написаны на Python).
- **SSH-ключи** или **пароли**:
  - Лучшая практика — использовать SSH-ключи для аутентификации (без пароля). Это безопаснее и удобнее.
  - Вы создаете пару ключей (`ssh-keygen`), копируете публичный ключ на управляемые узлы (`ssh-copy-id`), и Ansible использует приватный
    ключ для подключения.
  - Если пароли все же используются, Ansible может запрашивать их или использовать `ansible-vault` для хранения зашифрованных паролей.

#### 2. **Процесс работы через SSH**

Когда вы запускаете команду Ansible (например, `ansible` или `ansible-playbook`), происходит следующее:

1. **Чтение инвентаря**: Ansible смотрит в файл инвентаря (`inventory`), где указаны IP-адреса или доменные имена узлов, а также группы (
   например, `webservers`, `databases`).
2. **Установление SSH-соединения**:

- Ansible подключается к каждому узлу через SSH, используя указанные учетные данные (ключ или пароль).
- Если нужно выполнить привилегированные действия (например, установка пакетов), Ansible может использовать `sudo` (настраивается через
  параметр `become`).

3. **Передача модулей**:

- Ansible отправляет на узел небольшой Python-скрипт (модуль), который выполняет конкретную задачу (например, установка пакета через `apt`
  или копирование файла).
- Этот скрипт выполняется на узле, а результат отправляется обратно на управляющий узел.

4. **Очистка**: После выполнения задачи временные файлы (скрипты) удаляются с узла, чтобы не оставлять следов.
5. **Возврат результата**: Ansible собирает результаты (логи, статусы выполнения) и выводит их в консоль или сохраняет, если указано.

#### 3. **Ключевые моменты про SSH в Ansible**

- **Безопасность**:
  - SSH обеспечивает шифрование соединения, что делает взаимодействие безопасным.
  - Используйте SSH-ключи вместо паролей, чтобы минимизировать риски.
  - Для дополнительной безопасности можно настроить `ansible-vault` для хранения паролей или ключей.
- **Параллелизм**:
  - Ansible по умолчанию выполняет задачи на нескольких узлах параллельно (параметр `forks` в `ansible.cfg`).
  - Это ускоряет работу, но требует стабильного SSH-соединения.
- **Ошибки SSH**:
  - Если узел недоступен, SSH-соединение не установится, и задача завершится с ошибкой.
  - Проблемы с аутентификацией (неверные ключи, пароли) — частая причина сбоев. Проверяйте настройки SSH и инвентаря.

#### 4. **Пример простого взаимодействия**

Предположим, у вас есть файл инвентаря `inventory.yml`:

```yaml
all:
  hosts:
    webserver1:
      ansible_host: 192.168.1.100
    webserver2:
      ansible_host: 192.168.1.101
```

И плейбук `install_apache.yml`:

```yaml
---
- name: Install Apache on webservers
  hosts: all
  become: yes  # Использовать sudo
  tasks:
    - name: Install Apache
      apt:
        name: apache2
        state: present
```

- Вы запускаете: `ansible-playbook -i inventory.yml install_apache.yml`.
- Ansible:
  1. Читает инвентарь и узнает, что нужно подключиться к `192.168.1.100` и `192.168.1.101`.
  2. Устанавливает SSH-соединение с каждым узлом.
  3. Отправляет модуль `apt` (в виде Python-скрипта) для установки пакета `apache2`.
  4. Выполняет задачу через `sudo` (если `become: yes`).
  5. Возвращает результат: "Apache установлен" или "Ошибка, пакет уже установлен".

### Почему архитектура Ansible эффективна?

1. **Простота**:

- Не нужно устанавливать агенты, достаточно SSH и Python.
- YAML-плейбуки легко читаются даже новичками.

2. **Гибкость**:

- Подходит для управления серверами, облаками (AWS, Azure), контейнерами (Docker), сетевыми устройствами (Cisco, Juniper).
- Легко интегрируется с другими инструментами (Terraform, Jenkins).

3. **Масштабируемость**:

- Управляет от одного до тысяч серверов.
- Динамический инвентарь позволяет автоматически работать с облачными ресурсами.

4. **Идемпотентность**:

- Ansible проверяет состояние системы перед выполнением задачи (например, не устанавливает пакет, если он уже есть).

### Что важно запомнить?

- **Agentless**: Ansible не требует установки ПО на узлы, только SSH и Python.
- **Push-based**: Управляющий узел сам инициирует изменения, отправляя команды через SSH.
- **SSH в основе**: Ansible использует SSH для безопасного и простого взаимодействия с узлами.

## 1.2 **Терминология**:

### **Inventory** (Инвентарь)

**Inventory** — это файл (или группа файлов), где вы указываете, какие серверы (узлы) Ansible будет управлять, и как их группировать.

- **Что это?**
  - Инвентарь определяет список хостов (серверов) и их организацию в группы.
  - Это как адресная книга, где вы говорите Ansible: "Вот мои серверы, вот их IP-адреса, и вот как я их называю".
  - Обычно инвентарь пишется в формате **INI** или **YAML**, но может быть и динамическим (например, из облака AWS).

- **Пример** (файл `inventory.yml`):
  ```yaml
  all:
    hosts:
      web1:
        ansible_host: 192.168.1.100
      web2:
        ansible_host: 192.168.1.101
    children:
      webservers:
        hosts:
          web1:
          web2:
      databases:
        hosts:
          db1:
            ansible_host: 192.168.1.200
  ```
  Здесь:
  - `web1` и `web2` — это имена хостов.
  - `ansible_host` — IP-адрес или доменное имя сервера.
  - `webservers` и `databases` — группы хостов для удобства управления.

- **Зачем нужен?**
  - Позволяет Ansible знать, к каким серверам подключаться.
  - Группы упрощают выполнение задач на определенных наборах серверов (например, только на `webservers`).
  - Можно задавать параметры подключения (порт SSH, пользователь, ключи) прямо в инвентаре.

- **Динамический инвентарь**:
  - Если вы работаете с облаком (AWS, Azure), инвентарь можно генерировать автоматически, чтобы Ansible сам находил новые серверы.

- **Полезно знать**:
  - Файл инвентаря по умолчанию: `/etc/ansible/hosts`.
  - Можно указать свой файл с помощью флага `-i` (например, `ansible-playbook -i inventory.yml`).

### **Playbooks** (Плейбуки)

**Playbooks** — это YAML-файлы, в которых описывается, что Ansible должен сделать на серверах: какие задачи выполнить, на каких хостах и в
каком порядке.

- **Что это?**
  - Плейбук — это "сценарий автоматизации", где вы описываете последовательность действий (задач).
  - Написан в формате YAML, который прост для чтения и понимания.
  - Один плейбук может содержать несколько "плей" (plays), каждая из которых выполняется на определенной группе хостов.

- **Пример** (файл `deploy_web.yml`):
  ```yaml
  ---
  - name: Deploy web server
    hosts: webservers
    become: yes
    tasks:
      - name: Install Apache
        apt:
          name: apache2
          state: present
      - name: Start Apache
        service:
          name: apache2
          state: started
  ```
  Здесь:
  - `hosts: webservers` — задачи выполняются на группе `webservers` из инвентаря.
  - `become: yes` — использовать `sudo` для привилегированных операций.
  - `tasks` — список задач (установка и запуск Apache).

- **Зачем нужен?**
  - Плейбуки — это основной способ описания автоматизации в Ansible.
  - Они позволяют выполнять сложные сценарии: от установки ПО до настройки кластеров.
  - Идемпотентны: повторный запуск не ломает систему, если задачи уже выполнены.

- **Полезно знать**:
  - Плейбуки можно запускать командой `ansible-playbook <файл>.yml`.
  - Используйте `--check` для "сухого прогона" (проверка без реальных изменений).
  - Плейбуки поддерживают переменные, условия и циклы для гибкости.

### **Roles** (Роли)

**Roles** — это способ организовать задачи, файлы, шаблоны и переменные в модульную структуру, чтобы код был переиспользуемым и аккуратным.

- **Что это?**
  - Роль — это папка с определенной структурой, где хранятся задачи, шаблоны, файлы и переменные для выполнения определенной функции (
    например, установка веб-сервера).
  - Роли позволяют избежать длинных и запутанных плейбуков, разбивая их на логические блоки.

- **Пример структуры роли**:
  ```
  roles/
    webserver/
      tasks/
        main.yml  # Основные задачи (например, установка Apache)
      templates/
        httpd.conf.j2  # Шаблон конфигурации
      files/
        index.html  # Статические файлы
      vars/
        main.yml  # Переменные (например, порт сервера)
      defaults/
        main.yml  # Переменные по умолчанию
      handlers/
        main.yml  # Обработчики (например, перезапуск сервиса)
  ```

- **Как использовать?**
  В плейбуке:
  ```yaml
  ---
  - name: Deploy web server
    hosts: webservers
    roles:
      - webserver
  ```
  Здесь Ansible автоматически выполнит все задачи из роли `webserver`.

- **Зачем нужны?**
  - Упрощают организацию сложных проектов.
  - Делают код переиспользуемым (можно использовать одну роль для разных серверов).
  - Удобны для работы в команде и интеграции с **Ansible Galaxy** (репозиторий готовых ролей).

- **Полезно знать**:
  - Роли создаются командой `ansible-galaxy init <имя_роли>`.
  - Готовые роли можно скачать с Galaxy: `ansible-galaxy install <имя_роли>`.

### **Tasks** (Задачи)

**Tasks** — это отдельные действия, которые Ansible выполняет на узлах. Каждая задача — это вызов определенного модуля с параметрами.

- **Что это?**
  - Задача — это минимальная единица работы в Ansible (например, установить пакет, скопировать файл, запустить сервис).
  - Задачи указываются в плейбуках или ролях в разделе `tasks`.

- **Пример**:
  ```yaml
  - name: Ensure Nginx is installed
    apt:
      name: nginx
      state: present
  ```
  Здесь:
  - `name` — описание задачи для удобства чтения.
  - `apt` — модуль для работы с пакетами в Debian/Ubuntu.
  - `state: present` — указывает, что пакет должен быть установлен.

- **Зачем нужны?**
  - Задачи — это "кирпичики" автоматизации.
  - Каждая задача идемпотентна (не выполняется, если состояние уже соответствует желаемому).

- **Полезно знать**:
  - Задачи выполняются последовательно, но можно использовать условия (`when`) или циклы (`loop`).
  - Если задача завершается с ошибкой, выполнение плейбука может остановиться (настраивается параметром `ignore_errors`).

### **Modules** (Модули)

**Modules** — это готовые скрипты (обычно на Python), которые Ansible использует для выполнения конкретных задач.

- **Что это?**
  - Модули — это "инструменты" Ansible, которые делают конкретную работу: установка пакетов, управление файлами, запуск команд и т.д.
  - Ansible поставляется с сотнями встроенных модулей (например, `apt`, `yum`, `copy`, `service`, `command`).

- **Пример**:
  ```yaml
  - name: Copy index.html to web server
    copy:
      src: files/index.html
      dest: /var/www/html/index.html
      mode: '0644'
  ```
  Здесь модуль `copy` копирует файл с управляющего узла на целевой сервер.

- **Зачем нужны?**
  - Модули упрощают автоматизацию, так как уже содержат готовую логику.
  - Они идемпотентны: например, модуль `copy` не перезапишет файл, если он уже существует и не изменился.

- **Полезно знать**:
  - Полный список модулей — в [документации Ansible](https://docs.ansible.com/ansible/latest/collections/index_module.html).
  - Можно писать собственные модули на Python, если встроенных не хватает.

### **Facts** (Факты)

**Facts** — это информация о системе, которую Ansible автоматически собирает с управляемых узлов перед выполнением задач.

- **Что это?**
  - Факты — это данные о сервере: ОС, IP-адреса, объем памяти, процессор, установленные пакеты и т.д.
  - Ansible собирает их с помощью модуля `setup` перед запуском плейбука.

- **Пример использования**:
  ```yaml
  - name: Print OS information
    debug:
      msg: "This server runs {{ ansible_distribution }} {{ ansible_distribution_version }}"
  ```
  Вывод может быть: `This server runs Ubuntu 20.04`.

- **Зачем нужны?**
  - Факты позволяют адаптировать задачи под конкретные условия (например, разные пакеты для Ubuntu и CentOS).
  - Используются в условиях (`when`) и шаблонах Jinja2.

- **Пример с условием**:
  ```yaml
  - name: Install package for Ubuntu
    apt:
      name: apache2
      state: present
    when: ansible_distribution == "Ubuntu"
  ```

- **Полезно знать**:
  - Факты можно отключить (`gather_facts: no`) для ускорения выполнения.
  - Можно собирать только нужные факты с помощью `gather_subset`.
  - Пользовательские факты можно задавать через файлы в `/etc/ansible/facts.d/`.

### Как всё связано?

- **Inventory** определяет, на каких серверах работать.
- **Playbooks** описывают, что делать, используя **Tasks**.
- **Tasks** используют **Modules** для выполнения конкретных действий.
- **Roles** организуют задачи, файлы и переменные в переиспользуемые блоки.
- **Facts** дают информацию о серверах для адаптации задач.

### Практический пример

Предположим, вы хотите установить Nginx на серверы `webservers`:

1. **Inventory** (`inventory.yml`):
   ```yaml
   all:
     hosts:
       web1:
         ansible_host: 192.168.1.100
     children:
       webservers:
         hosts:
           web1:
   ```
2. **Playbook** (`install_nginx.yml`):
   ```yaml
   ---
   - name: Setup web server
     hosts: webservers
     become: yes
     roles:
       - nginx_role
   ```
3. **Role** (`roles/nginx_role/tasks/main.yml`):
   ```yaml
   - name: Install Nginx
     apt:
       name: nginx
       state: present
   - name: Copy config file
     copy:
       src: nginx.conf
       dest: /etc/nginx/nginx.conf
     notify: Restart Nginx
   ```
4. **Handlers** (`roles/nginx_role/handlers/main.yml`):
   ```yaml
   - name: Restart Nginx
     service:
       name: nginx
       state: restarted
   ```
5. **Facts**:
   В плейбуке можно использовать факты, чтобы, например, установить разные пакеты для разных ОС:
   ```yaml
   - name: Install web server
     package:
       name: "{{ 'nginx' if ansible_distribution == 'Ubuntu' else 'httpd' }}"
       state: present
   ```

### Полезные советы

- **Inventory**: Начните с простого INI-файла, затем переходите к YAML и динамическому инвентарю.
- **Playbooks**: Пишите короткие и понятные плейбуки, используйте роли для сложных задач.
- **Roles**: Структурируйте код с самого начала, чтобы избежать хаоса.
- **Tasks**: Проверяйте идемпотентность, используйте модули вместо команд `shell` там, где возможно.
- **Modules**: Изучите основные модули (`apt`, `yum`, `copy`, `template`, `service`) — они покрывают 80% задач.
- **Facts**: Используйте факты для гибкости, но отключайте сбор, если он замедляет выполнение.

## 1.3 **Конфигурация**:

### Что такое `ansible.cfg`?

`ansible.cfg` — это конфигурационный файл Ansible, в котором задаются настройки для управления поведением инструмента. Он определяет, как
Ansible подключается к узлам, где искать файлы (инвентарь, роли, плейбуки), и как выполнять задачи.

- **Зачем нужен?**
  - Упрощает настройку параметров, чтобы не указывать их в командной строке.
  - Позволяет задать глобальные или проектные настройки.
  - Дает гибкость в управлении подключением, логированием, параллелизмом и другими аспектами.

- **Где находится?**
  Ansible ищет `ansible.cfg` в следующем порядке (первый найденный используется):
  1. Переменная окружения `ANSIBLE_CONFIG` (например, `export ANSIBLE_CONFIG=/path/to/ansible.cfg`).
  2. `./ansible.cfg` — в текущей директории, где вы запускаете команду Ansible.
  3. `~/.ansible.cfg` — в домашней директории пользователя.
  4. `/etc/ansible/ansible.cfg` — глобальная конфигурация по умолчанию.

- **Формат**:
  Файл написан в формате **INI** и состоит из секций (например, `[defaults]`, `[inventory]`), где задаются параметры в виде `ключ=значение`.

### Основные секции и параметры `ansible.cfg`

Файл `ansible.cfg` делится на несколько секций, каждая из которых отвечает за определенные аспекты работы Ansible. Вот ключевые секции и
параметры, которые чаще всего настраивают:

#### 1. **[defaults]** — Общие настройки

Эта секция содержит основные параметры, влияющие на поведение Ansible.

- **inventory**  
  Указывает путь к файлу инвентаря (по умолчанию: `/etc/ansible/hosts`).
  ```ini
  inventory = /path/to/inventory.yml
  ```
  Пример: Если ваш инвентарь находится в `~/project/inventory.yml`, укажите путь к нему.

- **roles_path**  
  Путь к директории с ролями.
  ```ini
  roles_path = /path/to/roles
  ```
  Пример: `roles_path = ./roles:/usr/share/ansible/roles` — Ansible будет искать роли в этих папках.

- **library**  
  Путь к пользовательским модулям.
  ```ini
  library = /path/to/custom_modules
  ```

- **remote_user**  
  Имя пользователя для SSH-подключения к узлам.
  ```ini
  remote_user = ansible
  ```
  Пример: Если на серверах используется пользователь `admin`, укажите `remote_user = admin`.

- **become** и **become_user**  
  Включает использование привилегий (`sudo`) и задает пользователя для повышения прав.
  ```ini
  become = True
  become_user = root
  ```

- **forks**  
  Количество параллельных процессов для выполнения задач (по умолчанию: 5).
  ```ini
  forks = 10
  ```
  Увеличение этого значения ускоряет выполнение на большом количестве узлов, но требует больше ресурсов.

- **log_path**  
  Путь к файлу логов для записи результатов выполнения.
  ```ini
  log_path = /var/log/ansible.log
  ```

- **retry_files_enabled**  
  Включает/отключает создание файлов `.retry` для задач, которые завершились с ошибкой.
  ```ini
  retry_files_enabled = False
  ```

#### 2. **[privilege_escalation]** — Настройки повышения привилегий

Здесь задаются параметры для использования `sudo` или других методов повышения прав.

- **become_method**  
  Метод повышения привилегий (по умолчанию: `sudo`).
  ```ini
  become_method = sudo
  ```
  Другие варианты: `su`, `pbrun`, `pfexec`.

- **become_ask_pass**  
  Запрашивать пароль для `sudo` при выполнении.
  ```ini
  become_ask_pass = True
  ```

#### 3. **[ssh_connection]** — Настройки SSH-подключения

Эта секция управляет параметрами подключения к узлам через SSH.

- **ssh_args**  
  Дополнительные аргументы для SSH.
  ```ini
  ssh_args = -C -o ControlMaster=auto -o ControlPersist=60s
  ```
  Это включает мультиплексирование SSH для ускорения соединений.

- **pipelining**  
  Включает SSH-pipelining для уменьшения количества соединений (ускоряет выполнение).
  ```ini
  pipelining = True
  ```
  Требует, чтобы на узлах был отключен `requiretty` в настройках `sudo`.

- **private_key_file**  
  Путь к приватному SSH-ключу.
  ```ini
  private_key_file = /home/user/.ssh/id_rsa
  ```

- **timeout**  
  Таймаут для SSH-соединений (в секундах).
  ```ini
  timeout = 30
  ```

#### 4. **[inventory]** — Настройки инвентаря

- **enable_plugins**  
  Указывает, какие плагины инвентаря использовать (например, `yaml`, `ini`, `aws_ec2`).
  ```ini
  enable_plugins = yaml, ini
  ```

#### 5. **[callback]** — Настройки вывода и логов

- **callback_whitelist**  
  Указывает, какие плагины вывода использовать для кастомизации логов.
  ```ini
  callback_whitelist = profile_tasks
  ```
  Например, `profile_tasks` показывает время выполнения задач.

#### Пример файла `ansible.cfg`

```ini
[defaults]
inventory = ./inventory.yml
roles_path = ./roles
remote_user = ansible
forks = 10
log_path = ./ansible.log
retry_files_enabled = False

[privilege_escalation]
become = True
become_method = sudo
become_user = root
become_ask_pass = False

[ssh_connection]
pipelining = True
ssh_args = -C -o ControlMaster=auto -o ControlPersist=60s
timeout = 30
private_key_file = ~/.ssh/id_rsa
```

---

### Как настраивать `ansible.cfg`?

1. **Создание файла**:

- Создайте `ansible.cfg` в корне вашего проекта или в `~/.ansible.cfg`.
- Используйте текстовый редактор (например, `nano` или `vim`).

2. **Рекомендации по настройке**:

- **Пути**: Укажите пути к инвентарю (`inventory`), ролям (`roles_path`) и модулям (`library`), чтобы Ansible знал, где их искать.
- **Подключение**: Настройте `remote_user` и `private_key_file` для упрощения SSH-доступа.
- **Параллелизм**: Если управляете большим количеством узлов, увеличьте `forks` (например, до 50).
- **Логирование**: Включите `log_path` для отладки сложных плейбуков.
- **SSH-оптимизация**: Включите `pipelining` и настройте `ssh_args` для ускорения.

3. **Проверка конфигурации**:

- Проверьте, какой файл `ansible.cfg` используется, с помощью команды:
  ```bash
  ansible --version
  ```
  Она покажет путь к используемому конфигурационному файлу.
- Убедитесь, что пути к файлам (инвентарь, роли) существуют.
- Протестируйте настройки с помощью команды `ansible all -m ping` для проверки подключения.

4. **Переопределение настроек**:

- Параметры из `ansible.cfg` можно переопределить:
  - Через переменные окружения (например, `ANSIBLE_INVENTORY=/path/to/inventory`).
  - Через аргументы командной строки (например, `ansible-playbook -i inventory.yml`).
  - Через параметры в плейбуке (например, `become: yes`).

### Полезные советы

- **Минимализм**: Не перегружайте `ansible.cfg` лишними настройками — используйте только то, что нужно для вашего проекта.
- **Безопасность**:
  - Не храните пароли в `ansible.cfg`. Используйте `ansible-vault` для шифрования конфиденциальных данных.
  - Убедитесь, что SSH-ключи защищены (`chmod 600 ~/.ssh/id_rsa`).
- **Отладка**:
  - Включите `log_path` для записи логов при отладке.
  - Используйте `ansible-playbook --check` для проверки изменений без их применения.
- **Оптимизация**:
  - Включите `pipelining` для ускорения (но проверьте, что `requiretty` отключен в `/etc/sudoers`).
  - Настройте `forks` в зависимости от количества узлов и мощности управляющего сервера.

### Итог

Файл `ansible.cfg` — это центральное место для настройки поведения Ansible. Он позволяет:

- Задать пути к инвентарю, ролям и модулям.
- Настроить SSH-подключение (пользователь, ключи, таймауты).
- Управлять привилегиями (`sudo`) и параллелизмом.
- Включить логирование и оптимизировать производительность.

# 2. **Технические навыки**

## 2.1  **Linux/Unix**:

### Почему знание Linux/Unix важно для Ansible?

Ansible — это инструмент автоматизации, который чаще всего используется для управления **Linux/Unix-серверами** (хотя он также поддерживает
Windows и сетевые устройства). Поскольку Ansible взаимодействует с серверами через SSH и выполняет задачи, используя системные утилиты и
команды, знание Linux/Unix критически важно по следующим причинам:

- **SSH-подключение**: Ansible подключается к серверам через SSH, что требует понимания, как настроить SSH на Linux.
- **Модули Ansible**: Многие модули (например, `apt`, `yum`, `service`, `file`) взаимодействуют с Linux-системой, и для их использования
  нужно знать, как работают соответствующие команды и структуры в Linux.
- **Отладка**: Если задача Ansible завершается с ошибкой, вам нужно уметь анализировать состояние системы (файлы, процессы, логи) для
  диагностики.
- **Гибкость**: Знание Linux позволяет писать более сложные плейбуки, использовать пользовательские скрипты и адаптировать задачи под разные
  дистрибутивы.

Без базовых знаний Linux вы не сможете эффективно писать плейбуки, понимать, что делает Ansible, или исправлять ошибки. Давайте разберем
ключевые аспекты Linux/Unix, которые нужно знать.

### 1. **Команды Linux (Bash)**

**Bash** (Bourne Again Shell) — это основная командная оболочка в большинстве Linux/Unix-систем. Знание Bash-команд позволяет вам:

- Понимать, как Ansible выполняет задачи (многие модули являются обертками над командами).
- Писать пользовательские команды в модуле `command` или `shell`, если встроенных модулей недостаточно.
- Проверять состояние системы перед/после выполнения задач.

#### Ключевые команды, которые нужно знать:

- **Управление пакетами**:
  - `apt` (Debian/Ubuntu): `apt update`, `apt install nginx`, `apt remove nginx`.
  - `yum`/`dnf` (RHEL/CentOS): `yum install httpd`, `dnf update`.
  - Ansible использует модули `apt` и `yum` для этих задач, но вы должны понимать, что они делают.
  - Пример в Ansible:
    ```yaml
    - name: Install Nginx
      apt:
        name: nginx
        state: present
        update_cache: yes
    ```

- **Управление файлами**:
  - `ls`, `cp`, `mv`, `rm`, `mkdir`, `chown`, `chmod`: Для работы с файлами и директориями.
  - `cat`, `less`, `grep`: Для просмотра и поиска в файлах.
  - Ansible использует модули `file`, `copy`, `template` для этих операций.
  - Пример:
    ```yaml
    - name: Copy index.html
      copy:
        src: files/index.html
        dest: /var/www/html/index.html
        mode: '0644'
    ```

- **Управление сервисами**:
  - `systemctl start/stop/restart nginx`, `service nginx status`.
  - Ansible использует модуль `service`:
    ```yaml
    - name: Start Nginx
      service:
        name: nginx
        state: started
        enabled: yes
    ```

- **Команды для диагностики**:
  - `ps aux`: Просмотр запущенных процессов.
  - `top`/`htop`: Мониторинг процессов.
  - `df -h`, `du`: Проверка дискового пространства.
  - `netstat -tulpn`, `ss`: Просмотр сетевых соединений.
  - `journalctl`, `tail /var/log/syslog`: Чтение логов.
  - Эти команды полезны для отладки, если Ansible не выполняет задачу корректно.

- **Скрипты Bash**:
  - Иногда нужно запускать сложные команды через модуль `shell`:
    ```yaml
    - name: Run custom script
      shell: /path/to/script.sh
      args:
        executable: /bin/bash
    ```

#### Советы:

- Изучите основы Bash: переменные, циклы, условия (`if`, `for`, `while`).
- Практикуйтесь с командами в терминале, чтобы понять их вывод.
- Используйте модули Ansible вместо `shell`, где возможно, для идемпотентности.

### 2. **Файловая система Linux**

Понимание структуры файловой системы Linux необходимо, чтобы:

- Знать, где хранятся конфигурационные файлы, логи и данные.
- Настраивать права доступа и владельцев.
- Управлять файлами и директориями через Ansible.

#### Ключевые аспекты файловой системы:

- **Структура директорий**:
  - `/etc`: Конфигурационные файлы (например, `/etc/nginx/nginx.conf`, `/etc/ssh/sshd_config`).
  - `/var`: Данные приложений и логи (например, `/var/log/syslog`, `/var/www/html`).
  - `/home`: Домашние директории пользователей.
  - `/tmp`: Временные файлы.
  - `/usr`: Установленные программы и библиотеки.

- **Права доступа**:
  - Используйте `chmod` для установки прав (например, `chmod 644 file.txt`).
  - Используйте `chown` для смены владельца (например, `chown www-data:www-data /var/www/html`).
  - Ansible использует модули `file` и `copy`:
    ```yaml
    - name: Set permissions for web directory
      file:
        path: /var/www/html
        owner: www-data
        group: www-data
        mode: '0755'
    ```

- **Символические ссылки**:
  - Используйте `ln -s` для создания ссылок.
  - Ansible модуль `file`:
    ```yaml
    - name: Create symlink
      file:
        src: /var/www/html
        dest: /home/user/public_html
        state: link
    ```

- **Поиск файлов**:
  - Команды `find`, `locate` для поиска файлов.
  - Ansible может использовать модуль `find`:
    ```yaml
    - name: Find old log files
      find:
        paths: /var/log
        age: 30d
        file_type: file
      register: old_logs
    ```

#### Советы:

- Изучите стандартные пути для популярных сервисов (Nginx, Apache, MySQL).
- Проверяйте права доступа перед выполнением задач Ansible (`ls -l`).
- Используйте модуль `template` для динамических конфигурационных файлов.

### 3. **Процессы**

Понимание процессов в Linux помогает управлять сервисами, проверять их состояние и диагностировать проблемы.

#### Ключевые аспекты:

- **Просмотр процессов**:
  - `ps aux`: Показывает все процессы.
  - `top`/`htop`: Интерактивный мониторинг.
  - Ansible может проверять состояние процессов через модуль `service` или `shell`.

- **Управление сервисами**:
  - Используйте `systemctl` или `service` для запуска/остановки сервисов.
  - Ansible модуль `service`:
    ```yaml
    - name: Ensure Apache is running
      service:
        name: apache2
        state: started
        enabled: yes
    ```

- **Фоновые процессы**:
  - Если нужно запустить процесс в фоновом режиме, используйте `command` или `shell` с `&`:
    ```yaml
    - name: Run script in background
      shell: /path/to/script.sh &
    ```

- **Мониторинг ресурсов**:
  - Используйте `free -m`, `vmstat`, `iostat` для проверки памяти и нагрузки.
  - Ansible может собирать эту информацию через факты (`ansible_facts`):
    ```yaml
    - name: Print memory info
      debug:
        msg: "Free memory: {{ ansible_facts['memory_mb']['free'] }} MB"
    ```

#### Советы:

- Проверяйте, какие процессы запущены, перед выполнением задач Ansible (`ps aux | grep nginx`).
- Используйте модуль `service` для управления системными сервисами вместо прямых команд.
- Если процесс не запускается, проверяйте логи (`journalctl -u nginx`).

### 4. **Сетевые настройки**

Ansible часто используется для настройки сетевых сервисов (веб-серверов, баз данных, прокси), поэтому понимание сетевых настроек в Linux
критично.

#### Ключевые аспекты:

- **Сетевые интерфейсы**:
  - Используйте `ip addr`, `ifconfig` для проверки сетевых интерфейсов.
  - Файлы конфигурации: `/etc/network/interfaces` (Debian) или `/etc/sysconfig/network-scripts/` (RHEL).
  - Ansible может управлять интерфейсами через модуль `nmcli`:
    ```yaml
    - name: Configure network interface
      nmcli:
        conn_name: eth0
        type: ethernet
        ip4: 192.168.1.100/24
        state: present
    ```

- **Порты и соединения**:
  - `netstat -tulpn`, `ss -tulpn`: Проверка открытых портов.
  - Ansible может открывать порты через модуль `ufw` (для Ubuntu):
    ```yaml
    - name: Allow HTTP traffic
      ufw:
        rule: allow
        port: 80
        proto: tcp
    ```

- **DNS**:
  - Файл `/etc/resolv.conf` для настройки DNS.
  - Ansible может изменять его через модуль `lineinfile`:
    ```yaml
    - name: Set DNS server
      lineinfile:
        path: /etc/resolv.conf
        line: "nameserver 8.8.8.8"
    ```

- **SSH**:
  - Ansible использует SSH для подключения, поэтому нужно настроить `sshd`:
    - Файл `/etc/ssh/sshd_config` для настройки порта, пользователей, ключей.
    - Команда `systemctl restart sshd` для перезапуска SSH.
    - Ansible может управлять `sshd_config`:
      ```yaml
      - name: Configure SSH port
        lineinfile:
          path: /etc/ssh/sshd_config
          regexp: '^Port '
          line: 'Port 2222'
        notify: Restart SSH
      ```

## 3. **Практический опыт c ролями**

### Что такое роли в Ansible?

**Роли** — это способ организовать задачи, файлы, шаблоны, переменные и обработчики в модульную, переиспользуемую структуру. Роли позволяют:

- Разбить сложные плейбуки на логические блоки.
- Повторно использовать код в разных проектах.
- Упростить управление и поддержку автоматизации.
- Сделать плейбуки читаемыми и масштабируемыми.

Роли особенно полезны для сложных сценариев, таких как настройка веб-серверов, баз данных или CI/CD пайплайнов, где много задач и
зависимостей.

### Создание и использование ролей

#### **Структура роли**

Роль — это директория с определенной структурой, где каждый тип данных (задачи, файлы, переменные и т.д.) хранится в отдельной папке.
Стандартная структура роли выглядит так:

```
roles/
  my_role/
    defaults/
      main.yml  # Переменные по умолчанию (с низким приоритетом)
    vars/
      main.yml  # Переменные (с высоким приоритетом)
    tasks/
      main.yml  # Основные задачи роли
    handlers/
      main.yml  # Обработчики (например, перезапуск сервисов)
    templates/
      config.j2  # Шаблоны Jinja2
    files/
      static_file.txt  # Статические файлы
    meta/
      main.yml  # Метаданные роли (зависимости, описание)
```

- **defaults**: Переменные с низким приоритетом, которые легко переопределяются.
- **vars**: Переменные с высоким приоритетом, используемые в роли.
- **tasks**: Основной список задач, выполняемых ролью.
- **handlers**: Задачи, которые вызываются при уведомлениях (например, перезапуск сервиса).
- **templates**: Шаблоны Jinja2 для динамических файлов.
- **files**: Статические файлы для копирования.
- **meta**: Информация о роли (автор, зависимости).

#### **Создание роли**

Ansible предоставляет команду `ansible-galaxy` для создания заготовки роли:

```bash
ansible-galaxy init my_role
```

- Это создаст директорию `my_role` со всеми папками, описанными выше.
- Пример: Создадим роль для настройки Nginx.

#### **Пример роли для Nginx**

Давайте создадим роль `nginx`, которая устанавливает Nginx, копирует конфигурацию и запускает сервис.

1. **Создайте роль**:
   ```bash
   ansible-galaxy init roles/nginx
   ```

2. **Задачи** (`roles/nginx/tasks/main.yml`):
   ```yaml
   ---
   - name: Install Nginx
     apt:
       name: nginx
       state: present
       update_cache: yes
     when: ansible_os_family == "Debian"

   - name: Copy Nginx configuration
     template:
       src: nginx.conf.j2
       dest: /etc/nginx/nginx.conf
       mode: '0644'
     notify: Restart Nginx

   - name: Copy website content
     copy:
       src: index.html
       dest: /var/www/html/index.html
       owner: www-data
       group: www-data
       mode: '0644'

   - name: Ensure Nginx is running
     service:
       name: nginx
       state: started
       enabled: yes
   ```

3. **Шаблон конфигурации** (`roles/nginx/templates/nginx.conf.j2`):
   ```nginx
   server {
       listen {{ http_port | default(80) }};
       server_name {{ domain | default('example.com') }};
       root /var/www/html;
       index index.html;
   }
   ```

4. **Статический файл** (`roles/nginx/files/index.html`):
   ```html
   <h1>Welcome to {{ domain | default('example.com') }}!</h1>
   ```

5. **Переменные по умолчанию** (`roles/nginx/defaults/main.yml`):
   ```yaml
   ---
   http_port: 80
   domain: example.com
   ```

6. **Обработчики** (`roles/nginx/handlers/main.yml`):
   ```yaml
   ---
   - name: Restart Nginx
     service:
       name: nginx
       state: restarted
   ```

7. **Плейбук для использования роли** (`setup_nginx.yml`):
   ```yaml
   ---
   - name: Setup Nginx web server
     hosts: webservers
     become: yes
     roles:
       - nginx
   ```

8. **Запуск плейбука**:
   ```bash
   ansible-playbook -i inventory.yml setup_nginx.yml
   ```

- **Объяснение**:
  - Роль `nginx` устанавливает Nginx, копирует конфигурацию и HTML-файл, запускает сервис.
  - Переменные (`http_port`, `domain`) задаются в `defaults/main.yml` и могут быть переопределены в плейбуке или `group_vars`.
  - Шаблон `nginx.conf.j2` использует Jinja2 для динамической настройки.
  - Обработчик перезапускает Nginx, если конфигурация изменилась.

#### 1.4. **Использование ролей в плейбуке**

Роли подключаются в плейбуке через секцию `roles`:

```yaml
---
- name: Deploy web application
  hosts: webservers
  become: yes
  roles:
    - nginx
    - { role: postgresql, become_userਮ
```

- Можно указать несколько ролей.
- Роли выполняются в порядке указания.

#### 1.5. **Переменные и роли**

Переменные можно задавать:

- В `defaults/main.yml` (низкий приоритет).
- В `vars/main.yml` (высокий приоритет).
- В плейбуке или файлах `group_vars`/`host_vars` для переопределения.

Пример переопределения переменных в плейбуке:

```yaml
- name: Setup Nginx
  hosts: webservers
  become: yes
  vars:
    http_port: 8080
  roles:
    - nginx
```

### Итог

- **Роли**:
  - Позволяют модульно организовать код, делая плейбуки компактными и переиспользуемыми.
  - Создавайте роли с помощью `ansible-galaxy init` и следуйте стандартной структуре.
  - Используйте переменные, шаблоны и обработчики для гибкости.

## 4. **Глубокое изучение продвинутых возможностей**

## 4.1 **Jinja2 шаблоны**: Научитесь использовать шаблоны для динамической генерации конфигурационных файлов.

### Что такое Jinja2 и зачем нужны шаблоны в Ansible?

**Jinja2** — это шаблонизатор, написанный на Python, который Ansible использует для создания динамических файлов (например, конфигураций для
Nginx, Apache, баз данных). Шаблоны позволяют:

- Вставлять **переменные** в файлы (например, порт или имя домена).
- Использовать **условия**, **циклы** и **фильтры** для гибкой настройки.
- Создавать конфигурационные файлы, которые адаптируются к разным узлам или окружениям.

В Ansible шаблоны хранятся в файлах с расширением `.j2` (например, `nginx.conf.j2`) и обрабатываются модулем `template`, который заменяет
переменные и выражения на актуальные значения перед копированием файла на целевой узел.

**Зачем это нужно?**

- Без шаблонов пришлось бы создавать отдельные статические файлы для каждого сервера или окружения.
- Шаблоны делают конфигурации универсальными и повторно используемыми.
- Они интегрируются с переменными и фактами Ansible, что позволяет адаптировать файлы под конкретные узлы.

### Основы синтаксиса Jinja2

Jinja2 использует три основных типа синтаксиса в шаблонах:

1. **Переменные**: `{{ variable }}` — подставляет значение переменной.
2. **Управляющие конструкции**: `{% ... %}` — для условий, циклов и других операций.
3. **Комментарии**: `{# ... #}` — для добавления комментариев, которые не попадут в итоговый файл.

#### 1. **Переменные**

Переменные подставляются из:

- Плейбука (`vars`).
- Файлов переменных (`group_vars`, `host_vars`).
- Фактов Ansible (`ansible_facts`).
- Других источников (например, `defaults` в ролях).

Пример:

```jinja2
server_name {{ domain }};
listen {{ http_port }};
```

Если `domain = example.com` и `http_port = 80`, то результат будет:

```
server_name example.com;
listen 80;
```

#### 2. **Условия**

Условия позволяют включать или исключать части файла в зависимости от значений.

Пример:

```jinja2
{% if ansible_os_family == "Debian" %}
  user www-data;
{% else %}
  user apache;
{% endif %}
```

#### 3. **Циклы**

Циклы позволяют перебирать списки или словари.

Пример:

```jinja2
{% for user in users %}
  user {{ user.name }} {{ user.home }};
{% endfor %}
```

Если `users = [{name: alice, home: /home/alice}, {name: bob, home: /home/bob}]`, результат:

```
user alice /home/alice;
user bob /home/bob;
```

#### 4. **Фильтры**

Фильтры изменяют значения переменных. Например:

- `| default('value')`: Задает значение по умолчанию.
- `| upper`: Преобразует в верхний регистр.
- `| length`: Возвращает длину списка.

Пример:

```jinja2
server_name {{ domain | default('example.com') }};
```

Если `domain` не задан, будет использовано `example.com`.

#### 5. **Комментарии**

Комментарии полезны для пояснений в шаблоне:

```jinja2
{# Это конфигурация для Nginx #}
server_name {{ domain }};
```

### Как использовать Jinja2 в Ansible?

Шаблоны в Ansible обрабатываются с помощью модуля `template`. Файлы шаблонов обычно хранятся в папке `templates/` внутри роли или проекта.

#### Пример: Настройка Nginx с шаблоном

1. **Создайте шаблон** (`templates/nginx.conf.j2`):
   ```jinja2
   server {
       listen {{ http_port | default(80) }};
       server_name {{ domain | default('localhost') }};
       root /var/www/html;
       index index.html;

       {% if enable_ssl | default(false) %}
       listen 443 ssl;
       ssl_certificate {{ ssl_cert_path }};
       ssl_certificate_key {{ ssl_key_path }};
       {% endif %}
   }
   ```

2. **Плейбук** (`setup_nginx.yml`):
   ```yaml
   ---
   - name: Setup Nginx with dynamic config
     hosts: webservers
     become: yes
     vars:
       http_port: 80
       domain: example.com
       enable_ssl: true
       ssl_cert_path: /etc/ssl/certs/nginx.crt
       ssl_key_path: /etc/ssl/private/nginx.key
     tasks:
       - name: Install Nginx
         apt:
           name: nginx
           state: present
           update_cache: yes
         when: ansible_os_family == "Debian"

       - name: Copy Nginx configuration
         template:
           src: nginx.conf.j2
           dest: /etc/nginx/nginx.conf
           mode: '0644'
         notify: Restart Nginx

       - name: Ensure Nginx is running
         service:
           name: nginx
           state: started
           enabled: yes

     handlers:
       - name: Restart Nginx
         service:
           name: nginx
           state: restarted
   ```

3. **Инвентарь** (`inventory.yml`):
   ```yaml
   all:
     hosts:
       web1:
         ansible_host: 192.168.1.100
     children:
       webservers:
         hosts:
           web1:
   ```

4. **Запуск**:
   ```bash
   ansible-playbook -i inventory.yml setup_nginx.yml
   ```

- **Что происходит?**
  - Модуль `template` берёт файл `nginx.conf.j2`, подставляет значения переменных (`http_port`, `domain`, `enable_ssl` и т.д.) и копирует
    результат в `/etc/nginx/nginx.conf`.
  - Если `enable_ssl = true`, в конфигурацию добавляются строки для SSL.
  - После изменения конфигурации вызывается обработчик для перезапуска Nginx.

### Итог

**Jinja2 шаблоны** — мощный инструмент для создания динамических конфигурационных файлов в Ansible. Они позволяют:

- Использовать переменные, условия и циклы для адаптации конфигураций.
- Интегрироваться с ролями для модульности.
- Упрощать настройку серверов, баз данных и приложений.

**Практические шаги**:

1. Начните с простого шаблона (например, для Nginx).
2. Используйте переменные из `vars`, `group_vars` или фактов.
3. Добавляйте условия и циклы для сложных сценариев.
4. Тестируйте шаблоны с помощью `--check` и `ansible-lint`.

## 4.2 **Переменные и факты**:

### Что такое переменные и факты в Ansible?

- **Переменные**: Это пользовательские значения, которые задаются для настройки задач. Они делают плейбуки гибкими, позволяя использовать
  одни и те же задачи с разными параметрами (например, разные порты, имена пользователей или пути).
- **Факты**: Это автоматически собираемые данные о системе (узле), такие как версия ОС, IP-адрес, объем памяти и т.д. Факты позволяют
  адаптировать задачи под конкретные характеристики узла.

**Зачем они нужны?**

- Переменные позволяют переиспользовать код и настраивать поведение задач.
- Факты помогают писать универсальные плейбуки, которые работают на разных дистрибутивах Linux или конфигурациях оборудования.

### 1. Переменные в Ansible

Переменные в Ansible можно задавать в разных местах, и они имеют определенный **приоритет**. Давайте разберем, как их определять и
использовать.

#### 1.1. **Типы переменных**

1. **Переменные в плейбуке**:
   Задаются в секции `vars` или через `vars_files`.
   ```yaml
   - name: Setup Nginx
     hosts: webservers
     vars:
       http_port: 80
       domain: example.com
     tasks:
       - name: Copy Nginx config
         template:
           src: nginx.conf.j2
           dest: /etc/nginx/nginx.conf
   ```

2. **Групповые переменные (`group_vars`)**:
   Применяются ко всем хостам в определенной группе из инвентаря.

- Создайте файл `group_vars/webservers.yml`:
  ```yaml
  ---
  http_port: 80
  domain: example.com
  ```
- Переменные автоматически применяются к группе `webservers`.

3. **Хостовые переменные (`host_vars`)**:
   Применяются к конкретному хосту.

- Создайте файл `host_vars/web1.yml`:
  ```yaml
  ---
  http_port: 8080
  domain: web1.example.com
  ```

4. **Переменные в ролях**:

- В `roles/my_role/defaults/main.yml` (низкий приоритет, легко переопределяются):
  ```yaml
  ---
  http_port: 80
  ```
- В `roles/my_role/vars/main.yml` (высокий приоритет):
  ```yaml
  ---
  domain: example.com
  ```

5. **Переменные из инвентаря**:
   Задаются прямо в файле инвентаря:
   ```yaml
   all:
     hosts:
       web1:
         ansible_host: 192.168.1.100
         http_port: 8080
   ```

6. **Переменные из командной строки**:
   Можно передать через `-e`:
   ```bash
   ansible-playbook setup_nginx.yml -e "http_port=8080 domain=example.com"
   ```

#### 1.2. **Приоритет переменных**

Ansible использует строгий порядок приоритета (более высокий приоритет переопределяет более низкий):

1. Переменные из командной строки (`-e`).
2. Переменные в плейбуке (`vars`).
3. Хостовые переменные (`host_vars`).
4. Групповые переменные (`group_vars`).
5. Переменные в `vars` роли.
6. Переменные в `defaults` роли.

**Совет**: Используйте `defaults` для значений по умолчанию, а `vars`, `group_vars` или `host_vars` для специфичных настроек.

### 2. Факты в Ansible

**Факты** — это информация, которую Ansible автоматически собирает с управляемых узлов с помощью модуля `setup`. Они содержат данные о
системе, такие как:

- `ansible_distribution`: Название дистрибутива (например, `Ubuntu`, `CentOS`).
- `ansible_os_family`: Семейство ОС (`Debian`, `RedHat`).
- `ansible_hostname`: Имя хоста.
- `ansible_facts['all_ipv4_addresses']`: Список IPv4-адресов.
- `ansible_facts['memory_mb']['free']`: Свободная память.
- Процессор, диски, сетевые интерфейсы и т.д.

#### 2.1. **Как собираются факты?**

- По умолчанию Ansible собирает факты перед выполнением плейбука (если не указано `gather_facts: no`).
- Факты доступны как переменные в формате `ansible_facts['key']`.

Пример вывода фактов:

```bash
ansible all -m setup
```

### Итог

- **Переменные**:
  - Задавайте в `vars`, `group_vars`, `host_vars`, ролях или командной строке.
  - Используйте `ansible-vault` для конфиденциальных данных.
  - Управляйте приоритетом для гибкости.

- **Факты**:
  - Используйте `ansible_facts` для адаптации задач под ОС, IP, память и т.д.
  - Создавайте кастомные факты для специфичных данных.
  - Отключайте сбор фактов для оптимизации.

## 4.3 **Ansible Vault**

### Что такое Ansible Vault?

**Ansible Vault** — это встроенный инструмент Ansible для шифрования и хранения конфиденциальных данных, таких как:

- Пароли для SSH или баз данных.
- API-ключи.
- Секреты для доступа к внешним сервисам.

Vault позволяет:

- Шифровать отдельные переменные, файлы или целые YAML-файлы.
- Безопасно хранить секреты в репозиториях (например, Git).
- Использовать зашифрованные данные в плейбуках без необходимости их расшифровки вручную.

**Зачем это нужно?**

- Безопасность: Защищает конфиденциальные данные от несанкционированного доступа.
- Удобство: Позволяет хранить секреты вместе с кодом, не раскрывая их.
- Интеграция: Работает с переменными, ролями и плейбуками.

### Основы работы с Ansible Vault

Ansible Vault использует симметричное шифрование (один пароль для шифрования и расшифровки). Вы задаете пароль, который используется для
доступа к зашифрованным данным. Vault поддерживает два основных подхода:

1. **Шифрование файлов**: Целые YAML-файлы (например, `group_vars` или `host_vars`).
2. **Шифрование строк**: Отдельные переменные внутри YAML-файлов.


### 1. Создание и использование зашифрованных файлов

#### 1.1. **Создание зашифрованного файла**

Чтобы создать новый зашифрованный файл, используйте команду `ansible-vault create`:

```bash
ansible-vault create group_vars/secrets.yml
```

- Ansible запросит пароль для шифрования.
- После ввода пароля откроется редактор (по умолчанию `vim`), где вы можете добавить данные, например:
  ```yaml
  ---
  db_password: securepassword123
  api_key: abc123xyz
  ```

- Сохраненный файл будет зашифрован и выглядеть примерно так:
  ```
  $ANSIBLE_VAULT;1.1;AES256
  663861653465663735653234353364613465316234663961316234653831626136623033663432
  ...
  ```

#### 1.2. **Редактирование зашифрованного файла**

Чтобы отредактировать существующий зашифрованный файл:

```bash
ansible-vault edit group_vars/secrets.yml
```

- Введите пароль, и файл откроется в редакторе для изменения.

#### 1.3. **Шифрование существующего файла**

Если у вас уже есть YAML-файл с секретами, вы можете зашифровать его:

```bash
ansible-vault encrypt group_vars/secrets.yml
```

- Введите пароль для шифрования.

#### 1.4. **Расшифровка файла**

Чтобы просмотреть содержимое зашифрованного файла:

```bash
ansible-vault view group_vars/secrets.yml
```

- Введите пароль, и Ansible покажет содержимое в терминале.


### 2. Шифрование отдельных строк

Иногда нужно зашифровать только одну переменную, а не весь файл. Для этого используется `ansible-vault encrypt_string`.

#### Пример:

```bash
ansible-vault encrypt_string 'securepassword123' --name db_password
```

- Введите пароль для шифрования.
- Вывод будет выглядеть так:
  ```yaml
  db_password: !vault |
        $ANSIBLE_VAULT;1.1;AES256
        663861653465663735653234353364613465316234663961316234653831626136623033663432
        ...
  ```

- Вставьте этот блок в YAML-файл, например, `group_vars/webservers.yml`:
  ```yaml
  ---
  http_port: 80
  domain: example.com
  db_password: !vault |
        $ANSIBLE_VAULT;1.1;AES256
        663861653465663735653234353364613465316234663961316234653831626136623033663432
        ...
  ```


### 3. Использование Ansible Vault в плейбуках

Зашифрованные данные можно использовать в плейбуках без изменений в синтаксисе, если Ansible знает пароль для расшифровки.

#### Пример плейбука с Vault

```yaml
---
- name: Setup PostgreSQL with encrypted password
  hosts: databases
  become: yes
  vars_files:
    - group_vars/secrets.yml
  tasks:
    - name: Install PostgreSQL
      apt:
        name: postgresql
        state: present
      when: ansible_os_family == "Debian"

    - name: Create database user
      postgresql_user:
        name: appuser
        password: "{{ db_password }}"
        state: present
      become_user: postgres
```

- **vars_files**: Подключает зашифрованный файл `secrets.yml` с переменной `db_password`.
- Ansible автоматически расшифрует `db_password` при выполнении, если предоставлен правильный пароль.

### Итог

**Ansible Vault** — это мощный инструмент для защиты конфиденциальных данных:

- Шифруйте файлы (`ansible-vault create/edit/encrypt`) или строки (`ansible-vault encrypt_string`).
- Используйте зашифрованные переменные в плейбуках и ролях.
- Храните пароли Vault безопасно (в файле или менеджере паролей).
- Интегрируйте Vault с `group_vars`, `host_vars` и ролями для модульности.


## 4.4 **Динамический инвентарь**

### Что такое динамический инвентарь?

**Динамический инвентарь** в Ansible — это механизм, который позволяет автоматически собирать список узлов (хостов) и их параметры из внешних источников, таких как облачные провайдеры (AWS, Azure, GCP), базы данных или другие системы. В отличие от статического инвентаря, где хосты и группы задаются вручную в файле (например, `inventory.yml`), динамический инвентарь обновляется в реальном времени, что идеально для облачных сред, где виртуальные машины создаются и удаляются динамически.

**Зачем нужен динамический инвентарь?**
- **Автоматизация**: Устраняет необходимость вручную обновлять файлы инвентаря при изменении инфраструктуры.
- **Актуальность**: Гарантирует, что плейбуки работают с текущим состоянием облачных ресурсов.
- **Гибкость**: Позволяет группировать хосты по тегам, регионам, зонам или другим метаданным.

Динамический инвентарь в Ansible реализуется через **инвентарные плагины** или скрипты, которые взаимодействуют с API облачных провайдеров. Основные плагины для популярных облаков:
- **AWS**: `aws_ec2` — для работы с EC2-инстансами.
- **Azure**: `azure_rm` — для работы с виртуальными машинами Azure.
- **GCP**: `gcp_compute` — для работы с Google Compute Engine.

**Как это работает?**
1. Плагин или скрипт запрашивает данные через API облачного провайдера.
2. Возвращает JSON с информацией о хостах (IP, имена, теги, группы).
3. Ansible использует эту информацию как инвентарь для выполнения задач.

**Требования**:
- Установленные зависимости (например, `boto3` для AWS, `azure-sdk` для Azure, `google-auth` для GCP).
- Настроенные учетные данные (service account, access keys, credentials).
- Конфигурационный файл для плагина (обычно в формате YAML).

## 4.5 **Параллелизм и оптимизация**: 

### Что такое параллелизм и оптимизация в Ansible?

Ansible по умолчанию выполняет задачи на нескольких хостах параллельно, что ускоряет выполнение плейбуков. Однако производительность зависит от правильной настройки следующих параметров:
- **`forks`**: Количество параллельных процессов для выполнения задач на хостах.
- **`serial`**: Ограничение количества хостов, обрабатываемых одновременно в одном play.
- **`strategy`**: Стратегия выполнения задач (например, одновременное выполнение или пошаговое).

Эти параметры помогают сбалансировать скорость, стабильность и порядок выполнения задач, особенно при работе с облачными провайдерами (AWS, Azure, GCP) или большими кластерами.

### 1. Параметр `forks`

#### 1.1. Что такое `forks`?
- `forks` определяет, сколько хостов Ansible обрабатывает одновременно.
- По умолчанию `forks = 5`, то есть Ansible одновременно выполняет задачи на 5 хостах.
- Увеличение `forks` ускоряет выполнение плейбуков, но требует больше ресурсов (CPU, память) на управляющем узле.

#### 1.2. Настройка `forks`
- Задайте `forks` в конфигурационном файле `ansible.cfg`:
  ```ini
  [defaults]
  forks = 20
  ```
- Или укажите через командную строку:
  ```bash
  ansible-playbook -i inventory.yml playbook.yml -f 20
  ```

#### 1.3. Когда увеличивать или уменьшать `forks`?
- **Увеличьте** `forks` (например, до 20–50), если:
  - У вас много хостов (десятки или сотни).
  - Управляющий узел имеет достаточно ресурсов (CPU, память).
  - Задачи не требуют интенсивного обмена данными (например, установка пакетов).
- **Уменьшите** `forks` (например, до 5–10), если:
  - Управляющий узел ограничен по ресурсам.
  - Задачи вызывают высокую нагрузку на сеть (например, копирование больших файлов).
  - Вы сталкиваетесь с ошибками из-за перегрузки (например, таймауты SSH).

#### 1.4. Пример
Плейбук с большим количеством хостов:
```yaml
---
- name: Install Nginx on all servers
  hosts: webservers
  become: yes
  tasks:
    - name: Install Nginx
      apt:
        name: nginx
        state: present
      when: ansible_facts['os_family'] == "Debian"
```

Запуск с увеличенным `forks`:
```bash
ansible-playbook -i inventory.yml install_nginx.yml -f 50
```

- Ansible будет выполнять установку Nginx на 50 хостах одновременно.

**Совет**: Для больших инфраструктур (100+ хостов) начните с `forks=20` и увеличивайте, наблюдая за нагрузкой на управляющий узел (`top` или `htop`).

### 2. Параметр `serial`

#### 2.1. Что такое `serial`?
- `serial` ограничивает количество хостов, обрабатываемых в одном **play** одновременно.
- По умолчанию Ansible обрабатывает все хосты из группы `hosts` параллельно (ограничено только `forks`).
- `serial` позволяет выполнять play поэтапно, например, сначала на 2 хостах, затем на следующих 2 и т.д.

#### 2.2. Когда использовать `serial`?
- Для **пошаговых обновлений** (rolling updates), чтобы минимизировать downtime (например, обновление веб-серверов).
- Когда задачи на одном хосте зависят от завершения задач на другом (например, настройка базы данных перед веб-сервером).
- Для снижения нагрузки на целевые системы или сеть.

#### 2.3. Настройка `serial`
- Задайте `serial` в плейбуке:
  ```yaml
  ---
  - name: Rolling update of web servers
    hosts: webservers
    serial: 2
    become: yes
    tasks:
      - name: Install Nginx
        apt:
          name: nginx
          state: present
        when: ansible_facts['os_family'] == "Debian"

      - name: Restart Nginx
        service:
          name: nginx
          state: restarted
  ```

- **Объяснение**:
  - Ansible выполнит задачи на 2 хостах одновременно, затем перейдет к следующим 2.
  - Это полезно для обновления веб-серверов, чтобы не выключать все одновременно.

- Можно указать `serial` как процент:
  ```yaml
  serial: "20%"
  ```
  - Ansible обработает 20% хостов из группы за раз.

- Можно указать список значений:
  ```yaml
  serial:
    - 1
    - 2
    - "50%"
  ```
  - Сначала обработает 1 хост, затем 2, затем 50% оставшихся.

#### 2.4. Пример: Rolling update
Инвентарь (`inventory.yml`):
```yaml
all:
  hosts:
    web1:
      ansible_host: 192.168.1.101
    web2:
      ansible_host: 192.168.1.102
    web3:
      ansible_host: 192.168.1.103
    web4:
      ansible_host: 192.168.1.104
  children:
    webservers:
      hosts:
        web1:
        web2:
        web3:
        web4:
```

Плейбук (`rolling_update.yml`):
```yaml
---
- name: Rolling update of Nginx
  hosts: webservers
  serial: 2
  become: yes
  tasks:
    - name: Upgrade Nginx
      apt:
        name: nginx
        state: latest
        update_cache: yes
      when: ansible_facts['os_family'] == "Debian"

    - name: Restart Nginx
      service:
        name: nginx
        state: restarted
```

Запуск:
```bash
ansible-playbook -i inventory.yml rolling_update.yml
```

- Ansible обновит и перезапустит Nginx на `web1` и `web2`, затем на `web3` и `web4`, минимизируя downtime.

### 3. Параметр `strategy`

#### 3.1. Что такое `strategy`?
- `strategy` определяет, как Ansible выполняет задачи на хостах:
  - `linear` (по умолчанию): Все задачи выполняются на всех хостах поэтапно. Ansible завершает задачу на всех хостах (с учетом `serial` и `forks`), прежде чем перейти к следующей задаче.
  - `free`: Каждый хост выполняет задачи независимо и максимально быстро, не дожидаясь завершения задач на других хостах.
  - `host_pinned`: Похож на `free`, но с упором на независимость хостов (редко используется).
  - `debug`: Пошаговое выполнение для отладки (не для продакшена).

#### 3.2. Когда использовать какую стратегию?
- **`linear`**:
  - Подходит для большинства случаев.
  - Гарантирует, что задачи выполняются последовательно (например, установка пакета на всех хостах перед перезапуском сервиса).
- **`free`**:
  - Используйте для ускорения выполнения, когда задачи независимы между хостами.
  - Подходит для больших инфраструктур, где хосты могут завершать задачи с разной скоростью.
- **`host_pinned`**:
  - Используйте для специфичных случаев, где каждый хост должен обрабатываться полностью независимо.
- **`debug`**:
  - Используйте для отладки, чтобы выполнять задачи пошагово.

#### 3.3. Настройка `strategy`
- Задайте `strategy` в плейбуке:
  ```yaml
  ---
  - name: Fast deployment with free strategy
    hosts: webservers
    strategy: free
    become: yes
    tasks:
      - name: Install Nginx
        apt:
          name: nginx
          state: present
        when: ansible_facts['os_family'] == "Debian"

      - name: Copy configuration
        template:
          src: nginx.conf.j2
          dest: /etc/nginx/nginx.conf
        notify: Restart Nginx
  ```

- Или в `ansible.cfg`:
  ```ini
  [defaults]
  strategy = free
  ```

#### 3.4. Пример: Сравнение `linear` и `free`
Допустим, у вас 10 хостов, и задачи включают установку пакета (5 секунд) и копирование файла (10 секунд).

- **С `strategy: linear` и `forks: 5`**:
  - Ansible выполнит установку на 5 хостах (5 секунд), затем на оставшихся 5 (еще 5 секунд).
  - Затем копирование на 5 хостах (10 секунд), затем на оставшихся 5 (еще 10 секунд).
  - Итог: ~30 секунд.

- **С `strategy: free` и `forks: 5`**:
  - Каждый хост выполняет задачи независимо. Как только хост завершает установку (5 секунд), он начинает копирование (10 секунд).
  - Итог: ~15 секунд для большинства хостов (зависит от скорости хостов).

**Примечание**: `free` может нарушить порядок выполнения, если задачи зависят друг от друга (например, настройка базы данных перед веб-сервером). Используйте `linear` для таких случаев.

---

### 4. Дополнительные методы оптимизации

Помимо `forks`, `serial` и `strategy`, есть другие способы ускорить выполнение плейбуков:

#### 4.1. **Pipelining**
- Включает выполнение нескольких команд через одно SSH-соединение, снижая накладные расходы.
- Настройка в `ansible.cfg`:
  ```ini
  [ssh_connection]
  pipelining = True
  ```
- **Требование**: Отключите `requiretty` в `/etc/sudoers` на узлах:
  ```bash
  sudo visudo
  # Добавить: Defaults:ansible !requiretty
  ```

#### 4.2. **Кэширование фактов**
- Сбор фактов (`ansible_facts`) может замедлить выполнение. Включите кэширование:
  ```ini
  [defaults]
  fact_caching = jsonfile
  fact_caching_timeout = 7200  # 2 часа
  fact_caching_connection = /tmp/ansible_facts
  ```
- Это сохраняет факты локально, уменьшая запросы к хостам.

#### 4.3. **Ограничение хостов**
- Используйте флаг `-l` или `--limit` для работы с подмножеством хостов:
  ```bash
  ansible-playbook -i inventory.yml playbook.yml --limit web1,web2
  ```

#### 4.4. **Асинхронные задачи**
- Для длительных задач используйте `async` и `poll`:
  ```yaml
  - name: Run long task
    command: /path/to/long_running_script.sh
    async: 3600  # Максимальное время выполнения (1 час)
    poll: 10     # Проверять каждые 10 секунд
  ```

#### 4.5. **Оптимизация SSH**
- Используйте `ControlMaster` для повторного использования SSH-соединений:
  ```ini
  [ssh_connection]
  ssh_args = -C -o ControlMaster=auto -o ControlPersist=60s
  ```

### Итог

- **`forks`**: Увеличивайте для параллельной обработки большого числа хостов, но следите за ресурсами.
- **`serial`**: Используйте для rolling updates или зависимых задач, чтобы минимизировать downtime.
- **`strategy`**: Выбирайте `linear` для последовательности или `free` для скорости при независимых задачах.
- **Оптимизация**: Включите `pipelining`, кэширование фактов и SSH-оптимизации для ускорения.

## 4.6 **Ansible Tower/AWX**

- **Ansible Tower (Automation Controller)**: Коммерческий продукт Red Hat, часть **Ansible Automation Platform**, предназначенный для управления автоматизацией в корпоративных средах. Предоставляет поддержку, SLA, гарантированные обновления и интеграцию с Red Hat экосистемой.[](https://www.redhat.com/en/technologies/management/ansible/compare-awx-vs-ansible-automation-platform)[](https://www.redhat.com/en/ansible-collaborative/faq?intcmp=7015Y000003t7aWQAQ)
- **AWX**: Open-source проект, являющийся upstream для Tower/Ansible Automation Controller. Бесплатный, но без официальной поддержки Red Hat, что делает его подходящим для тестирования, разработки или небольших сред.[](https://medium.com/%40techlatest.net/ansible-awx-an-open-source-license-free-alternative-to-ansible-tower-4a1a5d747ac7)[](https://www.redhat.com/en/ansible-collaborative/faq?intcmp=7015Y000003t7aWQAQ)

**Основные возможности**:
- **Графический интерфейс (GUI)**: Упрощает управление плейбуками, инвентарями и задачами.
- **REST API**: Позволяет интегрировать автоматизацию с другими инструментами (например, CI/CD).
- **Ролевой доступ (RBAC)**: Управление доступом пользователей и команд.
- **Планирование задач**: Автоматизация выполнения плейбуков по расписанию.
- **Централизованное управление**: Мониторинг, логирование и управление инвентарями (включая облачные).
- **Многоплейбучные воркфлоу**: Оркестрация сложных процессов с несколькими плейбуками.

**Зачем это нужно?**
- Управление большими инфраструктурами (сотни/тысячи узлов).
- Обеспечение совместной работы команд (DevOps, админы, разработчики).
- Упрощение автоматизации для пользователей без глубоких знаний Ansible.
- Обеспечение безопасности, аудита и соблюдения стандартов (compliance).

**Ключевые различия**:
- **Tower**: Поддержка Red Hat, SLA, гарантированные обновления, подходит для продакшена. Лицензия платная (например, $13,000/год за 100 узлов).[](https://medium.com/%40uisk/ansible-awx-vs-ansible-tower-automation-platform-8b79eb92a40f)
- **AWX**: Бесплатный, но требует самостоятельного обслуживания, обновления и настройки. Подходит для labs, PoC или небольших команд.[](https://medium.com/%40techlatest.net/ansible-awx-an-open-source-license-free-alternative-to-ansible-tower-4a1a5d747ac7)[](https://medium.com/%40uisk/ansible-awx-vs-ansible-tower-automation-platform-8b79eb92a40f)

## 5. **Понимание DevOps-контекста**

## 5.1 **Интеграция с CI/CD**

### Что такое интеграция Ansible с CI/CD?

**CI/CD (Continuous Integration/Continuous Deployment)** — это процесс автоматизации сборки, тестирования и развертывания приложений. Ansible интегрируется с CI/CD для:
- **Автоматизации инфраструктуры**: Настройка серверов, баз данных, сетей.
- **Развертывания приложений**: Копирование кода, настройка конфигураций, перезапуск сервисов.
- **Оркестрации**: Управление сложными процессами (например, развертывание многоуровневых приложений).
- **Обеспечения воспроизводимости**: Инфраструктура как код (IaC) с плейбуками.

**Почему Ansible в CI/CD?**
- **Идемпотентность**: Плейбуки гарантируют одинаковое состояние системы при многократном выполнении.
- **Простота**: YAML-файлы легко читаются и интегрируются с Git.
- **Гибкость**: Поддержка статических и динамических инвентарей (AWS, Azure, GCP).
- **Безопасность**: Интеграция с Ansible Vault для защиты секретов.

**Инструменты CI/CD**:
- **Jenkins**: Популярный сервер автоматизации с плагинами для Ansible.
- **GitLab CI/CD**: Встроенный CI/CD в GitLab, поддерживающий выполнение Ansible.
- **AWX/Ansible Tower**: Графический интерфейс для запуска плейбуков, интегрируемый с CI/CD.

### 1. Интеграция Ansible с Jenkins

**Jenkins** — это сервер автоматизации, который поддерживает выполнение Ansible через плагины или командную строку. Вот как настроить пайплайн для запуска плейбуков.

#### 1.1. **Требования**
- Установленный Jenkins (на сервере или локально).
- Плагин **Ansible** (опционально, для упрощения интеграции).
  - Установите через **Manage Plugins** в Jenkins GUI: `Ansible Plugin`.
- Ansible установлен на сервере Jenkins:
  ```bash
  sudo apt-get install ansible
  ```
- Учетные данные для SSH, облаков или Ansible Vault.

#### 1.2. **Настройка Jenkins**
1. **Создайте учетные данные**:
  - В Jenkins GUI перейдите в **Manage Jenkins > Manage Credentials**.
  - Добавьте:
    - SSH-ключи для доступа к серверам.
    - Пароль Ansible Vault (например, ID: `vault-pass`).
    - Учетные данные для облаков (AWS, Azure, GCP) для динамического инвентаря.

2 **Настройка пайплайна**:
   Создайте файл `Jenkinsfile` в корне репозитория:
   ```groovy
   pipeline {
       agent any
       environment {
           ANSIBLE_VAULT_PASSWORD_FILE = credentials('vault-pass')
           AWS_ACCESS_KEY_ID = credentials('aws-access-key')
           AWS_SECRET_ACCESS_KEY = credentials('aws-secret-key')
       }
       stages {
           stage('Checkout') {
               steps {
                   git 'https://github.com/your-org/ansible-playbooks'
               }
           }
           stage('Run Ansible Playbook') {
               steps {
                   sh 'ansible-playbook -i inventory/aws_ec2.yml deploy_nginx.yml --vault-password-file=$ANSIBLE_VAULT_PASSWORD_FILE'
               }
           }
       }
   }
   ```

  - **Объяснение**:
    - `credentials('vault-pass')`: Извлекает пароль Vault из Jenkins Credentials.
    - `ansible-playbook`: Выполняет плейбук с динамическим инвентарем AWS.
    - `inventory/aws_ec2.yml`: Динамический инвентарь (см. раздел 4.4).

4**Запуск**:
  - Запустите пайплайн в Jenkins GUI.
  - Jenkins синхронизирует репозиторий, выполнит плейбук и развернет Nginx на серверах с тегом `Role=web`.

#### 1.3. **Использование Ansible Plugin**
- Вместо `sh` в пайплайне используйте шаг `ansiblePlaybook`:
  ```groovy
  stage('Run Ansible Playbook') {
      steps {
          ansiblePlaybook(
              playbook: 'deploy_nginx.yml',
              inventory: 'inventory/aws_ec2.yml',
              credentialsId: 'vault-pass',
              extraVars: [
                  http_port: '80',
                  domain: 'example.com'
              ]
          )
      }
  }
  ```  