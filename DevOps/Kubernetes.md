### **Что такое Kubernetes?**

Kubernetes — это портативная расширяемая платформа с открытым исходным кодом для управления контейнеризованными рабочими нагрузками и сервисами, которая облегчает как декларативную настройку, так и автоматизацию. У платформы есть большая, быстро растущая экосистема. Сервисы, поддержка и инструменты Kubernetes широко доступны.

### **Что такое OpenShift?**

OpenShift — готовая платформа для разработки и эксплуатации контейнерных приложений. Ее можно установить на свои серверы или арендовать у облачного провайдера. OpenShift — это больше чем Kubernetes. Kubernetes лежит в основе платформы, но кроме него еще есть много других инструментов, которые упрощают работу с кластером и контейнерными приложениями в целом. Некоторые инструменты, которые в простом Kubernetes нужно изучать и настраивать, тут доступны «из коробки». Например, в OpenShift более строгая политика безопасности, которая не позволяет запускать контейнеры от root-пользователя, есть инструменты для упрощения интеграции с Active Directory, встроенный конвейер CI/CD и другое.

### **Зачем вам Kubernetes и что он может сделать**

Контейнеры — отличный способ связать и запустить ваши приложения. В производственной среде необходимо управлять контейнерами, которые запускают приложения, и гарантировать отсутствие простоев. Например, если контейнер выходит из строя, необходимо запустить другой контейнер. Не было бы проще, если бы такое поведение обрабатывалось системой?

Вот тут Kubernetes приходит на помощь! Kubernetes дает вам фреймворк для гибкой работы распределенных систем. Он занимается масштабированием и обработкой ошибок в приложении, предоставляет шаблоны развертывания и многое другое. Например, Kubernetes может легко управлять канареечным развертыванием вашей системы.

Kubernetes предоставляет вам:
*   **Мониторинг сервисов и распределение нагрузки** Kubernetes может обнаружить контейнер, используя имя DNS или собственный IP-адрес. Если трафик в контейнере высокий, Kubernetes может сбалансировать нагрузку и распределить сетевой трафик, чтобы развертывание было стабильным.
*   **Оркестрация хранилища** Kubernetes позволяет вам автоматически смонтировать систему хранения по вашему выбору, такую как локальное хранилище, провайдеры общедоступного облака и многое другое.
*   **Автоматическое развертывание и откаты** Используя Kubernetes можно описать желаемое состояние развернутых контейнеров и изменить фактическое состояние на желаемое. Например, вы можете автоматизировать Kubernetes на создание новых контейнеров для развертывания, удаления существующих контейнеров и распределения всех их ресурсов в новый контейнер.
*   **Автоматическое распределение нагрузки** Вы предоставляете Kubernetes кластер узлов, который он может использовать для запуска контейнерных задач. Вы указываете Kubernetes, сколько ЦП и памяти (ОЗУ) требуется каждому контейнеру. Kubernetes может разместить контейнеры на ваших узлах так, чтобы наиболее эффективно использовать ресурсы.
*   **Самоконтроль** Kubernetes перезапускает отказавшие контейнеры, заменяет и завершает работу контейнеров, которые не проходят определенную пользователем проверку работоспособности, и не показывает их клиентам, пока они не будут готовы к обслуживанию.
*   **Управление конфиденциальной информацией и конфигурацией** Kubernetes может хранить и управлять конфиденциальной информацией, такой как пароли, OAuth-токены и ключи SSH. Вы можете развертывать и обновлять конфиденциальную информацию и конфигурацию приложения без изменений образов контейнеров и не раскрывая конфиденциальную информацию в конфигурации стека.

### **Чем Kubernetes не является?**

Kubernetes ― это не традиционная комплексная система PaaS (платформа как услуга). Поскольку Kubernetes работает на уровне контейнеров, а не на уровне оборудования, у него имеется определенные общеприменимые возможности, характерные для PaaS, такие как развертывание, масштабирование, балансировка нагрузки, ведение журналов и мониторинг. Тем не менее, Kubernetes это не монолитное решение, поэтому указанные возможности по умолчанию являются дополнительными и подключаемыми. У Kubernetes есть компоненты для создания платформы разработчика, но он сохраняет право выбора за пользователем и гибкость там, где это важно.

Kubernetes:
*   **Не ограничивает типы поддерживаемых приложений.** Kubernetes стремится поддерживать широкий спектр рабочих нагрузок, включая те, у которых есть или отсутствует состояние, а также связанные с обработкой данных. Если приложение может работать в контейнере, оно должно отлично работать и в Kubernetes.
*   **Не развертывает исходный код и не собирает приложение.** Рабочие процессы непрерывной интеграции, доставки и развертывания (CI/CD) определяются культурой и предпочтениями организации, а также техническими требованиями.
*   **Не предоставляет сервисы для приложения,** такие как промежуточное программное обеспечение (например, очереди сообщений), платформы обработки данных (например, Spark), базы данных (например, MySQL), кеши или кластерные системы хранения (например, Ceph), как встроенные сервисы. Такие компоненты могут работать в Kubernetes и/или могут быть доступны для приложений, работающих в Kubernetes, через переносные механизмы, такие как Open Service Broker.
*   **Не включает решения для ведения журнала, мониторинга или оповещения.** Он обеспечивает некоторые интеграции в качестве доказательства концепции и механизмы для сбора и экспорта метрик.
*   **Не указывает и не требует настройки языка/системы** (например, Jsonnet). Он предоставляет декларативный API, который может быть нацелен на произвольные формы декларативных спецификаций.
*   **Не предоставляет и не принимает никаких комплексных систем конфигурации,** технического обслуживания, управления или самовосстановления.

Кроме того, Kubernetes — это не просто система оркестрации. Фактически, Kubernetes устраняет необходимость в этом. Техническое определение оркестрации — это выполнение определенного рабочего процесса: сначала сделай A, затем B, затем C. Напротив, Kubernetes содержит набор независимых, компонуемых процессов управления, которые непрерывно переводит текущее состояние к предполагаемому состоянию. Неважно, как добраться от А до С. Не требуется также централизованный контроль. Это делает систему более простой в использовании, более мощной, надежной, устойчивой и расширяемой.

### **Что такое minikube?**

Локальный кластер для знакомства с кубером, или для проверки каких-либо вещей.

### **Приведите пример проблемы, которая решается с использованием Kubernetes?**

Например, у нас есть три машины. На них запущены контейнеры. И вдруг одна из машин выходит из строя вместе с запущенными контейнерами. Или нужно машину перезапустить, а контейнеры нужно переносить.

В итоге нужно будет решать следующие проблемы:
*   Контейнеры могут быть связаны, и они должны быть на одной ноде. Значит и перенести нужно на другую ноду их, сохранив эту связанность (например, использование общих данных или активное взаимодействие между собой).
*   Контейнеры не могут "поместиться" на одном узле, и нужно думать, куда их перевести и распределить.
*   При возвращении ноды в строй придётся возвращать все контейнеры, снова выполняя те же манипуляции.

Kubernetes автоматизирует решение этих проблем.

---

### **Что такое узлы (Nodes)?**

Узел (Node) — это физическая или виртуальная машина в кластере Kubernetes, на которой работают поды.

*   **Master (Control Plane) Node**: Узел, управляющий всем кластером. На нем работают компоненты плоскости управления. Обычно не запускает рабочие нагрузки.
*   **Worker Node**: Узел, на котором запускаются и работают контейнеризованные приложения (поды).

---

### **Обзор компонентов Kubernetes**

1.  **Компоненты плоскости управления (Control Plane)** - "мозг" кластера:
*   **kube-apiserver**: Центральный компонент, предоставляющий API для управления кластером.
*   **etcd**: Распределенное хранилище ключ-значение, где хранится все состояние кластера.
*   **kube-scheduler**: Назначает поды на узлы.
*   **kube-controller-manager**: Запускает контроллеры (Deployment, ReplicaSet и др.).

2.  **Компоненты рабочего узла (Worker Node)**:
*   **kubelet**: Агент, который работает на каждом узле, управляет подами и контейнерами.
*   **kube-proxy**: Отвечает за сетевые правила на узле и реализует концепцию Kubernetes Service.
*   **Container Runtime**: Программное обеспечение, отвечающее за запуск контейнеров (например, containerd).

3.  **Дополнительные компоненты (Add-ons)**:
*   **DNS-сервер**: Для обнаружения сервисов.
*   **Ingress Controller**: Для управления внешним доступом.
*   **Сетевой плагин (CNI)**: Для обеспечения сетевого взаимодействия между подами.

---

### **Роль ключевых компонентов**

*   **Что делает etcd?**
    `etcd` — это единственное место, где Kubernetes хранит состояние кластера и метаданные (определения подов, сервисов, секретов и т.д.). `kube-apiserver` — единственный компонент, который напрямую взаимодействует с `etcd`.

*   **Что делает kube-apiserver?**
    Это центральная точка входа в кластер. Он обрабатывает REST-запросы, валидирует их, записывает в `etcd` и предоставляет интерфейс для всех остальных компонентов для чтения и изменения состояния кластера.

*   **Как сервер API уведомляет клиентов об изменениях?**
    Через механизм **watch**. Клиенты (например, контроллеры или `kubelet`) устанавливают постоянное HTTP-соединение с API-сервером и получают поток уведомлений о создании, изменении или удалении ресурсов, за которыми они наблюдают.

*   **Что делает kube-scheduler?**
    Он "наблюдает" за API-сервером на предмет появления новых подов без назначенного узла. Для каждого такого пода он выбирает наилучший узел на основе требований пода (CPU, память) и доступности ресурсов на узлах. Затем он обновляет определение пода, указывая выбранный узел. Он не запускает под, а только назначает его.

*   **Что делает kube-controller-manager?**
    Это процесс, который запускает множество циклов управления (контроллеров). Каждый контроллер "наблюдает" за определенным ресурсом (например, Deployment, ReplicaSet, Service) и работает над тем, чтобы привести фактическое состояние системы в соответствие с желаемым состоянием, описанным в этом ресурсе.

*   **Что делает kubelet?**
    Это главный агент на каждом рабочем узле. Он "наблюдает" за API-сервером, и как только видит, что на его узел назначен под, он:
1.  Запускает контейнеры этого пода через Container Runtime.
2.  Постоянно отслеживает их состояние.
3.  Выполняет проверки работоспособности (liveness/readiness probes).
4.  Сообщает об их статусе обратно API-серверу.

*   **Что делает kube-proxy?**
    Он работает на каждом узле и отвечает за реализацию сетевой магии для **Services**. Он поддерживает сетевые правила (например, с помощью `iptables` или `IPVS`), которые перенаправляют трафик, приходящий на виртуальный IP-адрес сервиса, на реальные IP-адреса подов, стоящих за этим сервисом.

--------------------------------------------------------------------------------------------------------------------

### **Что такое под (pod) Kubernetes?**

Под — это сущность, которая состоит из одного или нескольких контейнеров (например, docker), размещённых на одном хосте и настроенных на совместное использование ресурсов, таких как сетевой стек и тома. Поды — это базовые строительные блоки, из которых построены приложения, работающие на платформе Kubernetes.

Каждому Pod'у присваивается уникальный IP-адрес. Внутри Pod'а все контейнеры используют общее пространство имен (namespace) сети, включая IP-адрес и сетевые порты. На практике это означает, что все контейнеры в составе пода могут взаимодействовать друг с другом через `localhost`. Например, если в поде есть контейнер с nginx на порту 80 и другой контейнер с scrapyd, второй может обратиться к первому по адресу `http://localhost:80`.

--------------------------------------------------------------------------------------------------------------------

### **Почему в поде должно быть как можно меньше контейнеров?**

Pod'ы могут содержать несколько контейнеров, но их количество следует ограничивать. Поскольку контейнеры в одном поде масштабируются как единое целое, все они будут масштабироваться вместе, независимо от их индивидуальных потребностей. Это приводит к неэффективному использованию ресурсов и увеличению затрат. Чтобы решить эту проблему, Pod'ы должны быть как можно меньше, обычно содержа только основной процесс и тесно связанные с ним вспомогательные контейнеры (sidecars).

--------------------------------------------------------------------------------------------------------------------

### **Как работает хранилище в поде?**

Pod может определить набор общих томов (volumes) для хранения данных. Контейнеры внутри Pod'а могут работать с этими томами и, таким образом, обмениваться данными между собой. Благодаря использованию томов, можно сохранить данные, если один из контейнеров Pod'а должен быть перезапущен. Время жизни томов совпадает с временем жизни самого Pod'а.

--------------------------------------------------------------------------------------------------------------------

### **В чем разница между контейнером init и контейнером sidecar?**

В поды можно упаковывать один или несколько контейнеров. Для расширения функциональности основного контейнера без его усложнения используются специальные шаблоны проектирования, реализуемые с помощью init- и sidecar-контейнеров.

*   **Контейнер Init**: Эти контейнеры всегда запускаются до sidecar- и основного контейнера приложения. Init-контейнер должен успешно завершить свою работу, прежде чем остальные контейнеры смогут запуститься. Его используют для выполнения предварительных задач: проверки наличия зависимостей, настройки среды и т.д.
*   **Контейнер Sidecar**: Этот контейнер работает параллельно с основным контейнером приложения. Его используют для расширения или улучшения функциональности основного контейнера. Например, sidecar может выступать в роли прокси для управления трафиком, использоваться для сбора логов, мониторинга и многого другого.

--------------------------------------------------------------------------------------------------------------------

### **В чем разница между подом и контейнером?**

Под — это минимальная развертываемая единица в Kubernetes, которая может содержать один или несколько контейнеров.

--------------------------------------------------------------------------------------------------------------------

### **Как создается под? Какие компоненты задействуются при его создании?**

Предварительная информация: Воркер-узлы состоят из трех компонентов:
*   **kubelet**: модуль для коммуникации с `kube-apiserver`. Он сообщает информацию о себе и принимает команды.
*   **CRI (Container Runtime Interface)**: движок, который непосредственно создает контейнер (например, containerd, CRI-O).
*   **kube-proxy**: нужен для сетевого взаимодействия узлов.

Процесс создания пода:
1.  Пользователь отправляет команду, например, через `kubectl`.
2.  Запрос попадает на `kube-apiserver` — основной компонент управления кластером.
3.  `kube-apiserver` аутентифицирует и валидирует запрос (проверяет права доступа).
4.  Сервер API записывает определение пода в `etcd` — распределенное хранилище, которое является "источником правды" для кластера. `etcd` подтверждает запись. На этом этапе под существует только как запись в базе данных.
5.  В дело вступает `scheduler` (планировщик). Он отслеживает поды, которые еще не назначены узлам. Он анализирует требования пода (CPU, RAM) и состояние узлов, чтобы найти подходящий воркер-узел.
6.  Найдя подходящий узел, `scheduler` сообщает об этом `kube-apiserver`.
7.  `kube-apiserver` передает информацию `kubelet` на выбранном узле.
8.  `kubelet` через CRI создает под и запускает в нем указанные контейнеры.

--------------------------------------------------------------------------------------------------------------------

### **Может ли под запуститься на двух разных узлах?**

Нет. У каждого пода есть поле, указывающее узел, на котором он должен работать. Планировщик назначает под конкретному узлу, и он работает только там.

--------------------------------------------------------------------------------------------------------------------

### **Что означает версия API (apiVersion)?**

Версия API (например, `v1`, `apps/v1`, `batch/v1`) указывает на зрелость и стабильность API-объекта. Существуют следующие стадии:
*   **Alpha** (например, `v1alpha1`): Отключены по умолчанию, могут содержать баги. Поддержка может быть прекращена в любое время без предупреждения. Не рекомендуется для production.
*   **Beta** (например, `v2beta1`): Включены по умолчанию, хорошо протестированы. Поддержка не будет прекращена, но детали могут измениться. При изменениях предоставляется инструкция по миграции. Не рекомендуется для production, но можно использовать для тестирования новых функций.
*   **Стабильные (Stable)** (например, `v1`): Готовы для production. Будут совместимы с будущими версиями.

--------------------------------------------------------------------------------------------------------------------


### **Что такое kubectl?**

`kubectl` — это основной инструмент командной строки для взаимодействия с кластером Kubernetes.

С технической точки зрения, `kubectl` — это клиент для Kubernetes API. Kubernetes API — это RESTful HTTP API, через который осуществляется полное управление кластером. Каждая операция в Kubernetes — это HTTP-запрос к определенной конечной точке API. Основная задача `kubectl` — выполнять эти HTTP-запросы.

Kubernetes является ресурсно-ориентированной системой. Это означает, что вы управляете кластером, создавая, читая, обновляя и удаляя (CRUD) ресурсы (поды, сервисы, деплойменты и т.д.), а Kubernetes сам определяет, какие действия предпринять для достижения желаемого состояния.

--------------------------------------------------------------------------------------------------------------------

### **Что такое метки (labels) в Kubernetes?**

Метки — это пары ключ-значение, которые прикрепляются к объектам Kubernetes (например, к подам). Они предназначены для идентификации атрибутов объектов, которые важны для пользователей, но не влияют напрямую на работу системы. Метки можно использовать для организации и выбора подмножеств объектов.

```yaml
metadata:
  labels:
    "key1": "value1"
    "key2": "value2"
```
--------------------------------------------------------------------------------------------------------------------

### **Что такое селекторы меток?**

Селекторы меток — это основной механизм группировки объектов в Kubernetes. Они позволяют выбрать подмножество ресурсов (например, подов) на основе их меток и выполнить над ними операцию.

Селектор меток может выбирать ресурсы на основе следующих критериев:
*   Содержит (или не содержит) ресурс метку с определенным ключом.
*   Содержит ресурс метку с определенным ключом и значением.
*   Содержит ресурс метку с определенным ключом, но со значением, отличным от указанного.

--------------------------------------------------------------------------------------------------------------------

### **Что такое аннотации Kubernetes?**

Аннотации — это тоже пары ключ-значение, которые можно прикрепить к объектам. В отличие от меток, они не используются для идентификации и выбора объектов. Они предназначены для хранения неидентифицирующей информации, полезной для инструментов, библиотек или пользователей.

Примеры использования аннотаций:
*   Указание имени пользователя, создавшего объект.
*   Информация о сборке, выпуске или образе (метка времени, ID релиза, ветка git).
*   Ссылки на репозитории логирования, мониторинга или аудита.

--------------------------------------------------------------------------------------------------------------------

### **Что такое пространства имён (Namespaces) Kubernetes?**

Пространство имён (Namespace) можно рассматривать как виртуальный кластер внутри вашего физического кластера Kubernetes. Вы можете иметь несколько пространств имён, изолированных друг от друга, внутри одного кластера.

--------------------------------------------------------------------------------------------------------------------

### **Причины использования нескольких пространств имен?**

Пространства имён применяются в окружениях с большим количеством пользователей, распределенных по нескольким командам или проектам. Они позволяют:
*   **Определять область видимости имён:** Имена ресурсов (подов, сервисов) должны быть уникальными в пределах одного пространства имён, но могут повторяться в разных.
*   **Разделять ресурсы кластера:** Это позволяет избежать конфликтов между командами.
*   **Применять политики контроля доступа (RBAC):** Можно настроить разные права доступа для пользователей к разным пространствам имён.

По умолчанию в кластере существуют пространства имён:
*   `default`: для объектов, создаваемых без указания пространства имён.
*   `kube-system`: для объектов, созданных системой Kubernetes.
*   `kube-public`: для публично доступных ресурсов.
--------------------------------------------------------------------------------------------------------------------

### **Что такое контроллеры в Kubernetes?**

Контроллеры — это циклы управления, которые следят за состоянием кластера и стремятся привести текущее состояние к желаемому.

Основные типы контроллеров:
*   **Deployment**: Управляет жизненным циклом подов, обеспечивает их обновление и откат. Самый распространенный способ развертывания приложений.
*   **ReplicaSet**: Гарантирует, что указанное количество реплик пода всегда запущено. Обычно управляется Deployment.
*   **StatefulSet**: Управляет приложениями с состоянием (stateful), обеспечивая постоянное хранилище и уникальные сетевые идентификаторы для подов.
*   **DaemonSet**: Гарантирует, что на каждом (или некоторых) узле кластера запущена копия пода.
*   **Job**: Выполняет задачу до её успешного завершения. Создает один или несколько подов и следит, чтобы они выполнили свою работу.
*   **CronJob**: Создает задачи (Job) по расписанию.

--------------------------------------------------------------------------------------------------------------------

### **Как k8s поддерживает поды в здоровом состоянии?**

`kubelet` на каждом узле следит за состоянием подов.
1.  **Автоматический перезапуск**: Если главный процесс контейнера завершается с ошибкой, `kubelet` автоматически перезапускает его.
2.  **Проверки работоспособности (Probes)**: Иногда приложение перестает работать, но его процесс не завершается (например, зависание). Для таких случаев Kubernetes использует пробы:

    *   **Проверка живучести (Liveness Probe)**: `kubelet` периодически выполняет эту проверку. Если она не удается, `kubelet` "убивает" контейнер и перезапускает его.
    *   **Проверка готовности (Readiness Probe)**: Эта проверка определяет, готов ли контейнер принимать трафик. Если проверка не удается, конечные точки сервиса, указывающие на этот под, удаляются. Под не будет получать трафик, пока проверка снова не станет успешной.
    - **Проверка запуска (Startup Probe)**: Указывает, что приложение внутри контейнера запустилось. Если эта проба сконфигурирована, все остальные пробы отключаются до тех пор, пока она не завершится успешно. Это полезно для медленно стартующих приложений.

Проверки могут выполняться тремя способами:
*   **HTTP GET**: Выполняется HTTP GET запрос. Ответ с кодом 2xx или 3xx считается успехом.
*   **TCP Socket**: Попытка установить TCP-соединение с указанным портом. Успешное соединение — успех.
*   **Exec**: Выполнение команды внутри контейнера. Код выхода 0 — успех.

Пример `livenessProbe`:
```yaml
livenessProbe:
  httpGet:
    path: /
    port: 8080
```

--------------------------------------------------------------------------------------------------------------------

### **Почему при запуске под может начать циклически перезагружаться?**

Это может произойти, если `livenessProbe` начинает работать слишком рано, до того как приложение полностью запустилось и готово отвечать на запросы. Проверка не удается, Kubernetes перезапускает контейнер, и цикл повторяется.

Чтобы избежать этого, нужно использовать `initialDelaySeconds`, чтобы задать начальную задержку перед первой проверкой.

```yaml
livenessProbe:
  httpGet:
    path: /
    port: 8080
  initialDelaySeconds: 15
```


--------------------------------------------------------------------------------------------------------------------


### **Что такое ReplicaSet?**

ReplicaSet — это ресурс Kubernetes, который гарантирует, что заданное количество реплик пода постоянно работает. Если под по какой-либо причине исчезает, ReplicaSet замечает это и создает новый под на замену.

ReplicaSet постоянно отслеживает количество запущенных подов, соответствующих его селектору меток, и сравнивает его с желаемым количеством. Если подов меньше — создаются новые, если больше — лишние удаляются.

### **Из чего состоит ReplicaSet?**

ReplicaSet состоит из трех основных частей:
1.  **Селектор меток** (`selector`): Определяет, какими подами управляет ReplicaSet.
2.  **Количество реплик** (`replicas`): Желаемое количество подов.
3.  **Шаблон пода** (`template`): Описывает, как создавать новые поды.

### **Преимущества использования ReplicaSet?**

*   Гарантирует постоянную работу нужного количества подов.
*   Автоматически восстанавливает поды в случае сбоя узла.
*   Позволяет легко выполнять горизонтальное масштабирование (ручное или автоматическое).


--------------------------------------------------------------------------------------------------------------------

### **Что будет, если поменять селектор меток в ReplicaSet?**

Изменение селектора меток приведет к тому, что существующие поды перестанут соответствовать новому селектору и выпадут из-под управления этого ReplicaSet. ReplicaSet перестанет о них заботиться и, скорее всего, создаст новые поды по шаблону, чтобы достичь желаемого числа реплик.

--------------------------------------------------------------------------------------------------------------------

### **Чем ReplicaSet отличается от ReplicationController?**

ReplicaSet — это следующее поколение ReplicationController. Основное различие заключается в поддержке селекторов. ReplicationController поддерживает только селекторы на основе равенства, в то время как ReplicaSet поддерживает более сложные селекторы на основе множеств:
*   `In`: значение метки должно совпадать с одним из указанных значений.
*   `NotIn`: значение метки не должно совпадать ни с одним из указанных значений.
*   `Exists`: под должен содержать метку с указанным ключом.
*   `DoesNotExist`: под не должен содержать метку с указанным ключом.

--------------------------------------------------------------------------------------------------------------------

### **Что такое DaemonSet?**

DaemonSet гарантирует, что на всех (или на некоторых, заданных селектором) узлах кластера запущена одна копия пода. Когда в кластер добавляется новый узел, на нем автоматически запускается под из DaemonSet. Когда узел удаляется, под на нем уничтожается.

Типичные применения DaemonSet:
*   **Сбор логов**: запуск агентов вроде `fluentd` или `logstash` на каждом узле.
*   **Мониторинг**: запуск агентов мониторинга, таких как `Prometheus Node Exporter` или `Datadog agent`.
*   **Кластерное хранилище**: запуск демонов для систем хранения, таких как `glusterd` или `ceph`.

--------------------------------------------------------------------------------------------------------------------

DaemonSet зачем нужен для чего его обычно используют?

У него широкое распространение. Нужен для сбора логов по разным нодам. Логи как-то надо собирать. Сертификаты нод. Смотреть через демонсет можно такие штуки

--------------------------------------------------------------------------------------------------------------------

### **Что такое Job?**

Job — это контроллер для выполнения одноразовых задач. Он создает один или несколько подов и следит за тем, чтобы они успешно завершили свою работу. Если под завершается с ошибкой, Job может перезапускать его до тех пор, пока задача не будет выполнена указанное количество раз.

Типичные примеры:
*   Запуск тестов.
*   Применение миграций базы данных.
*   Выполнение одноразовых скриптов.

Основные настройки:
*   `completions`: количество успешных завершений задачи.
*   `parallelism`: сколько подов могут работать параллельно.
*   `backoffLimit`: максимальное количество неудачных попыток перед тем, как Job будет помечен как проваленный.
*   `activeDeadlineSeconds`: максимальное время выполнения Job.
*   `ttlSecondsAfterFinished`: время жизни завершенного Job и его подов перед автоматическим удалением.

--------------------------------------------------------------------------------------------------------------------

### **Что такое CronJob?**

CronJob — это контроллер, который создает объекты Job по расписанию, заданному в формате cron.

Применение:
*   Регулярные бэкапы.
*   Отправка отчетов или уведомлений по расписанию.
*   Выполнение задач в периоды низкой нагрузки.

--------------------------------------------------------------------------------------------------------------------

### **Что такое Service в Kubernetes?**

Service — это абстракция, которая определяет логический набор подов и политику доступа к ним. Сервис предоставляет единую, стабильную точку входа (IP-адрес и порт), которая не меняется, даже если поды за ней создаются и удаляются. Клиенты обращаются к сервису, а он уже направляет трафик на один из работающих подов, соответствующих его селектору.

--------------------------------------------------------------------------------------------------------------------

### **Как Service находит pod?**

Service использует **селектор меток** для определения набора целевых подов. Когда сервис создан, Kubernetes создает связанный с ним объект **Endpoints**, который содержит список IP-адресов и портов всех подов, соответствующих селектору сервиса. Именно этот список Endpoints используется для маршрутизации трафика, а не сам сервис напрямую.

--------------------------------------------------------------------------------------------------------------------

### **Перечислите различные типы Service**

*   **ClusterIP**: Тип по умолчанию. Сервис получает внутренний IP-адрес, доступный только внутри кластера. Используется для взаимодействия между компонентами приложения внутри кластера.
*   **NodePort**: Сервис становится доступным извне кластера через определенный порт на каждом узле (`<NodeIP>:<NodePort>`). Kubernetes выделяет порт из диапазона 30000-32767. `NodePort` также создает `ClusterIP`.
*   **LoadBalancer**: Расширяет `NodePort`. Запрашивает у облачного провайдера внешний балансировщик нагрузки, который будет направлять трафик на `NodePort` сервиса на узлах. Это стандартный способ предоставления сервиса в интернет в облачных средах.
*   **Headless**: Сервис без `ClusterIP`. Когда выполняется DNS-запрос к такому сервису, он возвращает IP-адреса всех подов, на которые он указывает, а не один виртуальный IP. Это полезно для приложений с состоянием (stateful), когда нужно напрямую подключаться к конкретным подам (например, в кластерах баз данных).

--------------------------------------------------------------------------------------------------------------------


### **Что такое Ingress?**

Ingress — это API-объект, который управляет внешним доступом к сервисам в кластере, как правило, по HTTP(S). Он предоставляет маршрутизацию на основе хоста (например, `foo.bar.com`) и пути (например, `/app1`), позволяя использовать один IP-адрес для множества сервисов.

Для работы Ingress требуется **Ingress-контроллер** — специальное приложение (например, Nginx, Traefik), которое реализует правила, описанные в ресурсе Ingress. Ingress-контроллер принимает внешний трафик и маршрутизирует его к соответствующим сервисам.
--------------------------------------------------------------------------------------------------------------------

### **Через что реализованы сети в Kubernetes?**

Сеть в Kubernetes реализуется с помощью плагинов, соответствующих спецификации CNI (Container Network Interface). Каждый под получает уникальный IP-адрес в кластере, и поды могут общаться друг с другом напрямую, независимо от того, на каком узле они находятся.

Наиболее известные CNI-плагины:
*   **Flannel**: Простой и надежный плагин, создает оверлейную сеть.
*   **Calico**: Более мощный плагин, использует BGP для маршрутизации. Основное преимущество — поддержка **Network Policies** (сетевых политик), которые позволяют создавать правила файрвола для подов.

--------------------------------------------------------------------------------------------------------------------

### **Что такое DNS в Kubernetes?**

DNS (Система доменных имен) — это механизм для сопоставления легко запоминающихся имен (например, `my-service`) с IP-адресами. Большинство кластеров Kubernetes автоматически настраивают внутреннюю службу DNS (например, CoreDNS), которая выступает в качестве основного механизма обнаружения сервисов (Service Discovery). Это позволяет приложениям легко находить друг друга и взаимодействовать, даже если поды и сервисы постоянно создаются, удаляются и перемещаются между узлами.

---

### **Что предоставляет служба Kubernetes DNS?**

1.  В кластере создается сервис (например, `kube-dns` или `coredns`) и один или несколько подов, реализующих DNS-сервер.
2.  Эта служба DNS отслеживает создание, обновление и удаление других сервисов в кластере через Kubernetes API и автоматически создает/обновляет для них DNS-записи.
3.  Для каждого нового пода `kubelet` автоматически настраивает файл `/etc/resolv.conf` так, чтобы он использовал внутренний DNS-сервер кластера. Конфигурация также включает пути поиска, что позволяет использовать короткие имена для обращения к сервисам в том же пространстве имён.

Пример содержимого `/etc/resolv.conf` внутри пода:
```
nameserver 10.32.0.10
search <namespace>.svc.cluster.local svc.cluster.local cluster.local
options ndots:5
```
Благодаря этому, приложение в контейнере может разрешить имя `example-service` в IP-адрес сервиса, если они находятся в одном пространстве имён.

---

### **Какие объекты получают DNS-имена?**

Каждому **сервису** в кластере присваивается DNS-имя в формате `<service-name>.<namespace>.svc.cluster.local`.

Благодаря путям поиска, заданным в `/etc/resolv.conf`, действуют следующие правила:
*   Под, работающий в пространстве имён `bar`, может обратиться к сервису `foo` в том же пространстве имён просто по имени `foo`.
*   Под, работающий в пространстве имён `quux`, может обратиться к тому же сервису `foo` в пространстве `bar` по полному имени `foo.bar`.


--------------------------------------------------------------------------------------------------------------------

### **Что такое том (Volume)?**

Том (Volume) — это абстракция, которая позволяет подам хранить данные. Жизненный цикл тома привязан к жизненному циклу пода.

Тома решают две основные проблемы:
*   **Эфемерность контейнеров**: Файловая система контейнера временная и уничтожается вместе с ним. Тома позволяют сохранять данные при перезапуске контейнера.
*   **Обмен данными**: Тома позволяют нескольким контейнерам внутри одного пода совместно использовать файлы.

---

### **Какие бывают типы томов (Volumes)?**

Существует множество типов томов. Вот два базовых:

1.  **emptyDir**
*   Создается пустой каталог, когда под назначается узлу. Он существует, пока существует под.
*   Все контейнеры внутри пода могут читать и записывать в один и тот же `emptyDir`.
*   Когда под удаляется с узла (по любой причине), данные в `emptyDir` удаляются навсегда.
*   **Применение**: временное хранилище (кэш), обмен файлами между контейнерами в одном поде.

2.  **hostPath**
*   Монтирует файл или каталог из файловой системы хост-узла непосредственно в под.
*   Данные не удаляются после уничтожения пода, так как они находятся на узле.
*   **Внимание**: Использование `hostPath` не рекомендуется в большинстве случаев. Это создает сильную зависимость пода от конкретного узла и может представлять угрозу безопасности.
*   **Применение**: доступ к системным компонентам узла, например, к логам в `/var/log`.

---

### **Что такое ConfigMap?**

**ConfigMap** — это API-объект для хранения неконфиденциальных конфигурационных данных в виде пар ключ-значение. Использование ConfigMap позволяет отделить конфигурацию от кода приложения, что делает приложения более портативными.

Содержимое ConfigMap может быть использовано подами:
*   Как переменные окружения.
*   Как аргументы командной строки.
*   Как файлы в томе (volume).

---

### **Что такое Secret?**

**Secret** — это API-объект, похожий на ConfigMap, но предназначенный для хранения конфиденциальной информации, такой как пароли, токены и ключи SSH. Данные в Secret хранятся в формате base64, но это лишь кодировка, а не шифрование. Для защиты данных в `etcd` необходимо настраивать шифрование при хранении (encryption at rest).

Секреты могут использоваться подами так же, как и ConfigMaps:
*   Как файлы в томе.
*   Как переменные окружения.

---

### **Что такое PersistentVolume (PV) и PersistentVolumeClaim (PVC)?**

Это два API-ресурса, которые предоставляют абстракцию для управления хранилищами данных. Они позволяют отделить жизненный цикл данных от жизненного цикла подов, обеспечивая постоянное хранение.

1.  **PersistentVolume (PV)**: Это "кусок" хранилища в кластере (например, диск Google Cloud, том NFS, раздел на локальном диске), который подготовлен администратором. Это ресурс кластера, как и узел.
2.  **PersistentVolumeClaim (PVC)**: Это "запрос" на использование хранилища со стороны пользователя (или пода). Пользователь запрашивает определенный объем хранилища с определенными характеристиками (например, `10Gi` с доступом `ReadWriteOnce`).

Kubernetes находит подходящий PV для PVC и "связывает" их. После этого под может использовать PVC для монтирования тома и хранения данных. Такой подход абстрагирует разработчиков от деталей нижележащей инфраструктуры хранения.

**Типы доступа (`accessModes`) у PVC:**
*   **ReadWriteOnce (RWO)**: том может быть смонтирован для чтения и записи одним узлом.
*   **ReadOnlyMany (ROX)**: том может быть смонтирован для чтения многими узлами.
*   **ReadWriteMany (RWX)**: том может быть смонтирован для чтения и записи многими узлами.


--------------------------------------------------------------------------------------------------------------------

## **Что такое Deployment?**

**Deployment** — это API-ресурс высокого уровня, который управляет развертыванием и обновлением приложений. Он описывает желаемое состояние для подов и использует **ReplicaSet** для поддержания этого состояния.

При использовании Deployment вы декларативно описываете, какое приложение, в скольких экземплярах и какой версии должно работать, а Deployment сам заботится о создании, масштабировании, обновлении и откате подов.

### **Стратегии развертывания (Deployment Strategies)?**

*   **Recreate** (Воссоздание): Сначала все старые поды удаляются, а затем создаются новые. Это приводит к короткому простою приложения. Используется, если приложение не может работать в нескольких версиях одновременно.
*   **RollingUpdate** (Постепенное обновление): По умолчанию. Старые поды заменяются новыми по одному (или группами), что обеспечивает непрерывную доступность приложения во время обновления.
*   **Blue/Green** (Сине-зеленое): Новая версия ("синяя") развертывается параллельно со старой ("зеленой"). Трафик переключается на новую версию после её полной готовности и тестирования. Старая версия остается на случай быстрого отката.
*   **Canary** (Канареечное): Новая версия выкатывается для небольшого процента пользователей. Если все идет хорошо, процент постепенно увеличивается до 100%.

---

### **Что произойдет после обновления шаблона пода в Deployment?**

Когда вы изменяете шаблон пода в ресурсе Deployment (например, командой `kubectl set image deployment ...`), вы запускаете процесс обновления. Контроллер Deployment создает новый ReplicaSet с обновленным шаблоном и постепенно масштабирует его, одновременно уменьшая количество реплик в старом ReplicaSet в соответствии с выбранной стратегией обновления (например, RollingUpdate).

---

### **Как сделать откат развертывания (deployment)?**

Kubernetes хранит историю ревизий для каждого Deployment. Для отката к предыдущей версии используется команда:
```bash
kubectl rollout undo deployment <deployment-name>
```
Можно также откатиться к конкретной ревизии, указав ее номер.

---

### **В чем отличие Deployment от ReplicaSet?**

**ReplicaSet** — это низкоуровневый контроллер, единственная задача которого — поддерживать заданное количество реплик пода. Он не умеет управлять обновлениями.

**Deployment** — это высокоуровневый контроллер, который использует ReplicaSet "под капотом". Deployment добавляет функциональность управляемых обновлений и откатов. При обновлении Deployment создает новый ReplicaSet и оркестрирует передачу подов от старого к новому.

Проще говоря, Deployment — это "умная" обертка над ReplicaSet для управления жизненным циклом приложений.

---

### **В чем разница между Deployment и StatefulSet?**

| Характеристика | Deployment | StatefulSet |
| :--- | :--- | :--- |
| **Предназначение** | Приложения без состояния (stateless) | Приложения с состоянием (stateful), например, базы данных |
| **Имена подов** | Случайные, взаимозаменяемые (`nginx-6799fc88d8-z5k9n`) | Стабильные, предсказуемые (`web-0`, `web-1`) |
| **Хранилище** | Обычно используют один общий PVC на все реплики. | Каждая реплика получает свой уникальный PVC (`www-web-0`, `www-web-1`). |
| **Сеть** | Поды доступны через один общий Service. | Требует `Headless Service` для предоставления уникальных DNS-имен каждому поду. |
| **Масштабирование/Обновление** | В случайном порядке. | В строгом порядке (от 0 до N или наоборот). |

--------------------------------------------------------------------------------------------------------------------

### **Что такое приложения с сохранением состояния (Stateful Applications)?**

Это приложения, которым для работы необходимо сохранять свое состояние (данные). Если такое приложение перезапустить, оно должно восстановить свое состояние, чтобы продолжить работу.

*   **Примеры**: базы данных (MySQL, PostgreSQL), брокеры сообщений (Kafka, RabbitMQ), системы кеширования с сохранением на диск.
*   **Противоположность**: приложения без состояния (stateless), такие как веб-сервер Nginx или бэкенд на Node.js, которые не хранят данные о сессиях локально и могут быть заменены любой другой идентичной копией без потери информации.

---

### **Что такое StatefulSet?**

**StatefulSet** — это контроллер Kubernetes, предназначенный для управления stateful-приложениями. Он предоставляет своим подам гарантии относительно порядка их развертывания, масштабирования, обновления и уникальности.

Ключевые особенности:
*   **Стабильные, уникальные сетевые идентификаторы**: Имена подов предсказуемы (`app-0`, `app-1`).
*   **Стабильное постоянное хранилище**: Каждый под получает свой собственный PersistentVolumeClaim.
*   **Упорядоченное развертывание и масштабирование**: Поды создаются и масштабируются в строгом порядке (0, 1, 2...).
*   **Упорядоченное удаление и сворачивание**: Поды удаляются в обратном порядке (N, N-1, ... 0).

---

### **Когда использовать StatefulSet?**

StatefulSet следует использовать, когда важна хотя бы одна из следующих характеристик:
*   **Стабильный, уникальный сетевой идентификатор** для каждого пода.
*   **Стабильное постоянное хранилище** для каждого пода.
*   **Упорядоченное развертывание, масштабирование или сворачивание** подов.
*   **Необходимость в кластеризации**, когда поды должны "знать" друг о друге (например, для репликации данных в базе данных).
--------------------------------------------------------------------------------------------------------------------

### **Аутентификация в Kubernetes**

В Kubernetes есть два типа "пользователей":
*   **Users (Пользователи)**: Предназначены для людей. Управление ими осуществляется внешними системами (например, через сертификаты, токены, интеграцию с LDAP). Kubernetes не хранит объекты User.
*   **Service Accounts (Сервисные аккаунты)**: Предназначены для процессов, работающих внутри подов, чтобы они могли аутентифицироваться на API-сервере. ServiceAccount — это API-объект, который существует в кластере и привязан к пространству имён.

Каждый запрос к API должен быть аутентифицирован как User, Service Account или быть анонимным. После аутентификации запрос проходит авторизацию (например, через RBAC) и admission control.

--------------------------------------------------------------------------------------------------------------------