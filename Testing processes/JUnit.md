Значит, нужно автоматизировать и тестирование. А как автоматизировать поиск ошибок?

Краткий ответ: никак. Но тут нам на помощь опять приходит то, что мы программисты.
Процесс разработки программного обеспечения состоит из постоянного внесения в него изменений. как раз в процессе постоянного внесения изменений программисты очень часто ломают то, что до недавнего времени отлично работало.
И тестировщики вместо того, чтобы искать новые ошибки, вынуждены постоянно проверять, на поломали ли мы с вами то, что давно и хорошо работало. Так называемое регрессионное тестирование. Именно этот тип тестирования автоматизировать можно и нужно.
Тут весь софт можно поделить на две части:
программа взаимодействует с человеком
программа взаимодействует с другой программой
Первый вариант автоматизируется сложнее, для него нужны специальные тестировщики-автоматизаторы, их еще называют QA Automation или Software Test Engineer.
А вот второй вариант автоматизировать можно и нужно самостоятельно. Если у тебя есть часть программы, которая:
хорошо работает
уже протестирована
выполнена в виде отдельного модуля или логического блока
не планирует меняться
от нее зависят другие модули или программы
поломка функционала дорого обойдется
Рекомендую выделить время и написать для нее тесты, которые зафиксируют ключевые аспекты ее текущей функциональности. На это будет разумно выделить 5% твоего рабочего времени, или 1 день в месяц.
Не нужно писать тесты ради тестов.
Никто не будет поддерживать твои тесты. Ни другие программисты, ни ты сам. Так никто не делает. 99% всех написанных тестов заброшены и/или отключены. Если можешь не писать тесты — не пиши. Пиши только если без них ну точно не обойтись.

--------------------------------------------------------------------------------------------------------------------
Типы тестирования?

Каждый программист, если он не проходил специальное обучение, сможет рассказать своими словами, что такое тестирование: проверка, делает ли программа то, что должна. Однако профессионалы в этой области выделяют целые направления (типы) тестирования.

Все тестирование, действительно, крутится вокруг надежности и готовности программ, однако чтобы лучше понять направления тестирования, давай рассмотрим несколько примеров.

Допустим, ты тестируешь типичный интернет-магазин. Тогда направления тестирования можно разбить на такие типы: тестирование производительности, функциональное тестирование, интеграционное тестирование и модульное тестирование.

Если владелец сайта решит запустить серьезную рекламную компанию, то на сайт одновременно придет куча пользователей. Вполне может быть, что сайт не упадет, но некоторые его разделы могут работать медленно или вообще перестать работать
.
Для того, чтобы этого не случилось, тебе нужно заранее выявить такие проблемы и предпринять шаги для их устранения. Это делается с помощью нагрузочного тестирования, или его еще называют тестированием производительности.

Так же ты можешь захотеть проверить, как работает API твоего бэкенда и протестировать каждую его функцию: регистрацию, логин, добавление в корзину, обработку платежей, записи в базу данных и т. д. Все должно работать согласно ТЗ. В этом случае нужно выполнить функциональное тестирование.

Твой интернет-магазин скорее всего интегрирован со сторонними сервисами: рассылка писем и СМС, платежные системы, онлайн-чаты поддержки, сбор обратной связи от пользователей, рекламные системы и т. д. Чтобы убедиться, что все это работает как задумано, тебе нужно провести интеграционное тестирование.

И, наконец, сложные продукты часто разбивают на независимые модули. Из таких модулей можно собрать финальный продукт, как из конструктора. Если ты занимаешься разработкой такого модуля или взаимодействием таких модулей, то тебе
понадобиться провести модульное тестирование.

Подводя итоги, можно сказать, что функциональное тестирование нужно для проверки каждой отдельной функции сайта. Интеграционное — для тестирования взаимодействия крупных модулей и систем вашего продукта. Модульное — для проверки отдельного модуля, ну а тестирование производительности — для проверки работы твоего сайта под нагрузкой.
Типов тестирования может быть еще больше: чем сложнее продукт, тем больше его аспектов разработки нуждаются в контроле.

--------------------------------------------------------------------------------------------------------------------
Что такое JUnit?

Для тестирования Java-кода у нас есть шикарный фреймворк под названием JUnit. Он отлично работает, постоянно обновляется, очень популярен и, конечно, с ним очень плотно интегрирована Intellij IDEA.
Сейчас все пользуются пятой версией этого фреймворка — JUnit 5, хотя во многих проектах ты еще можешь встретить его четвертую версию. Они не сильно отличаются, но мы все равно рассмотрим самую последнюю. Думаю, к тому времени, когда ты начнешь активно писать тесты, ты одобришь мой выбор.

--------------------------------------------------------------------------------------------------------------------
Аннотации JUnit 5?

@BeforeEach
Аннотированный метод будет запускаться перед каждым тестовым методом в тестовом классе.

@AfterEach
Аннотированный метод будет запускаться после каждого тестового метода в тестовом классе.

@BeforeAll
Аннотированный метод будет запущен перед всеми тестовыми методами в тестовом классе. Этот метод должен быть статическим.

@AfterAll
Аннотированный метод будет запущен после всех тестовых методов в тестовом классе. Этот метод должен быть статическим.

@Test
Он используется, чтобы пометить метод как тест junit.

@DisplayName
Используется для предоставления любого настраиваемого отображаемого имени для тестового класса или тестового метода

@Disable
Он используется для отключения или игнорирования тестового класса или тестового метода из набора тестов.

@Nested
Используется для создания вложенных тестовых классов

@Tag
Пометьте методы тестирования или классы тестов тегами для обнаружения и фильтрации тестов.

@TestFactory
Отметить метод - это тестовая фабрика для динамических тестов.

--------------------------------------------------------------------------------------------------------------------
Фазы жизненного цикла теста

Setup (настройка): на этом этапе создается тестовая инфраструктура. JUnit обеспечивает настройку уровня класса (@BeforeAll) и настройку уровня метода (@BeforeEach). Как правило, тяжелые объекты, такие как подключения к базам данных, создаются при настройке уровня класса, в то время как легкие объекты, такие как тестовые объекты, перезапускаются при настройке уровня метода.

Test Execution (выполнение теста): на этом этапе происходит выполнение теста и assertion. Результат выполнения будет означать успех или неудачу теста.

Cleanup (очистка): этот этап используется для очистки настройки тестовой инфраструктуры, настроенной на первом этапе. Как на этане настройки, очистка также выполняется на уровне класса (@AfterAll) и уровне метода (@AfterEach).

--------------------------------------------------------------------------------------------------------------------
Допустим, у тебя есть класс, который ты хочешь протестировать. Как это лучше всего сделать?

Предположим, у нас есть класс Calculator, которые умеет выполнять 4 базовые операции: сложение, вычитание, умножение и деление

Мы хотим протестировать методы этого класса. Мало ли, в будущем наменяют чего-нибудь и все перестанет работать. Как нам написать для него тесты?

Нам нужно создать еще один класс. Для этого обычно берут то же имя и добавляют суффикс Test. Для каждого метода нужно добавить хотя бы один тестовый метод.

--------------------------------------------------------------------------------------------------------------------
Для чего нужно аннотация @BeforeAll?

Аннотация @BoforeAll используются для указания о том, что аннотированный метод должен быть выполнен перед всеми @Test, @RepeatedTest, @ParameterizedTest и @TestFactory методами в текущем классе.
По умолчанию тестовые методы будут выполняться в том же потоке, что и аннотированный @BeforeAll метод.

Аннотированный @BeforeAll метод ДОЛЖЕН быть статическим методом в тестовом классе.

Или мы можем применить эту аннотацию к default методам интерфейса, если тестовый интерфейс или тестовый класс аннотированы с помощью @TestInstance(Lifecycle.PER_CLASS).

--------------------------------------------------------------------------------------------------------------------
Для чего нужно аннотация @BeforeEach?

Аннотация @BeforeEach используется для обозначения того, что аннотированный метод должен выполняться перед каждым методом @Test, @RepeatedTest, @ParameterizedTest, или @TestFactory в текущем классе.
Аннотация JUnit 5 @BeforeEach является одним из методов жизненного цикла и заменяет аннотацию @Before в JUnit 4.
По умолчанию тестовые методы будут выполняться в том же потоке, что и аннотированный @BeforeEach метод

--------------------------------------------------------------------------------------------------------------------
Для чего нужно аннотация @AfterEach?

Аннотация @AfterEach используется для обозначения того, что аннотированный метод должен выполняться после каждого метода, помеченного @Test, @RepeatedTest, @ParameterizedTest, или @TestFactory в текущем классе.
Аннотация JUnit 5 @AfterEach является заменой аннотации @After в JUnit 4.
По умолчанию тестовые методы будут выполняться в том же потоке, что и аннотированный @AfterEach метод.
Аннотированный @AfterEach метод НЕ ДОЛЖЕН быть статическим, иначе он вызовет ошибку времени выполнения.

--------------------------------------------------------------------------------------------------------------------
Для чего нужно аннотация @AfterAll?

Аннотация JUnit 5 @AfterAll является заменой аннотации @AfterClass в JUnit 4. Она используется как метод очистки для тестового класса.
@AfterAll используется для обозначения того, что аннотированный метод должен быть выполнен после всех тестов в текущем тестовом классе.
Обратите внимание, что для выполнения метода после каждого теста мы можем использовать аннотацию @AfterEach.

Методы, аннотированные @AfterAll, должны иметь возвращаемый тип void, но не должны быть private.

Методы, аннотированные @AfterAll, могут опционально объявлять параметры, которые должны быть разрешены ParameterResolvers.

Методы, аннотированные @AfterAll, наследуются от суперклассов, если они не скрыты или не
переопределены. Кроме того, @AfterAll методы из суперклассов будут выполняться перед @AfterAll методами в подклассах.

Метод, аннотированный @AfterAll должен быть статическим, в противном случае он будет выдавать ошибки во время выполнения.

--------------------------------------------------------------------------------------------------------------------
Для чего нужно аннотация @RepeatedTest?

Аннотация @RepeatedTest используется для обозначения метода тестирования, который должен повторяться указанное количество раз с настраиваемым отображаемым именем.
Чтобы повторить тест с различными аргументами, рассмотрите возможность использования аннотации @ParameterizedTest.
Чтобы создать повторяемый тест, аннотируйте метод теста с помощью @RepeatedTest.
В данном примере тестовый метод использует аннотацию @RepeatedTest (5). Это означает, что тест будет выполнен пять раз.

Обратите внимание, что каждый вызов повторного теста ведет себя как выполнение обычного теста с полной поддержкой тех же обратных вызовов и расширений жизненного цикла.
Это означает, что аннотированные методы жизненного цикла @BeforeEach и @AfterEach будут вызываться при каждом вызове теста.

--------------------------------------------------------------------------------------------------------------------
Для чего нужно аннотация @Disabled?

Аннотация позволяет выключить определенный тест, чтобы JUnit его не вызывал. Она нужна в случаях, если ты заметишь, что тест работает неверно, или поменяешь код и тест случайно поломается.
Как я писал раньше, 99% тестов никто не поддерживает, поэтому все они рано или поздно оказываются отключены. Поэтому эта аннотация первая в списке полезных.

--------------------------------------------------------------------------------------------------------------------
Для чего нужно аннотация @ExtendWith?

Полезная аннотация — @ExtendWith. Скорее всего ты будешь встречать ее очень часто, так что рассмотрим ее подробнее.
JUnit — это мощный фреймворк, который позволяет писать различные плагины (расширения) для гибкой настройки своей работы. Некоторые расширения могут собирать статистику о тестах, другие — эмулировать файловую систему в памяти, третьи — эмулировать работу внутри веб-сервера, и так далее.
Если твой код работает внутри какого-нибудь фреймворка (например Spring), то почти всегда этот фреймворк управляет созданием и настройкой объектов твоего кода. Поэтому без специального тестового плагина не обойтись.

--------------------------------------------------------------------------------------------------------------------
Как задать время на выполнение теста?

@Timeout. Она позволяет задать время на выполнение теста. Если выполнение теста заняло больше времени, чем указанно в аннотации, то он считается проваленным.

--------------------------------------------------------------------------------------------------------------------
Ассерты (asserts) что такое?

Ассерты (asserts) — это специальные проверки, которые можно вставить в разные места кода. Их задача определять, что что-то пошло не так. Вернее, проверять, что все идет как нужно. Вот это "как нужно" они и позволяют задать различными способами.
С некоторыми ассертами ты уже сталкивался в коде выше. Первый из них - проверка объектов на равенство. Если объекты не равны — кинется исключение и тест будет провален.
Тут важен порядок сравнения, ведь JUnit в итоговом отчете напишет что-то типа "получено значение 1, а ожидалось 3". Общий формат такой проверки имеет вид:

assertEquals(эталон, значение)

--------------------------------------------------------------------------------------------------------------------
Какие бывают асерты?

assertEquals
Проверяет, что два объекта равны

assertArrayEquals
Проверяет, что два массива содержат равные значения

assertNotNull
Проверяет, что аргумент не равен null

assertNull
Проверяет, что аргумент равен null

assertNotSame
Проверят, что два аргумента — это не один и тот же объект

assertSame
Проверят, что два аргумента — это один и тот же объект

assertTrue
Проверяет, что аргумент равен true

assertFalse
Проверяет, что аргумент равен false

--------------------------------------------------------------------------------------------------------------------
Допустим выполняется сравнение:
Address address = unitUnderTest.methodUnderTest(); assertEquals("Вашингтон", address.getCity());
assertEquals("Oracle Parkway", address.getStreet()); assertEquals("500", address.getNumber());

Но если один из параметров не совпадет, то проверки остальных не произойдет. А хотелось бы чтобы они все-таки произошли и их результаты записались в лог. Но при этом, если хотя бы одна проверка не прошла, то тест все-таки был провален.

Для этого есть специальный метод — assertAll(). В качестве первого аргумента он принимает комментарий, который нужно записать в лог, а дальше — любое количество функций-ассертов.
Вот как будет переписан наш пример с его помощью:

Address address = unitUnderTest.methodUnderTest();

assertAll("Сложный сценарий сравнение адреса",
() -> assertEquals("Вашингтон", address.getCity()),
() -> assertEquals("Oracle Parkway", address.getStreet()), () -> assertEquals("500", address.getNumber())
);

Тогда если адрес будет неправильный, в лог будет написано что-то типа:
Сложный сценарий сравнение адреса (3 failures) expected: <Вашингтон> but was: <Сиэтл> expected: <Oracle Parkway> but was: <Main Street> expected: <500> but was: <5772>

--------------------------------------------------------------------------------------------------------------------
Метод assertThrows

Очень часто бывают ситуации, когда тебе нужно убедиться, что в определенной ситуации код кидает нужное исключение: определил ошибку и кинул нужное исключение. Это очень распространенная ситуация.
На этот случай есть еще один полезный метод assert — это assertThrows(). Общий формат его вызова имеет вид:
assertThrows(исключение, код)
По сути, он очень похож на метод assertTimeout(), только он проверяет, чтобы указанный код выкинул нужное исключение.

assertEquals("Exception message", exception.getMessage());

--------------------------------------------------------------------------------------------------------------------