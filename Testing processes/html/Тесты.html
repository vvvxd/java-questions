<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Вопросы по собеседованию</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .question-block {
            cursor: pointer;
            transition: background-color 0.3s ease;
            word-break: break-word;
        }
        .question-block:hover {
            background-color: #f3f4f6;
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen">

<!-- Контейнер с вопросом -->
<div id="question-container" class="bg-white shadow-lg rounded-lg p-6 w-[800px] h-[750px] flex items-center justify-center text-center relative">
    <div id="question-block" class="question-block p-4 border-b w-full h-full flex items-center justify-center text-center relative" onclick="toggleAnswer()">
        <strong class="text-lg block" id="question-text"></strong>
        <div id="answer-text" class="text-gray-700 hidden" onclick="toggleAnswer()"></div>
    </div>
</div>

<!-- Навигация -->
<div class="absolute bottom-10 flex justify-center gap-4">
    <button onclick="prevQuestion()" class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600">Назад</button>
    <button onclick="location.href='main.html'" class="bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600">На главную</button>
    <button onclick="nextQuestion()" class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600">Вперед</button>
</div>

<!-- Модальное окно -->
<div id="modal" class="fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 hidden">
    <div class="bg-white p-6 rounded-lg shadow-lg w-[900px] h-[800px] overflow-y-auto">
        <h2 class="text-lg font-semibold mb-4">Ответ</h2>
        <p id="modal-answer" class="text-gray-700"></p>
        <button onclick="closeModal()" class="mt-4 bg-red-500 text-white px-4 py-2 rounded hover:bg-red-600 w-full">Закрыть</button>
    </div>
</div>

<script>
    let currentQuestionIndex = 0;
    const MAX_ANSWER_LENGTH = 2000; // Максимальная длина ответа для отображения без модального окна

    const questions = [
        {
  question: "Что такое тесты?",
  answer: "Тесты - это инструменты для проверки качества и функционирования кода, программ или систем. Они используются для проверки того, что программа работает как задумано, и для поиска ошибок или дефектов. Тесты могут быть автоматическими или ручными."
}
,{
  question: "Зачем нужны в программе тесты?",
  answer: "Тесты нужны для проверки того, что программа работает правильно и соответствует требованиям. Они помогают находить ошибки и дефекты в коде, предотвращают нежелательные изменения в будущем и улучшают качество и устойчивость программы."
}
,{
  question: "Рассказать что такое Unit тесты?",
  answer: "Unit-тесты - это автоматизированные тесты, которые проверяют отдельные функции или модули программы. Они написаны для проверки конкретных аспектов кода, и их цель - обеспечить качество кода на уровне микроструктуры. Unit-тесты запускаются на машине разработчика и могут быть запущены несколько раз в процессе разработки, чтобы проверить корректность кода перед его публикацией."
}
,{
  question: "Зачем нужны модульные тесты?",
  answer: "Меньше времени на выполнение функциональных тестов. Функциональные тесты требуют большого количества ресурсов. Как правило, приходится открывать приложение и выполнять ряд действий, чтобы проверить ожидаемое поведение. Тест-инженеры не всегда знают, что это за действия, и им приходится обращаться к специалистам в этой области. Само тестирование может занимать несколько секунд, если это обычные изменения, или несколько минут для более масштабных изменений. Наконец, этот процесс необходимо повторять для каждого изменения, внесенного в систему.Модульные тесты, с другой стороны, занимают миллисекунды, выполняются простым нажатием кнопки и не обязательно требуют знаний о всей системе в целом. Успешность прохождения теста зависит от средства выполнения теста, а не от пользователя.Защита от регрессии. Дефекты регрессии вводятся при внесении изменений в приложение. Довольно часто тест-инженеры тестируют не только новую функцию, но и функции, существовавшие до этого, чтобы проверить, что эти функции по-прежнему работают должным образом. С модульным тестированием можно повторно запускать весь набор тестов после каждой сборки или даже после изменения строки кода. Это дает вам уверенность, что ваш новый код не нарушил существующие функциональные возможности.Исполняемая документация. Не всегда очевидно, что делает конкретный метод или как он себя ведет при определенных входных данных. Вы можете спросить себя: как поведет себя метод, если я передам ему пустую строку? А значение NULL? Если у вас есть набор модульных тестов с понятными именами, каждый тест сможет четко объяснить, какими будут выходные данные для определенных входных данных. Кроме того, он сможет проверить, что это действительно работает.Менее связанный код. Если код тесно связан, он плохо подходит для модульного тестирования. Без создания модульных тестов для кода это связывание может быть менее очевидным. Когда вы пишете тесты для кода, вы естественным образом разделяете его, иначе его будет сложнее тестировать."
}
,{
  question: "Какие характеристики хорошего модульного теста Вы знаете?",
  answer: "Быстрый. В хорошо разработанных проектах могут быть тысячи модульных тестов. Модульные тесты должны выполняться очень быстро. За миллисекунды.Изолированный. Модульные тесты являются автономными, могут выполняться изолированно и не имеют зависимостей от внешних факторов, таких как файловая система или база данных.Повторяемый. Запуски модульного теста должны иметь согласованные результаты, то есть всегда возвращать одинаковый результат, если вы не вносите никаких изменений между запусками.Самопроверяемый. Тест должен автоматически определять, пройден он или нет, без участия пользователя.Уместный. Время на написание модульного теста не должно значительно превышать время написания тестируемого кода. Если вам кажется, что тестирование кода занимает слишком много времени по сравнению с написанием кода, продумайте структуру, более подходящую для тестирования."
}
,{
  question: "Какие существуют шаблоны модульных тестов?",
  answer: "AAA (Arrange, Act, Assert) - хороший шаблон для написания модульных тестов. (входные данные, действие, ожидаемый результат). Один модульный тест должен тестировать что-то одно. Следовательно, каждый тест-кейс должен содержать только один AAA-набор. Тест-кейс не должен быть слишком большим (больше 10 строк кода), если он следует шаблону AAA.BDD-style (Given, When, Then)- использует три других ключевых слова для описания каждого тест-кейса: Given, When and Then. Подход 'given-when-then' почти аналогичен подходу 'arrange-act-assert'. Они оба просто определяют переход из одного состояния в другое в Конечном Автомате (Finite State Machine, FSM).Отличия AAA и BDD-style:<br>BDD-style смотрит на модуль как-бы 'снаружи', т.е фокусируется на его внешнем поведении<br>Используя BDD, вы должны определить язык предметной области (domain specific language, DSL) при написании ваших тестовых спецификаций. Из-за этого, обычно требуется использовать другой фреймворк."
}
,{
  question: "Какие виды тестов существют?",
  answer: "Существует несколько видов тестов, включая:Unit-тесты: тесты, которые проверяют отдельные функции или модули программы.Интеграционные тесты: тесты, которые проверяют взаимодействие между различными модулями программы.Функциональные тесты: тесты, которые проверяют, что программа работает согласно требованиям пользователей.Тесты надежности: тесты, которые проверяют устойчивость и надежность программы при наличии искажений или исключений.Тесты производительности: тесты, которые измеряют время выполнения и ресурсы, используемые программой.Тесты удобства использования: тесты, которые проверяют удобство использования программы для пользователей."
}
,{
  question: "Что такое Mock?",
  answer: "Mock (от англ. 'имитация') - это виртуальный объект, который создается для подделки реальных объектов в целях тестирования. Он может имитировать поведение реального объекта, позволяя тестировщикам испытывать сложные условия или исключения, которые невозможно повторить в реальной среде.Mock-объекты часто используются в тестах Unit, чтобы исключить влияние других компонентов программы и независимо проверять поведение отдельных функций или модулей."
}
,{
  question: "Рассказать отличия dummy / fake / stub / mock объектов.",
  answer: "Dummy, Fake, Stub, и Mock - это различные типы тестовых объектов, которые используются для реализации различных сценариев тестирования.<br>Dummy-объекты: это пустые объекты, которые используются для заполнения места, где необходимо передать аргумент, но на результат тестирования они не влияют.Fake-объекты: это объекты, которые имитируют реальные объекты, но не являются их частным случаем. Они используются в целях ускорения тестирования или предотвращения влияния других компонентов на результаты тестирования.Stub-объекты: это простые объекты, которые имитируют поведение реальных объектов в ограниченном объеме. Они используются для проверки определенных входных данных или предоставления ожидаемых результаMock (от англ. 'имитация') - это виртуальный объект, который создается для подделки реальных объектов в целях тестирования. Он может имитировать поведение реального объекта, позволяя тестировщикам испытывать сложные условия или исключения, которые невозможно повторить в реальной среде."
}
,{
  question: "Чем stub отличается от mock?",
  answer: "stub используется как заглушка сервисов, методов, классов и т.д. с заранее запрограммированным ответом на вызовы.mock использует подмену результатов вызова, проверяет сам факт взаимодействия, протоколирует и контролирует его."
}
,{
  question: "Что такое пирамида тестов",
  answer: "Пирамида тестирования - это метафорический термин, используемый для описания соотношения между различными уровнями тестирования в проекте ПО. В соответствии с этой метафорой, уровень тестирования снижается с верхней части пирамиды к нижней, что соответствует увеличению числа тестов и усложнению их сценариев.Обычно пирамида тестирования состоит из трех уровней:Модульные (Unit) тесты: на этом уровне проверяются отдельные модули или компоненты ПО.Интеграционные тесты: на этом уровне проверяется работа нескольких модулей или компонентов вместе.Тесты пользовательского интерфейса. : тесты, которые проверяют удобство использования программы для пользователей."
}
,{
  question: "Что такое «модульное тестирование»?",
  answer: "'Модульное тестирование' (Unit Testing) - это тип тестирования, который предназначен для проверки отдельных модулей или компонентов программного обеспечения. Целью модульного тестирования является выявление ошибок и дефектов в ранних стадиях разработки, что позволяет ускорить процесс исправления и улучшить качество программного обеспечения. Модульные тесты пишутся параллельно с разработкой кода и запускаются перед каждым коммитом, чтобы обеспечить, что новый код не нарушит работу существующего."
}
,{
  question: "Что такое «интеграционное тестирование»?",
  answer: "'Интеграционное тестирование' (Integration Testing) - это тип тестирования, который предназначен для проверки работы нескольких модулей или компонентов программного обеспечения вместе. Целью интеграционного тестирования является выявление конфликтов между модулями или компонентами, а также проверка работы системы в целом. Интеграционные тесты запускаются после проведения модульных тестов и позволяют выявить проблемы, которые могут возникнуть в ходе интеграции модулей."
}
,{
  question: "Чем интеграционное тестирование отличается от модульного?",
  answer: "'Модульное тестирование' (Unit Testing) и 'Интеграционное тестирование' (Integration Testing) являются разными типами тестирования, которые следует использовать в разных целях.<br>'Модульное тестирование' заключается в тестировании отдельных модулей или компонентов программного обеспечения, таких как функции, классы или методы. Модульные тесты запускаются на этапе разработки и помогают выявить проблемы с реализацией кода.'Интеграционное тестирование' представляет собой проверку работы нескольких модулей или компонентов вместе, то есть проверяется совместная работа компонентов программы. Интеграционные тесты запускаются после проведения модульных тестов и позволяют выявить проблемы, которые могут возникнуть в ходе интеграции модулей."
}
,{
  question: "Для чего в JUnit используется аннотация @Ignore?",
  answer: "Аннотация JUnit @Ignore используется для указания того, что конкретный метод тестирования следует игнорировать и не выполнять. Это может быть полезно, когда тест временно отключен, или если ожидается его сбой, или если тест больше не актуален или не применим к текущему коду. Пометив тест @Ignore, исполнитель тестов может пропустить его и не сообщать о нем как о сбое."
}
,{
  question: "Покрытие тестами функции: func element(by index: Int) -> Element",
  answer: "Чтобы иметь хорошее тестовое покрытие для func element(by index: Int), вам необходимо написать тесты, которые охватывают различные сценарии и условия, с которыми функция может столкнуться в производственной среде. Вот несколько примеров сценариев, которые следует учитывать при написании тестов для этой функции:<br>@Service<br>public class ListService {<br>private final List<Integer> list;<br>public ListService() {<br>this.list = new ArrayList<>();<br>}<br>public void add(Integer integer){<br>list.add(integer);<br>}<br>public Integer element(Integer id){<br>return list.get(id);<br>}<br>}<br>Тест на нормальную работу: этот тестовый пример должен убедиться, что функция возвращает правильный объект Element для допустимого индекса.<br>@Test<br>void testInList(){<br>listService.add(1);<br>assertEquals(1, listService.element(0));<br>}<br>Проверка индекса вне допустимого диапазона. Этот тестовый пример должен убедиться, что функция возвращает ошибку или выдает исключение, когда индекс отрицательный или превышает количество элементов в коллекции.<br>@Test<br>void testOutOfList(){<br>listService.add(1);<br>assertThrows(IndexOutOfBoundsException.class, () -> listService.element(1));<br>}<br>Тест на пустую коллекцию: этот тестовый пример должен убедиться, что функция возвращает ошибку или выдает исключение, когда коллекция пуста.<br>@Test<br>void testNoneList(){<br>assertThrows(IndexOutOfBoundsException.class, () -> listService.element(0));<br>}<br>Это всего лишь примеры, и конкретные тестовые случаи будут зависеть от требований и поведения func element(by index: Int). Цель состоит в том, чтобы написать тесты, охватывающие как можно больше различных сценариев, чтобы повысить уверенность в правильности кода."
}
,{
  question: "Какой тип/вид класс тестирования имеет смысл автоматизировать?",
  answer: "Регрессионное тестирование - Этот вид тестирования автоматизируют чаще всего, что неудивительно, ведь автоматизация в данном случае избавляет тестировщика от многократного выполнения одинаковых тест-кейсов перед каждым релизом. Как правило, сценарии автоматизированных регрессионных тестов разрабатываются на основании ручных тестов, которые уже показали свою эффективность путем выявления дефектов. Наибольшей эффективности при автоматизации регрессионного тестирования удается достичь, если речь идет о сервисах, требующих регулярного внесения изменений.Кроссбраузерное и кроссплатформенное тестирование - Автоматизация способна повысить эффективность и таких видов тестирования, как кроссплатформенное и кроссбраузерное. Тут все просто: одинаковые сценарии автоматизированных тестов используют на разных платформах.Тестирование локализации - Такое тестирование бывает весьма трудоемким для ручного исследования. К примеру, если мы тестируем сайт с десятками версий на различных языках, мы проверяем адаптацию элементов интерфейса, перевод текста и т. д. Наша задача — получить информацию о том, не привела ли локализация к появлению дефектов. В данном случае автоматизация позволит протестировать нужные аспекты с меньшей затратой времени.Исследование производительности, нагрузочное и стресс-тестирование - В наше время performance testing (исследование производительности), а также нагрузочное тестирование и стресс-тестирование почти всегда автоматизируются. Существует ряд инструментов для автоматизации (JMeter, Gatling, Tsung), позволяющих воспроизводить разные условия, в том числе и 'на грани фола', то есть условия, которые могут вызвать проблемы с производительностью программного приложения. Используя автоматизированные тесты, вы смоделируете нехватку оперативной памяти и другие ситуации, ну и, что немаловажно, сможете зафиксировать реакцию программного обеспечения на эти ситуации."
}
,{
  question: "Что такое «фикстуры»?",
  answer: "Фикстура (Fixture) - состояние среды тестирования, которое требуется для успешного выполнения тестового метода. Может быть представлено набором каких-либо объектов, состоянием базы данных, наличием определенных файлов, соединений и прочее."
}
,{
  question: "Какие аннотации фикстур существуют в JUnit?",
  answer: "@BeforeClass в JUnit4 / @BeforeAll в JUnit5 - определяет код, который должен единожды выполниться перед запуском набора тестовых методов.<br>@AfterClass в JUnit4 / @AfterAll в JUnit5 - код, выполняемый один раз после исполнения набора тестовых методов.<br>@Before в JUnit4 / @BeforeEach в JUnit5 - определяет код, который должен выполняться каждый раз перед запуском любого тестовым методом.<br>@After в JUnit4 / @AfterEach в JUnit5 - код, выполняемый каждый раз после исполнения любого тестового метода."
}
,{
  question: "Опишите подход Test-Driven Development",
  answer: "Test-driven development(TDD, Разработка через тестирование) - это стиль разработки, в котором развитие системы определяется тестами в коротких циклах:Написать один тест.Написать только лишь необходимое количество кода, чтобы тест проходил.Провести рефакторинг кода, чтобы сделать его 'чистым'.В языках программирования, таких как Java, такие циклы занимают не более пяти минут. В старых языках, с медленной компиляцией и меньшей поддержкой автоматизации рефакторинга, такой цикл занимает больше времени - около 20 минут."
}
,
    ];

    const questionText = document.getElementById('question-text');
    const answerText = document.getElementById('answer-text');
    const modal = document.getElementById('modal');
    const modalAnswer = document.getElementById('modal-answer');

    function toggleAnswer() {
        const answer = questions[currentQuestionIndex].answer;
        if (answer.length > MAX_ANSWER_LENGTH) {
            showModal(answer);
        } else {
            if (answerText.classList.contains('hidden')) {
                answerText.innerHTML = answer;
                answerText.classList.remove('hidden');
                questionText.classList.add('hidden');
            } else {
                answerText.classList.add('hidden');
                questionText.classList.remove('hidden');
            }
        }
    }

    function showModal(answer) {
        modalAnswer.innerHTML = answer;
        modal.classList.remove('hidden');
    }

    function showQuestion(index) {
        questionText.textContent = questions[index].question;
        answerText.innerHTML = ""; // Скрываем ответ при смене вопроса
        questionText.classList.remove('hidden');
        answerText.classList.add('hidden');
    }

    function nextQuestion() {
        if (currentQuestionIndex < questions.length - 1) {
            currentQuestionIndex++;
            showQuestion(currentQuestionIndex);
        }
    }

    function prevQuestion() {
        if (currentQuestionIndex > 0) {
            currentQuestionIndex--;
            showQuestion(currentQuestionIndex);
        }
    }

    function closeModal() {
        modal.classList.add('hidden');
    }

    showQuestion(currentQuestionIndex);
</script>

</body>
</html>
