1)Что такое MongoDb?

MongoDB — это мощная, гибкая и масштабируемая база данных, которая относится к категории NoSQL (нереляционных баз данных). В отличие от традиционных реляционных баз данных, таких как MySQL или PostgreSQL, MongoDB использует модель документов, где данные хранятся в формате BSON (Binary JSON), а не в виде таблиц.

--------------------------------------------------------------------------------------------------------------------
2)Как в MongoDb организуются данные?

документ представляет собой основную единицу данных в MongoDB и приблизительно эквивалентен строке в реляционной системе
управления базами данных (но гораздо более выразителен);

аналогично коллекцию можно рассматривать как таблицу с динамической схемой;

один экземпляр MongoDB может содержать несколько независимых баз данных, каждая из которых содержит свои собственные коллекции;

--------------------------------------------------------------------------------------------------------------------
3)Что такое _id?

Это уникальный идентификатор в рамках коллекции, который создаётся автоматически базой.

--------------------------------------------------------------------------------------------------------------------
4)Какие типы данных есть в MongoDB?

В MongoDB существуют следующие типы данных:

Строка
Число
Число с точкой
Массив
Дата
Boolean

--------------------------------------------------------------------------------------------------------------------
5)Как можно выбирать данные?

В MongoDB можно выбирать данные с помощью команд:

db.c.find({},{})

и

db.c.findOne({},{})

В первом объекте мы передаём те поля по которым будет производится поиск:

db.c.find({name:"12345"})

--------------------------------------------------------------------------------------------------------------------
6)Опишите основные опции поиска.

В методах

db.c.find({},{})

и

db.c.findOne({},{})

Есть второй объект, который мы передаём, и там мы указываем, какие поля мы хотим видеть в результате:

db.c.find({},{name:true})

Значением может быть и число(0, 1) и значение boolean(true, false), лучше boolean, тк это более наглядно

--------------------------------------------------------------------------------------------------------------------
7)Как можно вставлять данные?

Вставка – основной метод добавления данных в MongoDB. Чтобы вставить один документ, используйте метод коллекции insertOne:

db.movies.insertOne({"title" : "Stand by Me"})

insertOne добавит в документ ключ "_id" (если вы его не предоставили) и сохранит документ в MongoDB

Если вам нужно вставить несколько документов в коллекцию, можно использовать метод insertMany. Этот метод позволяет передавать массив документов в базу данных, что гораздо более эффективно, потому что ваш код не будет бегать в базу данных и обратно ради каждого документа, а вставит их все сразу.

db.movies.insertMany([
... {"_id" : 0, "title" : "Top Gun"},
... {"_id" : 1, "title" : "Back to the Future"},
... {"_id" : 2, "title" : "Gremlins"},
... {"_id" : 3, "title" : "Aliens"}])

--------------------------------------------------------------------------------------------------------------------
8)Как можно изменять данные?

После сохранения документа в базе данных его можно изменить с помощью одного из нескольких методов обновления: updateOne, updateMany и replaceOne. Методы updateOne и updateMany принимают документ фильтра
в качестве первого параметра и документ модификатора, описывающий изменения, которые необходимо внести, в качестве второго параметра.
Метод replaceOne также принимает фильтр в качестве первого параметра, а в качестве второго параметра ожидает документ, которым он заменит
документ, соответствующий фильтру.
Обновление документа является атомарным: если два обновления происходят одновременно, будет применено то из них, которое достигнет сервера первым, а затем будет применено следующее.

db.analytics.updateOne({"url" : "www.example.com"})

db.analytics.updateMany({"url" : "www.example.com"})

--------------------------------------------------------------------------------------------------------------------
9)Опишите основные опции изменения.

$inc - увеличение значения на 1

db.analytics.updateOne({"url" : "www.example.com"},
... {"$inc" : {"pageviews" : 1}})

Модификатор "$set" устанавливает значение поля. Если поле еще не существует, оно будет создано.

db.users.updateOne({"_id" : ObjectId("4b253b067525f35f94b60a31")},
... {"$set" : {"favorite book" : "War and Peace"}})

Добавление элементов. Оператор "$push" добавляет элементы в конец массива, если массив существует, и создает новый массив, если его нет.

Вы можете сдвинуть несколько значений за одну операцию, используя модификатор "$each" для оператора "$push"

db.stock.ticker.updateOne({"_id" : "GOOG"},
... {"$push" : {"hourly" : {"$each" : [562.776, 562.790, 559.123]}}})

Если вы хотите, чтобы массив увеличивался до определенной длины, вы можете использовать модификатор "$slice" с "$push", чтобы предотвратить рост массива выше определенного размера

db.movies.updateOne({"genre" : "horror"},
... {"$push" : {"top10" : {"$each" : ["Nightmare on Elm Street", "Saw"],
... "$slice" : -10}}})

Наконец, можно применять модификатор "$sort" к операциям с "$push"перед усечением:

db.movies.updateOne({"genre" : "horror"},
... {"$push" : {"top10" : {"$each" : [{"name" : "Nightmare on Elm Street",
... "rating" : 6.6},
... {"name" : "Saw", "rating" : 4.3}],
... "$slice" : -10,
... "$sort" : {"rating" : -1}}}})

$addToSet - добавить элемент в массив

db.users.updateOne({"_id" : ObjectId("4b2d75476cc613d5ee930164")},
... {"$addToSet" : {"emails" : "joe@gmail.com"}})

Если вы хотите рассматривать массив как очередь или стек,
можно использовать оператор "$pop", который может удалять элементы с
любого конца. {"$pop" : {"key" : 1}} удаляет элемент из конца массива.
{"$pop" : {"key" : -1}} удаляет его с начала.

Оператор "$pull" используется для
удаления элементов массива, соответствующих заданным критериям.

--------------------------------------------------------------------------------------------------------------------
10)Логические операторы в MongoDb

$and: Выполняет операцию обновления, если все указанные условия истинны.

db.collection.updateMany(
{ $and: [ { status: "active" }, { quantity: { $gt: 0 } } ] },
{ $set: { inStock: true } }
)
$or: Выполняет операцию обновления, если хотя бы одно из указанных условий истинно.

db.collection.updateMany(
{ $or: [ { status: "active" }, { quantity: { $gt: 10 } } ] },
{ $set: { promotion: true } }
)
$not: Выполняет операцию обновления, если указанное условие не истинно.

db.collection.updateMany(
{ price: { $not: { $gt: 100 } } },
{ $set: { discounted: true } }
)
$nor: Выполняет операцию обновления, если ни одно из указанных условий не истинно.

db.collection.updateMany(
{ $nor: [ { status: "inactive" }, { quantity: { $lte: 0 } } ] },
{ $set: { visible: true } }
)
$exists: Выполняет операцию обновления, если указанное поле существует (или не существует, в зависимости от значения).

db.collection.updateMany(
{ tags: { $exists: false } },
{ $set: { tags: [] } }
)

$ne: Выполняет операцию обновления, если значение поля не равно указанному значению.

db.collection.updateMany(
{ price: { $ne: 0 } },
{ $set: { available: true } }
)
$eq: Выполняет операцию обновления, если значение поля равно указанному значению. Обратите внимание, что это оператор по умолчанию, если не указан другой оператор сравнения.

db.collection.updateMany(
{ status: { $eq: "active" } },
{ $set: { available: true } }
)
$gt: Выполняет операцию обновления, если значение поля больше указанного значения.

db.collection.updateMany(
{ quantity: { $gt: 100 } },
{ $set: { inStock: true } }
)
$gte: Выполняет операцию обновления, если значение поля больше или равно указанному значению.

db.collection.updateMany(
{ quantity: { $gte: 50 } },
{ $set: { inStock: true } }
)
$lt: Выполняет операцию обновления, если значение поля меньше указанного значения.

db.collection.updateMany(
{ price: { $lt: 10 } },
{ $set: { cheap: true } }
)
$lte: Выполняет операцию обновления, если значение поля меньше или равно указанному значению.

db.collection.updateMany(
{ price: { $lte: 20 } },
{ $set: { affordable: true } }
)
--------------------------------------------------------------------------------------------------------------------
11)Как можно удалять данны?

Теперь, когда в нашей базе данных есть данные, давайте удалим их. Для этой цели CRUD API предоставляет методы deleteOne и deleteMany. Оба этих метода принимают документ фильтра в качестве первого параметра.
Фильтр задает набор критериев для сопоставления при удалении документов.

db.movies.deleteOne({"_id" : 4})

db.movies.deleteMany({"year" : 1984})

Удаление документов обычно является довольно быстрой операцией. Однако если вы хотите очистить всю коллекцию, ее быстрее удалить с помощью метода drop:

db.movies.drop()

--------------------------------------------------------------------------------------------------------------------
12)Что такое курсоры в MongoDb?

База данных возвращает результаты из метода find, используя курсор.
Реализация курсоров на стороне клиента, как правило, позволяет в значительной степени контролировать конечный результат запроса. Вы можете ограничить количество результатов, пропустить некоторое количество
результатов, отсортировать результаты по любой комбинации клавиш в
любом направлении и выполнить ряд других мощных операций.

--------------------------------------------------------------------------------------------------------------------
13)Опишите дополнительные ограничения в поиске в MongoDB.

Наиболее распространенные параметры запроса – ограничение количества возвращаемых результатов, пропуск количества результатов и сортировка. Все эти параметры должны быть добавлены до отправки запроса
в базу данных

Чтобы установить предел, включите в свой вызов метода find функцию
limit. Например, чтобы вернуть только три результата, используйте это

db.c.find().limit(3)

Если в коллекции меньше трех документов, соответствующих вашему запросу, будет возвращено только количество совпадающих документов; 
функция limit устанавливает верхний предел, а не нижний.
Функция skip работает похожим образом:

db.c.find().skip(3)

Функция sort принимает объект: набор пар типа «ключ/значение», где
ключи – это имена ключей, а значения – направления сортировки. Направление сортировки может быть 1 (по возрастанию) или –1 (по убыванию).

db.c.find().sort({username : 1, age : -1})

--------------------------------------------------------------------------------------------------------------------
14)Что такое индексы в MongoDb?

Индекс базы данных похож на указатель книги. Вместо того чтобы просматривать всю книгу, СУБД использует ярлык и просто просматривает упорядоченный список со ссылками на содержимое. Это позволяет MongoDB выполнять запросы на порядок быстрее.
Запрос, который не использует индекс, называется сканированием коллекции. Это означает, что сервер должен «просмотреть всю книгу», чтобы найти результаты запроса. Этот процесс в основном представляет собой
то, что вы делали бы, если бы искали информацию в книге, где нет оглавления: вы бы начали с первой страницы и прочитали все это целиком.
В целом не нужно заставлять сервер выполнять сканирование коллекций, поскольку в случае с большими коллекциями этот процесс будет очень медленным

--------------------------------------------------------------------------------------------------------------------
15)Как создать индексы?

Теперь давайте попробуем создать индекс по полю "username". Для создания индекса мы будем использовать метод коллекции createIndex(1 - asc, -1 - desc):

db.users.createIndex({"username" : 1})

Также можно создавать составные индексы

db.users.createIndex({"age" : 1, "username" : 1})

Мы могли бы поместить индекс в одно из вложенных полей "loc", скажем "loc.city", чтобы ускорить запросы, использующие это поле:
db.users.createIndex({"loc.city" : 1})

Вы также можете индексировать массивы, что позволяет использовать
индекс для эффективного поиска определенных элементов массива.

db.blog.createIndex({"comments.date" : 1})

--------------------------------------------------------------------------------------------------------------------
16)Как MongoDB выбирает индекс?

Представим, что у нас есть пять индексов. Когда приходит запрос, MongoDB смотрит на форму запроса. Форма связана с тем, в каких полях производится поиск, и дополнительной информацией, такой как наличие или отсутствие сортировки. Основываясь на этой информации,
система идентифицирует набор индексов-кандидатов, которые она может использовать при удовлетворении запроса
Предположим, мы получили запрос, и три из пяти наших индексов определены как кандидаты на этот запрос. Затем MongoDB создаст три плана
запросов, по одному для каждого из этих индексов, и выполнит запрос в трех параллельных потоках, каждый из которых использует свой индекс.
Задача состоит в том, чтобы увидеть, какой из них способен быстрее вернуть результаты.
Визуально можно рассматривать это как гонку, как показано на рис. 5.1. Идея заключается в том, что первым планом выполнения запроса для
достижения целевого состояния является победитель. Но что еще более важно, в дальнейшем он будет выбран в качестве индекса для запросов,
которые имеют ту же форму запроса. Планы состязаются друг с другом на протяжении некоего периода (называемого пробным периодом), после которого результаты каждой гонки используются для расчета общего плана выигрыша.

--------------------------------------------------------------------------------------------------------------------
17)Типы индексов

Уникальные индексы гарантируют, что каждое значение будет отображаться в индексе не более одного раза.

db.users.createIndex({"firstname": 1},
... {"unique": true,"partialFilterExpression": {
"firstname": {$exists: true } } }

Частичные индексы - Если у вас есть поле, которое может или не может существовать, но должно быть уникальным, когда оно существует, можно сочетать параметры «unique" и "partial".

db.users.ensureIndex({"email" : 1}, {"unique" : true, "partialFilterExpression" :
... { email: { $exists: true } }})

Текстовый индекс

db.blog.createIndex({"post" : "text"})

--------------------------------------------------------------------------------------------------------------------
18)Какая команда позволит посмотреть запрос в MongoDb?

сли мы выполняем запрос к этой коллекции, то можем использовать
команду explain, чтобы увидеть, что делает MongoDB при выполнении запроса. Предпочтительнее использовать команду explain через вспомогательный метод курсора, который обертывает эту команду. Метод курсора
explain предоставляет информацию о выполнении различных CRUD-операций. Этот метод может быть запущен в нескольких режимах детализации. Мы рассмотрим режим executionStats, поскольку это помогает нам
понять эффект использования индекса для удовлетворения запросов.

db.users.find({"username": "user101"}).explain("executionStats")

--------------------------------------------------------------------------------------------------------------------
19)Что такое aggregate в MongoDb?

Фреймворк агрегации представляет собой набор аналитических инструментов, которые позволяют работать с документами в одной или нескольких коллекциях.
Он основан на концепции конвейера. С помощью конвейера агрегации
мы берем входные данные из коллекции MongoDB и пропускаем документы из этой коллекции через один или несколько этапов, каждый из которых выполняет свою операцию (рис. 7.1). Каждый этап рассматривается в
качестве входных данных, независимо от этапа, прежде чем будут созданы
выходные данные. Входные и выходные данные всех этапов – это документы, поток документов, если хотите.

aggregate- Это метод, который мы вызываем, когда хотим выполнить запрос на агрегацию.
Для того чтобы осуществить агрегацию, мы переходим в конвейер агрегации. Конвейер – это массив с документами в качестве элементов.

--------------------------------------------------------------------------------------------------------------------
20)Опишите основные дополнения aggregate.

$match - фильтрация

db.companies.aggregate([
{$match: {founded_year: 2004}},
])

$project - уменьшает выдаваемый объект до тех полей, которые мы указали

db.companies.aggregate([
{$match: {founded_year: 2004}},
{$project: {
_id: 0,
name: 1,
founded_year: 1
}
}
])

$limit - уменьшает количество объектов до этого значения.

$sort - сортировка

$skip - пропуск значений

При работе с полями массива в конвейере агрегации часто возникает необходимость использовать один или несколько этапов с использованием
оператора $unwind. Это позволяет нам производить вывод таким образом,
что для каждого элемента в указанном поле массива имеется один выходной документ.

db.companies.aggregate([
{ $match: { "funding_rounds.investments.financial_org.permalink":
"greylock" } },
{ $unwind: "$funding_rounds"
},
{ $project: {
_id: 0,
name: 1,
amount: "$funding_rounds.raised_amount",
year: "$funding_rounds.funded_year"
}
}
])

$filter: в $project - Оператор $filter предназначен для работы с полями массива и определяет параметры, которые
мы должны предоставить.

db.companies.aggregate([
{ $match: { "funding_rounds.investments.financial_org.permalink": "greylock" } },
{ $project: {
_id: 0,
name: 1,
founded_year: 1,
rounds: { $filter: {
input: "$funding_rounds",
as: "round",
cond: { $gte: [
"$$round.raised_amount",
100000000 ]
}
}
}
}
},
{ $match: { "rounds.investments.financial_org.permalink": "greylock" } },
]).pretty()

Оператор $arrayElemAt позволяет выбрать элемент в определенной ячейке массива

db.companies.aggregate([
{ $match: { "founded_year": 2010 } },
{ $project: {
_id: 0,
name: 1,
founded_year: 1,
first_round: { $arrayElemAt: [ "$funding_rounds", 0 ] },
last_round: { $arrayElemAt: [ "$funding_rounds", -1 ] }
} }
]).pretty()

$group: - группировка 

b.companies.aggregate([
{ $group: {
_id: { founded_year: "$founded_year" },
average_number_of_employees: { $avg: "$number_of_employees" }
} }])

--------------------------------------------------------------------------------------------------------------------
21)Что такое шардинг?

Шардинг обозначает процесс распределения данных по разным серверам;
для описания этой концепции также иногда используется термин разделение. Размещая подмножество данных на каждой машине, становится возможным хранить больше данных и обрабатывать б?льшую нагрузку, без
необходимости наличия больших или более мощных машин – достаточно
просто б?льшего количества менее мощных компьютеров.


--------------------------------------------------------------------------------------------------------------------
22)Как добавить шардинг в MongoDb 

sh.enableSharding("accounts")

sh.shardCollection("accounts.users", {"username" : 1})

--------------------------------------------------------------------------------------------------------------------
23)Преимущества MongoDB над Реляционными базами

MongoDB предлагает несколько преимуществ перед реляционными базами данных:

Гибкая схема данных: MongoDB использует гибкую схему данных в формате JSON-подобных документов, что позволяет легко изменять структуру данных без необходимости изменения схемы базы данных.

Горизонтальное масштабирование: MongoDB обеспечивает возможность горизонтального масштабирования, что позволяет расширять базу данных по мере роста нагрузки, добавляя новые узлы в кластер.

Высокая производительность: MongoDB обеспечивает высокую производительность при обработке больших объемов данных благодаря использованию денормализации данных и индексации.

Поддержка гибридных структур данных: MongoDB позволяет хранить сложные структуры данных, включая вложенные документы и массивы, что упрощает моделирование данных с использованием объектно-ориентированного подхода.

Гибкий язык запросов: MongoDB предоставляет мощный язык запросов, включая возможность использования агрегаций, индексов и геопространственных запросов для эффективного извлечения данных.

Поддержка многих языков программирования: MongoDB имеет богатое экосистемное сообщество и поддерживает множество языков программирования, что делает его легко интегрируемым с различными технологиями и платформами.

--------------------------------------------------------------------------------------------------------------------