# Глава 1. Введение
---

## 1. Базы данных и кластеры

### Основы

- **PostgreSQL** — это СУБД, которая при запуске работает как сервер (экземпляр сервера). Сервер управляет **кластером баз данных** —
  набором нескольких баз данных, которые хранятся в одном каталоге, называемом **PGDATA**.
- **PGDATA** — это каталог файловой системы, содержащий все данные кластера (таблицы, индексы, конфигурации). Он задается переменной
  окружения **PGDATA** или параметрами при запуске сервера.
- Перед использованием кластер должен быть **инициализирован** с помощью утилиты `initdb`, которая создает структуру каталогов и базовые
  файлы.

### Базы данных по умолчанию

При инициализации кластера создаются три базы данных:

1. **template0**:
    - Используется для восстановления из логических резервных копий или создания баз с другой кодировкой.
    - Не подлежит изменениям, чтобы сохранить чистую копию начального состояния.
    - Пример использования: создание базы с кодировкой, отличной от кластера (`CREATE DATABASE newdb TEMPLATE template0 ENCODING 'UTF8';`).
2. **template1**:
    - Служит шаблоном для новых баз данных, создаваемых командой `CREATE DATABASE`.
    - Может быть модифицирована пользователем для добавления стандартных объектов (таблиц, функций и т.д.) в новые базы.
    - Пример: добавление таблицы в `template1` делает её доступной во всех новых базах.
3. **postgres**:
    - Обычная база данных для общего использования.
    - Подходит для хранения пользовательских данных, если не требуется создание специализированных баз.

### Кластер баз данных

- Один экземпляр PostgreSQL управляет несколькими базами одновременно, образующими кластер.
- Каждая база изолирована: объекты (таблицы, схемы) в одной базе не видны в другой, если не настроено иное.
- Пример структуры кластера:
  ```
  PGDATA/
  --- base/         # Каталог для баз данных
  ------ 16384/    # Каталог для базы postgres (OID=16384)
  ------ 1/        # Каталог для template1
  ------ 2/        # Каталог для template0
  --- global/       # Общие объекты кластера
  --- pg_tblspc/    # Символьные ссылки на табличные пространства
  ```

---

## 2. Системный каталог

### Описание

- **Системный каталог** — это набор таблиц и представлений, хранящих метаданные обо всех объектах кластера: базах данных, таблицах,
  индексах, типах, функциях и т.д.
- Каждая база данных имеет собственный системный каталог, описывающий её объекты. Также существуют общие таблицы кластера, доступные из
  любой базы (формально хранятся в базе с OID=0).

### Структура

- Таблицы системного каталога имеют префикс **pg_** (например, `pg_database`, `pg_class`, `pg_attribute`).
- Столбцы в этих таблицах начинаются с трехбуквенного кода, соответствующего имени таблицы (например, `datname` в `pg_database` для имени
  базы).
- Первичный ключ — столбец **oid** (тип `oid`, 32-битное целое число), уникально идентифицирующий объект.
- Пример: запрос для получения списка баз данных:
  ```sql
  SELECT oid, datname FROM pg_database;
  ```

### Механизм OID

- **OID** (Object Identifier) — это уникальный идентификатор, генерируемый единым счетчиком для всех объектов кластера.
- Особенности:
    - Используется в разных таблицах системного каталога.
    - Если диапазон значений (2??) исчерпан, счетчик обнуляется, а уникальность проверяется индексами.
    - Пример: таблица `pg_class` хранит `oid` для каждой таблицы или индекса.
- Запрос для проверки OID таблицы:
  ```sql
  SELECT oid, relname FROM pg_class WHERE relname = 'my_table';
  ```

### Доступ

- К системному каталогу можно обращаться через SQL-запросы.
- В клиенте `psql` доступны специальные команды, такие как `\dt` (список таблиц) или `\d` (описание объекта), которые упрощают просмотр
  метаданных.
- Пример: просмотр структуры таблицы `pg_database`:
  ```sql
  \d pg_database
  ```

---

## 3. Схемы

### Определение

- **Схемы** — это пространства имен внутри базы данных, позволяющие группировать объекты (таблицы, индексы, функции).
- Схемы помогают организовать данные и избежать конфликтов имен.

### Основные схемы

1. **public**:
    - Используется по умолчанию для пользовательских объектов, если схема не указана.
    - Пример: `CREATE TABLE my_table (...)` создает таблицу в схеме `public`.
2. **pg_catalog**:
    - Хранит таблицы и представления системного каталога.
    - Всегда включена в путь поиска (`search_path`).
3. **information_schema**:
    - Предоставляет стандартизированное (SQL) представление метаданных.
    - Пример: запрос списка таблиц:
      ```sql
      SELECT table_name FROM information_schema.tables WHERE table_schema = 'public';
      ```
4. **pg_toast**:
    - Используется для хранения данных, вынесенных по технологии TOAST (см. ниже).
5. **pg_temp**:
    - Содержит временные таблицы, создаваемые в схемах `pg_temp_N` для каждого пользователя.
    - Пример: временная таблица `temp_table` видна пользователю как `pg_temp.temp_table`.

### Путь поиска

- Параметр `search_path` определяет порядок поиска схем для объектов, если схема не указана явно.
- По умолчанию: `search_path = "$user", public`, где `"$user"` — схема с именем текущего пользователя.
- Схемы `pg_catalog` и `pg_temp` добавляются неявно.
- Пример настройки:
  ```sql
  SET search_path TO my_schema, public;
  ```

---

## 4. Табличные пространства

### Определение

- **Табличные пространства** — это физические каталоги в файловой системе, где хранятся данные базы.
- Позволяют разделять данные по типу носителей (например, медленные HDD для архивов, быстрые SSD для активных данных).

### По умолчанию

- **pg_default**:
    - Расположен в `PGDATA/base`.
    - Используется для объектов, если не указано иное.
- **pg_global**:
    - Расположен в `PGDATA/global`.
    - Хранит общие объекты системного каталога, доступные всему кластеру.

### Пользовательские табличные пространства

- Создаются с указанием каталога, на который в `PGDATA/pg_tblspc` создается символьная ссылка.
- Пример создания:
  ```sql
  CREATE TABLESPACE fast_space LOCATION '/mnt/fast_storage';
  ```
- Использование:
  ```sql
  CREATE TABLE my_table (id integer) TABLESPACE fast_space;
  ```

### Логическая и физическая структура

- Логическая структура (базы, схемы) независима от физической (табличные пространства).
- Одна база может использовать несколько табличных пространств, и одно пространство — несколько баз.

---

## 5. Отношения

### Определение

- **Отношения** — это объекты базы данных, состоящие из строк: таблицы, индексы, последовательности, материализованные представления.
- Термин происходит от реляционной теории, но в PostgreSQL охватывает больше объектов, чем классические таблицы.
- Хранятся в таблице `pg_class`, где столбцы начинаются с префикса `rel` (например, `relname`, `relfilenode`).

### Примеры

- **Таблицы**: хранят пользовательские данные.
- **Индексы**: содержат строки с индексированными значениями (например, B-дерево).
- **Последовательности**: однострочные таблицы для генерации уникальных чисел.
- **Материализованные представления**: хранят результат запроса как таблицу.
- Пример создания отношения:
  ```sql
  CREATE TABLE my_table (id integer, name text);
  SELECT relname, relkind FROM pg_class WHERE relname = 'my_table';
  -- relkind: 'r' (таблица)
  ```

---

## 6. Слои и файлы

### Слои

Каждое отношение делится на **слои** (forks), каждый из которых хранит определенный тип данных:

1. **Основной слой** (main fork):
    - Содержит данные таблицы или индекса.
    - Имя файла — числовой идентификатор (`relfilenode` из `pg_class`).
    - Пример: файл `16385` для таблицы с `relfilenode = 16385`.
2. **Карта свободного пространства** (free space map, `_fsm`):
    - Отслеживает свободное место на страницах для оптимизации вставки данных.
    - Создается после операций, таких как `VACUUM`.
    - Пример: файл `16385_fsm`.
3. **Карта видимости** (visibility map, `_vm`):
    - Хранит информацию о страницах, требующих очистки или заморозки.
    - Используется для ускорения `VACUUM` и индексного сканирования.
    - Пример: файл `16385_vm` (только для таблиц).
4. **Слой инициализации** (init fork, `_init`):
    - Создается для нежурналируемых таблиц (`UNLOGGED`) и их индексов.
    - Используется для восстановления пустого состояния после сбоя.
    - Пример: файл `16385_init`.

![img_3.png](img_3.png)

### Файлы

- Каждый слой представлен одним или несколькими файлами.
- Если файл превышает 1 ГБ, создается новый сегмент (например, `16385.1`, `16385.2`).
- Ограничение в 1 ГБ можно изменить при сборке PostgreSQL (`--with-segsize`).
- Файлы хранятся в подкаталогах табличных пространств, организованных по базам данных (например, `PGDATA/base/16384/` для базы с OID=16384).

### Пример

Создание и проверка файлов таблицы:

```sql
CREATE
UNLOGGED TABLE t (a integer, b numeric, c text, d json);
INSERT INTO t
VALUES (1, 2.0, 'foo', '{}');
SELECT pg_relation_filepath('t'); -- Вывод: base/16384/16385
SELECT size
FROM pg_stat_file('/usr/local/pgsql/data/base/16384/16385'); -- Размер основного слоя
VACUUM
t;
SELECT size
FROM pg_stat_file('/usr/local/pgsql/data/base/16384/16385_fsm'); -- Размер карты свободного пространства
```

---

## 7. Страницы

### Описание

- Файлы делятся на **страницы** (обычно 8 КБ) — минимальные единицы ввода-вывода.
- Размер страницы задается при сборке PostgreSQL (`--with-blocksize`, до 32 КБ).
- Страницы кэшируются в **буферном кэше** для ускорения доступа.

### Использование

- Алгоритмы PostgreSQL (например, `VACUUM`, вставка данных) ориентированы на работу со страницами.
- Пример: карта видимости использует 2 бита на страницу для отслеживания актуальности строк.

---

## 8. TOAST

### Определение

- **TOAST** (The Oversized Attributes Storage Technique) — технология для хранения длинных строк, которые не помещаются на одной странице (~
  2000 байт после вычета заголовка).
- Цель: обеспечить размещение строки на одной странице или вынести её части в отдельную таблицу.

### Стратегии

1. **plain**:
    - TOAST не используется (для коротких типов, например, `integer`).
2. **extended**:
    - Сначала сжатие, затем, если нужно, хранение в `pg_toast`.
3. **external**:
    - Хранение в `pg_toast` без сжатия (например, для JPEG).
4. **main**:
    - Сжатие, затем хранение в `pg_toast`, если сжатие не помогло.

### Алгоритм

1. Если строка превышает ~2000 байт, применяются стратегии `extended` и `external`:
    - Сжимаются атрибуты `extended`, выносятся в `pg_toast`, если всё ещё длинные.
    - Атрибуты `external` выносятся без сжатия.
2. Если строка всё ещё велика, сжимаются атрибуты `main`.
3. Если нужно, атрибуты `main` выносятся в `pg_toast`.

### TOAST-таблицы

- Создаются автоматически для таблиц с длинными типами (`text`, `json`, `numeric`).
- Хранятся в схеме `pg_toast` (или `pg_toast_temp_N` для временных таблиц).
- Структура: столбцы `chunk_id` (oid), `chunk_seq` (integer), `chunk_data` (bytea).
- Имеют индекс для быстрого доступа (например, `pg_toast_16385_index`).



### Сжатие

- Используются алгоритмы **PGLZ** (по умолчанию) или **LZ4** (более эффективный, с версии 15).
- Настройка: параметр `default_toast_compression` или `COMPRESSION` в `CREATE TABLE`.
- Пример изменения стратегии:
  ```sql
  ALTER TABLE t ALTER COLUMN c SET STORAGE external;
  ```

---

## 9. Процессы и память

### Процессы

- **Postmaster**:
    - Главный процесс, запускает и контролирует другие процессы.
    - Перезапускает процессы при сбоях.
- **Фоновые процессы**:
    - **startup**: восстанавливает данные после сбоев.
    - **autovacuum**: очищает устаревшие версии строк.
    - **wal writer**: записывает журнал предзаписи (WAL).
    - **checkpointer**: создает контрольные точки.
    - **writer**: записывает измененные страницы на диск.
    - **wal sender/receiver**: обеспечивают репликацию.
- **Backend**: обслуживает клиентские соединения.

### Память

- **Общая память**:
    - **Буферный кэш**: хранит страницы для ускорения ввода-вывода.
    - Другие буферы для оптимизации операций.
- **Журнал предзаписи (WAL)**:
    - Гарантирует согласованность данных при сбоях.
    - Записывает операции перед их применением.
- Двойное кэширование: PostgreSQL использует кэш операционной системы и собственный буферный кэш.

---

## 10. Клиент-серверный протокол

### Соединения

- **Postmaster** принимает клиентские подключения и создает процесс **backend** для каждого клиента.
- Проблемы большого числа соединений:
    - Высокое потребление памяти.
    - Затраты на установку соединений.
    - Снижение производительности из-за множества процессов.
- Решение: пулы соединений (например, **PgBouncer**, **Odyssey**).

### Протокол

- Реализуется через библиотеку **libpq** (или независимые реализации).
- Клиент подключается к базе под определенной ролью (пользователем).
- Аутентификация проверяет права доступа.
- SQL-запросы передаются в текстовом виде и обрабатываются backend-процессом.
- Пример подключения:
  ```sql
  psql -U username -d postgres
  ```

---

# Глава 2. Изоляция

---

## 2.1. Согласованность

### Основы

- **Согласованность** (consistency) — это корректность данных, обеспечиваемая реляционными СУБД. Она шире, чем **целостность** (integrity),
  которая поддерживается ограничениями, такими как `NOT NULL`, `UNIQUE`, `CHECK`, `FOREIGN KEY`.
- Ограничения целостности задаются на уровне базы данных, и СУБД гарантирует их соблюдение. Например:
  ```sql
  ALTER TABLE accounts ADD CONSTRAINT positive_balance CHECK (amount >= 0);
  ```
- Однако согласованность включает более сложные правила, которые не всегда можно выразить ограничениями (например, правила, охватывающие
  несколько таблиц). Такие правила контролируются приложением, и СУБД не знает о них.
- Пример: правило «сумма на всех счетах клиента не может быть отрицательной» сложно выразить как ограничение, но оно критично для
  согласованности.

### Роль СУБД

- Если приложение выполняет корректные операции, СУБД обеспечивает согласованность через **транзакции** — неделимые наборы операций,
  переводящие базу из одного корректного состояния в другое.
- **Пример с переводом денег**:
    - Правило: сумма денег на всех счетах не меняется при переводе.
    - Операции:
        1. `UPDATE accounts SET amount = amount - 100 WHERE id = 1;` (нарушение согласованности)
        2. `UPDATE accounts SET amount = amount + 100 WHERE id = 2;` (восстановление согласованности)
    - Если вторая операция не выполнится (например, из-за сбоя), согласованность нарушится. Транзакции решают эту проблему, гарантируя
      атомарность (все операции или ни одной).

### Проблема конкурентного выполнения

- Транзакции, корректные по отдельности, могут вести к некорректным результатам при одновременном (конкурентном) выполнении из-за
  перемешивания операций.
- **Аномалии одновременного выполнения** возникают, когда порядок операций разных транзакций нарушает согласованность.
- Пример аномалии: **грязное чтение** — чтение незафиксированных изменений другой транзакции, которые могут быть отменены.
- СУБД изолирует транзакции, чтобы результат конкурентного выполнения соответствовал какому-либо последовательному выполнению, минимизируя
  аномалии.

### ACID

- Согласованность связана с тремя свойствами транзакций из акронима **ACID**:
    - **Atomicity** (атомарность): все операции транзакции выполняются или ни одна.
    - **Consistency** (согласованность): база остается в корректном состоянии.
    - **Isolation** (изоляция): транзакции не мешают друг другу.
- **Durability** (долговечность) также связана: после сбоя система восстанавливает согласованность, удаляя изменения незафиксированных
  транзакций.

### Проблема полной изоляции

- Полная изоляция (отсутствие всех аномалий) сложна технически и снижает производительность, так как требует строгой синхронизации
  транзакций.
- На практике используются ослабленные уровни изоляции, допускающие некоторые аномалии, что перекладывает часть ответственности за
  согласованность на приложение.

---

## 2.2. Уровни изоляции и аномалии в стандарте SQL

### Уровни изоляции

Стандарт SQL определяет четыре уровня изоляции, различающиеся по допустимым аномалиям:

1. **Read Uncommitted**
2. **Read Committed**
3. **Repeatable Read**
4. **Serializable**

### Аномалии

1. **Потерянное обновление** (lost update):
    - Две транзакции читают одну строку, обновляют её, и вторая перезаписывает изменения первой.
    - Пример: две транзакции увеличивают баланс с 1000 ? на 100 ?, но итог — 1100 ? вместо 1200 ?.
    - Запрещено на всех уровнях изоляции.
2. **Грязное чтение** (dirty read):
    - Чтение незафиксированных изменений, которые могут быть отменены.
    - Пример: транзакция А переводит 100 ?, транзакция Б видит это до фиксации, но А откатывается.
    - Допустимо только на **Read Uncommitted**.
3. **Неповторяющееся чтение** (non-repeatable read):
    - Транзакция читает строку дважды, но между чтениями другая транзакция изменяет строку.
    - Пример: транзакция А проверяет баланс (1000 ?), транзакция Б уменьшает его до 0, и А продолжает с устаревшими данными.
    - Допустимо на **Read Uncommitted** и **Read Committed**.
4. **Фантомное чтение** (phantom read):
    - Транзакция читает набор строк по условию дважды, но между чтениями другая транзакция добавляет новые строки.
    - Пример: транзакция А проверяет количество счетов клиента (2), транзакция Б добавляет счёт, и А видит 3.
    - Допустимо на **Read Uncommitted**, **Read Committed**, **Repeatable Read**.
5. **Другие аномалии**:
    - Стандарт не перечисляет все возможные аномалии (например, несогласованное чтение).
    - **Serializable** устраняет все аномалии, включая неизвестные.

### Таблица аномалий

| Уровень изоляции | Потерянное обновление | Грязное чтение | Неповторяющееся чтение | Фантомное чтение | Другие аномалии |
|------------------|-----------------------|----------------|------------------------|------------------|-----------------|
| Read Uncommitted | —                     | Да             | Да                     | Да               | Да              |
| Read Committed   | —                     | —              | Да                     | Да               | Да              |
| Repeatable Read  | —                     | —              | —                      | Да               | Да              |
| Serializable     | —                     | —              | —                      | —                | —               |

### Почему эти аномалии?

- Выбор аномалий в стандарте исторический: в 1970–80-х годах теория баз данных отставала от практики.
- Уровни изоляции основаны на **двухфазном блокировании** (2PL):
    - Транзакция блокирует строки на чтение или запись.
    - Больше блокировок — выше изоляция, но ниже производительность.
    - **Read Uncommitted**: блокировки только на запись.
    - **Read Committed**: блокировки на чтение и запись для изменяемых строк.
    - **Repeatable Read**: блокировки на все читаемые и изменяемые строки.
    - **Serializable**: требует блокировки предикатов (условий), что сложно реализовать.
- Предикатные блокировки (для предотвращения фантомов) были предложены в 1976 году, но их практическая реализация ограничена.

---

## 2.3. Уровни изоляции в PostgreSQL

PostgreSQL использует **изоляцию на основе снимков** (Snapshot Isolation, SI) с многоверсионной моделью (MVCC), где строки хранятся в
нескольких версиях. Это отличается от стандартного подхода, основанного на блокировках, и обеспечивает более высокую производительность.

### Особенности

- **Снимок данных**: каждая транзакция видит согласованное состояние базы на момент начала (или первого запроса).
- **Многоверсионность**: разные версии строки сосуществуют, позволяя читать устаревшие данные без конфликтов.
- **Блокировки**: минимальны, только для одновременных изменений одной строки.
- **Read Uncommitted** в PostgreSQL работает как **Read Committed**, поэтому не рассматривается отдельно.
- Уровни изоляции:
    - **Read Committed**: допускает потерянное обновление, неповторяющееся и фантомное чтение, а также несогласованное чтение.
    - **Repeatable Read**: предотвращает все стандартные аномалии, но допускает несогласованную запись и аномалию только читающей
      транзакции.
    - **Serializable**: устраняет все аномалии, но с накладными расходами.

### Таблица аномалий в PostgreSQL

| Уровень изоляции | Потерянное обновление | Грязное чтение | Неповторяющееся чтение | Фантомное чтение | Другие аномалии |
|------------------|-----------------------|----------------|------------------------|------------------|-----------------|
| Read Committed   | Да                    | —              | Да                     | Да               | Да              |
| Repeatable Read  | —                     | —              | —                      | —                | Да              |
| Serializable     | —                     | —              | —                      | —                | —               |

## 2.4. Какой уровень изоляции использовать?

### Read Committed

- **Плюсы**:
    - По умолчанию, минимальные накладные расходы.
    - Нет ошибок сериализации, не требует повторов транзакций.
- **Минусы**:
    - Допускает множество аномалий (неповторяющееся чтение, фантомное чтение, несогласованное чтение, потерянное обновление).
    - Требует осторожного написания кода: использовать один SQL-оператор или блокировки.
    - Сложно тестировать и отлаживать аномалии.
- **Применение**: подходит для простых приложений, где аномалии редки или контролируются кодом.

### Repeatable Read

- **Плюсы**:
    - Устраняет стандартные аномалии (грязное, неповторяющееся, фантомное чтение).
    - Идеально для читающих транзакций (например, отчеты).
- **Минусы**:
    - Допускает несогласованную запись и аномалию читающей транзакции.
    - Пишущие транзакции требуют обработки ошибок сериализации.
- **Применение**: для читающих транзакций или приложений, где важна стабильность данных.

### Serializable

- **Плюсы**:
    - Устраняет все аномалии, упрощает разработку.
    - Требует только обработки ошибок сериализации.
- **Минусы**:
    - Накладные расходы на обнаружение аномалий.
    - Возможны ложноположительные ошибки, увеличивающие повторы.
    - Не работает на репликах, требует единообразного использования.
- **Применение**: для критически важных приложений, где согласованность приоритетна.

---

# 3 Страницы и версии строк в PostgreSQL

---

## 3.1. Структура страниц

### Основы

- **Страницы** — минимальные единицы ввода-вывода в PostgreSQL (обычно 8 КБ, задается при сборке параметром `--with-blocksize`).
- Каждая страница имеет фиксированную внутреннюю разметку, содержащую:
    1. **Заголовок** (в младших адресах).
    2. **Массив указателей на версии строк**.
    3. **Свободное пространство**.
    4. **Версии строк** (данные).
    5. **Специальная область** (в старших адресах).

### Заголовок страницы

- Расположен в начале страницы, фиксированного размера (обычно 24 байта).
- Содержит:
    - Контрольную сумму.
    - Указатели на начало и конец других областей (`lower`, `upper`, `special`).
    - Дополнительные метаданные (например, флаги страницы).
- Пример анализа с использованием расширения `pageinspect`:
  ```sql
  CREATE EXTENSION pageinspect;
  SELECT lower, upper, special, pagesize
  FROM page_header(get_raw_page('accounts', 0));
  ```
  Вывод:
  ```
  lower | upper | special | pagesize
  ------+-------+---------+---------
  152   | 6904  | 8192    | 8192
  ```
    - `lower`: начало массива указателей (152 байта от начала страницы).
    - `upper`: конец свободного пространства (6904 байта).
    - `special`: начало специальной области (8192 байта, конец страницы).
    - `pagesize`: размер страницы (8192 байт = 8 КБ).

### Специальная область

- Расположена в конце страницы (старшие адреса).
- Используется для индексов (например, B-дерево хранит метаданные или ссылки на дочерние узлы).
- Для таблиц обычно имеет нулевой размер.
- Пример: в B-дереве нулевая страница хранит метаданные, а обычные страницы — индексные записи.

### Версии строк

- **Версии строк** (row versions, tuples) — это данные таблицы с добавленной служебной информацией.
- Многоверсионность (MVCC) позволяет хранить несколько версий одной строки для поддержки конкурентного доступа.
- В отличие от таблиц, индексы не содержат версий строк, а ссылаются на все табличные версии через идентификаторы (`tid`).

### Указатели на версии строк

- Массив указателей (line pointers) — это оглавление страницы, расположенное после заголовка.
- Каждый указатель (4 байта) содержит:
    - Смещение версии строки относительно начала страницы.
    - Длину версии строки.
    - Статус (например, `normal`, `unused`, `redirect`, `dead`).
- Идентификатор версии строки (`tid`) состоит из:
    - Номера страницы в файле основного слоя.
    - Номера указателя в массиве (не смещения, для избежания фрагментации при перемещении строк).
- Пример: `tid = (0,1)` указывает на первую строку на странице 0.

### Свободное пространство

- Расположено между указателями и версиями строк.
- Всегда представлено одним непрерывным фрагментом (без фрагментации).
- Отслеживается в карте свободного пространства (`_fsm`) для оптимизации вставки данных.

### Схема страницы

```
0          24         lower         upper         special       pagesize
|----------|----------|-------------|-------------|-------------|
| Заголовок| Указатели| Свободное   | Версии строк| Специальная |
|          |          | пространство |             | область     |
```

---

## 3.2. Структура версий строк

### Основы

- Версия строки состоит из:
    - **Заголовка** (минимально 23 байта).
    - **Данных** (собственно значения столбцов).
- Заголовок содержит:
    - `xmin`: номер транзакции, создавшей строку (`INSERT`).
    - `xmax`: номер транзакции, удалившей или обновившей строку.
    - `infomask`: биты, определяющие свойства версии (например, статус `xmin` и `xmax`).
    - `ctid`: ссылка на следующую версию строки (тип `tid`, например, `(0,2)`).
    - Битовую карту `NULL`-значений (для столбцов, допускающих `NULL`).
- Данные выровнены по границам машинных слов (например, 4 или 8 байт в зависимости от архитектуры).


## 3.3. Выполнение операций над версиями строк

- Каждая версия строки имеет поля `xmin` и `xmax`, использующие номера транзакций (`xid`) для определения видимости.
- Номера транзакций — 32-битные счетчики, увеличивающиеся последовательно.
- **Операции**:
    - `INSERT`: создает новую версию строки с `xmin = текущий xid`.
    - `DELETE`: устанавливает `xmax = текущий xid` в текущей версии.
    - `UPDATE`: комбинация `DELETE` (установка `xmax`) и `INSERT` (новая версия с `xmin = текущий xid`).
    - `MERGE` (с версии 15): разбивается на `INSERT`, `UPDATE`, `DELETE`.


## 3.4. Индексы

- Индексы не содержат версий строк, только ссылки (`tid`) на все версии строк в таблице.
- Транзакция проверяет видимость версии строки в таблице с учетом `xmin`, `xmax` и карты видимости.

---

## 3.5. TOAST

- **TOAST** — технология для хранения длинных значений (более ~2000 байт).
- TOAST-таблицы:
    - Хранятся в схеме `pg_toast`, имеют собственную многоверсионность.
    - Строки только добавляются или удаляются, не обновляются.
- При обновлении:
    - Если длинное значение не изменилось, новая версия строки ссылается на старое значение в TOAST.
    - Если изменилось, создается новая версия в TOAST.

---

## 3.6. Виртуальные транзакции

- **Виртуальные номера транзакций** (`virtual xid`):
    - Используются для читающих транзакций, чтобы экономить реальные номера (`xid`).
    - Формат: идентификатор процесса + последовательный номер.
    - Хранятся только в памяти, не записываются на диск.

---

## 3.7. Вложенные транзакции

### Точки сохранения

- **Точки сохранения** (`SAVEPOINT`) позволяют откатить часть транзакции без её завершения.
- Реализуются через **вложенные транзакции** (`subtransactions`):
    - Каждая имеет собственный номер (`xid`), больший, чем у основной транзакции.
    - Статус хранится в `clog` и `PGDATA/pg_subtrans`.
    - Если основная транзакция откатывается, все вложенные считаются отмененными.


# 4. Снимки данных


## 4.1. Что такое снимок данных

### Основы

- **Снимок данных** (snapshot) — это согласованное представление данных базы на определенный момент времени, соответствующее свойствам *
  *ACID** (в частности, согласованности и изоляции).
- Снимок включает только **актуальные версии строк**, зафиксированные к моменту его создания.
- **Многоверсионность** (MVCC): физически в таблицах могут существовать несколько версий одной строки, но каждая транзакция видит максимум
  одну из них, определенную снимком.
- **Изоляция**: каждая транзакция работает со своим снимком, что обеспечивает независимость от других транзакций и согласованность данных на
  разные моменты времени.

### Создание снимков

- **Read Committed**:
    - Новый снимок создается для **каждого оператора** в транзакции.
    - Активен только во время выполнения оператора.
- **Repeatable Read и Serializable**:
    - Один снимок создается в начале **первого оператора** транзакции.
    - Остается активным до конца транзакции.
- **Графическое представление**:
  ```
  Read Committed:
  xid:       |------|------|
             | снимок1 | снимок2 |
             | оператор1 | оператор2 |

  Repeatable Read/Serializable:
  xid:       |-------------|
             |   снимок    |
             | оператор1 | оператор2 |
  ```

---

## 4.2. Видимость версий строк в снимке

### Основы

- Снимок не является физической копией данных, а задается **набором параметров**, определяющих, какие версии строк видны.
- Видимость зависит от полей заголовка версии строки:
    - `xmin`: номер транзакции, создавшей строку (`INSERT`).
    - `xmax`: номер транзакции, удалившей или обновившей строку.
    - Информационные биты (`infomask`): статус транзакций (`xmin_committed`, `xmin_aborted`, `xmax_committed`, `xmax_aborted`).
- **Правило видимости** (упрощенно):
    - Версия строки видна, если:
        - Изменения транзакции `xmin` видны (транзакция зафиксирована до создания снимка или это собственные изменения текущей транзакции).
        - Изменения транзакции `xmax` не видны (транзакция не завершена, началась после снимка или отменена).
- Интервалы `xmin`–`xmax` не пересекаются, поэтому в снимке видна максимум одна версия строки.

### Пример видимости

- Сценарий:
    - Транзакция 1 (`xid=1`) активна.
    - Транзакция 2 (`xid=2`) завершилась до создания снимка.
    - Транзакция 3 (`xid=3`) началась после снимка.
- Графически:
  ```
  xid:    1       2       3
         |-------|-------|-------|
                | снимок |
  ```
    - Транзакция 2: изменения видны (завершилась до снимка).
    - Транзакция 1: изменения не видны (активна на момент снимка).
    - Транзакция 3: изменения не видны (началась после снимка).

---

## 4.3. Из чего состоит снимок

### Проблема времени фиксации

- PostgreSQL не отслеживает момент фиксации транзакций (кроме случаев, когда включен параметр `track_commit_timestamp`, используемый для
  репликации).
- Доступна информация:
    - Номер транзакции (`xid`) — момент начала.
    - Текущий статус транзакции (активна, зафиксирована, отменена) через структуру `ProcArray` в общей памяти.
- Для определения видимости снимок должен содержать статусы транзакций на момент его создания.

### Состав снимка

Снимок включает:

1. **Нижняя граница (`xmin`)**:
    - Номер самой старой активной транзакции на момент создания снимка.
    - Все транзакции с `xid < xmin` либо зафиксированы (видны), либо отменены (не видны).
2. **Верхняя граница (`xmax`)**:
    - Значение на 1 больше номера последней зафиксированной транзакции.
    - Транзакции с `xid >= xmax` не видны (не завершены или не существуют).
3. **Список активных транзакций (`xip_list`)**:
    - Номера всех активных транзакций (`xmin <= xid < xmax`), кроме виртуальных.
4. Дополнительные параметры (например, `cmin` для учета операций внутри транзакции).

### Графическое представление

```
xid:    1       2       3
       |-------|-------|-------|
       |<-- снимок -->|
       xmin           xmax
       xip_list: [1]
```

---

## 4.4. Видимость собственных изменений

- Транзакция должна видеть свои изменения, даже если они не зафиксированы.
- Однако некоторые изменения (например, сделанные после открытия курсора) могут быть не видны.

### Поле `cmin`/`cmax`

- В заголовке версии строки есть поле для хранения **порядкового номера операции** внутри транзакции:
    - `cmin`: номер операции вставки.
    - `cmax`: номер операции удаления.
    - Для экономии места используется одно поле, а при совпадении операций (`INSERT` и `DELETE` в одной транзакции) создается «комбо-номер»
      с отображением в памяти процесса.
- Курсоры учитывают только версии строк с `cmin` меньше номера операции открытия курсора.

---

## 4.5. Горизонт транзакции


- **Горизонт транзакции** — это нижняя граница снимка (`xmin`), определяющая самую старую активную транзакцию.
- Транзакции с `xid < xmin`:
    - Либо зафиксированы (видны).
    - Либо отменены (не видны).
- **Горизонт базы данных**:
    - Наименьший `xmin` среди всех активных транзакций в базе.
    - Определяет, какие версии строк можно безопасно удалить (очистка, `VACUUM`).
- **Виртуальные транзакции**:
    - Имеют горизонт только при активном снимке.
    - Без снимка (например, в `Read Committed` между операторами) горизонт не определен.

- Долгие транзакции (`Repeatable Read`, `Serializable`, или `Read Committed` в состоянии `idle in transaction`) удерживают горизонт,
  препятствуя очистке.
- Долгие транзакции увеличивают объем неактуальных версий строк, вызывая раздувание таблиц и индексов.
- **Графическое представление**:
  ```
  xid:  1  2  3  4  5  6  7  8  9 10
       |-------------------|
       | горизонт базы данных |
       | неактуальные версии можно вычищать |
  ```

---

## 4.6. Снимок данных для системного каталога


- Системный каталог (таблицы в схеме `pg_catalog`) использует **отдельные снимки**, чтобы всегда видеть последние изменения (например, новые
  столбцы или ограничения).
- Обычный снимок транзакции может быть устаревшим, что недопустимо для каталога.
- Реализация:
    - Создается «свежий» снимок для каждого обращения к каталогу.
    - Кэширование объектов каталога оптимизирует производительность.


---

## 4.7. Экспорт снимка данных

- **Экспорт снимка** позволяет нескольким транзакциям видеть одну и ту же согласованную картину данных.
- Используется, например, в `pg_dump` для параллельного резервного копирования.
- Механизм:
    - Функция `pg_export_snapshot()` возвращает идентификатор снимка.
    - Команда `SET TRANSACTION SNAPSHOT` импортирует снимок в другую транзакцию (требуется `Repeatable Read` или `Serializable`).

---

# 5. Внутристраничная очистка и hot-обновления

### Проблема стандартного `UPDATE`

Чтобы понять гениальность HOT-обновлений, нужно знать, как работает обычный `UPDATE` в PostgreSQL из-за его MVCC-архитектуры (многоверсионность):

1.  **`UPDATE` — это `DELETE` + `INSERT`.** Когда вы делаете `UPDATE users SET balance = balance + 10 WHERE id = 123;`, PostgreSQL не перезаписывает старую строку. Он:
    *   Помечает старую версию строки как "мертвую" (dead tuple).
    *   Создает **новую версию** строки с новым значением `balance` и вставляет её в **новое физическое место** на диске.
2.  **Индексы тоже обновляются.** Поскольку новая версия строки находится в новом месте (у неё новый TID — Tuple ID), PostgreSQL обязан обновить **каждый индекс** на этой таблице, чтобы он указывал на новую строку.

**Последствия:**
*   **Раздувание таблицы (Table Bloat):** "Мертвые" строки занимают место, пока их не уберет `VACUUM`.
*   **Раздувание индексов (Index Bloat):** Обновление даже одного неиндексированного столбца приводит к созданию новых записей во всех индексах. Это очень дорого.
*   **Высокие издержки:** Множество операций записи на диск (в таблицу, во все индексы) и в журнал предзаписи (WAL).

---

###  HOT-обновления (Heap-Only Tuple Updates)

**Суть в одном предложении:** Это супероптимизированный `UPDATE`, который позволяет создать новую версию строки на той же странице данных, что и старая, **без необходимости обновлять индексы**.

**Как это работает (магия PostgreSQL):**

1.  **Главное условие:** HOT-обновление возможно только тогда, когда:
    *   Новая версия строки может поместиться на **той же странице данных**, что и старая.
    *   Значения в **индексированных столбцах не изменяются**.

2.  **Процесс HOT-обновления:**
    *   PostgreSQL создает новую версию строки, как обычно.
    *   Он размещает её на **той же самой странице** данных (в "куче" — heap).
    *   **Ключевой момент:** Он НЕ обновляет записи в индексах. Индексы по-прежнему указывают на **физическое местоположение старой, "мертвой" строки**.
    *   В заголовке старой строки устанавливается специальный флаг, который перенаправляет любой запрос, пришедший по старому адресу, на новую версию строки (которая лежит рядом на той же странице).

**Преимущества:**
*   **Нет затрат на обновление индексов.** Это главное. Если у вас 10 индексов на таблице, вы экономите 10 операций записи в индекс. Производительность `UPDATE` возрастает в разы.
*   **Значительно меньше раздувание индексов.** Индексы остаются компактными и быстрыми.
*   **Меньше записей в WAL**, что снижает общую нагрузку на систему.

*   **`FILLFACTOR`:** Установка `FILLFACTOR` для таблицы меньше 100 (например, 90) оставляет на каждой странице 10% свободного места. Это повышает вероятность того, что новая версия строки поместится на ту же страницу и `UPDATE` станет HOT-обновлением.

---

### Внутристраничная очистка (In-page cleanup)

**Проблема:** HOT-обновления оставляют на странице "мертвые" версии строк (HOT-tuples). Кто их уберет? Ждать глобальный `VACUUM` для очистки одной страницы — неэффективно.

**Решение — внутристраничная очистка:**

**Суть в одном предложении:** Это легковесный, "ленивый" механизм, который удаляет "мертвые" HOT-tuples прямо в момент обращения к странице, не дожидаясь `VACUUM`.

**Как это работает:**
1.  **Триггер:** Любая последующая операция (`SELECT`, `INSERT`, `UPDATE`), которая обращается к странице данных, где лежат "мертвые" HOT-tuples.
2.  **Проверка:** Прежде чем выполнить свою основную работу, запрос проверяет: "А есть ли на этой странице мертвые HOT-версии, которые уже не видит ни одна активная транзакция?"
3.  **Очистка:** Если такие версии найдены, они **немедленно удаляются**, а освободившееся место становится доступным для новых строк на этой же странице.

**Это очень важно:**
*   **Оппортунистический процесс:** Очистка происходит "попутно", почти бесплатно.
*   **Локальный:** Работает только в пределах одной страницы, не блокируя всю таблицу.
*   **Эффективность:** Позволяет многократно использовать пространство на странице без раздувания и без вызова тяжелого `VACUUM`.

---

# 6. Очистка и автоочистка


Как мы уже выяснили, из-за MVCC (многоверсионности) операции `DELETE` и `UPDATE` не удаляют строки физически, а лишь помечают их как "мертвые" (dead tuples). Это приводит к двум проблемам:
1.  **Раздувание (Bloat):** Таблицы и индексы разрастаются, занимая лишнее место и замедляя работу.
2.  **Устаревшая статистика:** Планировщик запросов не знает об актуальном состоянии данных и может строить неэффективные планы.

`VACUUM` и `ANALYZE` решают эти проблемы. `AUTOVACUUM` делает это автоматически.


### `VACUUM`: Ручная уборка

Это команда, которую вы можете запустить вручную. Её главная задача — сделать "мертвое" пространство **повторно используемым**. Стандартный `VACUUM` не блокирует таблицу для чтения и записи.

#### Этапы выполнения `VACUUM`:

1.  **Поиск "мертвых" строк:** `VACUUM` последовательно сканирует файл таблицы (heap), находя строки, помеченные как удаленные и уже невидимые для любой активной транзакции.
2.  **Очистка индексов:** Для каждой найденной "мертвой" строки `VACUUM` удаляет соответствующие ей указатели из **всех** индексов таблицы. Это критически важно для поддержания производительности и компактности индексов.
3.  **Обновление Карты Свободного Пространства (FSM):** Освободившееся место помечается в специальной карте (Free Space Map). Теперь PostgreSQL знает, что сюда можно быстро вставлять новые строки, не ища место по всей таблице.
4.  **Обновление Карты Видимости (VM):** Если страница была полностью очищена и все строки на ней "видны всем", она помечается в Карте Видимости (Visibility Map). Это необходимо для сверхбыстрых **Index-Only Scans**.
5.  **Защита от зацикливания ID транзакций (TXID Wraparound):** Самая важная, невидимая задача. `VACUUM` "замораживает" ID очень старых транзакций, чтобы после переполнения 32-битного счетчика они не стали ошибочно считаться новыми. Это предотвращает катастрофическую потерю данных.


### `ANALYZE`: Сбор разведданных

`VACUUM` убирает мусор, а `ANALYZE` составляет отчет о том, что осталось.

**Что делает:**
*   Проходит по таблице и собирает статистику о распределении данных в столбцах.
*   Он узнает: количество уникальных значений, самые частые значения, гистограмму распределения, среднюю ширину строк и т.д.
*   Записывает эту информацию в системные таблицы (`pg_statistic`).

**Зачем нужно:**
Эта статистика — **"пища для ума" планировщика запросов**. Без нее планировщик слеп. Он не сможет правильно оценить, сколько строк вернет условие `WHERE city = 'Москва'`, и может выбрать медленный `Seq Scan` вместо быстрого `Index Scan`, или неверный тип соединения таблиц.

**Важно:** `VACUUM` и `ANALYZE` — разные задачи, но они настолько важны вместе, что почти всегда выполняются в паре: `VACUUM ANALYZE`.


### `AUTOVACUUM`: Автоматический уборщик и аналитик

Запускать `VACUUM ANALYZE` вручную утомительно и непрактично. `AUTOVACUUM` — это встроенный фоновый процесс (демон) PostgreSQL, который делает эту работу за вас. Это одна из лучших функций СУБД.

**Как он решает, когда запускаться?**

`AUTOVACUUM` не работает по расписанию. Он срабатывает на основе **пороговых значений**, которые рассчитываются для каждой таблицы индивидуально.

1.  **Триггер для `AUTOVACUUM` (очистки):**
    Процесс запускается для таблицы, если количество "мертвых" строк в ней превышает:
    `autovacuum_vacuum_threshold + (autovacuum_vacuum_scale_factor * количество_строк_в_таблице)`
    *   `autovacuum_vacuum_threshold` (по умолчанию `50`) — минимальное количество мертвых строк.
    *   `autovacuum_vacuum_scale_factor` (по умолчанию `0.2` или 20%) — процент от размера таблицы.

    **Пример:** Для таблицы в 10 000 строк `AUTOVACUUM` сработает при `50 + (0.2 * 10000) = 2050` мертвых строк.

2.  **Триггер для `AUTOANALYZE` (анализа):**
    Логика та же, но с другими параметрами. Запускается, если количество измененных (`INSERT`, `UPDATE`, `DELETE`) строк превышает:
    `autovacuum_analyze_threshold + (autovacuum_analyze_scale_factor * количество_строк_в_таблице)`
    *   По умолчанию это `50` строк + `10%` от размера таблицы.

**Ключевые особенности `AUTOVACUUM`:**
*   **Он "вежливый":** Он работает в фоновом режиме с низкой приоритетностью и автоматически приостанавливается, если видит высокую нагрузку на систему, чтобы не мешать пользовательским запросам.
*   **Он обязателен:** Отключение `AUTOVACUUM` — верный путь к серьезным проблемам с производительностью и, в конечном итоге, к остановке базы данных из-за TXID Wraparound.

    
# 7 Заморозка

### Заморозка (Freezing) в PostgreSQL: Невидимый страж вашей базы данных

**Суть в одном предложении:** Это превентивный механизм, который защищает базу данных от катастрофической потери данных из-за исчерпания и "зацикливания" идентификаторов транзакций (TXID).

---

### Проблема: Зацикливание ID Транзакций (TXID Wraparound)

Чтобы понять заморозку, нужно понять проблему, которую она решает.

*   **Каждая транзакция имеет номер:** Когда вы делаете `INSERT`, `UPDATE` или `DELETE`, эта операция выполняется внутри транзакции, которой присваивается уникальный номер — **Transaction ID (TXID)**.
*   **Счетчик не бесконечен:** TXID — это 32-битное число. Это значит, что существует всего около 4 миллиардов уникальных номеров. В активно используемой базе этот счетчик может "обнулиться" (пройти полный круг) за несколько недель или месяцев.
*   **MVCC и сравнение:** Механизм многоверсионности (MVCC) работает, сравнивая TXID текущей транзакции с TXID, записанными в строках (`xmin` - кем создана, `xmax` - кем удалена). Логика сравнения хитрая: она понимает, что TXID 10 "новее", чем TXID 4,000,000,000, если счетчик только что "зациклился".

**Катастрофа:** Что произойдет со строкой, которая была создана очень-очень давно, например, 3 миллиарда транзакций назад? Когда счетчик TXID пройдет полный круг, эта "древняя" транзакция внезапно станет выглядеть как "будущая" транзакция. С точки зрения MVCC, данные из будущего невидимы. **В результате очень старые, но абсолютно валидные строки просто исчезнут из результатов запросов.** Это и есть **TXID Wraparound Failure** — тихая потеря данных.

---

### Решение: Заморозка (Freezing)

Заморозка — это процесс замены обычного числового TXID в заголовке строки на специальное, зарезервированное значение — `FrozenTransactionId`.

*   **Что означает `FrozenTransactionId`?** Он говорит системе: "Эта строка настолько стара, что она гарантированно была создана до начала любой возможной активной транзакции в этой базе данных. **Считай её видимой всегда и для всех**, не утруждай себя сравнением TXID."

Это полностью решает проблему зацикливания для этой конкретной строки. Она становится "вечной" с точки зрения видимости.

---

###  Кто и как выполняет заморозку? `VACUUM`!

Заморозка — это неотъемлемая и важнейшая часть работы `VACUUM`.

**Как это происходит:**
1.  При своем обычном сканировании таблицы `VACUUM` проверяет не только "мертвые" строки, но и возраст "живых".
2.  Для каждой "живой" строки он вычисляет её возраст (`age`): `текущий_TXID - TXID_создания_строки`.
3.  Если возраст строки превышает определенный порог (`vacuum_freeze_min_age`, по умолчанию 150 млн транзакций), `VACUUM` **перезаписывает эту строку**, заменяя её `xmin` на `FrozenTransactionId`.

**Важные моменты:**
*   **Заморозка — это операция записи.** Хоть данные и не меняются, перезапись строки генерирует запись в WAL (журнал предзаписи) и может создавать нагрузку на дисковую систему.
*   **Процесс ленивый.** `VACUUM` не замораживает все строки подряд, а только те, которые "состарились" достаточно сильно.

---

### Защитные механизмы: `AUTOVACUUM` как страж

Что если какая-то таблица очень редко обновляется, и обычный `AUTOVACUUM` на ней никогда не запускается? Строки в ней будут стареть, приближая базу к катастрофе. Для этого есть два уровня защиты:

1.  **Агрессивный Autovacuum (`autovacuum_freeze_max_age`):**
    *   PostgreSQL постоянно отслеживает возраст самой старой, еще не замороженной транзакции во всей базе данных.
    *   Если этот возраст превышает порог `autovacuum_freeze_max_age` (по умолчанию 200 млн), PostgreSQL принудительно запускает **агрессивный `AUTOVACUUM`** на таблице, содержащей эту старую строку. Этот `AUTOVACUUM` будет более настойчивым и менее "вежливым", чем обычный.

2.  **Аварийная остановка (`vacuum_failsafe_age`):**
    *   Если по какой-то причине (например, `AUTOVACUUM` отключен или не справляется) возраст транзакции достигнет критического порога `vacuum_failsafe_age` (по умолчанию 2.1 млрд), PostgreSQL примет экстренные меры.
    *   Он **запретит запуск новых транзакций и, в конечном итоге, остановит работу базы данных**, чтобы предотвратить потерю данных. В логах появится страшное сообщение `WARNING: database is approaching transaction ID wraparound limit`. Этого нужно избегать любой ценой.



---
# 8 Перестроение таблиц и индексов
---

## 8.1. Полная очистка

### Необходимость

- **Обычная очистка** (`VACUUM`) освобождает место внутри страниц, но не уменьшает число страниц, кроме случаев с пустыми "хвостовыми"
  страницами (см. раздел 6.3).
- **Проблемы излишнего размера**:
    - Замедление полного сканирования таблицы/индекса.
    - Увеличение потребности в буферном кэше.
    - Дополнительный уровень в B-дереве, замедляющий индексный доступ.
    - Лишнее место на диске и в резервных копиях.
- **Решение**: `VACUUM FULL` перестраивает таблицу и индексы, компактно упаковывая данные (с учетом `fillfactor`).

### Особенности

- Требует монопольной блокировки таблицы (чтение и запись недоступны).
- Создает новые файлы, удваивая потребность в дисковом пространстве во время выполнения.
- Автоматически замораживает строки.

---

## 8.2. Другие способы перестроения

### Аналоги `VACUUM FULL`

1. **CLUSTER**:
    - Перестраивает таблицу, упорядочивая строки по индексу (см. раздел 10.2).
    - Монопольно блокирует таблицу.
    - Является частным случаем `VACUUM FULL` без упорядочивания.
2. **REINDEX**:
    - Перестраивает индексы, используется в `VACUUM FULL` и `CLUSTER`.
3. **TRUNCATE**:
    - Удаляет все строки, создавая новый файл (быстрее, чем `DELETE`).

### Перестроение без долгих блокировок

- **pg_repack**:
    - Перестраивает таблицы/индексы с минимальными блокировками (только в начале и конце).
    - Использует триггеры для сохранения изменений, затем подменяет таблицы в каталоге.
- **pgcompacttable**:
    - Многократные фиктивные обновления перемещают актуальные строки к началу файла.
    - Очистка усекает файл постепенно.
    - Требует больше времени, но не создает пиковых нагрузок и не требует дополнительного места.

---

# 9 Буферный кеш

---

### 9.1. Кеширование

Кеширование компенсирует разницу в производительности между быстрой (дорогой, малой по объему) и медленной (дешевой, большой по объему)
памятью. Активные ("горячие") данные хранятся в кеше, минимизируя обращения к медленной памяти. Буферный кеш PostgreSQL хранит страницы
отношений, сглаживая разницу во времени доступа: оперативная память — наносекунды, диски — миллисекунды. PostgreSQL использует
буферизованные операции ввода-вывода через кеш ОС, а не прямой ввод-вывод, что упрощает код, но исключает прямое управление записью и
предвыборкой. Прямой ввод-вывод использует DMA, избегая копирования через кеш ОС, но требует асинхронного ввода-вывода и учета различий в
ОС. Работа над этим ведется (параметр `debug_io_direct`).

### 9.2. Устройство буферного кеша

Буферный кеш — массив буферов в общей памяти, доступный всем процессам. Каждый буфер содержит страницу данных (8 КБ) и заголовок:

- Физическое расположение (файл, слой, номер блока).
- Флаг "грязной" страницы (`isdirty`) — требует записи на диск.
- Счетчик обращений (`usage count`) — число использований.
- Счетчик закреплений (`pin count`) — число процессов, удерживающих буфер.

Процесс запрашивает страницу у менеджера буферов, получает номер буфера, закрепляет его для работы, избегая замены. Изменения происходят в
кеше без немедленного ввода-вывода. Расширение `pg_buffercache` позволяет анализировать кеш.

### 9.3. Попадание в кеш

Менеджер ищет страницу в хеш-таблице (`buf_table.c`) по ключу: идентификатор файла, слой, номер страницы. Хеш-таблица динамически
расширяется, коллизии разрешаются цепочками (`dynahash.c`). При нахождении буфер закрепляется, `usagecount` увеличивается, работа идет без
ввода-вывода. Закрепление предотвращает замену страницы, но допускает обновления строк. Закрепленные буферы могут блокировать операции,
например, `VACUUM`. Хеш-таблица неэффективна для операций `DROP` или `TRUNCATE`.

### 9.4. Промах кеша

Если страница отсутствует, выбирается новый буфер:

1. **Свободные буферы**: при старте кеш содержит пустые буферы в списке (`freelist.c`). Первый свободный используется.
2. **Занятые буферы**: при их отсутствии применяется алгоритм "часовой стрелки" (`clock sweep`):
    - Уменьшает `usagecount` буферов.
    - Выбирает незакрепленный буфер с `usagecount=0`.
    - Грязные страницы записываются на диск перед вытеснением.
    - Максимальный `usagecount=5`.

Новая страница читается через буферизованный ввод-вывод, добавляется в хеш-таблицу, `usagecount=1`. Кеш ОС может смягчить промахи.
Статистика доступна через `pg_statio_all_tables`.

### 9.5. Массовое вытеснение

Массовые операции используют буферные кольца, ограничивающие вытеснение внутри кольца (`GetBufferFromRing`). Стратегии:

- **bulkread**: для таблиц >1/4 кеша, кольцо 256 КБ (32 страницы), грязные буферы заменяются без записи.
- **bulkwrite**: для `COPY`, `CREATE TABLE AS`, кольцо до 16 МБ (2048 страниц, ?1/8 кеша).
- **vacuum**: для очистки/анализа, размер кольца — `vacuum_buffer_usage_limit`.

Кольца не всегда эффективны, например, при массовых `UPDATE`/`DELETE` или доступе к TOAST-таблицам по индексу. Статистика в `pg_stat_io`
показывает операции по стратегиям.

### 9.6. Настройка размера

Параметр `shared_buffers` (по умолчанию 128 МБ) задает размер кеша, требует перезапуска. Оптимальный размер зависит от памяти, данных и
нагрузки. Рекомендация: ~1/4 оперативной памяти. Маленький кеш вызывает избыточный ввод-вывод, большой — увеличивает накладные расходы. Кеш
ОС смягчает промахи, но использует другую стратегию вытеснения. Анализ
через `pg_buffercache`, `pg_buffercache_summary`, `pg_buffercache_usage_counts` помогает оценить использование.

### 9.7. Прогрев кеша

После перезапуска кеш заполняется постепенно. Расширение `pg_prewarm` загружает таблицы в кеш. При включении в `shared_preload_libraries`
процесс `autoprewarm leader` сохраняет кеш в файл `autoprewarm.blocks` каждые `pg_prewarm.autoprewarm_interval` (300 с) и восстанавливает
его после перезапуска.

### 9.8. Локальный кеш

Временные таблицы используют локальный кеш в памяти процесса. Особенности:

- Собственная хеш-таблица, алгоритм вытеснения без колец.
- Нет блокировок (один процесс) и защиты от сбоев (данные до конца сеанса).
- Размер — `temp_buffers` (по умолчанию 8 МБ).

Статистика доступна через `pg_stat_io`.

---

# 10 Журнал предзаписи

---

#### 10.1. Журналирование

Журнал предзаписи (WAL, write-ahead log) обеспечивает согласованность данных после сбоев (например, отключения питания или отказа СУБД/ОС),
когда содержимое оперативной памяти теряется. Данные на диске рассогласованы, так как страницы записываются отложенно. WAL фиксирует каждое
действие (например, изменение страницы в буферном кеше) в виде журнальной записи, которая сохраняется на диск до записи измененной страницы.
Это позволяет восстановить пропавшие изменения после сбоя. Журналирование эффективнее записи отдельных страниц, так как записи небольшие и
пишутся последовательно. Журналируются:

- Изменения страниц в буферном кеше.
- Фиксация/отмена транзакций (в буферах clog).
- Файловые операции (создание/удаление файлов).

Не журналируются:

- Операции с нежурналируемыми (`UNLOGGED`) таблицами и последовательностями.
- Операции с временными таблицами и последовательностями.

WAL используется для восстановления после сбоя, восстановления из резервной копии и репликации.

#### 10.2. Устройство журнала

**Логическая структура**:  
Журнал — последовательность записей разной длины, каждая с заголовком, содержащим:

- Номер транзакции.
- Менеджер ресурсов (интерпретирует запись).
- Контрольная сумма.
- Длина записи.
- Ссылка на предыдущую запись.

Данные записи зависят от менеджера ресурсов (таблицы, индексы, статус транзакций). Журнальный кеш в разделяемой памяти (размер
задается `wal_buffers`, по умолчанию ~16 МБ) работает как кольцевой буфер: записи добавляются в "голову", сбрасываются на диск с "хвоста".
Позиция записи обозначается `pg_lsn` (64-битное смещение, формат: два 32-битных числа через "/"). LSN страницы хранит последнюю связанную
запись WAL. Функции `pg_current_wal_lsn()` и `pg_current_wal_insert_lsn()` показывают позиции сохраненных и вставленных записей.

**Физическая структура**:  
Журнал хранится в каталоге `PGDATA/pg_wal` как файлы-сегменты (по умолчанию 16 МБ, параметр `wal_segment_size`). При заполнении сегмента
создается новый. Имя файла включает номер ветви времени и старшие разряды LSN. Функция `pg_walfile_name_offset` возвращает имя файла и
смещение для LSN. Расширение `pg_walinspect` и утилита `pg_waldump` анализируют записи.

#### 10.3. Контрольная точка

Контрольная точка определяет момент, с которого начинается восстановление, позволяя удалять старые записи WAL. Процесс `checkpointer`
выполняет контрольную точку:

- **Начало**: сбрасываются небольшие структуры (clog, вложенные транзакции).
- **Выполнение**: помечаются грязные буферы, постепенно записываются на диск по порядку номеров для последовательной записи. Чередуется
  запись в разные табличные пространства. Другие процессы могут сбрасывать помеченные буферы.
- **Завершение**: создается запись WAL о завершении, обновляется `PGDATA/global/pg_control` с LSN начала точки. Старые записи WAL становятся
  ненужными.

#### 10.4. Восстановление

При старте процесс `postmaster` запускает `startup`, который проверяет статус кластера в `pg_control` ("in production" указывает на сбой).
Восстановление начинается с LSN последней контрольной точки (или из `backup_label` при восстановлении из копии). Записи WAL применяются к
страницам в буферном кеше, если LSN страницы меньше LSN записи. Полные образы страниц (FPI) и изменения статуса транзакций идемпотентны.
После восстановления нежурналируемые отношения перезаписываются, выполняется контрольная точка. PostgreSQL не требует отката транзакций —
незавершенные считаются оборванными.

#### 10.5. Фоновая запись

Процесс `bgwriter` асинхронно сбрасывает грязные буферы, снижая нагрузку на обслуживающие процессы. Использует алгоритм "часовой стрелки",
но не уменьшает `usagecount` и сбрасывает незакрепленные буферы с нулевым `usagecount`. Это увеличивает вероятность, что вытесняемые буферы
не будут грязными.

---

## 11. Режимы журнала

### 11.1. Производительность

WAL записывается последовательно, что эффективно даже для HDD, но SSD ускоряет операции. Размещение `pg_wal` на отдельном диске снижает
конкуренцию за I/O, особенно при высокой нагрузке.

**Синхронный режим** (`synchronous_commit = on`):

- Ждет синхронизации WAL (`fsync`), гарантируя надежность (ACID).
- `commit_delay` группирует записи, если есть `commit_siblings` транзакций, сокращая `fsync`.
- Плюсы: надежность для критичных систем (финансы). Минусы: высокая задержка, низкий TPS.

**Асинхронный режим** (`synchronous_commit = off`):

- Фиксация без ожидания записи. `walwriter` пишет каждые `wal_writer_delay` (200 мс).
- Плюсы: высокий TPS. Минусы: риск потери данных (до 0.6 с).
- Для некритичных приложений (логи, аналитика).

**Оптимизация**:

- Используйте SSD для WAL.
- Настройте `wal_writer_delay` и `commit_delay` для OLTP.
- Мониторьте I/O через `pg_stat_io` и отставание реплики через `pg_stat_replication`.

### 11.2. Надежность

**Кеширование и синхронизация**:

- WAL проходит через кеши ОС и дисков. `fsync` или `fdatasync` обеспечивают надежность.
- Выберите `wal_sync_method` по оборудованию (RAID с батареей использует кеш).
- `fsync = off` недопустим в производстве — риск потери данных.

**Повреждение данных**:

- WAL защищен контрольными суммами. Страницы данных — при `data_checksums = on`.
- Проверка только при чтении, не защищает `clog` или нулевые страницы.
- Включите `data_checksums` в производстве.

**Неатомарность записи**:

- Страницы (8 КБ) могут записываться частично. `full_page_writes = on` сохраняет FPI.
- `wal_compression` (`zstd` лучше) сокращает объем FPI, снижая I/O, но нагружает CPU.

### 11.3. Уровни журнала

**Minimal**:

- Только восстановление после сбоя. Не журналирует `CREATE TABLE AS`, `TRUNCATE` (> `wal_skip_threshold`).
- Требует `max_wal_senders = 0`. Для систем без репликации.

**Replica**:

- Для физической репликации и PITR. Добавляет `LOCK`, `RUNNING_XACTS`.
- По умолчанию с версии 10. Для большинства систем.

**Logical**:

- Для логической репликации. Добавляет записи для декодирования каталога.
- Используйте только при необходимости.

**Рекомендации**:

- `minimal` для производительности без репликации.
- `replica` для физической репликации.
- `logical` для логической репликации.
- Мониторьте WAL через `pg_stat_io`, `pg_walinspect`.

---

**12. Блокировки отношений**

---

**12.1. Общие сведения о блокировках**  
Блокировки (locks, или замки) — механизм для упорядочивания конкурентного доступа к разделяемым ресурсам, когда несколько процессов или
потоков одновременно пытаются использовать один и тот же ресурс. Конкурентный доступ возникает при параллельном (на многоядерных системах)
или последовательном (в режиме разделения времени) выполнении процессов. Если конкуренции нет, блокировки не требуются: например, общий
буферный кеш нуждается в блокировках, а локальный кеш каждого процесса — нет.

Перед доступом к ресурсу процесс обязан **захватить (acquire)** связанную с ним блокировку, а после завершения работы — **освободить (
release)** её, чтобы другие процессы могли получить доступ. В системах управления базами данных (СУБД), таких как PostgreSQL, управление
блокировками обычно автоматизировано, и порядок их использования поддерживается системой. Если же блокировки устанавливаются приложением,
ответственность за соблюдение правил ложится на разработчика.

На низком уровне блокировка представляет собой участок **разделяемой памяти**, где хранится информация о её состоянии (свободна или
захвачена) и, при необходимости, дополнительные данные, такие как идентификатор процесса, время захвата или другие метаданные. Сам этот
участок памяти является ресурсом, и конкурентный доступ к нему регулируется с помощью **примитивов синхронизации**, предоставляемых
операционной системой, например:

- **Семафоры** — для ограничения числа процессов, имеющих доступ к ресурсу.
- **Мьютексы** — для обеспечения взаимного исключения.

Эти примитивы, в свою очередь, реализуются на основе **атомарных инструкций процессора**, таких как:

- **Test-and-set** — проверяет и устанавливает значение в одной операции.
- **Compare-and-swap** — сравнивает и заменяет значение атомарно.

Такие инструкции гарантируют строгую последовательность выполнения кода, обращающегося к разделяемому ресурсу, исключая состояния гонки.

**Ресурсы**, защищаемые блокировками, могут быть любыми, если их можно однозначно идентифицировать и связать с адресом блокировки. Примеры:

- **Объекты СУБД**:
    - Таблица (идентификатор — oid в системном каталоге).
    - Страница данных (идентификатор — имя файла и позиция в нём).
    - Версия строки (идентификатор — страница и смещение внутри неё).
- **Структуры в памяти**:
    - Хеш-таблица или буфер (идентификатор — заранее присвоенный номер).
- **Абстрактные ресурсы**: не связанные с физическими объектами, но используемые для координации процессов.

Если ресурс уже занят, процесс, пытающийся захватить блокировку, либо:

- Встаёт в **очередь ожидания** (если механизм это поддерживает).
- Повторяет попытку захвата через интервал времени (спинлок или повторные запросы).

В обоих случаях процесс может простаивать, ожидая освобождения ресурса, что влияет на производительность.

**Ключевые факторы, влияющие на эффективность блокировок:**

1. **Гранулярность блокировки** — уровень детализации ресурса, на который устанавливается блокировка:
    - **Крупная гранулярность** (например, блокировка всей таблицы): упрощает управление, но ограничивает параллелизм, так как блокирует
      доступ даже к неиспользуемым частям ресурса (например, другим строкам или страницам).
    - **Мелкая гранулярность** (например, блокировка отдельных строк): повышает параллелизм, позволяя процессам работать с разными частями
      ресурса, но увеличивает количество блокировок и объём памяти для их хранения.
    - **Эскалация блокировок**: при превышении определённого числа мелкогранулярных блокировок (например, на строки) система может заменить
      их одной крупногранулярной блокировкой (например, на таблицу), чтобы сократить накладные расходы. Это компромисс между памятью и
      производительностью.
2. **Режимы блокировки** — определяют, какие операции могут выполняться одновременно:
    - **Исключительный режим (exclusive)**: несовместим с любыми другими режимами, включая себя. Используется для операций, требующих
      монопольного доступа, например, для изменения данных.
    - **Разделяемый режим (shared)**: позволяет нескольким процессам одновременно захватывать блокировку, обычно для операций чтения.
    - Существуют и другие режимы, их совместимость определяется **матрицей конфликтов**. Чем больше совместимых режимов, тем выше
      возможности для распараллеливания.

**Классификация блокировок по времени использования:**

- **Длительные блокировки**:
    - Удерживаются на протяжении длительного времени, обычно до завершения транзакции.
    - Применяются к ресурсам, таким как отношения (таблицы, индексы) или строки.
    - Управляются PostgreSQL автоматически, но пользователь может частично влиять на их поведение.
    - Характеризуются большим числом режимов для поддержки различных операций и сложной инфраструктурой (очереди ожидания, обнаружение
      взаимоблокировок, мониторинг), так как стоимость операций над данными значительно превышает затраты на управление блокировками.
- **Короткие блокировки**:
    - Удерживаются на доли секунды, часто на время выполнения нескольких инструкций процессора.
    - Применяются к структурам данных в общей памяти, например, буферам или хеш-таблицам.
    - Полностью управляются PostgreSQL автоматически.
    - Имеют минимум режимов (обычно два) и простую инфраструктуру, часто без средств мониторинга, чтобы минимизировать накладные расходы.

**В PostgreSQL** используются различные виды блокировок:

- **Длительные**:
    - Тяжёлые блокировки (на уровне отношений и других объектов).
    - Блокировки на уровне строк.
- **Короткие**: блокировки структур данных в оперативной памяти.
- **Особые**: предикатные блокировки, которые, несмотря на название, не являются классическими блокировками.

**12.2. Тяжелые блокировки**  
Тяжёлые (heavyweight) блокировки относятся к длительным и устанавливаются на уровне объектов СУБД, преимущественно отношений (таблиц,
индексов), но также и других объектов, таких как последовательности или материализованные представления. Их назначение:

- Защита объектов от одновременных изменений.
- Обеспечение безопасности при реорганизации объектов (например, при `VACUUM FULL` или `TRUNCATE`).
- Координация других операций, зависящих от состояния объекта.

Тяжёлые блокировки хранятся в **общей памяти сервера** и доступны для анализа через системное представление `pg_locks`. Их общее количество
ограничено произведением параметров конфигурации сервера:

- `max_locks_per_transaction` — максимум блокировок на транзакцию.
- `max_connections` — максимум подключений к серверу.

Пул блокировок является общим для всех транзакций, что позволяет одной транзакции захватить больше блокировок, чем
задано `max_locks_per_transaction`, если другие транзакции используют меньше. Однако общее число блокировок не должно превышать
установленный лимит. Пул выделяется при запуске сервера, поэтому изменение указанных параметров требует перезагрузки.

Если ресурс занят в **несовместимом режиме**, процесс, пытающийся захватить блокировку, добавляется в очередь ожидания и переводится в
спящий режим, не тратя процессорное время. Когда ресурс освобождается, операционная система пробуждает ожидающий процесс.

**Взаимоблокировки (deadlocks)** возникают, когда два или более процесса блокируют друг друга, ожидая освобождения ресурсов. Например,
транзакция A удерживает блокировку ресурса X и ждёт Y, а транзакция B удерживает Y и ждёт X. PostgreSQL автоматически обнаруживает такие
ситуации и прерывает одну из транзакций, позволяя остальным продолжить работу.

**Типы тяжёлых блокировок** (по столбцу `locktype` в `pg_locks`):

- `transactionid`, `virtualxid`: блокировки идентификаторов транзакций (реальных или виртуальных).
- `relation`: блокировки отношений (таблиц, индексов и т.д.).
- `tuple`: блокировки версии строки.
- `object`: блокировки объектов, не являющихся отношениями (например, последовательности).
- `extend`: блокировки при добавлении файлов отношений для новых страниц.
- `page`: блокировки страниц данных (используются некоторыми индексами).
- `advisory`: рекомендательные блокировки, управляемые пользователем для собственных целей.

Большинство тяжёлых блокировок устанавливаются и освобождаются автоматически при выполнении SQL-команд, но некоторые можно запросить явно (
например, `LOCK TABLE` для отношений) или управлять вручную (рекомендательные блокировки).

**12.3. Блокировки номеров транзакций**  
Каждая транзакция в PostgreSQL всегда удерживает **исключительную блокировку** своего идентификатора — виртуального (`virtualxid`) и, если
назначен, реального (`transactionid`). Это необходимо для координации работы транзакций и предотвращения конфликтов.

**Режимы блокировки номеров транзакций:**

- **Разделяемый (shared)** — совместим только с самим собой, позволяет нескольким процессам ожидать завершения транзакции.
- **Исключительный (exclusive)** — несовместим с любыми режимами, включая себя.

**Матрица конфликтов:**  
![img_5.png](img_5.png)

Чтобы дождаться завершения транзакции, другой процесс запрашивает блокировку её номера в любом режиме. Так как транзакция уже удерживает
исключительную блокировку своего номера, запрос блокируется, и процесс засыпает до освобождения номера (то есть завершения транзакции).
После этого ресурс (номер) исчезает, но ожидающий процесс пробуждается, что сигнализирует о завершении целевой транзакции.

**12.4. Блокировки отношений**  
Для отношений (таблиц, индексов и других объектов) определено **восемь режимов** блокировок, чтобы максимизировать параллельное выполнение
операций. Режимы и их конфликты описаны в следующей **матрице конфликтов:**

![img_4.png](img_4.png)

- **Access Share**: самый слабый режим, совместимый со всеми, кроме Access Exclusive, используется для операций, не изменяющих данные.
- **Row Share**: допускает чтение и выборку строк с защитой от модификаций.
- **Row Exclusive**: позволяет изменять данные, но конфликтует с другими изменяющими режимами.
- **Share Update Exclusive**: для операций, которые изменяют структуру или данные, но допускают чтение.
- **Share**: для создания индексов, совместим с чтением, но не с модификацией.
- **Share Row Exclusive**: для операций, изменяющих структуру с ограничениями.
- **Exclusive**: для монопольных операций с изменением данных.
- **Access Exclusive**: самый строгий, несовместимый ни с чем, используется для операций, требующих полной изоляции (например, удаление
  таблицы).

Первые четыре режима поддерживают одновременное изменение данных, следующие четыре — нет. Разнообразие режимов позволяет минимизировать
блокировки и повышать производительность при параллельной работе.

**12.5. Очередь ожидания**  
Тяжёлые блокировки в PostgreSQL реализуют **честную очередь ожидания**, которая обеспечивает справедливый порядок доступа к ресурсам.
Процесс добавляется в очередь, если запрашивает блокировку в режиме, несовместимом с:

- Текущим режимом, в котором ресурс уже захвачен.
- Режимами, запрошенными другими процессами, уже стоящими в очереди.

Ожидающие процессы переводятся в спящее состояние, не потребляя процессорное время, и пробуждаются, когда ресурс освобождается.

**Особенности**:

- Даже совместимые режимы могут быть заблокированы, если в очереди есть несовместимый запрос. Например, запрос на `AccessShare` будет ждать,
  если в очереди уже стоит запрос на `AccessExclusive`, даже если текущая блокировка позволяет совместимость.
- При **завершении транзакции** (фиксация или откат) все её блокировки освобождаются, и первый процесс в очереди получает запрашиваемую
  блокировку.
- При **откате к точке сохранения** (`ROLLBACK TO SAVEPOINT` или в случае исключений в PL/pgSQL) снимаются все блокировки, захваченные после
  создания этой точки, так как это связано с откатом вложенной транзакции.

**Мониторинг очередей**:

- Функция `pg_blocking_pids` показывает идентификаторы процессов, которые блокируют указанный процесс, удерживая или запрашивая
  несовместимые блокировки.
- Таблица `pg_stat_activity` предоставляет информацию о текущем состоянии процессов, включая их запросы и события ожидания.
- Анализ `pg_locks` позволяет получить детальную картину зависимостей и блокировок в системе.

Эффективное управление блокировками и очередями в PostgreSQL минимизирует задержки и предотвращает бесконечные ожидания, обеспечивая высокую
производительность даже при высокой конкуренции за ресурсы.

---

**13. Блокировки строк**

**13.1. Устройство**  
В PostgreSQL блокировки строк реализованы с учётом изоляции на основе снимков (snapshot isolation), что исключает необходимость блокировать
строки при чтении. Это позволяет транзакциям читать данные, не мешая друг другу, так как каждая транзакция работает с собственной
моментальной копией данных. Однако для операций, изменяющих строки (например, `UPDATE` или `DELETE`), требуется защита от одновременных
изменений одной и той же строки несколькими транзакциями.

**Проблемы с тяжёлыми блокировками для строк**:  
Тяжёлые блокировки, описанные в разделе 12, не подходят для блокировки строк по следующим причинам:

- Каждая тяжёлая блокировка занимает значительный объём разделяемой памяти (сотни байт, плюс вспомогательная инфраструктура).
- Механизмы тяжёлых блокировок не рассчитаны на обработку огромного количества одновременно существующих блокировок, что типично для строк в
  больших таблицах.

В других СУБД проблема решается **эскалацией блокировок**: если число блокировок строк становится слишком большим, они заменяются одной
блокировкой более высокого уровня (например, на страницу или таблицу). Это упрощает реализацию, но снижает параллелизм, так как блокирует
доступ к данным, которые могли бы обрабатываться независимо.

**Подход PostgreSQL**:  
В PostgreSQL информация о блокировке строки хранится **непосредственно в заголовке версии строки** в страницах данных, а не в оперативной
памяти. Это не полноценные блокировки в традиционном смысле, а **признаки блокировки**, которые указывают на состояние строки. Основной
механизм:

- При изменении или удалении строки её актуальная версия помечается как удалённая.
- В поле `xmax` заголовка строки записывается номер транзакции, которая выполняет изменение.
- Дополнительные информационные биты в заголовке указывают, что строка заблокирована, а также режим блокировки.

Когда другая транзакция пытается изменить ту же строку и видит в `xmax` номер незавершённой транзакции, она обязана дождаться завершения
этой транзакции. После завершения блокирующей транзакции (фиксация или откат) все признаки блокировки снимаются, и ожидающая транзакция
может продолжить работу.

**Преимущества подхода**:

- Блокировка строк не требует дополнительной памяти в пуле тяжёлых блокировок, что позволяет масштабировать систему для таблиц с миллионами
  строк.
- Количество заблокированных строк не ограничено, так как данные хранятся в самих страницах таблицы.

**Недостатки**:

- Отсутствие информации о блокировках строк в оперативной памяти означает, что другие процессы не могут напрямую встать в очередь ожидания
  для конкретной строки.
- Для ожидания освобождения строки используется тяжёлая блокировка **номера транзакции** (`transactionid`), которая указана в `xmax`. Это
  означает, что число тяжёлых блокировок пропорционально количеству одновременно работающих транзакций, а не числу заблокированных строк.

Таким образом, PostgreSQL эффективно минимизирует затраты на управление блокировками строк, сохраняя высокую степень параллелизма.

**13.2. Режимы блокировки строки**  
PostgreSQL поддерживает **четыре режима блокировки строки**, которые делятся на:

- **Исключительные** (удерживаются только одной транзакцией):
    - **Update**: используется для изменения любых полей строки или её удаления.
    - **No Key Update**: используется для изменения полей, не входящих в уникальные индексы (например, поля, не связанные с внешними
      ключами).
- **Разделяемые** (могут удерживаться несколькими транзакциями одновременно):
    - **Share**: защищает строку от любых изменений, но позволяет чтение.
    - **Key Share**: защищает только ключевые поля (входящие в уникальные индексы), позволяя изменять неключевые поля.

**Матрица конфликтов режимов**:  
![img_6.png](img_6.png)

**Особенности режимов**:

- **Update**: применяется для операций, которые могут затрагивать ключевые поля, например, изменение первичного ключа или удаление строки.
- **No Key Update**: используется, если изменяются только неключевые поля, что чаще всего происходит при выполнении команды `UPDATE`.
  PostgreSQL автоматически выбирает этот режим, если изменение не затрагивает уникальные индексы, минимизируя конфликты.
- **Share**: используется для защиты строки от любых изменений, но допускает чтение. Применяется, например, командой `SELECT FOR SHARE`.
- **Key Share**: используется ядром PostgreSQL для проверки ссылочной целостности (внешних ключей). Этот режим совместим с `No Key Update`,
  что позволяет одновременно обновлять неключевые поля и проверять внешние ключи.

**Информация о блокировках**:

- Признак блокировки хранится в поле `xmax` версии строки, а режим определяется информационными битами в заголовке:
    - Бит `keys_updated` указывает на режим `Update` или `No Key Update`.
    - Бит `xmax_lock_only` указывает, что строка только заблокирована (например, командой `SELECT FOR`), но не помечена как удалённая.
    - Биты `xmax_keyshr_lock` и другие определяют разделяемые режимы (`Key Share`, `Share`).

Для анализа блокировок строк можно использовать расширение **pageinspect**, чтобы просмотреть заголовки строк, или **pgrowlocks**, которое
предоставляет удобный интерфейс для получения информации о блокировках строк.

**13.3. Мультитранзакции**  
Поскольку разделяемые режимы (`Share`, `Key Share`) могут удерживаться несколькими транзакциями одновременно, возникает проблема: как в одно
поле `xmax` (32 бита) записать номера нескольких транзакций? Для этого в PostgreSQL используются **мультитранзакции** (MultiXact).

**Мультитранзакция** — это группа транзакций, которой присваивается единый 32-битный идентификатор, аналогичный обычному номеру
транзакции (`xid`). Однако:

- Номера мультитранзакций выделяются из отдельного счётчика и могут пересекаться с номерами обычных транзакций.
- Для различения в заголовке строки устанавливается бит `xmax_is_multi`, указывающий, что `xmax` содержит номер мультитранзакции.
- Детальная информация о составе мультитранзакции (номера транзакций и их режимы) хранится в файлах каталога `PGDATA/pg_multixact`.
- Эти файлы кэшируются в общей памяти сервера для ускорения доступа и защищаются от сбоев с помощью журнала предзаписи (WAL).

**Пример работы мультитранзакций**:

- Если строка заблокирована в режиме `Key Share` одной транзакцией, а затем другая транзакция запрашивает совместимую блокировку (
  например, `Key Share` или `Share`), создаётся мультитранзакция, которая включает обе транзакции.
- Расширение `pgrowlocks` позволяет увидеть состав мультитранзакции: номера транзакций (`xids`), режимы блокировок (`modes`) и
  идентификаторы процессов (`pids`).

**Проблема переполнения номеров**:

- Как и обычные номера транзакций, мультитранзакции используют 32-битные идентификаторы, что приводит к риску **переполнения счётчика** (xid
  wraparound).
- Для предотвращения переполнения применяется **заморозка мультитранзакций**, аналогичная заморозке обычных транзакций. Заморозка заменяет
  старые номера мультитранзакций на новые или, если осталась только одна транзакция, на обычный номер (`xid`).
- Заморозка выполняется для поля `xmax`, так как актуальные версии строк могут постоянно блокироваться новыми транзакциями в разделяемых
  режимах.
- За процесс заморозки отвечают параметры:
    - `vacuum_multixact_freeze_min_age` — минимальный возраст мультитранзакций для заморозки.
    - `vacuum_multixact_freeze_table_age` — возраст таблицы, при котором запускается заморозка.
    - `autovacuum_multixact_freeze_max_age` — максимальный возраст мультитранзакций, при котором автоочистка принудительно запускает
      заморозку.
    - `vacuum_multixact_failsafe_age` (с версии 14) — возраст для экстренной заморозки во избежание сбоев.

**13.4. Очередь ожидания**  
Блокировка строки в PostgreSQL — это лишь признак в заголовке строки, поэтому организация очереди ожидания для строк сложнее, чем для
тяжёлых блокировок. Когда транзакция пытается изменить строку, уже заблокированную в несовместимом режиме, она выполняет следующую
последовательность действий:

1. **Проверка `xmax` и битов**: Если поле `xmax` и информационные биты указывают на несовместимую блокировку, транзакция захватывает *
   *тяжёлую блокировку версии строки** (`tuple lock`, тип `tuple` в `pg_locks`).
2. **Ожидание освобождения**: Транзакция запрашивает тяжёлую блокировку номера транзакции (или мультитранзакции) из `xmax`, чтобы дождаться
   завершения блокирующей транзакции.
3. **Установка новой блокировки**: После освобождения строки транзакция записывает свой номер в `xmax` и устанавливает необходимые
   информационные биты.
4. **Освобождение `tuple lock`**: Если на шаге 1 была захвачена блокировка версии строки, она освобождается.

**Особенности**:

- **Блокировка версии строки** (`tuple lock`) предотвращает состояние гонки, когда несколько транзакций одновременно пытаются обновить одну
  строку после завершения текущей блокирующей транзакции. Без неё могла бы возникнуть ситуация **ресурсного голодания** (starvation), когда
  некоторые транзакции ждут неопределённо долго.
- Очередь ожидания формируется за счёт тяжёлых блокировок типа `tuple` и `transactionid`, что обеспечивает строгую последовательность
  обработки.

**Сценарий работы очереди**:

- Первая транзакция удерживает блокировку строки в режиме `No Key Update`.
- Вторая транзакция, пытаясь обновить ту же строку, захватывает `tuple lock` и запрашивает тяжёлую блокировку номера первой
  транзакции (`ShareLock` на `transactionid`).
- Третья и последующие транзакции, желающие обновить строку, запрашивают `tuple lock`, но, поскольку он уже захвачен второй транзакцией,
  встают в очередь за ней.
- После завершения первой транзакции вторая получает доступ к строке, выполняет обновление и освобождает `tuple lock`.
- Третья транзакция пробуждается, но, если уровень изоляции `Read Committed`, она перечитывает строку и может обнаружить новый `xmax`. В
  этом случае она запрашивает тяжёлую блокировку номера второй транзакции, а `tuple lock` уже не используется. Это может привести к **гонке
  ** за строку между третьей и последующими транзакциями, разрушая строгую очередь.

**Вывод**:

- Очередь ожидания строк работает надёжно только до завершения первой блокирующей транзакции.
- При высокой конкуренции за одну строку (горячая точка) производительность может резко упасть из-за гонок и повторных попыток.
- Для избежания проблем рекомендуется минимизировать одновременные обновления одной строки в параллельных транзакциях.

**13.5. Блокировка без ожидания**  
Обычно команды SQL в PostgreSQL ожидают освобождения необходимых блокировок, что может привести к задержкам. Однако в некоторых случаях
требуется избежать ожидания:

1. **Предложение `NOWAIT`**:
    - Используется в командах `SELECT FOR`, `LOCK`, `ALTER` и других.
    - Если блокировка не может быть получена немедленно, команда завершается с ошибкой (`ERROR: could not obtain lock`).
    - Это полезно в приложениях, где требуется быстрая реакция, а ожидание нежелательно.
    - Для команд `UPDATE` и `DELETE` прямой поддержки `NOWAIT` нет, но можно сначала выполнить `SELECT FOR UPDATE NOWAIT`, а затем обновить
      или удалить строку, если блокировка получена.

2. **Предложение `SKIP LOCKED`**:
    - Используется в `SELECT FOR` для пропуска уже заблокированных строк и обработки только свободных.
    - Полезно для многопоточной обработки очередей или пакетной обработки строк, где не критично, какие именно строки обрабатываются.
    - Применение ограничено задачами обработки очередей; для других целей обычно есть более простые решения.

3. **Тайм-аут блокировки (`lock_timeout`)**:
    - Параметр `lock_timeout` задаёт максимальное время ожидания блокировки (например, `SET lock_timeout = '1s'`).
    - Если блокировка не получена в течение указанного времени, команда завершается с
      ошибкой (`ERROR: canceling statement due to lock timeout`).
    - Может устанавливаться на уровне сеанса, транзакции или отдельной команды.
    - Отличается от `statement_timeout`, который ограничивает общее время выполнения команды, а не только ожидание блокировки.
    - Полезно для предотвращения длительных блокировок в нагруженных системах, позволяя повторять команду позже.

**13.6. Взаимоблокировки**  
**Взаимоблокировка** (deadlock) возникает, когда несколько транзакций блокируют друг друга, образуя циклическую зависимость. Например:

- Транзакция T1 удерживает ресурс A и ждёт ресурс B.
- Транзакция T2 удерживает ресурс B и ждёт ресурс A.

В PostgreSQL взаимоблокировки отслеживаются с помощью **графа ожиданий**, где:

- Вершины — процессы (или транзакции, так как обычно процесс выполняет одну транзакцию).
- Рёбра — зависимости, где процесс ждёт ресурс, удерживаемый другим процессом.
- Цикл в графе указывает на взаимоблокировку.

**Обнаружение и обработка**:

- Когда процесс не может захватить блокировку, он встаёт в очередь и засыпает. При этом устанавливается таймер на `deadlock_timeout` (по
  умолчанию 1 секунда).
- Если по истечении времени ожидание продолжается, процесс инициирует проверку взаимоблокировок, строя граф ожиданий.
- Проверка требует остановки всех операций с тяжёлыми блокировками, чтобы зафиксировать текущее состояние.
- Если цикл обнаружен, одна из транзакций прерывается (обычно та, что инициировала проверку, но автоочистка имеет меньший приоритет, если не
  выполняет заморозку).
- Ошибка фиксируется в журнале сервера, а счётчик `deadlocks` в `pg_stat_database` увеличивается.

**Взаимоблокировки при обновлении строк**:

- Основная причина — **разный порядок блокировки строк**. Например, одна транзакция обновляет строки в порядке возрастания идентификаторов,
  а другая — в обратном порядке.
- Команды `UPDATE` и `DELETE` блокируют строки последовательно, а не все сразу, что может привести к взаимоблокировкам, если планы
  выполнения используют разные порядки сканирования (например, последовательное сканирование против индексного).

**Пример сценария**:

- Транзакция T1 обновляет строку `(0,1)`, затем пытается обновить `(0,2)`.
- Транзакция T2 обновляет строку `(0,2)`, затем пытается обновить `(0,1)`.
- Каждая транзакция ждёт завершения другой, формируя цикл.

**Профилактика**:

- Всегда блокируйте строки в одном и том же порядке (например, по возрастанию идентификаторов).
- Используйте `NOWAIT` или `lock_timeout` для избежания длительного ожидания.
- Мониторьте `pg_stat_database` и журнал сервера для выявления частых взаимоблокировок, что указывает на проблемы в дизайне приложения.

**14. Блокировки разных объектов**

**14.1. Блокировки неотношений**  
В PostgreSQL для ресурсов, не являющихся отношениями (таблицами, индексами и т.д.), используются **тяжёлые блокировки типа `object`**. Эти блокировки применяются к объектам системного каталога, таким как табличные пространства, подписки, схемы, роли, политики и перечислимые типы данных.

**Механизм**:
- Блокируемый ресурс идентифицируется тремя полями в представлении `pg_locks`:
    - `database`: OID базы данных (или 0 для общих объектов кластера).
    - `classid`: OID таблицы системного каталога (из `pg_class`), определяющей тип ресурса (например, `pg_namespace` для схем).
    - `objid`: OID конкретного объекта в указанной таблице системного каталога.
- Пример: создание таблицы в транзакции блокирует схему (например, `public`) в режиме `AccessShareLock`, чтобы предотвратить её удаление до завершения транзакции.
- При удалении объектов захватываются **исключительные блокировки** как самого объекта, так и всех зависимых объектов (см. `backend/catalog/dependency.c`).

**Пример**:
```sql
BEGIN;
CREATE TABLE example(n integer);
SELECT database, (SELECT datname FROM pg_database WHERE oid = database) AS dbname,
       classid, (SELECT relname FROM pg_class WHERE oid = classid) AS classname,
       objid, mode, granted
FROM pg_locks
WHERE locktype = 'object' AND pid = pg_backend_pid();
```
**Результат**:
```
database | 16391
dbname   | internals
classid  | 2615
classname | pg_namespace
objid    | 2200
mode     | AccessShareLock
granted  | t
```
Здесь заблокирована схема `public` (OID 2200 в `pg_namespace`). После завершения транзакции (`ROLLBACK`) блокировка снимается.

**14.2. Блокировки расширения отношения**  
Когда таблица или индекс растёт, PostgreSQL добавляет новые страницы в конец файла-сегмента. Чтобы предотвратить одновременное добавление страниц несколькими процессами, используется тяжёлая блокировка типа `extend`.

**Особенности**:
- Применяется для операций расширения таблиц и очистки индексов.
- Снимается сразу после завершения операции, не дожидаясь конца транзакции.
- Не участвует в графе ожиданий для обнаружения взаимоблокировок, чтобы избежать ненужных проверок.
- Однако, если ожидание блокировки `extend` превышает `deadlock_timeout` (по умолчанию 1 секунда), проверка взаимоблокировок всё равно запускается, что может замедлить систему при высокой нагрузке вставок.

**Оптимизация**:
- Таблицы расширяются сразу на несколько страниц (до 64, в зависимости от числа ожидающих процессов), чтобы уменьшить частоту блокировок (см. `backend/access/heap/hio.c`).
- Для B-дерева индексы расширяются по одной странице за раз (см. `backend/access/nbtree/nbtpage.c`).

**Проблемы**:
- При большом количестве параллельных вставок конкуренция за блокировку `extend` может стать узким местом, вызывая многократные проверки взаимоблокировок и снижая производительность.

**14.3. Блокировки страниц**  
Тяжёлая блокировка типа `page` используется только для **GIN-индексов** в специфическом сценарии.

**Контекст**:
- GIN-индексы (Generalized Inverted Index) оптимизированы для поиска элементов в составных значениях (например, слов в текстовых документах).
- При добавлении новой записи индекс перестраивается, добавляя каждое слово в структуру (B-дерево).
- Для повышения производительности используется **отложенная вставка** (`fastupdate = on`), где новые элементы сначала добавляются в неупорядоченный список ожидания (`pending list`), а затем переносятся в основную структуру индекса.

**Блокировка**:
- Чтобы предотвратить одновременный перенос данных из списка ожидания в индекс несколькими процессами, метастраница индекса блокируется в **исключительном режиме**.
- Эта блокировка не мешает обычному использованию индекса (поиск, вставка в список ожидания).
- Как и блокировка `extend`, она снимается сразу после завершения операции и не участвует в графе ожиданий для взаимоблокировок.

**14.4. Рекомендательные блокировки**  
**Рекомендательные блокировки** (`advisory locks`) — это тяжёлые блокировки, которые не устанавливаются автоматически PostgreSQL, а управляются разработчиком приложения. Они предназначены для реализации нестандартной логики блокирования ресурсов, не связанных с объектами базы данных.

**Особенности**:
- Ресурс идентифицируется числовым идентификатором, например, хеш-кодом имени ресурса (функция `hashtext`).
- Поддерживаются функции управления:
    - `pg_advisory_lock` — захват исключительной блокировки.
    - `pg_advisory_lock_shared` — захват разделяемой блокировки.
    - `pg_advisory_try_lock` — попытка захвата без ожидания.
    - `pg_advisory_unlock` — освобождение блокировки.
    - Суффикс `xact` указывает, что блокировка действует до конца транзакции (иначе — до конца сеанса).
- Блокировки отображаются в `pg_locks` с типом `advisory`.

**Пример**:
```sql
BEGIN;
SELECT pg_advisory_lock(hashtext('ресурс1'));
SELECT locktype, objid, mode, granted
FROM pg_locks WHERE locktype = 'advisory' AND pid = pg_backend_pid();
```
**Результат**:
```
locktype | objid      | mode           | granted
---------+------------+----------------+---------
advisory | 243773337  | ExclusiveLock  | t
```
- Блокировка сохраняется после `COMMIT`, если не использован суффикс `xact`.
- Освобождается явно с помощью `pg_advisory_unlock(hashtext('ресурс1'))`.

**Применение**:
- Рекомендательные блокировки полезны для синхронизации доступа к внешним ресурсам или для реализации пользовательской логики блокирования.
- Требуется, чтобы все процессы следовали единому порядку захвата блокировок, иначе синхронизация не гарантируется.

**14.5. Предикатные блокировки**  
**Предикатные блокировки** в PostgreSQL используются для реализации уровня изоляции **Serializable** на основе протокола **Serializable Snapshot Isolation (SSI)**. Они не блокируют данные в традиционном смысле, а отслеживают зависимости между транзакциями для предотвращения аномалий сериализации, таких как несогласованная запись и аномалия только читающей транзакции.

**Контекст**:
- На уровне `Repeatable Read` изоляция на основе снимков допускает некоторые аномалии, которые исключаются на уровне `Serializable`.
- Для этого SSI отслеживает два типа зависимостей:
    - **RW-зависимости** (чтение одной транзакцией строки, изменённой другой).
    - **WR-зависимости** (изменение строки одной транзакцией, прочитанной другой).
- WR-зависимости отслеживаются через обычные блокировки, а RW-зависимости — через предикатные блокировки.

**Механизм**:
- Предикатные блокировки устанавливаются автоматически при уровне изоляции `Serializable` и отображаются в `pg_locks` с режимом `SIReadLock`.
- Они не блокируют доступ, а лишь регистрируют, какие данные были прочитаны, чтобы при фиксации транзакции проверить граф зависимостей на наличие аномалий. Если аномалия обнаружена, транзакция прерывается с ошибкой сериализации.
- Для работы SSI важно, чтобы все взаимосвязанные транзакции использовали уровень `Serializable`, иначе защита от аномалий может быть нарушена (вырождение до `Repeatable Read`).

**15. Блокировки в памяти**

**15.1. Спин-блокировки**  
**Спин-блокировки** (spinlocks) — это простейший вид лёгких блокировок, используемых в PostgreSQL для защиты структур данных в разделяемой оперативной памяти.

**Особенности**:
- **Цель**: Защищают небольшие участки памяти от одновременного изменения, удерживаются на очень короткое время (несколько инструкций процессора).
- **Реализация**: Основаны на атомарных инструкциях процессора (например, `compare-and-swap`, см. `backend/storage/lmgr/s_lock.c`).
- **Режим**: Только исключительный (один процесс за раз).
- **Ожидание**: Если блокировка занята, процесс выполняет **активное ожидание** (цикл повторения попыток захвата, «спин»), пока блокировка не освободится. При длительном ожидании процесс временно приостанавливается.
- **Плюсы**: Минимальные накладные расходы, подходят для сценариев с низкой вероятностью конфликтов.
- **Минусы**:
    - Не поддерживают обнаружение взаимоблокировок.
    - Нет средств мониторинга (не отображаются в `pg_locks` или других представлениях).
- **Применение**: Ответственность за корректное использование лежит на разработчиках PostgreSQL, для прикладных разработчиков спинлоки прозрачны.

**15.2. Лёгкие блокировки**  
**Лёгкие блокировки** (lightweight locks, lwlocks) — более сложный механизм, используемый для защиты структур данных в разделяемой памяти на время операций, таких как доступ к хеш-таблицам или спискам указателей.

**Особенности**:
- **Время удержания**: Обычно короткое, но может быть дольше при операциях ввода-вывода.
- **Режимы**:
    - **Исключительный**: Для изменения данных.
    - **Разделяемый**: Для чтения данных, допускает одновременный доступ несколькими процессами.
- **Очередь ожидания**:
    - Поддерживается очередь для процессов, ожидающих исключительный режим.
    - Процессы, запрашивающие разделяемый режим, проходят **вне очереди**, что в системах с высокой нагрузкой может приводить к **ресурсному голоданию** (см. обсуждение на форуме PostgreSQL).
- **Мониторинг**: Лёгкие блокировки видны в представлении `pg_stat_activity` (столбцы `wait_event_type` и `wait_event`).
- **Ограничения**: Не поддерживают обнаружение взаимоблокировок, корректность использования обеспечивается разработчиками PostgreSQL.

**16. Этапы выполнения запросов**

### Этап 1: Парсинг (Parsing / Синтаксический анализ)

**Суть в одном предложении:** Проверка синтаксической корректности SQL-запроса, без понимания его смысла.

**Что происходит:**
1.  **Лексический анализ:** Запрос разбивается на отдельные "слова" — токены (`SELECT`, `*`, `FROM`, `users`, `WHERE`, `id`, `=`, `10`).
2.  **Синтаксический анализ:** Проверяется, что токены расположены в правильном порядке, согласно грамматике SQL. Конструкция `SELECT ... FROM ... WHERE` корректна, а `FROM ... SELECT ... WHERE` — нет.

**Результат этапа:** **Дерево разбора (Parse Tree).** Это иерархическая структура, которая просто представляет синтаксис вашего запроса. На этом этапе PostgreSQL еще не знает, существует ли таблица `users` или столбец `id`.


### Этап 2: Анализ и Переписывание (Analysis & Rewrite)

**Суть в одном предложении:** Проверка смысловой корректности запроса и его преобразование в стандартную внутреннюю форму.

**Что происходит:**
1.  **Семантический анализ:** PostgreSQL обращается к системному каталогу и проверяет:
    *   Существуют ли таблицы и представления (views), упомянутые в запросе (`users`).
    *   Существуют ли столбцы (`id`).
    *   Совпадают ли типы данных (например, что `id` можно сравнить с числом `10`).
2.  **Разрешение имен:** Символ `*` заменяется на реальный список столбцов таблицы. Имена без указания таблицы (просто `id`) соотносятся с конкретной таблицей.
3.  **Переписывание (Rewrite):** Это очень важный шаг. Если ваш запрос обращается к представлению (`VIEW`), то здесь его определение подставляется в основной запрос. Также на этом этапе применяются правила (Rules), если они созданы в базе.

**Результат этапа:** **Дерево запроса (Query Tree).** Это детальное, семантически проверенное представление того, **ЧТО** нужно сделать. Оно содержит всю информацию об объектах, операциях и условиях.


### Этап 3: Планирование и Оптимизация (Planning & Optimization)

**Суть в одном предложении:** Найти самый дешевый способ выполнить запрос. Это "мозг" всей системы.

**Что происходит:**
1.  **Генерация планов:** Планировщик берет Дерево запроса и генерирует множество **возможных планов выполнения**. Например, для соединения двух таблиц он рассмотрит `Nested Loop`, `Hash Join` и `Merge Join`. Для фильтрации он рассмотрит `Seq Scan` и различные виды `Index Scan`.
2.  **Оценка стоимости:** Для **каждого** сгенерированного плана планировщик рассчитывает его **оценочную стоимость**. Он использует статистику, собранную командой `ANALYZE` (размер таблиц, распределение данных в столбцах, наличие индексов), чтобы предсказать, сколько операций чтения с диска и процессорного времени потребует каждый шаг плана.
3.  **Выбор лучшего плана:** Выбирается план с **наименьшей итоговой стоимостью**.

**Результат этапа:** **План выполнения (Execution Plan).** Это пошаговая инструкция для исполнителя, как именно, в каком порядке и какими методами получить данные. Это именно то, что вы видите в выводе `EXPLAIN`.


### Этап 4: Исполнение (Execution)

**Суть в одном предложении:** Механическое выполнение инструкций из плана.

**Что происходит:**
*   Модуль-исполнитель (Executor) берет План выполнения и просто следует ему, как рецепту.
*   Он не принимает никаких решений. Если план говорит "использовать `Seq Scan`", он будет использовать `Seq Scan`, даже если это очевидно неэффективно.
*   Он выполняет сканирование таблиц, строит хэш-таблицы, сортирует данные, объединяет строки и, наконец, формирует итоговый набор данных.

**Результат этапа:** **Набор строк (Result Set),** который отправляется клиенту.



**17. Статистика**

**Статистика** — это метаданные о содержимом базы данных, которые PostgreSQL использует для оценки характеристик данных

## Как собирается статистика?

Статистика в PostgreSQL собирается с помощью команды `ANALYZE` или автоматически процессом **autovacuum**.

### Команда `ANALYZE`
- **Описание**: `ANALYZE` сканирует таблицу или её часть, собирает статистику о содержимом и обновляет системный каталог `pg_statistic`.
- **Синтаксис**:
  ```sql
  ANALYZE [VERBOSE] [table_name [(column_name, ...)]];
  ```
    - Без указания таблицы `ANALYZE` обновляет статистику для всей базы данных.
    - Можно указать конкретные таблицы или столбцы.
    - `VERBOSE` выводит подробный отчёт о процессе.

- **Что собирается**:
    - Количество строк (`pg_class.reltuples`).
    - Размер таблицы (`pg_class.relpages`).
    - Гистограммы распределения значений для столбцов.
    - Наиболее частые значения (MCV, Most Common Values) и их частоты.
    - Количество уникальных значений (`n_distinct`).
    - Корреляция между физическим порядком строк и значениями столбца (для оценки эффективности индексов).


### Autovacuum и статистика
- Процесс `autovacuum` автоматически запускает `ANALYZE` для таблиц, в которых произошли значительные изменения (например, после множества `INSERT`, `UPDATE`, `DELETE`).
- Порог для запуска определяется параметрами:
    - `autovacuum_analyze_scale_factor`: Доля изменённых строк (по умолчанию 0.1, т.е. 10%).
    - `autovacuum_analyze_threshold`: Минимальное количество изменённых строк (по умолчанию 50).

## Где хранится статистика?

Статистика сохраняется в системных каталогах:
- **`pg_statistic`**: Основной каталог, содержащий детализированные данные о распределении значений, гистограммах и MCV. Доступен только суперпользователям.
- **`pg_stats`**: Представление, упрощающее доступ к статистике для обычных пользователей. Содержит человеко-читаемые данные

## Как используется статистика?

Оптимизатор запросов PostgreSQL (query planner) использует статистику для:
1. **Оценки стоимости запроса**:
    - Выбор между последовательным сканированием (`Seq Scan`), индексным сканированием (`Index Scan`) или другими методами.
    - Оценка количества строк, которые вернёт запрос (селективность).
2. **Выбора алгоритма соединения**:
    - Например, если статистика показывает, что в таблице мало уникальных значений, оптимизатор может выбрать Hash Join вместо Nested Loop.
3. **Оптимизации условий**:
    - Для условий в `WHERE` или `JOIN` статистика помогает оценить, сколько строк будет отфильтровано.
    - Например, для `WHERE age > 30` гистограмма значений столбца `age` покажет, сколько строк удовлетворяет условию.

    
##  Типы статистических данных

PostgreSQL собирает следующие типы статистики для каждого столбца:
- **Доля строк с `NULL`** (`null_frac`): Показывает, насколько часто столбец содержит `NULL`.
- **Средняя длина значений** (`avg_width`): Используется для оценки затрат на чтение данных.
- **Количество уникальных значений** (`n_distinct`):
    - Положительное значение: Оценка числа уникальных значений.
    - Отрицательное значение (например, `-0.5`): Доля строк с уникальными значениями (50% строк уникальны).
- **Наиболее частые значения** (`most_common_vals`, `most_common_freqs`): Список самых популярных значений и их частота.
- **Гистограмма** (`histogram_bounds`): Распределение значений для столбцов с непрерывными данными (например, числовых или временных).
- **Корреляция** (`correlation`): Оценивает, насколько физический порядок строк соответствует порядку значений в столбце (от -1 до 1). Важно для индексов B-tree.


**18. Табличные методы доступа**

### Последовательное сканирование (Sequential Scan / Seq Scan)

**Суть в одном предложении:** Это самый простой и прямолинейный способ прочитать таблицу — от самого первого байта до самого последнего, строка за строкой.

**Аналогия:** Чтение книги от первой до последней страницы без использования оглавления.

**Как работает:**
1.  Один рабочий процесс (backend process) PostgreSQL находит первый блок данных (страницу) таблицы на диске.
2.  Он загружает этот блок в память.
3.  Он проверяет каждую строку на этой странице, соответствует ли она условиям `WHERE` вашего запроса (если они есть).
4.  Подходящие строки возвращаются.
5.  Процесс переходит к следующему блоку и повторяет шаги 2-4, пока не достигнет конца файла таблицы.

**Когда используется (и это эффективно):**
*   **Когда нужно прочитать всю таблицу или большую её часть.** Например, для запроса `SELECT sum(amount) FROM payments`. Нет смысла использовать индекс, если нужно обработать все записи.
*   **Когда условие `WHERE` очень неселективно.** Например, `WHERE active = true`, если 95% пользователей активны. Прочитать всю таблицу один раз последовательно гораздо быстрее, чем миллионы раз прыгать между индексом и таблицей.
*   **На очень маленьких таблицах.** Если таблица занимает всего несколько страниц на диске, PostgreSQL почти всегда выберет `Seq Scan`, так как накладные расходы на использование индекса будут выше, чем простое чтение всей таблицы.

**Сильные стороны:**
*   **Эффективное чтение с диска:** Последовательное чтение — самая быстрая операция для жестких дисков (HDD) и достаточно быстрая для SSD.
*   **Простота и надежность:** Нет сложных алгоритмов, предсказуемое поведение.

**Слабые стороны:**
*   **Катастрофически неэффективен для поиска малого числа строк** в большой таблице (`WHERE id = 12345`).

###  Параллельное последовательное сканирование (Parallel Sequential Scan)

**Суть в одном предложении:** Разделение работы по чтению одной большой таблицы между несколькими рабочими процессами для ускорения выполнения.

**Аналогия:** Вы даете одну большую книгу не одному человеку, а **четырем**, и просите каждого прочитать свою четверть книги (главы 1-5, 6-10, 11-15, 16-20) **одновременно**. Общее время чтения сокращается почти в 4 раза.

**Как работает:**
1.  **Лидер (Leader Process):** Основной процесс, который получил ваш запрос, становится "лидером".
2.  **Запуск рабочих (Workers):** Лидер запрашивает у PostgreSQL несколько дополнительных **параллельных рабочих процессов** (parallel workers) из специального пула. Количество рабочих определяется настройками (`max_parallel_workers_per_gather`).
3.  **Разделение работы:** Таблица динамически "разрезается" на несколько частей (диапазонов блоков). Каждый рабочий процесс (включая лидера) получает свою часть для сканирования.
4.  **Одновременное сканирование:** Все рабочие **одновременно** выполняют `Seq Scan` на своем участке таблицы.
5.  **Сбор результатов (`Gather`):** Лидер ожидает, пока все рабочие закончат свою работу, и **собирает** (`Gather` или `Gather Merge`) результаты от них в единый поток, который затем возвращается клиенту.

**Когда используется:**
*   Только для **достаточно больших таблиц**. Запускать параллельное выполнение для маленькой таблицы не имеет смысла — накладные расходы на запуск рабочих и координацию будут выше выгоды. Порог определяется параметром `min_parallel_table_scan_size` (по умолчанию 8 МБ).
*   Когда запрос потребляет значительное количество CPU. Параллелизм в первую очередь ускоряет задачи, ограниченные процессорной мощностью (CPU-bound), а не дисковым вводом-выводом (I/O-bound).
*   Внутри запроса не должно быть функций, помеченных как `PARALLEL UNSAFE`.

**Сильные стороны:**
*   **Значительное ускорение:** Может сократить время выполнения долгих аналитических запросов на больших таблицах в несколько раз (почти линейно от количества ядер CPU).

**Слабые стороны:**
*   **Потребление ресурсов:** Каждый рабочий процесс — это полноценный процесс ОС, который потребляет память и CPU. Агрессивный параллелизм на системе с высокой нагрузкой может ухудшить общую производительность.
*   **Накладные расходы:** Есть издержки на запуск, координацию и сбор результатов.


**Вывод:**
*   `Seq Scan` — это базовый, но очень эффективный инструмент для чтения больших объемов данных.
*   `Parallel Seq Scan` — это его "турбированная" версия для больших таблиц на многоядерных системах, которая является основой для быстрого выполнения аналитических запросов в PostgreSQL.


**19. Индексные методы доступа**

**19.1. Индексы и расширяемость**  
Индексы — вспомогательные структуры базы данных, ускоряющие доступ к данным и поддерживающие ограничения целостности. Их можно удалить и восстановить по данным таблицы.

**Типы индексов** (`pg_am`, `amtype = 'i'`):
```sql
SELECT amname FROM pg_am WHERE amtype = 'i';
```
**Результат**:
```
amname
-------
btree
hash
gist
gin
spgist
brin
```
- Расширяемость: новые методы доступа добавляются без изменения ядра (например, `bloom` в стандартных расширениях).
- Индексы устанавливают соответствие между ключом (значение столбца) и идентификаторами версий строк (`TID`, 6 байт).

**Механизм индексирования**:
- Основная задача: получение `TID` от метода доступа и работа с ними:
    - Чтение строк из таблицы.
    - Проверка видимости в снимке данных (см. стр. 97).
    - Перепроверка условий, если метод не гарантирует их выполнение.
- Интерфейс (`backend/access/index/indexam.c`):
    - Построение индекса, вставка/удаление строк.
    - Разбиение данных по страницам (для буферного кеша, см. стр. 179).
    - Очистка индекса (см. стр. 125).
    - Установка блокировок (см. стр. 295).
    - Формирование журнала предзаписи (WAL, см. стр. 201).
    - Поиск по ключу.
    - Оценка стоимости.
- Оптимизатор учитывает свойства методов:
    - Возможность сортировки результата.
    - Возможность частичного возврата данных.
    - Поддержка уникальности или составных индексов.

**Расширяемость типов данных**:
- Методы доступа поддерживают новые типы через классы операторов (`pg_opclass`), включающие операторы и опорные функции.
- Логика разделена: часть в методе доступа, часть в классе операторов.



**20. Индексное сканирование**

**20.1. Index Scan (Классическое индексное сканирование)**

**Суть в одном предложении:** Поочередная работа: найти одну запись в индексе, затем найти соответствующую ей строку в таблице, и так для каждого совпадения.

**Как работает:**
1.  PostgreSQL обращается к индексу (например, B-Tree) и находит в нем первую запись, удовлетворяющую условию `WHERE`.
2.  Из этой записи он извлекает **TID** — физический адрес строки в основной таблице (в файле "кучи").
3.  Он "прыгает" по этому адресу в файл таблицы и извлекает оттуда полную строку.
4.  Затем он возвращается в индекс, чтобы найти **следующую** подходящую запись, и повторяет шаги 2 и 3.

**Ключевая особенность:** Это похоже на то, как человек ищет слова в словаре: нашел слово, прочитал определение, вернулся к списку слов.

*   **Сильная сторона:** Очень низкая "цена запуска". Он начинает возвращать первые строки почти мгновенно, что идеально для запросов с `LIMIT 1` или для быстрого поиска уникального значения (`WHERE id = 123`).
*   **Слабая сторона:** Если по условию находится много строк (например, тысячи), это приводит к тысячам хаотичных "прыжков" между файлом индекса и файлом таблицы. Такое **случайное чтение с диска** очень неэффективно.

**Когда используется:** Когда нужно найти очень небольшое количество строк, и селективность запроса высока.

**20.2. Index-Only Scan (Сканирование только по индексу)**

**Суть в одном предложении:** Получить все необходимые данные напрямую из индекса, полностью игнорируя основную таблицу.

**Как работает:**
1.  Планировщик видит, что все столбцы, запрашиваемые в `SELECT` и используемые в `WHERE`, **уже содержатся в самом индексе**. (Это возможно для составных индексов или с помощью `INCLUDE`).
2.  Он находит нужные данные, как в обычном Index Scan, но вместо того, чтобы брать TID и идти в таблицу...
3.  ...он проверяет **карту видимости (Visibility Map)**. Это специальная структура, которая сообщает, все ли строки на данной странице диска "стары" и точно видны всем транзакциям.
4.  Если карта видимости это подтверждает, PostgreSQL просто возвращает данные прямо из индекса. Ходить в основную, "тяжелую" таблицу не нужно.

**Ключевая особенность:** Это вершина оптимизации чтения. Читается только компактная структура индекса.

*   **Сильная сторона:** Максимальная производительность. Исключаются любые обращения к основной таблице, что экономит огромное количество дисковых операций.
*   **Слабая сторона:** Требует специальной подготовки — индекс должен "покрывать" запрос. Если карта видимости устарела (из-за недавних `UPDATE` или `DELETE`), PostgreSQL может быть вынужден всё же обращаться к таблице для проверки видимости строк, и сканирование "деградирует" до обычного Index Scan.

**Когда используется:** Для идеально оптимизированных запросов, где индекс полностью покрывает все потребности запроса.

**20.3. Bitmap Index Scan (Сканирование по битовой карте)**

**Суть в одном предложении:** Двухэтапная стратегия: сначала составить в памяти "карту" всех нужных строк, а затем за один последовательный проход собрать их из таблицы.

Это всегда процесс из двух частей:

**Шаг 1: Bitmap Index Scan**
1.  PostgreSQL сканирует один или **несколько** индексов.
2.  Вместо того чтобы сразу извлекать строки, он создает в памяти **битовую карту (bitmap)**. Это массив битов, где каждый бит соответствует странице данных в таблице. Если на странице есть нужная строка, бит устанавливается в '1'.
3.  **Главное преимущество:** Если в `WHERE` есть несколько условий по разным индексам (`col1 > 100 AND col2 = 'A'`), PostgreSQL может построить две битовые карты и мгновенно объединить их в памяти с помощью логической операции `AND`.

**Шаг 2: Bitmap Heap Scan**
1.  PostgreSQL берет итоговую битовую карту.
2.  Теперь он сканирует **основную таблицу**, но не целиком, а только те страницы, которые отмечены в карте.
3.  Важно, что он читает эти страницы **в физическом порядке, как они лежат на диске**.

**Ключевая особенность:** Этот метод превращает множество медленных случайных чтений (как в Index Scan) в одно быстрое последовательное чтение.

*   **Сильная сторона:** Идеален для запросов, которые возвращают "среднее" количество строк (слишком много для Index Scan, но слишком мало для Seq Scan). Незаменим для сложных условий `WHERE` с `AND`/`OR` по разным индексам.
*   **Слабая сторона:** Есть накладные расходы на создание битовой карты. Он не начнет возвращать строки, пока вся карта не будет построена, поэтому для `LIMIT 1` он медленнее, чем обычный Index Scan.

**Когда используется:** Когда запрос не очень селективен или содержит сложные комбинации условий по разным индексированным столбцам.

**21. Вложенный цикл**

**21.1. Виды и способы соединений**  
Соединения — ключевая операция SQL, позволяющая объединять пары наборов строк (таблиц или результатов операций).

**Виды соединений**:
1. **Внутренние соединения** (`INNER JOIN` или `JOIN`):
    - Включают пары строк, удовлетворяющие условию соединения.
    - **Эквисоединение**: условие требует равенства столбцов (наиболее частый случай).
    - **Декартово произведение** (`CROSS JOIN`): все возможные пары строк (условие всегда истинно).
2. **Внешние соединения**:
    - **Левое внешнее** (`LEFT OUTER JOIN`): включает строки левого набора, даже без соответствия в правом (столбцы правого набора — `NULL`).
    - **Правое внешнее** (`RIGHT JOIN`): аналогично, для правого набора.
    - **Полное внешнее** (`FULL JOIN`): объединяет левое и правое, включая строки без соответствия с обеих сторон.
3. **Полусоединения**: строки первого набора, для которых есть хотя бы одно соответствие во втором (например, `EXISTS`).
4. **Антисоединения**: строки первого набора, для которых нет соответствия во втором (например, `NOT EXISTS`).

**Способы соединений** (алгоритмы в PostgreSQL):
- Вложенный цикл (`Nested Loop`).
- Соединение хешированием (`Hash Join`).
- Соединение слиянием (`Merge Join`).
- Каждый способ поддерживает разные виды соединений:
    - `Nested Loop`: внутренние, левые внешние, полу- и антисоединения.
    - Не поддерживает полные и правые внешние соединения.
- Планировщик выбирает способ по стоимости (`backend/optimizer/path/joinpath.c`).

Отлично, давайте разберем три основных способа соединения таблиц в PostgreSQL — кратко, по сути и с акцентом на то, почему планировщик выбирает тот или иной метод.

Это не команды, которые вы пишете (`LEFT JOIN` и т.д.), а внутренние **алгоритмы**, которые PostgreSQL использует для выполнения этих команд. Выбор алгоритма — ключевой фактор производительности запроса.

### 1. Nested Loop Join (Соединение вложенными циклами)

**Суть в одном предложении:** Самый простой и интуитивный способ, похожий на два вложенных цикла `for` в программировании.

**Как работает:**
1.  Берется **первая** строка из внешней таблицы (обычно той, что меньше).
2.  Для этой строки **полностью сканируется** вся внутренняя (вторая) таблица в поиске совпадений по условию `JOIN`.
3.  Найденные совпадения возвращаются.
4.  Процесс повторяется для **каждой** строки из внешней таблицы.

**Ключевая оптимизация (Index Nested Loop):** Если на столбце соединения во **внутренней** таблице есть **индекс**, то вместо полного сканирования (шаг 2) происходит сверхбыстрый поиск по индексу. Это превращает неэффективный алгоритм в очень эффективный.

**Когда используется:**
*   **Идеальный сценарий:** Одна из таблиц очень маленькая (например, 1-10 строк), а на второй есть индекс по ключу соединения.
*   Когда нужно очень быстро получить первые несколько строк результата (например, с `LIMIT 10`), так как Nested Loop начинает выдавать результат сразу, не дожидаясь полной обработки.

---

### 2. Hash Join (Соединение через хэш-таблицу)

**Суть в одном предложении:** Создание в памяти "картотеки" (хэш-таблицы) для одной таблицы, чтобы потом быстро находить в ней записи из второй таблицы.

**Как работает (два этапа):**
1.  **Фаза построения (Build):**
    *   PostgreSQL выбирает **меньшую** из двух таблиц.
    *   Он считывает её целиком и на основе ключа соединения строит в оперативной памяти **хэш-таблицу**. Ключ — это хэш от значения в столбце, а значение — сама строка.
2.  **Фаза проверки (Probe):**
    *   PostgreSQL начинает считывать **вторую (большую) таблицу** строка за строкой.
    *   Для каждой строки он вычисляет хэш от её ключа соединения и моментально проверяет, есть ли такой хэш в построенной таблице.
    *   Если есть — строки совпадают и возвращаются как результат.

**Ключевые особенности:**
*   **Требование к памяти:** Эффективность напрямую зависит от того, поместится ли хэш-таблица от меньшей таблицы в память, выделенную для операций (`work_mem`). Если нет, таблица сбрасывается на диск, что сильно замедляет процесс.
*   **Только для равенства:** Работает только для операций экви-соединения (`table1.id = table2.id`). Не работает для `>` или `<`.
*   **Высокая цена запуска:** Результат не будет возвращен, пока вся хэш-таблица не будет построена (фаза 1). Поэтому для запросов с `LIMIT` он может быть медленнее, чем Nested Loop.

**Когда используется:**
*   **Идеальный сценарий:** Соединение двух больших таблиц, где нет подходящих индексов, но меньшая из таблиц помещается в `work_mem`. Это самый частый тип соединения для аналитических запросов.

---

### 3. Merge Join (Соединение слиянием)

**Суть в одном предложении:** Эффективное слияние двух **уже отсортированных** списков (таблиц).

**Как работает:**
1.  **Фаза сортировки (если необходимо):** Обе таблицы должны быть отсортированы по ключу соединения. PostgreSQL может получить отсортированные данные двумя путями:
    *   **Бесплатно:** Если данные уже отсортированы благодаря сканированию по B-Tree индексу.
    *   **Платно:** Если индексов нет, PostgreSQL сначала выполняет явную сортировку обеих таблиц, что является дорогой операцией.
2.  **Фаза слияния (Merge):**
    *   Берутся два "указателя", по одному на начало каждой отсортированной таблицы.
    *   Указатели одновременно движутся вперед. Сравниваются значения, на которые они указывают.
    *   Если значения равны — найдено совпадение, строки возвращаются.
    *   Если нет — указатель в таблице с меньшим значением сдвигается вперед.
    *   Процесс продолжается, пока один из списков не закончится.

**Ключевые особенности:**
*   **Эффективность при больших объемах:** Лучший выбор для соединения двух **очень больших** таблиц, которые не помещаются в память для Hash Join. Сортировка больших объемов данных на диске часто эффективнее, чем дисковый Hash Join.
*   **Универсальность:** В отличие от Hash Join, поддерживает не только равенство (`=`), но и другие операторы (`>`, `<`, `>=` и т.д.).

**Когда используется:**
*   **Идеальный сценарий:** Соединение двух очень больших таблиц, особенно если на ключах соединения уже есть индексы (что дает "бесплатную" сортировку).

### Сводка и как на это влиять

| Способ | Принцип работы | Сильные стороны | Слабые стороны | Главный сценарий использования |
| :--- | :--- | :--- | :--- | :--- |
| **Nested Loop** | Цикл в цикле | Быстрый старт (для `LIMIT`), идеален с индексом на внутренней таблице. | Катастрофически медленный без индекса на больших таблицах (O(N*M)). | Одна из таблиц очень маленькая. |
| **Hash Join** | Хэш-таблица в памяти | Очень быстрый для больших объемов, не требует сортировки. | Требует много памяти (`work_mem`), медленный старт, только для `=`. | Соединение больших таблиц по равенству. |
| **Merge Join** | Слияние 2-х отсортированных наборов | Экономичен по памяти, работает с очень большими данными, поддерживает `>` и `<`. | Требует предварительной сортировки, которая может быть дорогой. | Соединение гигантских таблиц или данных, уже отсортированных по индексу. |

