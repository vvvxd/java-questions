1)Что такое страницы?

В PostgreSQL данные организованы на диске в блоках, которые называются "страницами"

--------------------------------------------------------------------------------------------------------------------
2)Что такое версии строке?

Перед специальной областью располагаются строки (rows) — те самые данные, которые хранятся в базе, с добавлением некоторой служебной информации.
В случае таблиц мы говорим не просто о строках, а о версиях строк (row versions, tuples), поскольку многоверсионность предполагает существование нескольких версий одной и той же строки. На индексы многоверсионность не распространяется; вместо этого индексы ссылаются на все возможные табличные версии строк, среди которых по правилам видимости выбираются подходящие.

--------------------------------------------------------------------------------------------------------------------
3)Как сохраняются большие данные в PostgreSQL?

В PostgreSQL TOAST (The Oversized-Attribute Storage Technique) — это механизм, используемый для хранения и управления большими значениями данных в базе данных. Этот механизм применяется к столбцам, содержащим значения, которые могут быть слишком большими для хранения в обычном формате страницы. Примерами могут служить длинные текстовые строки, большие объекты (BLOBs), JSON-объекты и др.

Когда размер значения превышает некоторый предопределенный порог (обычно 2 кБ), PostgreSQL автоматически применяет TOAST к этому значению. Процесс TOAST состоит в том, что PostgreSQL сжимает, разделяет и хранит большое значение в специальном формате, который затем может быть обработан более эффективно. При этом сами значения не теряются и могут быть извлечены и использованы без потери данных.

TOAST помогает управлять памятью и улучшает производительность базы данных, позволяя PostgreSQL эффективно работать с большими объемами данных и предотвращать излишнее расходование ресурсов.

--------------------------------------------------------------------------------------------------------------------
4)Что такое snapshot isolation

Snapshot isolation (изоляция снимка) в PostgreSQL — это уровень изоляции транзакций, который гарантирует, что каждая транзакция видит когерентный "снимок" базы данных на момент её начала. Другими словами, транзакция, работающая в режиме изоляции снимка, видит данные, как если бы они были зафиксированы на момент начала транзакции, и изменения, сделанные другими транзакциями после этого момента, не будут видны до завершения текущей транзакции.

--------------------------------------------------------------------------------------------------------------------
5)Почему в PostgreSql нет Read uncommited

Потому что в PostgreSQL используется Snapshot Isolation, который не позволяет видеть данные.

--------------------------------------------------------------------------------------------------------------------
6)Что такое область видимость бд?

Область видимости транзакции (также известная как "scope" или "visibility") в PostgreSQL определяет, какие данные транзакция видит и может изменять в рамках своего выполнения. Область видимости транзакции определяется с помощью изоляции транзакции.

В PostgreSQL существует несколько уровней изоляции транзакций, которые определяют область видимости данных для каждой транзакции.

--------------------------------------------------------------------------------------------------------------------
7)Что такое mvcc?

MVCC (Multi-Version Concurrency Control) в PostgreSQL - это механизм контроля параллельности, который обеспечивает согласованное чтение и запись данных в многопользовательской среде без блокировки всей таблицы или больших диапазонов данных.

Основные принципы MVCC в PostgreSQL:

Множество версий данных: При изменении данных новая версия строки создается с сохранением предыдущей версии. Таким образом, в базе данных могут существовать несколько версий одной и той же строки.

Идентификация версий: Каждая версия строки в PostgreSQL имеет свой собственный идентификатор транзакции (XID), который позволяет определить, когда эта версия была создана и какие транзакции могут её видеть.

Контроль чтения по версиям: При выполнении запросов каждая транзакция видит только те версии данных, которые были зафиксированы на момент начала этой транзакции. Это позволяет избежать блокировок чтения и предотвращает чтение "грязных" данных.

Устранение фантомных чтений: MVCC в PostgreSQL также предотвращает фантомные чтения путем зафиксирования состояния базы данных на момент начала транзакции и гарантируя, что транзакция увидит только те данные, которые существовали на этот момент.

--------------------------------------------------------------------------------------------------------------------
8)Какие уровни памяти в PostgreSQL

Общая память (Shared Memory): Этот уровень памяти используется для обмена данными между различными процессами PostgreSQL и предназначен для хранения общих структур данных, таких как буферы с данными, журналы WAL (Write-Ahead Logging), информация о процессах и т. д.

Буферный кэш (Buffer Cache): Буферный кэш в PostgreSQL используется для кэширования данных, считанных с диска, в оперативной памяти. Это позволяет уменьшить количество обращений к диску и увеличить скорость доступа к данным. Размер буферного кэша настраивается параметром shared_buffers.

Кэш планов (Plan Cache): PostgreSQL также имеет кэш для планов выполнения запросов. Этот кэш хранит планы выполнения запросов, которые ранее были скомпилированы и выполнены, чтобы ускорить выполнение повторяющихся запросов. Размер кэша планов настраивается параметром plan_cache_mode.

Рабочая память (Working Memory): Рабочая память используется в процессе выполнения запросов для сортировки, хеширования, агрегации и других операций. Размер рабочей памяти ограничивается параметрами, такими как work_mem.

Кэш операторов (Operator Cache): Этот кэш хранит информацию о функциях и операторах базы данных, что позволяет избежать повторной компиляции операторов и функций во время выполнения запросов.

Стековая память (Stack Memory): Этот уровень памяти используется для хранения данных о выполнении функций и процедур в рамках сессии PostgreSQL.

--------------------------------------------------------------------------------------------------------------------
9)Что такое Буферный кеш?

Кеширование используется в современных вычислительных системах повсеместно, как на программном, так и на аппаратном уровне. У одного только процессора можно насчитать три-четыре уровня кеша; свой кеш бывает
также и у контроллеров дисковых массивов, и у самих дисков.
Вообще, любой кеш нужен для того, чтобы компенсировать разную производительность двух типов памяти, одна из которых быстрее, но дороже и
меньше по объему, а другая — медленнее, но дешевле и больше. В быстрой
памяти невозможно разместить все данные из медленной памяти. Но в большинстве случаев активная работа ведется одновременно только с небольшой
выборкой, поэтому, выделив часть быстрой памяти под кеш для хранения
«горячих» данных, удается существенно экономить на обращениях к медленному устройству.
Буферный кеш PostgreSQL1
хранит страницы отношений, сглаживая разницу между временем доступа к оперативной памяти (наносекунды) и к дискам (миллисекунды).
Свой кеш, решающий ту же самую задачу, имеется и у операционной системы. Поэтому обычно при проектировании СУБД стараются избегать двойного кеширования, предпочитая обращаться к диску напрямую, минуя кеш ОС.
Но в случае PostgreSQL это не так: все данные читаются и записываются с помощью буферизованных файловых операций.

Буферный кеш располагается в общей памяти сервера и доступен всем процессам. Он занимает б?льшую часть общей памяти и является одной из
самых важных и сложных структур данных. Понимание принципа работы
кеша важно само по себе; к тому же многие другие структуры (такие как
вложенные транзакции, статусы транзакций clog, журнальные записи) используют похожее, хотя и более простое кеширование.
Кеш называется буферным, потому что представляет собой массив буферов.
Каждый буфер резервирует фрагмент памяти, достаточный для одной страницы данных и ее заголовка2

--------------------------------------------------------------------------------------------------------------------
10)Как читается большое количество записей?

Из-за того, что чтение большого количества данных может полностью занять всю оперативную память выделенную для PostgreSQL, 
то применяется специальная структура "зацикленный список", этот список имеет некоторую длину и постоянно вставляет значения в конец списка, из-за этого
количество данных уменьшается.

--------------------------------------------------------------------------------------------------------------------
11)Какие индексы существуют в PostgreSQL.

B-Tree индексы: B-Tree (Balanced Tree) индексы являются самым распространенным типом индексов в PostgreSQL. Они подходят для поиска данных по точному значению, диапазону значений или с использованием операторов сравнения (=, >, <, >=, <=). B-Tree индексы хорошо подходят для большинства запросов и обеспечивают логарифмическое время выполнения операций поиска.

Hash индексы: Hash индексы используются для быстрого поиска данных по точному значению (оператор "="). Они хорошо подходят для равенственных операций, но не поддерживают операции диапазонного поиска или с использованием операторов сравнения. Hash индексы работают эффективно для поиска значений, но не гарантируют порядок результатов.

GiST (Generalized Search Tree) индексы: GiST индексы предназначены для работы с данными, которые имеют многомерную или нестандартную структуру. Они поддерживают различные типы операций, такие как поиск ближайших соседей, текстовый поиск, географические запросы и т. д. GiST индексы могут быть использованы для создания индексов на столбцах, содержащих массивы, JSON-данные, геометрические объекты и другие нестандартные типы данных.

GIN (Generalized Inverted Index) индексы: GIN индексы также предназначены для работы с нестандартными типами данных и поддерживают различные типы запросов, такие как полнотекстовый поиск, поиск по массивам и поиск по JSON-данным. GIN индексы хорошо подходят для создания полнотекстовых индексов и поиска по спискам или множествам.

BRIN (Block Range Index) индексы: BRIN индексы используются для индексации больших таблиц с отсортированными данными, например, временных рядов или таблиц, упорядоченных по дате. Они хранят информацию о минимальных и максимальных значениях диапазонов блоков данных, что позволяет эффективно выполнить операции диапазонного поиска на больших объемах данных.

--------------------------------------------------------------------------------------------------------------------
12)Что такое журналы предзаписи?

Журналы предзаписи (WAL - Write-Ahead Logging) - это техника, используемая в базах данных для обеспечения целостности данных и надежности транзакций. Принцип журналов предзаписи заключается в том, что перед фактической записью данных в файлы данных, изменения записываются в журнальные файлы (WAL-файлы).

В PostgreSQL, когда происходит операция вставки, обновления или удаления данных, эти изменения сначала записываются в журнал, а затем применяются к реальным файлам данных. Это гарантирует, что перед применением изменений к самим данным, они были сохранены в журнале. Если произойдет сбой или отказ системы, PostgreSQL сможет восстановить данные из журнала, применив изменения, которые были предварительно записаны, но еще не применены к файлам данных.

--------------------------------------------------------------------------------------------------------------------
13)Что такое запорозка?

Под номер транзакции в PostgreSQL выделено 32 бита. Четыре миллиарда
выглядит довольно большим числом, но при активной работе оно может
быть израсходовано довольно быстро. Например, при нагрузке 1000 транзакций в секунду (не считая виртуальных) это произойдет всего через полтора месяца непрерывной работы.

Чтобы корректно обрабатывать переполнение счетчика, надо сравнивать не
номера транзакций, а их возраст (выраженный в количестве транзакций,
начатых с момента появления данной транзакции). Таким образом, вместо понятий «меньше» и «больше» используются «предшествует» («старше»)
и «следует за» («младше»).
В коде это естественным образом реализуется 32-битной арифметикой: надо найти разницу 32-битных номеров транзакций и сравнить полученный
результат с нулем1
.
Графически можно представить, что номера транзакций закольцованы. Тогда для любой транзакции половина номеров против часовой стрелки будет
старше (в прошлом), а половина по часовой стрелке — младше (в будущем)


--------------------------------------------------------------------------------------------------------------------