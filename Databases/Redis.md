## **1. Что такое Redis?**

Redis — это база данных, которая хранит всю информацию в оперативной памяти (RAM) компьютера, а не на медленном жестком диске.
Благодаря этому она работает с молниеносной скоростью. Её основная модель — «ключ-значение», как в словаре, где у каждого слова (ключа) есть
своё определение (значение).

---

## **2. Популярные сценарии использования**

* **Кэширование:** Самый частый случай. Хранить результаты «тяжелых» запросов к основной базе или внешним API. Это кардинально ускоряет
  отклик приложения.
* **Очереди сообщений:** Использование списков (`LPUSH`/`BRPOP`) для создания простых, но очень быстрых очередей задач (отправка писем,
  обработка видео).
* **Хранение сессий:** Вместо того чтобы хранить данные сессии пользователя в файлах или в SQL-базе, их кладут в Redis. Это очень быстро и
  легко масштабируется.
* **Аналитика в реальном времени:** Различные счетчики, статистика. Например, подсчет уникальных посетителей сайта в реальном времени с
  помощью `HyperLogLog` (еще одна структура данных Redis).
* **Таблицы лидеров (Leaderboards):** Идеальная задача для упорядоченных множеств (`Sorted Sets`).
* **Pub/Sub (Издатель-подписчик):** Redis может работать как брокер сообщений. Одни клиенты публикуют сообщения в «канал», а другие,
  подписанные на него, мгновенно их получают. Используется в чатах, системах уведомлений.

---

## **3. Redis и CAP-теорема**

**Redis в этом контексте:**

* **Одиночный экземпляр Redis:** К нему теорема не совсем применима, т.к. это не распределенная система. Он одновременно согласован и
  доступен, пока работает. Если он падает, он становится недоступен.

**Redis с репликацией (Master-Slave):**
* По умолчанию это **AP-система (Доступность + Устойчивость к разделению)**. Почему? Репликация асинхронна. Вы записали данные на `Master`,
  и почти сразу получили ответ `OK`. Данные еще не успели скопироваться на `Slave`. Если в этот момент другой клиент прочитает данные
  со `Slave`, он получит старую версию. **Консистентности нет, зато система доступна.**
* Можно настроить его как **CP-систему (Согласованность + Устойчивость)**. Используя команду `WAIT`, можно заставить `Master` ждать
  подтверждения записи от определенного числа `Slave`. В этом случае, если `Slave` недоступны, `Master` не сможет подтвердить запись и
  вернет ошибку или будет ждать. **Доступность страдает, зато данные консистентны.**

**Redis Cluster (Шардирование):**
* Это тоже **AP-система**. Кластер спроектирован так, чтобы оставаться доступным, даже если часть узлов выходит из строя. В момент сбоя
  мастер-узла и выбора нового мастера (failover) будет короткое окно, когда часть данных недоступна, но система в целом продолжает работать.
  Она жертвует строгой согласованностью и частичной доступностью в момент сбоя ради общей работоспособности.

---

## 4. Структуры данных

#### **Strings (Строки)**

Самый базовый тип данных в Redis. По сути, это классическая пара `ключ: значение`, где значением может быть что угодно:
текст, число, бинарные данные, сериализованный объект в формате JSON и т.д. Максимальный размер значения — 512 МБ.

* **Где использовать:**

1. **Кэширование:** Идеально для кэширования HTML-страниц, ответов API, результатов сложных SQL-запросов.
2. **Счетчики:** Атомарные операции `INCR`/`DECR` делают строки идеальным решением для всевозможных счетчиков (просмотры страницы,
   количество лайков, оставшийся товар на складе). Атомарность гарантирует, что даже при тысячах одновременных запросов значение счетчика
   будет корректным.

Сила в простоте и атомарных операциях. Вместо того чтобы в приложении делать "прочитай-измени-запиши" для счетчика, вы отправляете одну
быструю команду `INCR`, и Redis все делает сам, безопасно и мгновенно.

---

#### **Lists (Списки)**

Упорядоченная коллекция строк, по сути — двусвязный список. Элементы можно быстро добавлять и удалять как в начало, так и в
конец списка (операции за O(1)).

* **Где использовать:**

1. **Очереди задач (FIFO - First-In, First-Out):** Один процесс (продюсер) добавляет задачи в конец списка (`LPUSH`), а другой (воркер)
   забирает их из начала (`RPOP`). Это простейший и очень быстрый способ организовать фоновую обработку.
2. **Стеки (LIFO - Last-In, First-Out):** Например, для хранения истории действий пользователя, которые можно "отменить" (`LPUSH` для
   добавления, `LPOP` для отмены).
3. **Ленты новостей:** Можно хранить последние N постов в ленте пользователя.

---

#### **Sets (Множества)**

Неупорядоченная коллекция **уникальных** строк. Если вы попытаетесь добавить элемент, который уже есть в множестве, ничего не
произойдет.

* **Где использовать:**

1. **Теги:** Хранение тегов для статьи или товара. Уникальность гарантирована.
2. **Отслеживание уникальности:** Например, подсчет уникальных пользователей, посетивших страницу за день.
3. **Социальные графы:** Хранение списка лайкнувших пост или друзей пользователя.

---

#### **Sorted Sets (Упорядоченные множества)**

Множество уникальных элементов (как Set), но у каждого элемента есть связанный с ним весовой коэффициент (score) — число с
плавающей точкой. Коллекция всегда отсортирована по этому score.

* **Где использовать:**

1. **Таблицы лидеров (Leaderboards):** Классический пример. Элемент — ID игрока, score — его очки.
2. **Ранжирование:** Сортировка задач по приоритету, товаров по популярности.
3. **Очереди с приоритетом:** Где score — это время выполнения или приоритет задачи.

---

#### **Hashes (Хэши)**

Структура для хранения набора пар "поле-значение" внутри одного ключа. По сути, это как объект или словарь.

* **Где использовать:**

1. **Хранение объектов:** Идеально для профиля пользователя, описания товара, сессии. Вместо того чтобы хранить весь объект как JSON-строку,
   вы храните его в виде полей.

Сила в эффективности обновлений. Если вам нужно изменить только одно поле в профиле пользователя (например, возраст), вы
отправляете одну команду `HINCRBY user:1 age 1`. Если бы вы хранили профиль в JSON-строке, вам бы пришлось: получить строку -> распарсить
JSON -> изменить поле -> сериализовать обратно -> сохранить строку. Это гораздо медленнее.

---

#### **Bitmaps (Битовые карты) и HyperLogLog**

Эти структуры предназначены для аналитики и работы с большими объемами данных при минимальном расходе памяти.

* **Bitmaps:** Это не отдельный тип данных, а набор побитовых операций над строками. Вы можете представить строку как массив битов и
  работать с каждым битом индивидуально.
* **Где использовать:** Отслеживание ежедневной активности пользователей. Представьте, что у вас 10 миллионов пользователей. Вы можете
  завести ключ `active_users:2023-10-27` и выставить бит в позиции, равной ID пользователя, в 1, если он был активен в этот день. Это займет
  всего ~1.2 МБ памяти на 10 млн пользователей.

* **HyperLogLog:** Пробабилистическая структура для подсчета *уникальных* элементов. "Пробабилистическая" означает, что результат
  приблизительный (стандартная погрешность ~0.81%), но для этого используется невероятно мало памяти — всего 12 КБ на один счетчик,
  независимо от того, считаете вы 100 элементов или 100 миллионов.
* **Где использовать:** Подсчет уникальных IP-адресов, посетивших сайт, или уникальных поисковых запросов.

---

#### **Streams (Потоки)**

Самая сложная и мощная структура данных, добавленная в Redis 5.0. Это неизменяемый журнал событий (append-only log), очень
похожий по концепции на Apache Kafka, но встроенный прямо в Redis.

* **Где использовать:**
  1. **Обработка событий в реальном времени:** Сбор данных с IoT-устройств, логов приложений.
  2. **Надежные очереди сообщений:** В отличие от Lists, сообщения в Streams не удаляются после прочтения. Их могут читать несколько
     потребителей (consumer groups), и Redis отслеживает, кто какое сообщение обработал. Это позволяет создавать отказоустойчивые системы
     обработки.

* **Команды:** `XADD` (добавить событие), `XREAD` (прочитать события), `XGROUP` (создать группу потребителей для параллельной обработки
  потока).

---

#### **Модули: Расширяя границы**

Redis имеет модульную архитектуру, которая позволяет сторонним разработчикам добавлять новые структуры данных и команды. Это превращает
Redis в настоящую платформу данных.

* **RedisJSON:** Добавляет нативную поддержку JSON, позволяя работать с полями внутри JSON-документов без необходимости их полной
  десериализации.
* **RediSearch:** Превращает Redis в полнотекстовый поисковый движок.
* **RedisGraph:** Позволяет создавать и запрашивать графовые базы данных.
* **RedisTimeSeries:** Оптимизированная структура для хранения и анализа временных рядов (например, котировки акций, данные с сенсоров).


---

## 5. Архитектура и производительность

---

### **In-memory хранение: Источник скорости и ответственности**

Все ключи и данные, с которыми работает Redis, находятся в оперативной памяти (RAM). Жесткий диск (SSD/HDD) используется
только для сохранения резервных копий (персистентности), а не для выполнения запросов.

Доступ к RAM на несколько порядков быстрее, чем к любому типу дисков. Задержка (latency) измеряется в микросекундах,
а не миллисекундах. Большинство простых команд, таких как `GET`, `SET`, `HGET`, `LPUSH`, выполняются за константное время — **O(1)**. Это
означает, что время выполнения не зависит от количества данных в базе.

* **Практические выводы и ограничения:**

1. **Объем данных ограничен RAM:** Вы не можете хранить в Redis данных больше, чем у вас есть оперативной памяти на сервере. Это самое
   главное ограничение.
2. **Оптимизация памяти — это ключ:** Необходимо думать о том, как хранить данные компактно.

* **Пример:** Если у вас есть объект пользователя с 5 полями, хранить его в **Hashes** (`HSET`) будет значительно экономнее по памяти,
  чем хранить каждое поле как отдельный ключ-строку (`SET user:1:name "Alex"`, `SET user:1:email "..."`). Redis использует специальные
  внутренние оптимизации (ziplist, listpack) для маленьких хэшей и списков.
* Используйте **Bitmaps** или **HyperLogLog** для аналитики вместо того, чтобы хранить миллионы строк в **Sets**.

---

### **Однопоточность: Простота, скорость и подводные камни**

Redis обрабатывает все клиентские команды последовательно, в одном главном потоке, используя модель с циклом событий (event
loop). Это не значит, что Redis использует только одно ядро процессора — фоновые задачи, такие как сохранение на диск (RDB/AOF), могут
выполняться в отдельных потоках или процессах. Но *все клиентские команды* — в одном.

* **Отсутствие гонок данных:** Поскольку команды выполняются строго по очереди, вам не нужно беспокоиться о блокировках и других сложностях
  многопоточного программирования. `INCR` всегда будет атомарным.
* **Низкие накладные расходы:** Нет затрат на переключение контекста между потоками.


**Главное правило и опасность:** **НИКОГДА не блокируйте event loop!**
Одна-единственная долгая команда остановит обработку всех остальных запросов от всех клиентов. Для всех остальных ваш Redis "замрет".
* **Команды-убийцы (избегать в продакшене):**
  * `KEYS *`: Сканирует *всё* пространство ключей. На базе с миллионами ключей это может занять секунды и даже минуты, полностью
    парализовав сервер.
  * `SMEMBERS`, `HGETALL`, `LRANGE 0 -1` на очень больших коллекциях: Возвращают все элементы сразу. Это нагружает не только процессор, но
    и сеть, и память клиента.
  * `SORT`: Сложная операция сортировки, которая может быть очень ресурсоемкой.

**Правильные альтернативы:**
* Вместо `KEYS` всегда используйте `SCAN`. Эта команда возвращает ключи порциями (итеративно), не блокируя сервер надолго. Ваши клиентские
  библиотеки обычно предоставляют удобные обертки для этого.
* Для больших коллекций используйте итеративные аналоги: `SSCAN` (для Sets), `HSCAN` (для Hashes), `ZSCAN` (для Sorted Sets).

---

### **Персистентность: Как не потерять данные**

Redis предлагает два механизма для сохранения данных из RAM на диск.

1. **RDB (Redis Database):**

Redis создает "снимок" (snapshot) всей базы данных в определенный момент времени и сохраняет его в один компактный
  бинарный файл (`dump.rdb`). Это происходит по настроенному расписанию (например, `save 60 1000` — сохранить, если за последние 60 секунд
  изменилось не менее 1000 ключей).
* **Компромиссы:**
  * **(+) Плюсы:** Файл компактный. Восстановление при старте очень быстрое (просто загрузка одного файла в память). Незначительное
    влияние на производительность (делается в форкнутом процессе).
  * **(-) Минусы:** **Риск потери данных.** Если сервер упадет между двумя сохранениями, все изменения за этот период будут потеряны.

2. **AOF (Append-Only File):**

Redis записывает в конец специального файла *каждую команду*, которая изменяет данные (`SET`, `INCR`, `DEL` и т.д.). При
  перезапуске Redis просто "проигрывает" этот лог, выполняя все команды заново и восстанавливая состояние.
* **Компромиссы:**
  * **(+) Плюсы:** **Максимальная надежность.** Можно настроить режим `appendfsync`, чтобы данные записывались на диск после каждой
    команды (`always`) или раз в секунду (`everysec`). Потеря данных минимальна (максимум за 1 секунду при `everysec`).
  * **(-) Минусы:** Файл AOF обычно больше, чем RDB. Восстановление может быть медленнее, так как нужно выполнить все команды. Может
    немного снижать производительность записи из-за дисковых операций.

**Золотая середина (рекомендованная конфигурация):** Использовать **оба механизма одновременно**.

* AOF обеспечивает повседневную надежность и минимизирует потерю данных.
* RDB удобен для создания бэкапов (просто скопировать один файл) и быстрого восстановления после серьезных сбоев. Когда оба режима включены,
  при старте Redis предпочтет AOF-файл как более полный.

---

### **Репликация: Отказоустойчивость и масштабирование чтения**

Создание одной или нескольких точных копий (реплик, бывш. "slaves") вашего основного сервера Redis (мастера, "master").

**Как работает:**

1. Все операции записи идут **только на мастер**.
2. Мастер, выполнив команду, асинхронно отправляет её поток на все свои реплики.
3. Реплики выполняют эти же команды и поддерживают свое состояние идентичным мастеру.
4. Операции чтения можно выполнять как с мастера, так и с реплик.

**Практическое применение:**
* **Отказоустойчивость:** Если мастер выходит из строя, вы можете (вручную или автоматически с помощью **Redis Sentinel**) "повысить" одну
  из реплик до нового мастера. Это минимизирует время простоя.
* **Масштабирование чтения:** Если у вашего приложения гораздо больше операций чтения, чем записи, вы можете распределить нагрузку на чтение
  между всеми репликами, разгружая мастер.

**Важный нюанс — задержка репликации (replication lag):** Так как репликация асинхронна, всегда есть небольшая (обычно миллисекунды)
  задержка между записью на мастер и применением этой записи на реплике. Это означает, что если вы сразу после записи попытаетесь прочитать
  данные с реплики, вы можете получить устаревшее значение. Это классический пример компромисса "доступность > строгая консистентность".

---

### **Кластеризация: Горизонтальное масштабирование**

Механизм, позволяющий объединить несколько серверов Redis в единую систему для хранения объемов данных, которые не помещаются
в память одной машины, и для распределения нагрузки на запись.

**Как работает (шардинг):**

1. Всё возможное пространство ключей делится на **16384 хэш-слота**.
2. Эти слоты распределяются между узлами (мастерами) в кластере. Например, узлу А достаются слоты 0-5500, узлу Б — 5501-11000, и т.д.
3. Когда клиент хочет выполнить команду для ключа `mykey`, клиентская библиотека вычисляет хэш от ключа (CRC16) и по его значению
   определяет, какому слоту он принадлежит (например, `CRC16('mykey') % 16384 = 7635`).
4. Библиотека знает, что слот 7635 находится на узле Б, и отправляет команду напрямую этому узлу.

**Преимущества:**
* **Горизонтальное масштабирование:** Вы можете увеличивать общую емкость и производительность, просто добавляя новые узлы в кластер.
* **Отказоустойчивость:** Каждый мастер в кластере может иметь свои реплики. Если мастер-узел падает, его реплика автоматически становится
  новым мастером для его набора слотов, и кластер продолжает работать.

* **Сложности:** Некоторые операции, работающие с несколькими ключами (`MGET`, транзакции), могут выполняться только если все
  задействованные ключи находятся в одном и том же слоте. Это нужно учитывать при проектировании схемы именования ключей (используя "
  хэш-теги", например `{user:1}:profile` и `{user:1}:settings`).

---

## 6. Кэширование

---

### **Cache-Aside (Ленивая загрузка)**

**Приложение управляет кэшем.**

1. **Чтение**:
  - Проверяет Redis:
    - **Cache Hit**: Возвращает данные.
    - **Cache Miss**: Запрашивает данные из БД, сохраняет в Redis (с TTL), возвращает пользователю.
2. **Запись**:
  - Обновляет БД, затем **удаляет** ключ из Redis.

**Диаграмма**:
```
Чтение: Приложение → Redis? (Нет) → БД → Redis (Сохранить) → Приложение
Запись: Приложение → БД (Обновить) → Redis (Удалить)
```

**Плюсы**:
- Простота реализации.
- Отказоустойчивость: работает с БД при сбое Redis.
- Кэшируются только запрашиваемые данные.

**Минусы**:
- Первый запрос медленный ("холодный старт").
- Риск устаревших данных при сбое удаления ключа.

---

### **Write-Through (Сквозная запись)**

**Приложение пишет в Redis, кэш синхронно обновляет БД.**

1. **Чтение**: Как в Cache-Aside.
2. **Запись**:
  - Данные записываются в Redis.
  - Redis (или прокси) синхронно записывает в БД.
  - Ответ после записи в оба хранилища.

**Диаграмма**:
```
Запись: Приложение → Redis (Сохранить) → БД (Сохранить) → Ответ
```

**Плюсы**:
- Полная синхронизация кэша и БД.
- Простота для приложения.

**Минусы**:
- Медленная запись из-за синхронности.
- Сложность реализации (требуется прокси или доп. логика).

---

### **Write-Behind (Отложенная запись)**

**Асинхронная запись в БД.**

1. **Запись**:
  - Данные записываются в Redis.
  - Redis отвечает `OK` сразу.
  - Данные в очереди асинхронно записываются в БД.

**Плюсы**:
- Быстрая запись (приложение не ждет БД).

**Минусы**:
- Риск потери данных при сбое Redis до записи в БД.
- Сложность: нужна надежная очередь и фоновая запись.

---

### **7. TTL и Eviction: Как управлять переполнением кэша**


#### **TTL (Time To Live) — Время жизни**

Это таймер, который можно установить на любой ключ. По истечении этого времени Redis автоматически удалит ключ.

* **Зачем нужно:** Это основной механизм для автоматической инвалидации кэша. Вы решаете, как долго данные могут считаться "достаточно
  свежими". Для профиля пользователя это может быть час, а для курса валют — минута.
* **Команды:**
* `EXPIRE mykey 60`: Установить TTL для ключа `mykey` на 60 секунд.
* `SET mykey "value" EX 60`: Сделать то же самое, но в одной атомарной команде.
* `TTL mykey`: Проверить, сколько секунд осталось "жить" ключу. (-1 — вечный, -2 — ключ не существует).

#### **Eviction Policies (Политики вытеснения)**

Правила, по которым Redis решает, какие ключи удалить, когда заканчивается память (достигнут лимит `maxmemory`).

* **Основные политики (`maxmemory-policy`):**
* **`noeviction` (по умолчанию):** **Ничего не удалять.** Redis просто будет возвращать ошибку на все команды записи, которые требуют
  дополнительной памяти. Безопасно, но может остановить работу приложения.
* **`allkeys-lru`:** Удалять **не использовалась дольше всего (Least Recently Used)** ключи из *всех* ключей. Хороший выбор для чистого
  кэша, где все данные временные.
* **`volatile-lru`:** Удалять не использовалась дольше всего ключи, но **только среди тех, у которых установлен TTL**. Идеально, если вы
  используете один и тот же Redis и для кэша (ключи с TTL), и для постоянных данных (ключи без TTL).
* **`allkeys-random`:** Удалять случайные ключи. Подходит, когда доступ ко всем ключам равновероятен.
* **`volatile-ttl`:** Удалять ключи с наименьшим оставшимся временем жизни (TTL) из тех, у кого он установлен.
* **`allkeys-lfu`, `volatile-lfu` (Least Frequently Used):Удалять те ключи, к которым обращаются реже всего. Более интеллектуальный алгоритм,
  чем LRU. Он лучше сохраняет популярные, но временно неактивные ключи.

* **Какой выбрать?** `volatile-lru` или `allkeys-lru` — самые популярные и универсальные политики для
  кэширования. `volatile-lfu` / `allkeys-lfu` могут быть эффективнее, если у вас есть "хиты", которые нужно сохранять в кэше как можно
  дольше.

---

### **Кэш-инвалидация: Как поддерживать данные в тонусе**

1. **Инвалидация по TTL (неявная)**
  - Ключи в Redis "протухают" по истечении TTL.
  - **Проблема**: Данные могут быть устаревшими весь срок действия TTL (например, час).

2. **Явная инвалидация (Write-Through/Cache-Aside)**
  - После обновления БД приложение отправляет `DEL` в Redis для удаления ключа.
  - **Проблема**: Если обновление БД происходит "в обход" (другим сервисом), кэш может не инвалидироваться.

3. **Инвалидация на основе событий (Pub/Sub или Streams)**
  - **Как работает**:
    1. Сервис (например, `UserService`) после изменения данных в БД публикует событие в канал Redis (например, `users:updates`, сообщение `{"id": 123, "action": "updated"}`).
    2. Подписанные сервисы (например, `OrderService`) получают событие и удаляют соответствующий ключ из кэша.
  - **Преимущества**:
    - Развязка: сервисы независимы, публикатор не знает, кто использует данные.
    - Надежность: своевременная инвалидация во всей системе.
  - **Инструменты**:
    - `PUBLISH`/`SUBSCRIBE`: Быстро, но без гарантии доставки.
    - **Redis Streams**: Надежнее, с сохранением истории событий.

**Рекомендация**: Для надежности используйте Redis Streams, для простоты — Pub/Sub.
  
---

## 8. Pub/Sub и Streams


### **Pub/Sub: Простой и быстрый "радиоэфир"**

* **Издатель (`PUBLISH`)** — это диджей, который отправляет песню в эфир на определенной частоте (канале). Ему неважно, кто его слушает и
  слушает ли вообще.
* **Канал (`channel`)** — это радиочастота.
* **Подписчик (`SUBSCRIBE`)** — это радиоприемник, настроенный на эту частоту. Он получает все песни, которые выходят в эфир *после* того,
  как он был включен и настроен.

**Как это работает:**

1. Клиент-подписчик отправляет команду `SUBSCRIBE channel_name`. Его соединение с Redis переходит в специальный "слушающий" режим.
2. Клиент-издатель отправляет команду `PUBLISH channel_name "Hello World"`.
3. Redis немедленно пересылает сообщение "Hello World" всем клиентам, которые в данный момент подписаны на `channel_name`.

**Ключевая характеристика — "Fire and Forget" (Выстрелил и забыл):**
* Если в момент публикации на канал никто не подписан, сообщение **просто исчезает навсегда**.
* Redis не хранит историю сообщений. Подписчик не может прочитать то, что было опубликовано до его подписки.

**Где использовать:**
* **Системы уведомлений в реальном времени:** "Пользователь X прокомментировал вашу запись". Если вы не онлайн, вы не увидите это
  уведомление в реальном времени (но оно будет сохранено в основной БД).
* **Простые чаты:** Все участники чата подписываются на один канал и публикуют сообщения в него.
* **Сигнализация:** Например, публикация сообщения в канал `cache:invalidate` для того, чтобы все веб-серверы немедленно сбросили
  определенный кэш.


---

### **Streams: Надежный и персистентный "журнал событий"**


**Как это работает:**

1. Издатель добавляет сообщение (которое может быть набором полей и значений, как Hash) в поток командой `XADD`. Redis присваивает сообщению
   уникальный ID (обычно на основе времени) и сохраняет его.
2. Потребитель может прочитать сообщения с помощью `XREAD`, указав, с какого ID он хочет начать чтение.
3. Сообщения остаются в потоке даже после прочтения, пока их не удалят явно.

**Ключевая особенность — Consumer Groups (Группы потребителей):**
  Это то, что делает Streams похожими на Kafka или RabbitMQ.
* Вы можете создать группу потребителей для одного потока.
* Redis будет распределять сообщения из потока **между участниками группы**. Каждое сообщение будет доставлено только **одному** потребителю
  внутри группы.
* Это позволяет легко распараллелить обработку: запустите 10 экземпляров вашего воркера, объедините их в одну группу, и они будут разбирать
  задачи из потока в 10 раз быстрее.
* Есть механизм подтверждения (`XACK`): потребитель должен сообщить Redis, что он успешно обработал сообщение. Если он "упадет", не
  подтвердив сообщение, другой потребитель из группы сможет забрать это сообщение себе. Это обеспечивает **надежность доставки**.

**Где использовать:**
* **Надежные очереди задач:** Альтернатива Celery или Sidekiq.
* **Event Sourcing:** Хранение всех изменений состояния системы в виде последовательности событий.
* **Сбор данных с IoT-устройств или логов:** Тысячи устройств могут писать в один поток, а группа обработчиков — разбирать эти данные.
* Любые сценарии, где важна история сообщений и гарантированная обработка.

---

### **Сравнение: Pub/Sub vs Streams vs Kafka/RabbitMQ**

Чтобы было понятнее, поместим их на одну шкалу.

| Критерий               | Redis Pub/Sub                                       | Redis Streams                                                                      | Kafka / RabbitMQ                                                   |
|:-----------------------|:----------------------------------------------------|:-----------------------------------------------------------------------------------|:-------------------------------------------------------------------|
| **Парадигма**          | "Огонь и забвение" (Fire-and-Forget)                | Персистентный лог                                                                  | Персистентный лог / Брокер сообщений                               |
| **Хранение сообщений** | Нет (сообщения не хранятся)                         | Да, в памяти Redis (персистентность настраивается)                                 | Да, на диске (основная функция)                                    |
| **История сообщений**  | Нет                                                 | Да, можно читать с любого места                                                    | Да, можно читать с любого места                                    |
| **Модель доставки**    | Широковещательная (одно сообщение всем подписчикам) | Гибкая: широковещательная (разные группы) ИЛИ распределенная (внутри одной группы) | Гибкая: очереди (один потребитель) ИЛИ топики (много потребителей) |
| **Надежность**         | Низкая (сообщения могут теряться)                   | Высокая (с подтверждением `XACK`)                                                  | Очень высокая (транзакции, гарантии доставки)                      |
| **Сложность**          | Тривиальная                                         | Средняя                                                                            | Высокая                                                            |
| **Экосистема**         | Только Redis                                        | Только Redis                                                                       | Огромная (коннекторы, инструменты, UI)                             |


---

## 9. Lua-скрипты

#### **Атомарность**
Lua-скрипты выполняются **атомарно**: пока скрипт работает, другие команды не вмешиваются. Это решает проблему гонки данных, например, при списании очков:

* **Без скрипта**:  
  Клиент 1 и Клиент 2 читают `score=100`. Оба проверяют, достаточно ли (100 >= 50), и списывают 50. Итог: списано 100 вместо 50 (race condition).

* **С Lua-скриптом**:
  ```lua
  local score = tonumber(redis.call('GET', KEYS[1]))
  local debit = tonumber(ARGV[1])
  if score >= debit then
      return redis.call('DECRBY', KEYS[1], debit)
  end
  return -1
  ```
  Скрипт выполняется целиком, исключая гонку данных.

#### **Снижение сетевых задержек**
Множество команд в одном скрипте — один сетевой запрос вместо нескольких.

* **Без скрипта**:
  ```plaintext
  HSET user:1 name "Alex"
  HSET user:1 email "alex@new.com"
  HSET user:1 last_login "1667894400"
  INCR user:1:logins
  LPUSH user:1:history "changed profile"
  ```
  5 запросов = 5 RTT.

* **С Lua-скриптом**:
  ```lua
  redis.call('HSET', KEYS[1], 'name', ARGV[1])
  redis.call('HSET', KEYS[1], 'email', ARGV[2])
  redis.call('HSET', KEYS[1], 'last_login', ARGV[3])
  redis.call('INCR', KEYS[2])
  redis.call('LPUSH', KEYS[3], 'changed profile')
  return 'OK'
  ```
  1 запрос = 1 RTT.

---

### **Как работают Lua-скрипты**

#### **`EVAL`: Прямое выполнение**
```plaintext
EVAL "lua_script" num_keys key1 key2 ... arg1 arg2 ...
```
* `lua_script`: Код скрипта.
* `num_keys`: Число ключей (для Redis Cluster).
* `KEYS[n]` и `ARGV[n]`: Доступ к ключам и аргументам.

**Пример**:  
`EVAL "return redis.call('SET', KEYS[1], ARGV[1])" 1 mykey "Hello World"`  
Устанавливает `mykey = "Hello World"`.

#### **`SCRIPT LOAD` и `EVALSHA`: Эффективный способ**
1. **`SCRIPT LOAD "lua_script"`**: Сохраняет скрипт на сервере, возвращает SHA1-хэш.
2. **`EVALSHA sha1 num_keys key1 ... arg1 ...`**: Выполняет скрипт по хэшу.

**Преимущества**:
* Меньше трафика: скрипт отправляется раз.
* Быстрее: Redis не парсит скрипт повторно.
* Надежность: хэш фиксирован.

**Лучшая практика**:
```plaintext
try {
    EVALSHA cached_sha1 keys args
} catch (NoScriptError) {
    cached_sha1 = SCRIPT_LOAD script_body
    EVALSHA cached_sha1 keys args
}
```

---


## 10. Ограничения и альтернативы

### **Ограниченный объем данных (RAM)**

* **Суть**: Все данные хранятся в оперативной памяти. Если данных больше, чем RAM (например, 100 ГБ при 64 ГБ RAM), производительность падает.
* **Последствия**:
  * RAM дороже SSD/HDD, что увеличивает затраты.
  * Ограниченное вертикальное масштабирование (нельзя бесконечно добавлять память).
* **Решения**:
  * **Redis Cluster**: Горизонтальное масштабирование via шардинг.
  * **Оптимизация памяти**: Использовать Hashes, Bitmaps, HyperLogLog.
  * **"Горячие" данные**: Хранить в Redis только часто используемые данные, остальное — в другой СУБД.

### **Отсутствие сложных SQL-запросов**

* **Суть**: Redis не поддерживает `JOIN`, сложные агрегации или фильтрацию как в SQL.
* **Последствия**: Требуется заранее продумывать структуру данных (например, вторичные индексы через Sets/Sorted Sets).
* **Решения**:
  * **RediSearch**: Добавляет полнотекстовый поиск и индексацию.
  * **Lua-скрипты**: Реализуют сложную логику на сервере.
  * **Денормализация**: Хранить данные в разных представлениях для разных запросов.

### **Однопоточность**

* **Суть**: Одна ресурсоемкая команда блокирует сервер.
* **Последствия**:
  * Команды вроде `KEYS *` или тяжелые Lua-скрипты "вешают" Redis.
  * Производительность ограничена одним ядром CPU.
* **Решения**:
  * Использовать итеративные команды (`SCAN`, `HSCAN`).
  * Мониторить медленные запросы через `SLOWLOG GET`.
  * Рассмотреть многопоточные альтернативы (например, KeyDB).

### **Сравнение с альтернативами**

| Инструмент                                   | Ключевые отличия и когда использовать                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
|:---------------------------------------------|:---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **Memcached**                                | **Против Redis (как кэш):** <br> - **Проще:** Только строки (ключ-значение), нет персистентности, нет репликации "из коробки". <br> - **Многопоточный:** Лучше утилизирует многоядерные процессоры для простых `GET`/`SET` операций. <br> **Когда использовать:** Если вам нужен максимально простой и быстрый распределенный кэш для строк, и больше ничего. Redis давно превзошел Memcached по функциональности и может быть не менее быстрым.                                                                                                                                                                                                                                                                                                                     |
| **KeyDB**                                    | **Против Redis:** <br> - **Многопоточный форк Redis:** Стремится быть полной заменой Redis, но с многопоточной обработкой команд. <br> - **Потенциально выше производительность:** На многоядерных системах при высокой нагрузке может показывать значительно лучшую пропускную способность. <br> - **Совместимость:** Полностью совместим с API и протоколом Redis. <br> **Когда использовать:** Когда производительность вашего Redis уперлась в CPU одного ядра, и вы хотите "проапгрейдиться", не меняя код приложения.                                                                                                                                                                                                                                          |
| **Aerospike /<br> DynamoDB /<br> Cassandra** | **Против Redis:** <br> - **Гибридные (RAM+SSD):** Спроектированы для хранения огромных объемов данных (терабайты), которые не помещаются в RAM. Интеллектуально держат индексы в памяти, а данные на быстрых SSD. <br> - **Масштаб:** Созданы для работы в кластерах из десятков и сотен узлов. <br> - **Сложность:** Значительно сложнее в настройке и эксплуатации, чем Redis. <br> **Когда использовать:** Когда вам нужна NoSQL база данных для хранения петабайтов данных с низкой задержкой, и Redis просто не справляется с объемом. Это системы другого класса и масштаба.                                                                                                                                                                                   |
| **Kafka /<br> RabbitMQ**                     | **Против Redis (как брокер сообщений):** <br> - **Специализированные инструменты:** Их основная и единственная задача — надежная доставка сообщений. <br> - **Дисковое хранилище:** Сообщения по умолчанию хранятся на диске, обеспечивая максимальную долговечность. <br> - **Экосистема и фичи:** Имеют гораздо более развитые механизмы маршрутизации, управления, мониторинга и интеграции. <br> **Когда использовать:** Когда обмен сообщениями — это ядро вашей системы, и вам нужны строгие гарантии доставки, долгосрочное хранение сообщений и сложные паттерны (например, Dead Letter Queues в RabbitMQ или потоковая обработка в Kafka). Redis Streams — отличная "легковесная" альтернатива, когда не хочется разворачивать отдельного тяжелого брокера. |

