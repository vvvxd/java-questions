Что такое ORM?

ORM (англ. Object-relational mapping, рус. Объектно-реляционное отображение) - технология программирования, которая связывает базы данных с концепциями объектно-ориентированных языков программирования, создавая "виртуальную объектную базу данных".

--------------------------------------------------------------------------------------------------------------------

Какие преимущства от использования Hibernate?

Устраняет множество повторяющегося кода, который постоянно преследует разработчика при работе с JDBC. Скрывает от разработчика множество кода, необходимого для управления ресурсами и позволяет сосредоточиться на бизнес логике.

Поддерживает XML так же как и JPA аннотации, что позволяет сделать реализацию кода независимой.

Предоставляет собственный мощный язык запросов (HQL), который похож на SQL. Стоит отметить, что HQL полностью объектно-ориентирован и понимает такие принципы, как наследование, полиморфизм и ассоциации (связи).

Hibernate легко интегрируется с другими Java EE фреймворками, например, Spring Framework поддерживает встроенную интеграцию с Hibernate.

Поддерживает ленивую инициализацию используя proxy объекты и выполняет запросы к базе данных только по необходимости.

Поддерживает разные уровни cache, а следовательно может повысить производительность.

Важно, что Hibernate может использовать чистый SQL, а значит поддерживает возможность оптимизации запросов и работы с любым сторонним вендором БД.

Hibernate - open source проект. Благодаря этому доступны тысячи открытых статей, примеров, а так же документации по использованию фреймворка.

--------------------------------------------------------------------------------------------------------------------

Как Hibernate помогает в программировании?

Hibernate реализует ряд фичь которые значительно упрощают работу разработчика.

Одной из таких фичь является то, что hibernate позволяет разработчику избежать написания большинства SQL запросов (они уже реализованы , вам надо просто использовать методы которые предоставляет фреймворк).

Под бортом у Hibernate есть куча полезных инструментов которые значительно ускоряют работу приложения, самыми примечательными из них являются двухуровневое кэширования и тонкие настройки lazy и fetch изъятия.

Сам генерирует таблицы в базу данных

--------------------------------------------------------------------------------------------------------------------

Какие преимущества Hibernate над JDBC?

Hibernate имеет ряд преимуществ перед JDBC API:

Hibernate удаляет множество повторяющегося кода из JDBC API, а следовательно его легче читать, писать и поддерживать.

Hibernate поддерживает наследование, ассоциации и коллекции, что не доступно в JDBC API.

Hibernate неявно использует управление транзакциями. Большинство запросов нельзя выполнить вне транзакции. При использовании JDBC API для управления транзакциями нужно явно использовать commit и rollback.

JDBC API throws SQLException, которое относится к проверяемым исключениям, а значит необходимо постоянно писать множество блоков try-catch. В большинстве случаев это не нужно для каждого вызова JDBC и используется для управления транзакциями. Hibernate оборачивает исключения JDBC через непроверяемые JDBCException или HibernateException, а значит нет необходимости проверять их в коде каждый раз. Встроенная поддержка управления транзакциями в Hibernate убирает блоки try-catch.

Hibernate Query Language (HQL) более объектно ориентированный и близкий к Java язык программирования, чем SQL в JDBC.

Hibernate поддерживает кэширование, а запросы JDBC - нет, что может понизить производительность.

Hibernate предоставляет возможность управления БД (например создания таблиц), а в JDBC можно работать только с существующими таблицами в базе данных.

Конфигурация Hibernate позволяет использовать JDBC вроде соединения по типу JNDI DataSource для пула соединений. Это важная фича для энтерпрайз приложений, которая полностью отсутствует в JDBC API.

Hibernate поддерживает аннотации JPA, а значит код является переносимым на другие ORM фреймворки, реализующие стандарт, в то время как код JDBC сильно привязан к приложению.

--------------------------------------------------------------------------------------------------------------------

Что такое конфигурационный файл Hibernate?

Файл конфигурации Hibernate содержит в себе данные о базе данных и необходим для инициализации SessionFactory. В .xml файле необходимо указать вендора базы данных или JNDI ресурсы, а так же информацию об используемом диалекте, что поможет hibernate выбрать режим работы с конкретной базой данных.

--------------------------------------------------------------------------------------------------------------------

Способы конфигурации работы с Hibernate.

Существует четыре способа конфигурации работы с Hibernate

используя аннотации;
hibernate.cfg.xml;
hibernate.properties;
persistence.xml.

Самый частый способ конфигурации: через аннотации и файл persistence.xml, что касается файлов hibernate.properties и hibernate.cfg.xml, то hibernate.cfg.xml главнее (если в приложение есть оба файла, то принимаются настройки из файла hibernate.cfg.xml). Конфигурация аннотациями, хоть и удобна, но не всегда возможна, к примеру, если для разных баз данных или для разных ситуаций вы хотите иметь разные конфигурацию сущностей, то следует использовать xml файлы конфигураций.

--------------------------------------------------------------------------------------------------------------------

Какая роль интерфейса Session в Hibernate?

Объект Hibernate Session является связью между кодом java приложения и hibernate. Это основной интерфейс для выполнения операций с базой
данных. Жизненный цикл объекта session связан с началом и окончанием транзакции. Этот объект предоставляет методы для CRUD (create, read,
update, delete) операций для объекта персистентности. С помощью этого экземпляра можно выполнять HQL, SQL запросы и задавать критерии
выборки.
(персистентный объект - объект который уже находится в базе данных; объект запроса - объект который получается когда мы получаем результат
запроса в базу данных, именно с ним работает приложение). Обьект Session можно получить из SessionFactory :

Session session = sessionFactory.openSession();

Роль интерфейса Session:
является оберткой для jdbc подключения к базе данных;
является фабрикой для транзакций (согласно официальной документации transaction - аllows the application to define units of work, что , по
сути, означает что транзакция определяет границы операций связанных с базой данных).
является хранителем обязательного кэша первого уровня.

В JPA эквивалентом Session является EntityManager

--------------------------------------------------------------------------------------------------------------------

Какая роль интерфейса SessionFactory в Hibernate?

SessionFactory является фабрикой классов и используется для получения объектов session. SessionFactory отвечает за считывание параметров
конфигурации Hibernate и подключение к базе данных. Обычно в приложении имеется только один экземпляр SessionFactory и потоки, обслуживающие
клиентские запросы, получают экземпляры session с помощью объекта SessionFactory. Внутреннее состояние SessionFactory неизменно (immutable).
Internal state (внутреннее состояние) включает в себя все метаданные об Object/ Relational Mapping и задается при создании SessionFactory.
SessionFactory также предоставляет методы для получения метаданных класса и статистики, вроде данных о втором уровне кэша, выполняемых
запросах и т.д.
SessionFactory кэширует мета-дату и SQL запросы которые часто используются приложением во время работы. Так же оно кэширует информацию
которая была получена в одной из транзакций и может быть использована и в других транзакциях.

В контексте JPA используется EntityManagerFactory, которая выполняет аналогичную роль.

--------------------------------------------------------------------------------------------------------------------

Является ли Hibernate SessionFactory потокобезоспансым?

Т.к. объект SessionFactory immutable (неизменяемый), то да, он потокобезопасный. Множество потоков может обращаться к одному объекту
одновременно.

--------------------------------------------------------------------------------------------------------------------

В чем разница между openSession и getCurrentSession?

| **Характеристика**         | **`openSession()`**                                                                     | **`getCurrentSession()`**                                                                                     |
|----------------------------|-----------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------|
| **Источник создания**      | Создает **новую сессию** каждый раз при вызове.                                         | Возвращает **текущую сессию**, связанную с контекстом (например, с текущей транзакцией).                      |
| **Контекст управления**    | Не привязан к контексту, сессия полностью независима.                                   | Привязан к **контексту сессии** (Session Context), обычно управляется контейнером (например, Spring) или JTA. |
| **Закрытие сессии**        | Требует явного вызова `session.close()` для закрытия.                                   | Закрывается автоматически при завершении транзакции или контекста, если настроено.                            |
| **Потокобезопасность**     | Не привязан к потоку, можно использовать в любом потоке, но требует ручного управления. | Привязан к текущему потоку (Thread-Local) в рамках контекста, безопасен для текущего потока.                  |
| **Типичное использование** | Подходит для автономных приложений или случаев, где нужен полный контроль над сессией.  | Используется в управляемых окружениях (например, Spring, JEE), где сессия связана с транзакцией.              |
| **Конфигурация**           | Не требует специальной настройки контекста.                                             | Требует настройки свойства `hibernate.current_session_context_class` (например, `thread` или `jta`).          |

--------------------------------------------------------------------------------------------------------------------

### Расскажите про первый уровень кэша (First-Level Cache)?

**Описание**:  
Первый уровень кэша — это кэш, встроенный в сессию Hibernate (`Session`). Он автоматически включён и не требует дополнительной настройки. Этот кэш хранит сущности, загруженные в рамках одной сессии, и используется для обеспечения консистентности данных внутри сессии.

**Характеристики**:
- **Привязка к сессии**: Кэш первого уровня существует только в пределах одной сессии Hibernate. Когда сессия закрывается (или очищается с помощью `session.clear()`), кэш уничтожается.
- **Автоматическое использование**: Hibernate автоматически кэширует все сущности, загруженные через методы `get()`, `load()`, или запросы в рамках сессии.
- **Консистентность**: Гарантирует, что в рамках одной сессии все обращения к одной и той же сущности возвращают один и тот же объект (идентичность объектов).
- **Dirty Checking**: Hibernate использует кэш первого уровня для отслеживания изменений в сущностях (механизм "грязной проверки") и синхронизации их с базой данных при коммите транзакции.

**Как работает**:
- При загрузке сущности (например, `session.get(User.class, 1L)`) Hibernate сначала проверяет кэш первого уровня. Если сущность уже есть в кэше, она возвращается без обращения к базе данных.
- Если сущность отсутствует, Hibernate выполняет SQL-запрос, загружает данные из базы и помещает сущность в кэш сессии.
- Последующие обращения к той же сущности в рамках той же сессии возвращают объект из кэша.

**Пример**:
```java
Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();

// Первое обращение: SQL-запрос к базе
User user1 = session.get(User.class, 1L);

// Второе обращение: возвращается из кэша сессии, без SQL-запроса
User user2 = session.get(User.class, 1L);

assert user1 == user2; // true, это один и тот же объект
tx.commit();
session.close(); // Кэш очищается
```

**Ограничения**:
- Кэш первого уровня недоступен для других сессий или приложений, так как он локален.
- Может потреблять много памяти, если в сессии загружается большое количество объектов.
- Не подходит для долгоживущих сессий, так как кэш растёт и становится неуправляемым.

**Управление**:
- `session.evict(Object entity)`: Удаляет конкретную сущность из кэша.
- `session.clear()`: Полностью очищает кэш сессии.
- `session.contains(Object entity)`: Проверяет, находится ли объект в кэше.

**Когда использовать**:
- Всегда используется по умолчанию в Hibernate.
- Эффективен для операций в рамках одной транзакции или короткой сессии, где требуется высокая консистентность.

---

### Расскажите про второй уровень кэша (Second-Level Cache)?

Второй уровень кэша — это кэш, общий для всех сессий в рамках одного `SessionFactory`. Он хранит данные на уровне приложения и позволяет минимизировать обращения к базе данных для сущностей, которые редко изменяются. В отличие от первого уровня кэша, второй уровень кэша требует явной настройки и подключения провайдера кэша.

**Характеристики**:
- **Привязка к SessionFactory**: Кэш второго уровня существует на протяжении жизненного цикла приложения (или пока `SessionFactory` не закрыт).
- **Настраиваемость**: Можно включить кэширование для отдельных сущностей, коллекций или ассоциаций.
- **Провайдеры**: Hibernate поддерживает несколько провайдеров второго уровня кэша, таких как **EHCache**, **Infinispan**, **Hazelcast**, **Caffeine**, или другие. Каждый провайдеров имеет свои особенности и настройки.
- **Типы кэширования**:
    - **Entity Cache**: Хранит данные сущностей (их поля и идентификаторы).
    - **Collection Cache**: Хранит идентификаторы элементов коллекций (например, `@OneToMany`).
- **Стратегии кэширования**:
    - **Read-Only**: Для данных, которые никогда не изменяются.
    - **Nonstrict-Read-Write**: Для данных, которые редко обновляются, с минимальной гарантией консистентности.
    - **Read-Write**: Для данных, которые могут обновляться, с обеспечением консистентности.
    - **Transactional**: Для данных, требующих строгой транзакционной консистентности (редко используется).

**Как работает**:
- При загрузке сущности Hibernate сначала проверяет кэш первого уровня (сессии).
- Если сущность не найдена, проверяется кэш второго уровня.
- Если сущность отсутствует и во втором уровне кэша, выполняется SQL-запрос к базе данных, после чего данные помещаются в кэш второго уровня (и первого уровня для текущей сессии).
- При обновлении или удалении сущности Hibernate синхронизирует кэш второго уровня, чтобы избежать устаревших данных.

**Популярные провайдеры**:
- **EHCache**:
    - Прост в настройке, подходит для локального кэширования.
    - Ограниченная поддержка распределённого кэширования.
    - Хорошо работает для приложений с одним сервером.
- **Infinispan**:
    - Мощный распределённый кэш, поддерживает кластеризацию.
    - Подходит для масштабируемых приложений с несколькими узлами.
    - Более сложная настройка по сравнению с EHCache.
- **Hazelcast** и **Caffeine**:
    - Современные альтернативы с поддержкой распределённого кэширования (Hazelcast) или высокой производительности в однопоточном режиме (Caffeine).


**Ограничения**:
- Требует тщательной настройки стратегий кэширования, чтобы избежать устаревших данных.
- Увеличивает потребление памяти, особенно в кластеризованных средах.
- Не подходит для часто обновляемых данных (например, транзакционных записей).

**Когда использовать**:
- Для данных, которые редко изменяются (например, справочники, конфигурации).
- В приложениях с интенсивным чтением, где повторные запросы к одним и тем же данным часты.
- В распределённых системах с провайдерами, поддерживающими кластеризацию (например, Infinispan).

---

### Расскажите про кэш запросов (Query Cache)?
 
Кэш запросов (Query Cache) хранит результаты выполнения запросов (JPQL, HQL, Criteria API) и их идентификаторы. Он используется для повторного использования результатов запросов, чтобы избежать повторного обращения к базе данных. Кэш запросов работает в связке со вторым уровнем кэша.

**Характеристики**:
- **Зависимость от второго уровня кэша**: Кэш запросов хранит только идентификаторы сущностей, а сами данные сущностей берутся из второго уровня кэша. Без включённого второго уровня кэша он неэффективен.
- **Кэширование результатов запросов**: Хранит результаты запросов (например, списки идентификаторов сущностей) для повторного использования.
- **Инвалидация**: Кэш запросов автоматически инвалидируется при изменении данных в таблицах, связанных с кэшируемым запросом.
- **Настройка**: Требует явного включения и указания, какие запросы нужно кэшировать.

**Как работает**:
- При выполнении запроса Hibernate проверяет, есть ли результат в кэше запросов.
- Если результат найден, Hibernate загружает сущности по их идентификаторам из второго уровня кэша (или из базы, если их нет в кэше).
- Если результат отсутствует, запрос выполняется, а его результат кэшируется для будущих вызовов.

**Ограничения**:
- Кэш запросов чувствителен к изменениям данных: любое изменение в таблице, связанной с запросом, инвалидирует кэш.
- Неэффективен для запросов с часто меняющимися параметрами, так как кэш хранит результаты для конкретных комбинаций запроса и параметров.
- Требует включённого второго уровня кэша для хранения самих сущностей.
- Может потреблять значительное количество памяти при большом количестве кэшируемых запросов.

**Когда использовать**:
- Для запросов, которые выполняются часто с одинаковыми параметрами и возвращают редко изменяющиеся данные (например, списков категорий, стран).
- В связке со вторым уровнем кэша для максимальной эффективности.
- Избегайте для динамических запросов или данных, которые часто обновляются.


--------------------------------------------------------------------------------------------------------------------
### Расскажите про Жизненный цикл объектов в Hibernate?

В Hibernate объект может находиться в одном из четырёх состояний, каждое из которых отражает его связь с сессией (`Session`) и базой данных:

1. **Transient (Переходное состояние)**
    - **Описание**: Объект находится в состоянии `Transient`, когда он создан, но ещё не связан с сессией Hibernate и не имеет соответствующей записи в базе данных. Это просто обычный Java-объект, не управляемый Hibernate.
    - **Характеристики**:
        - Объект не имеет идентификатора (`id`), связанного с базой данных (или `id` есть, но он не соответствует записи в базе).
        - Не отслеживается Hibernate (не находится в контексте персистентности).
        - Изменения в объекте не синхронизируются с базой данных.
    - **Пример**:
      ```java
      User user = new User();
      user.setName("John");
      // Объект user в состоянии Transient, так как он не сохранён в базе данных.
      ```
    - **Переход в другое состояние**:
        - Вызов методов `persist()`, `save()`, или `saveOrUpdate()` переводит объект в состояние `Persistent`.

2. **Persistent (Управляемое состояние)**
    - **Описание**: Объект находится в состоянии `Persistent`, когда он связан с текущей сессией Hibernate и имеет соответствующую запись в базе данных. Hibernate отслеживает изменения в таких объектах и синхронизирует их с базой при коммите транзакции или вызове `flush()`.
    - **Характеристики**:
        - Объект имеет идентификатор (`id`), соответствующий записи в базе данных.
        - Все изменения в объекте автоматически отслеживаются Hibernate (механизм "dirty checking").
        - При закрытии сессии или вызове `evict()` объект переходит в состояние `Detached`.
    - **Пример**:
      ```java
      Session session = sessionFactory.openSession();
      Transaction tx = session.beginTransaction();
      User user = new User();
      user.setName("John");
      session.persist(user); // Теперь user в состоянии Persistent
      user.setName("Jane"); // Изменение автоматически сохранится при коммите
      tx.commit();
      session.close();
      ```
    - **Переход в другое состояние**:
        - Закрытие сессии или вызов `evict()` переводит объект в состояние `Detached`.
        - Вызов `remove()` переводит объект в состояние `Removed`.

3. **Detached (Отсоединённое состояние)**
    - **Описание**: Объект находится в состоянии `Detached`, когда он был ранее связан с сессией (и, возможно, базой данных), но сессия, управлявшая им, была закрыта или объект был явно отсоединён (например, через `evict()`).
    - **Характеристики**:
        - Объект имеет идентификатор (`id`), соответствующий записи в базе данных, но изменения в нём не отслеживаются Hibernate.
        - Для синхронизации изменений с базой данных требуется повторное присоединение к сессии (через `merge()`, `update()`, или `saveOrUpdate()`).
    - **Пример**:
      ```java
      Session session = sessionFactory.openSession();
      Transaction tx = session.beginTransaction();
      User user = session.get(User.class, 1L); // Persistent
      tx.commit();
      session.close(); // Теперь user в состоянии Detached
      user.setName("Jane"); // Изменения не синхронизируются с базой
      ```
    - **Переход в другое состояние**:
        - Вызов `merge()` или `update()` переводит объект в состояние `Persistent`.
        - Если объект заново привязать к сессии, он снова станет управляемым.

4. **Removed (Удалённое состояние)**
    - **Описание**: Объект находится в состоянии `Removed`, когда он помечен для удаления из базы данных с помощью метода `remove()` (или `delete()` в старых версиях Hibernate). После коммита транзакции запись, связанная с объектом, удаляется из базы данных.
    - **Характеристики**:
        - Объект всё ещё связан с сессией, но помечен как удалённый.
        - После коммита транзакции объект переходит в состояние `Transient` (если сессия закрыта) или становится недействительным.
    - **Пример**:
      ```java
      Session session = sessionFactory.openSession();
      Transaction tx = session.beginTransaction();
      User user = session.get(User.class, 1L); // Persistent
      session.remove(user); // Теперь user в состоянии Removed
      tx.commit(); // Запись удаляется из базы данных
      session.close();
      ```
    - **Переход в другое состояние**:
        - После коммита транзакции объект становится `Transient`.
        - Если отменить транзакцию (rollback), объект вернётся в состояние `Persistent`.

--------------------------------------------------------------------------------------------------------------------
### Сущность выбрана в одной транзакции, сессия закрыта, попытка взаимодействия в другой транзакции Что будет?

**Ситуация**:
```java
      User user;
      // Первая транзакция
      try (Session session1 = sessionFactory.openSession()) {
          Transaction tx1 = session1.beginTransaction();
          user = session1.get(User.class, 1L); // Persistent
          tx1.commit();
      } // Сессия закрыта, user теперь Detached
 
      // Вторая транзакция
      try (Session session2 = sessionFactory.openSession()) {
          Transaction tx2 = session2.beginTransaction();
          user.setName("Jane"); // Изменение Detached объекта
          session2.update(user); // Попытка обновления
          tx2.commit();
      }
```
- **Что происходит**:
        - После закрытия первой сессии сущность `user` становится **Detached**. Она больше не связана с контекстом персистентности и не отслеживается Hibernate.
        - Попытка изменить её свойства (например, `user.setName("Jane")`) не влияет на базу данных, так как Hibernate не отслеживает изменения в **Detached**-объектах.
        - Чтобы синхронизировать изменения с базой данных, нужно явно привязать сущность к новой сессии с помощью методов `update()`, `merge()`, или `saveOrUpdate()`.
- **Возможные проблемы**:
    - Если сущность с таким идентификатором уже загружена в новой сессии, вызов `update()` может вызвать исключение `NonUniqueObjectException`, так как Hibernate не допускает два объекта с одинаковым идентификатором в одном контексте персистентности.
    - Если сущности больше нет в базе данных (например, она была удалена), вызов `update()` выбросит исключение.
- **Решение**:
    - Используйте `merge()` вместо `update()`, так как `merge()` безопаснее: он копирует состояние **Detached**-объекта в существующий объект в контексте персистентности или создаёт новый, если объекта нет.
    - Перед вызовом `update()` убедитесь, что в новой сессии нет объекта с таким же идентификатором, или используйте `session.evict()` для удаления конфликтующего объекта из контекста.
  ```java
  try (Session session2 = sessionFactory.openSession()) {
      Transaction tx2 = session2.beginTransaction();
      user.setName("Jane");
      User mergedUser = session2.merge(user); // Безопасное обновление
      tx2.commit();
  }
  ```

--------------------------------------------------------------------------------------------------------------------
### Попытка доступа к лениво загруженным связям после закрытия сессии. Что будет?
- **Ситуация**:
```java
      User user;
      try (Session session = sessionFactory.openSession()) {
          Transaction tx = session.beginTransaction();
          user = session.get(User.class, 1L); // Persistent, связи лениво загружаемы
          tx.commit();
      } // Сессия закрыта, user теперь Detached
 
      // Попытка доступа к лениво загруженной коллекции
     user.getOrders().size(); // Lazy loading
   ```
- **Что происходит**:
        - Если коллекция `orders` в сущности `User` настроена на ленивую загрузку (`lazy loading`), она не загружается при извлечении объекта из базы, а представлена прокси-объектом.
        - После закрытия сессии прокси-объект теряет связь с базой данных, и попытка доступа к коллекции вызовет исключение `LazyInitializationException`.
- **Возможные проблемы**:
        - `LazyInitializationException` — одна из самых распространённых ошибок в Hibernate, связанная с доступом к лениво загруженным данным вне сессии.
- **Решение**:
    - **Инициализация связей в первой транзакции**:
```java
          try (Session session = sessionFactory.openSession()) {
              Transaction tx = session.beginTransaction();
              user = session.get(User.class, 1L);
              Hibernate.initialize(user.getOrders()); // Явная загрузка коллекции
              tx.commit();
          }
          user.getOrders().size(); // Теперь безопасно
```
- **Использование немедленной загрузки (eager fetching)**:
          Настройте связь как `fetch = FetchType.EAGER` в аннотации или используйте `fetch join` в HQL/JPQL-запросе.
```java
          @OneToMany(fetch = FetchType.EAGER)
         private List<Order> orders;
 ```
- **Открытие новой сессии для работы с данными**:
          Повторно привяжите сущность к новой сессии с помощью `merge()` и работайте с коллекцией в контексте новой сессии.

--------------------------------------------------------------------------------------------------------------------
### Попытка изменения сущности вне транзакции. Что будет?

- **Ситуация**:
```java
      User user;
      try (Session session = sessionFactory.openSession()) {
          Transaction tx = session.beginTransaction();
          user = session.get(User.class, 1L); // Persistent
          tx.commit();
      } // user теперь Detached
 
      user.setName("Jane"); // Изменение Detached объекта
      // Нет сессии или транзакции для сохранения изменений
```
- **Что происходит**:
        - Изменения в **Detached**-объекте не отслеживаются Hibernate и не сохраняются в базе данных, так как нет активной сессии.
        - Чтобы сохранить изменения, нужно открыть новую сессию и транзакцию и использовать `merge()`, `update()`, или `saveOrUpdate()`.
- **Возможные проблемы**:
        - Если изменения не сохраняются явно, это может привести к рассинхронизации между объектом в памяти и базой данных, что создаёт логические ошибки в приложении.
- **Решение**:
   - Всегда сохраняйте изменения в базе данных в контексте сессии и транзакции:
   ```java
          try (Session session = sessionFactory.openSession()) {
              Transaction tx = session.beginTransaction();
              session.merge(user); // Сохранение изменений
              tx.commit();
          }
    ```

--------------------------------------------------------------------------------------------------------------------
### Если сущность использует оптимистическую блокировку (например, с аннотацией `@Version`), изменения в одной транзакции могут конфликтовать с изменениями в другой. Что будет?

```java
      User user1, user2;
      // Первая транзакция
      try (Session session1 = sessionFactory.openSession()) {
          Transaction tx1 = session1.beginTransaction();
          user1 = session1.get(User.class, 1L);
          tx1.commit();
      }
 
      // Вторая транзакция
      try (Session session2 = sessionFactory.openSession()) {
          Transaction tx2 = session2.beginTransaction();
          user2 = session2.get(User.class, 1L);
          user2.setName("Jane");
          tx2.commit();
      }
 
      // Попытка обновления в третьей транзакции
      try (Session session3 = sessionFactory.openSession()) {
          Transaction tx3 = session3.beginTransaction();
          user1.setName("John");
          session3.merge(user1); // Конфликт версий
          tx3.commit();
      }
```
- **Что происходит**:
        - Hibernate использует поле `@Version` для отслеживания изменений. Если вторая транзакция обновила сущность, версия в базе данных изменилась.
        - При попытке обновления в третьей транзакции Hibernate обнаружит, что версия объекта `user1` устарела, и выбросит исключение `OptimisticLockException`.
- **Возможные проблемы**:
    - `OptimisticLockException` указывает на конфликт изменений, что требует обработки в приложении.
- **Решение**:
    - Перехватывайте исключение и уведомляйте пользователя о конфликте, предлагая перезагрузить данные:
      ```java
      try (Session session3 = sessionFactory.openSession()) {
          Transaction tx3 = session3.beginTransaction();
          try {
              session3.merge(user1);
              tx3.commit();
          } catch (OptimisticLockException e) {
              // Перезагрузить сущность и повторить попытку
              User refreshedUser = session3.get(User.class, user1.getId());
              refreshedUser.setName("John");
              session3.merge(refreshedUser);
              tx3.commit();
          }
      }
      ```
- Используйте пессимистическую блокировку (`LockMode.PESSIMISTIC_WRITE`), если конфликты недопустимы:
  ```java
  user = session.get(User.class, 1L, LockMode.PESSIMISTIC_WRITE);
  ```

--------------------------------------------------------------------------------------------------------------------
### Попытка удаления сущности в другой транзакции. Что будет?
- **Ситуация**:
```java
      User user;
      try (Session session1 = sessionFactory.openSession()) {
          Transaction tx1 = session1.beginTransaction();
          user = session1.get(User.class, 1L); // Persistent
          tx1.commit();
      } // user теперь Detached
 
      try (Session session2 = sessionFactory.openSession()) {
          Transaction tx2 = session2.beginTransaction();
          session2.remove(user); // Ошибка
          tx2.commit();
      }
  ```
- **Что происходит**:
        - Метод `remove()` требует, чтобы сущность находилась в состоянии **Persistent**. Попытка удалить **Detached**-объект вызовет исключение `IllegalArgumentException`.
- **Решение**:
    - Привяжите сущность к новой сессии перед удалением:
      ```java
      try (Session session2 = sessionFactory.openSession()) {
          Transaction tx2 = session2.beginTransaction();
          User persistentUser = session2.merge(user); // Перевод в Persistent
          session2.remove(persistentUser); // Теперь можно удалить
          tx2.commit();
      }
      ```
    - Или загрузите сущность заново:
      ```java
      try (Session session2 = sessionFactory.openSession()) {
          Transaction tx2 = session2.beginTransaction();
          User persistentUser = session2.get(User.class, user.getId());
          session2.remove(persistentUser);
          tx2.commit();
      }
      ```
---
### Расскажи про **Диалекты Hibernate**

Диалект Hibernate — это класс, который определяет, как Hibernate взаимодействует с конкретной СУБД. Диалект отвечает за генерацию SQL-запросов, учитывающих особенности базы данных (например, синтаксис, функции, поддержка функций).

- Hibernate поддерживает множество диалектов для различных СУБД, таких как MySQL, PostgreSQL, Oracle, SQL Server, H2 и других.
- Диалект определяет:
    - Синтаксис SQL (например, `LIMIT` в MySQL или `FETCH FIRST` в Oracle).
    - Поддерживаемые типы данных (например, `TEXT` в PostgreSQL или `CLOB` в Oracle).
    - Специфичные для СУБД функции (например, `JSON` в PostgreSQL).
    - Стратегии генерации первичных ключей (`IDENTITY`, `SEQUENCE`).

**Основные диалекты**:
- **MySQL**: `org.hibernate.dialect.MySQL8Dialect` (для MySQL 8.x), `org.hibernate.dialect.MySQL57Dialect` (для MySQL 5.7).
- **PostgreSQL**: `org.hibernate.dialect.PostgreSQLDialect` (универсальный), `org.hibernate.dialect.PostgreSQL10Dialect` (для PostgreSQL 10+).
- **Oracle**: `org.hibernate.dialect.Oracle12cDialect` (для Oracle 12c+), `org.hibernate.dialect.OracleDialect` (устаревший).
- **SQL Server**: `org.hibernate.dialect.SQLServer2012Dialect` (для SQL Server 2012+).
- **H2**: `org.hibernate.dialect.H2Dialect` (для в-memory базы H2, часто используется в тестах).

### Выбор диалекта
- **Автоматический выбор**: Если указать правильный JDBC-драйвер, Hibernate может автоматически определить диалект в некоторых случаях, но лучше задавать его явно для избежания ошибок.
- **Версионность**: Выбирайте диалект, соответствующий версии СУБД, чтобы использовать новые функции и оптимизации (например, `MySQL8Dialect` вместо устаревшего `MySQL5Dialect`).
- **Кастомизация**: Если требуется поддержка нестандартных функций, можно создать собственный диалект, унаследовав его от существующего:
  ```java
  public class CustomMySQLDialect extends MySQL8Dialect {
      public CustomMySQLDialect() {
          super();
          registerFunction("custom_function", new StandardSQLFunction("custom_function", StandardBasicTypes.STRING));
      }
  }
  ```
---

### **Расскажи про Пул соединений**

Пул соединений — это механизм для управления соединениями с базой данных, который повышает производительность за счёт повторного использования соединений и ограничения их количества. Hibernate поддерживает интеграцию с различными пулами соединений, такими как **C3P0**, **HikariCP** и **DBCP**.

#### *Популярные пулы соединений**
1. **C3P0**:
2. **HikariCP**:
    - Современный и высокопроизводительный пул соединений.
    - Является стандартом де-факто в Spring Boot.
    - Лёгкий, с минимальной задержкой и высокой надёжностью.
    - Зависимость (Maven):
      ```xml
      <dependency>
          <groupId>com.zaxxer</groupId>
          <artifactId>HikariCP</artifactId>
          <version>5.1.0</version>
      </dependency>
      ```
3. **DBCP (Apache Commons DBCP)**:

#### **Настройка пула соединений**
  ```properties
  spring.datasource.hikari.minimum-idle=5
  spring.datasource.hikari.maximum-pool-size=20
  spring.datasource.hikari.idle-timeout=300000
  spring.datasource.hikari.max-lifetime=1800000
  spring.datasource.hikari.connection-timeout=30000
  ```
- **Основные параметры**:
    - `min_size` / `minimum-idle`: Минимальное количество соединений в пуле.
    - `max_size` / `maximum-pool-size`: Максимальное количество соединений.
    - `timeout` / `connection-timeout`: Максимальное время ожидания соединения (в миллисекундах).
    - `idle_test_period` / `idle-timeout`: Время простоя соединения перед его закрытием.
    - `max_statements`: Максимальное количество кэшируемых подготовленных запросов (для C3P0).
    - `max-lifetime`: Максимальное время жизни соединения (для HikariCP).

#### **Рекомендации по настройке**
- **Оптимизация производительности**:
    - Установите `min_size` и `max_size` в зависимости от нагрузки приложения и доступных ресурсов сервера базы данных.
    - Для высоконагруженных приложений используйте HikariCP из-за его скорости и надёжности.
- **Тайм-ауты**:
    - Настройте `connection-timeout` (обычно 20–30 секунд), чтобы избежать длительного ожидания при недоступности базы.
    - Установите `idle-timeout` и `max-lifetime`, чтобы закрывать устаревшие соединения и предотвращать утечки.
- **Тестирование соединений**:
    - Включите проверку соединений (`test-on-borrow`, `test-on-idle`) для обеспечения их актуальности.
    - Пример для HikariCP:
      ```properties
      spring.datasource.hikari.connection-test-query=SELECT 1
      ```
- **Мониторинг**:
    - Используйте инструменты мониторинга (например, Actuator в Spring Boot) для отслеживания состояния пула соединений.
    - Логируйте ошибки соединений для диагностики проблем.
--------------------------------------------------------------------------------------------------------------------

### Какие есть Аннотации JPA и Hibernate**

JPA (Java Persistence API) предоставляет стандартные аннотации для маппинга сущностей, которые Hibernate реализует и расширяет собственными аннотациями для дополнительных возможностей. Рассмотрим основные категории аннотаций и их использование.

#### **Основные аннотации**
Эти аннотации используются для базового маппинга сущностей и их атрибутов:

- **`@Entity`**:
    - **Описание**: Помечает класс как сущность, которая соответствует таблице в базе данных.
    - **Применение**: Класс должен иметь конструктор без параметров (по умолчанию или явно определённый).

- **`@Table(name = "table_name")`**:
    - **Описание**: Указывает имя таблицы в базе данных, к которой привязана сущность. Если не указана, Hibernate использует имя класса.
    - **Параметры**:
        - `name`: Имя таблицы.
        - `schema`: Схема базы данных (опционально).

- **`@Id`**:
    - **Описание**: Помечает поле как первичный ключ сущности.
    - **Применение**: Обязательно для каждой сущности. Может быть простым (одно поле) или композитным (несколько полей).


- **`@GeneratedValue`**:
    - **Описание**: Указывает стратегию генерации значения первичного ключа.
    - **Стратегии**:
        - `GenerationType.AUTO`: Hibernate выбирает подходящую стратегию (зависит от СУБД).
        - `GenerationType.IDENTITY`: Использует автоинкремент (например, в MySQL).
        - `GenerationType.SEQUENCE`: Использует последовательности (например, в PostgreSQL).
        - `GenerationType.TABLE`: Использует таблицу для хранения идентификаторов.

- **`@Column`**:
    - **Описание**: Указывает маппинг поля на столбец в таблице.
    - **Параметры**:
        - `name`: Имя столбца.
        - `nullable`: Может ли столбец быть `null`.
        - `length`: Длина для строковых полей.
        - `unique`: Уникальность значения.

#### **Аннотации для связей**
Связные аннотации определяют отношения между сущностями (`OneToOne`, `OneToMany`, `ManyToOne`, `ManyToMany`) и управляют их поведением через каскадирование и стратегии загрузки.

- **`@OneToOne`**:
    - **Описание**: Определяет связь "один к одному" между двумя сущностями.
    - **Параметры**:
        - `mappedBy`: Указывает, какая сторона связи является владельцем (обратная сторона).
        - `cascade`: Тип каскадирования.
        - `fetch`: Стратегия загрузки (`FetchType.LAZY` или `FetchType.EAGER`).

- **`@OneToMany` и `@ManyToOne`**:
    - **Описание**: Определяют связь "один ко многим" и "многие к одному".

- **`@ManyToMany`**:
    - **Описание**: Определяет связь "многие ко многим", обычно с использованием промежуточной таблицы.

- **`@JoinColumn`**:
    - **Описание**: Указывает столбец внешнего ключа для связи.
    - **Параметры**:
        - `name`: Имя столбца внешнего ключа.
        - `referencedColumnName`: Имя столбца, на который ссылается внешный ключ.


#### **1.3. Каскадирование и стратегии загрузки**
- **`CascadeType`**:
    - **Описание**: Определяет, какие операции (сохранение, обновление, удаление) должны автоматически распространяться на связанные сущности.
    - **Типы**:
        - `CascadeType.PERSIST`: Сохранение связанной сущности при сохранении основной.
        - `CascadeType.MERGE`: Обновление связанной сущности при обновлении основной.
        - `CascadeType.REMOVE`: Удаление связанной сущности при удалении основной.
        - `CascadeType.ALL`: Включает все вышеперечисленные операции.
        - `CascadeType.DETACH`: Отсоединение связанной сущности при отсоединении основной.
        - `CascadeType.REFRESH`: Обновление связанной сущности из базы данных.
    - **Пример**:
      ```java
      @OneToMany(mappedBy = "user", cascade = CascadeType.ALL)
      private List<Order> orders;
      ```
      При сохранении объекта `User` все связанные `Order` также будут сохранены.

- **`FetchType`**:
    - **Описание**: Определяет, когда загружаются связанные данные.
    - **Типы**:
        - `FetchType.LAZY`: Данные загружаются только при обращении (ленивая загрузка). Подходит для оптимизации производительности.
        - `FetchType.EAGER`: Данные загружаются сразу вместе с сущностью. Может привести к избыточным запросам.
    - **Пример**:
      ```java
      @ManyToOne(fetch = FetchType.LAZY)
      @JoinColumn(name = "user_id")
      private User user;
      ```
    - **Рекомендации**:
        - Используйте `LAZY` для большинства связей, чтобы избежать ненужных запросов.
        - Используйте `EAGER` только для небольших и часто используемых данных.
        - Для `LAZY` избегайте `LazyInitializationException`, инициализируя данные с помощью `Hibernate.initialize()` или `fetch join` в запросах.

---

### Расскажите про Композитные ключи?

Сложные маппинги включают работу с композитными ключами, наследованием сущностей и маппингом коллекций, которые требуют более тонкой настройки.

Композитные ключи используются, когда первичный ключ сущности состоит из нескольких полей.

- **`@EmbeddedId`**:
    - **Описание**: Использует отдельный класс для представления композитного ключа.
    - **Пример**:
      ```java
      @Embeddable
      public class OrderItemKey implements Serializable {
          @Column(name = "order_id")
          private Long orderId;
  
          @Column(name = "product_id")
          private Long productId;
  
          // Геттеры, сеттеры, equals, hashCode
      }
  
      @Entity
      @Table(name = "order_items")
      public class OrderItem {
          @EmbeddedId
          private OrderItemKey id;

      }
      ```
    - **Особенности**:
        - Класс ключа должен быть помечен `@Embeddable` и реализовать `Serializable`.
        - Атрибуты ключа мапятся на столбцы с помощью `@MapsId`.

- **`@IdClass`**:
    - **Описание**: Альтернативный способ, где композитный ключ определяется через отдельный класс, но поля ключа дублируются в сущности.
    - **Пример**:
      ```java
      public class OrderItemKey implements Serializable {
          private Long orderId;
          private Long productId;
  
          // Геттеры, сеттеры, equals, hashCode
      }
  
      @Entity
      @Table(name = "order_items")
      @IdClass(OrderItemKey.class)
      public class OrderItem {
          @Id
          @Column(name = "order_id")
          private Long orderId;
  
          @Id
          @Column(name = "product_id")
          private Long productId;
          
      }
      ```
    - **Особенности**:
        - Требует дублирования полей ключа в сущности.
        - Менее гибкий, чем `@EmbeddedId`, но проще в некоторых случаях.

- **Когда использовать**:
    - `@EmbeddedId`: Для сложных ключей, где требуется чёткое разделение логики ключа.
    - `@IdClass`: Для простых ключей, где дублирование полей не создаёт проблем.

#### **Как работает наследование сущностей**?
Hibernate поддерживает три стратегии наследования для маппинга иерархий классов:

- **`SINGLE_TABLE`**:
    - **Описание**: Все классы иерархии хранятся в одной таблице с дискриминаторным столбцом.
    - **Аннотации**:
        - `@Inheritance(strategy = InheritanceType.SINGLE_TABLE)`
        - `@DiscriminatorColumn`: Указывает столбец для различения типов.
        - `@DiscriminatorValue`: Значение для конкретного подкласса.
    - **Пример**:
      ```java
      @Entity
      @Inheritance(strategy = InheritanceType.SINGLE_TABLE)
      @DiscriminatorColumn(name = "type", discriminatorType = DiscriminatorType.STRING)
      public abstract class Vehicle {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;
          private String brand;
      }
  
      @Entity
      @DiscriminatorValue("CAR")
      public class Car extends Vehicle {
          private int seats;
      }
  
      @Entity
      @DiscriminatorValue("BIKE")
      public class Bike extends Vehicle {
          private boolean hasSidecar;
      }
      ```
    - **Особенности**:
        - Все данные хранятся в одной таблице, столбцы для специфичных полей подклассов могут быть `null`.
        - Высокая производительность при чтении, но может быть неэффективна для больших иерархий.

- **`TABLE_PER_CLASS`**:
    - **Описание**: Каждый класс иерархии мапится на отдельную таблицу.
    - **Аннотация**: `@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)`
    - **Пример**:
      ```java
      @Entity
      @Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)
      public abstract class Vehicle {
          @Id
          @GeneratedValue(strategy = GenerationType.AUTO)
          private Long id;
          private String brand;
      }
  
      @Entity
      @Table(name = "cars")
      public class Car extends Vehicle {
          private int seats;
      }
  
      @Entity
      @Table(name = "bikes")
      public class Bike extends Vehicle {
          private boolean hasSidecar;
      }
      ```
    - **Особенности**:
        - Каждая таблица содержит все поля класса, включая унаследованные.
        - Может приводить к дублированию структуры таблиц.
        - Использует `UNION` для запросов к базовому классу, что снижает производительность.

- **`JOINED`**:
    - **Описание**: Базовый класс и подклассы мапятся на отдельные таблицы, связанные по первичному ключу.
    - **Аннотация**: `@Inheritance(strategy = InheritanceType.JOINED)`
    - **Пример**:
      ```java
      @Entity
      @Inheritance(strategy = InheritanceType.JOINED)
      public abstract class Vehicle {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;
          private String brand;
      }
  
      @Entity
      @Table(name = "cars")
      public class Car extends Vehicle {
          private int seats;
      }
  
      @Entity
      @Table(name = "bikes")
      public class Bike extends Vehicle {
          private boolean hasSidecar;
      }
      ```
    - **Особенности**:
        - Таблица базового класса содержит общие поля, а таблицы подклассов — специфичные.
        - Требует `JOIN` для загрузки подклассов, что может быть менее производительным.
        - Обеспечивает нормализацию данных и экономию пространства.

- **Когда использовать**:
    - `SINGLE_TABLE`: Для простых иерархий с небольшим количеством специфичных полей.
    - `TABLE_PER_CLASS`: Для иерархий, где подклассы сильно различаются, и нормализация не требуется.
    - `JOINED`: Для сложных иерархий, где важна нормализация и минимизация дублирования данных.

---

### **Как использовать Кастомные типы**

Hibernate позволяет работать с нестандартными типами данных (например, JSON, массивы PostgreSQL) через аннотацию `@Type` и реализацию пользовательских типов (`UserType`).

#### ** Использование `@Type`**
- **Описание**: Аннотация `@Type` указывает Hibernate, как мапить поле на нестандартный тип данных, поддерживаемый конкретной СУБД.
- **Пример (JSON в PostgreSQL)**:
  ```java
  import org.hibernate.annotations.Type;

  @Entity
  public class User {
      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;

      @Type(type = "jsonb")
      @Column(name = "data", columnDefinition = "jsonb")
      private Map<String, Object> data;
  }
  ```
    - **Требования**:
        - Зависимость для поддержки JSON (например, `hibernate-types` от Vlad Mihalcea):
          ```xml
          <dependency>
              <groupId>com.vladmihalcea</groupId>
              <artifactId>hibernate-types-52</artifactId>
              <version>2.21.1</version>
          </dependency>
          ```
        - Диалект, поддерживающий JSON (например, `PostgreSQLDialect`).
    - **Особенности**:
        - Hibernate автоматически сериализует/десериализует JSON в `Map`, `List` или пользовательский объект.
        - Поддерживает типы `json` и `jsonb` в PostgreSQL.
        - 

#### **Реализация пользовательских типов через `UserType`**
- **Описание**: Для сложных нестандартных типов можно реализовать интерфейс `org.hibernate.usertype.UserType`, определяющий, как Hibernate мапит Java-объект на SQL-данные и обратно.
- **Пример**:
  ```java
  import org.hibernate.usertype.UserType;
  import java.sql.*;

  public class CustomMoneyType implements UserType {
      @Override
      public int[] sqlTypes() {
          return new int[]{Types.NUMERIC};
      }

      @Override
      public Class returnedClass() {
          return Money.class;
      }

      @Override
      public Object nullSafeGet(ResultSet rs, String[] names, SharedSessionContractImplementor session, Object owner) throws SQLException {
          BigDecimal amount = rs.getBigDecimal(names[0]);
          return rs.wasNull() ? null : new Money(amount);
      }

      @Override
      public void nullSafeSet(PreparedStatement st, Object value, int index, SharedSessionContractImplementor session) throws SQLException {
          if (value == null) {
              st.setNull(index, Types.NUMERIC);
          } else {
              st.setBigDecimal(index, ((Money) value).getAmount());
          }
      }

      // Реализация остальных методов (equals, hashCode, deepCopy, и т.д.)
  }
  ```
    - **Использование**:
      ```java
      @Entity
      public class Product {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;
  
          @Type(type = "com.example.CustomMoneyType")
          @Column(name = "price")
          private Money price;
      }
      ```
    - **Особенности**:
        - Требуется реализация методов для сериализации/десериализации, обработки `null`, сравнения и копирования.
        - Используется для сложных типов, не поддерживаемых стандартными маппингами Hibernate.

- **Когда использовать**:
    - `@Type`: Для типовых нестандартных данных (JSON, массивы, геометрические типы PostgreSQL) с использованием готовых библиотек.
    - `UserType`: Для полностью кастомных типов, где требуется специфическая логика маппинга.

--------------------------------------------------------------------------------------------------------------------
### Работа с запросами в Hibernate

#### **HQL (Hibernate Query Language)**

HQL — это объектно-ориентированный язык запросов, похожий на SQL, но работающий с сущностями и их свойствами, а не с таблицами и столбцами.

- **Синтаксис**: HQL использует синтаксис, аналогичный SQL, но вместо таблиц и столбцов оперирует сущностями и их атрибутами. Например:
  ```java
  from User u where u.name = :name
  ```
  Здесь `User` — это класс сущности, а `name` — её поле.

- **Параметры в запросах**: Для безопасности и предотвращения SQL-инъекций используются именованные параметры (`:param`):
  ```java
  Query query = session.createQuery("from User u where u.id = :userId");
  query.setParameter("userId", 1L);
  User user = (User) query.getSingleResult();
  ```
  
#### **Criteria API**

Criteria API предоставляет программный, типобезопасный способ создания запросов, что особенно полезно для динамических запросов.

- **Основные компоненты**:
    - `CriteriaBuilder` — фабрика для создания условий, выражений и предикатов.
    - `CriteriaQuery` — объект, представляющий сам запрос.
    - `Root` — корень запроса, представляющий сущность.

- **Пример выборки**:
  ```java
  CriteriaBuilder cb = session.getCriteriaBuilder();
  CriteriaQuery<User> cq = cb.createQuery(User.class);
  Root<User> root = cq.from(User.class);
  cq.select(root).where(cb.equal(root.get("age"), 18));
  List<User> users = session.createQuery(cq).getResultList();
  ```

#### **JPQL (Java Persistence Query Language)**

JPQL — это стандартный язык запросов, определённый в спецификации JPA. HQL является расширением JPQL, специфичным для Hibernate.

- **Различия между HQL и JPQL**:
    - JPQL строго следует стандарту JPA, тогда как HQL включает дополнительные возможности Hibernate (например, поддержку `WITH`, `FETCH` и некоторых специфичных функций).
    - JPQL переносим между различными реализациями JPA, HQL — нет.

- **Именованные запросы**:
    - `@NamedQuery`: Определяется в аннотации сущности для повторно используемых JPQL-запросов.
      ```java
      @Entity
      @NamedQuery(name = "User.findByName", query = "SELECT u FROM User u WHERE u.name = :name")
      public class User { ... }
      ```
      ```
    - `@NamedNativeQuery`: Для нативных SQL-запросов с маппингом на сущности.
      ```java
      @NamedNativeQuery(name = "User.findByNameNative",
                        query = "SELECT * FROM users WHERE name = :name",
                        resultClass = User.class)
      ```

#### **Нативные SQL-запросы**

Нативные SQL-запросы используются, когда HQL/JPQL недостаточно гибки (например, для специфичных функций СУБД).

- **Когда использовать**:
    - Для оптимизации сложных запросов, которые трудно выразить в HQL/JPQL.
    - Для использования специфичных функций СУБД (например, оконных функций).
    - Для выполнения массовых операций, не связанных с сущностями.


--------------------------------------------------------------------------------------------------------------------
### Оптимизация производительности в Hibernate

#### **Ленивая и жадная загрузка**

- **Разница между `FetchType.LAZY` и `FetchType.EAGER`**:
    - **`FetchType.LAZY`**: Данные ассоциаций (например, коллекций или связанных сущностей) загружаются только при первом обращении к ним. Это уменьшает объём данных, загружаемых из базы, но может привести к дополнительным запросам (проблема N+1).
      ```java
      @OneToMany(fetch = FetchType.LAZY)
      private List<Order> orders;
      ```
    - **`FetchType.EAGER`**: Все связанные данные загружаются сразу вместе с основной сущностью. Упрощает доступ, но может привести к избыточным данным и снижению производительности.
      ```java
      @ManyToOne(fetch = FetchType.EAGER)
      private User user;
      ```
    - **Рекомендация**: По умолчанию используйте `LAZY` для коллекций (`@OneToMany`, `@ManyToMany`) и анализируйте, где `EAGER` действительно необходим.

- **Проблема N+1 и способы её решения**:
    - **Описание проблемы**: При загрузке N сущностей с ленивыми ассоциациями Hibernate выполняет 1 запрос для основных данных и N дополнительных запросов для загрузки ассоциаций при их обращении.
      ```java
      List<User> users = session.createQuery("from User", User.class).getResultList();
      for (User user : users) {
          user.getOrders().size(); // Выполняется N запросов для orders
      }
      ```
    - **Решения**:
        - **Fetch Join**:
          Используйте `JOIN FETCH` в HQL/JPQL для загрузки ассоциаций в одном запросе:
          ```java
          List<User> users = session.createQuery("from User u left join fetch u.orders", User.class)
                                    .getResultList();
          ```
        - **Batch Fetching**:
          Настройте групповую загрузку через аннотацию `@BatchSize` или свойство `hibernate.default_batch_fetch_size`. Hibernate загружает ассоциации пачками, уменьшая количество запросов:
          ```java
          @OneToMany
          @BatchSize(size = 10)
          private List<Order> orders;
          ```
          Или в `hibernate.cfg.xml`:
          ```xml
          <property name="hibernate.default_batch_fetch_size">10</property>
          ```
        - **Entity Graph**:
          Используйте `@NamedEntityGraph` для явного указания, какие ассоциации загружать:
          ```java
          @NamedEntityGraph(name = "User.orders", attributeNodes = @NamedAttributeNode("orders"))
          @Entity
          public class User { ... }
          ```
          Применение:
          ```java
          EntityGraph<?> graph = session.getEntityGraph("User.orders");
          List<User> users = session.createQuery("from User", User.class)
                                    .setHint("javax.persistence.fetchgraph", graph)
                                    .getResultList();
          ```
#### **Батчинг (Batch Processing)**

- **Оптимизация операций вставки/обновления/удаления**:
    - Для обработки больших объёмов данных используйте пакетную обработку, чтобы минимизировать количество SQL-запросов.
    - Пример вставки:
      ```java
      Session session = sessionFactory.openSession();
      Transaction tx = session.beginTransaction();
      for (int i = 0; i < 1000; i++) {
          User user = new User("User" + i);
          session.persist(user);
          if (i % 50 == 0) { // Сбрасываем каждые 50 операций
              session.flush();
              session.clear();
          }
      }
      tx.commit();
      session.close();
      ```

- **Настройка `hibernate.jdbc.batch_size`**:
    - Устанавливает размер пакета для группировки SQL-операций:
      ```xml
      <property name="hibernate.jdbc.batch_size">50</property>
      ```
    - **Важно**:
        - Убедитесь, что драйвер JDBC и СУБД поддерживают пакетные операции.
        - Для разных сущностей Hibernate может отключать батчинг, если порядок операций важен. Используйте `hibernate.order_inserts=true` и `hibernate.order_updates=true`:
          ```xml
          <property name="hibernate.order_inserts">true</property>
          <property name="hibernate.order_updates">true</property>
          ```
--------------------------------------------------------------------------------------------------------------------
#### **Подходы управление транзакциями**

- **Разница между декларативным и программным управлением транзакциями**:
    - **Декларативное управление (`@Transactional` в Spring)**:
        - Используется аннотация `@Transactional` на уровне методов или классов для автоматического управления транзакциями через AOP.
        - Преимущества: Чистый код, централизованное управление, легко настраиваемый.
        - Пример:
          ```java
          @Service
          public class UserService {
              @Transactional(readOnly = true)
              public User findUser(Long id) {
                  return userRepository.findById(id)");
              }
    
              @Transactional
              public void updateUser(User user) {
                  userRepository.save(user);
              }
          }
          ```
        - **Программное управление**:
            - Явное управление транзакциями через API `Session` (Hibernate) или `PlatformTransactionManager` (Spring).
            - Пример с Hibernate:
              ```java
              Session session = sessionFactory.openSession();
              Transaction tx = null;
              try {
                  tx = session.beginTransaction();
                  session.save(user);
                  tx.commit();
              } catch (Exception e) {
                  if (tx != null) tx.rollback();
                  throw e;
              } finally {
                  session.close();
              }
              ```
        
            - **Сравнение**:
                - Декларативное: Лучше для большинства случаев, упрощает код.
                - Программное: Используется для сложной логики, где требуется детальный контроль (например, несколько транзакций в одном методе).

--------------------------------------------------------------------------------------------------------------------

#### Расскажите про блокировки

- **Оптимистическая блокировка**:
    - Используется для предотвращения конфликтов при одновременном обновлении одной сущности несколькими транзакциями.
    - Реализуется через аннотацию `@Version`:
      ```java
      @Entity
      public class User {
          @Id
          private Long id;
          @Version
          private Integer version; // Поле для отслеживания версии
          private String name;
      }
      ```
    - Как работает:
        - При каждом обновлении сущности Hibernate увеличивает значение `version`.
        - Если две транзакции пытаются обновить одну сущность, Hibernate проверяет `version`. Если версия изменилась, выбрасывается `OptimisticLockException`.
    - Пример обработки:
      ```java
      @Transactional
      public void updateUser(Long id, String newName) {
          try {
              User user = session.get(User.class, id);
              user.setName(newName);
              session.update(user);
          } catch (OptimisticLockException e) {
              // Обработка конфликта, например, повторная попытка или уведомление пользователя
              throw new RuntimeException("Конфликт обновления", e);
          }
      }
      ```
    - **Когда использовать**: Для приложений с высокой конкуренцией чтения и редкими обновлениями.

- **Пессимистическая блокировка**:
    - Блокирует записи в базе данных на уровне СУБД, предотвращая доступ других транзакций.
    - Поддерживаемые режимы (`LockModeType`):
        - `PESSIMISTIC_READ`: Блокировка для чтения (другие могут читать, но не записывать).
        - `PESSIMISTIC_WRITE`: Эксклюзивная блокировка (никто не может читать или записывать).
        - `PESSIMISTIC_FORCE_INCREMENT`: Блокировка с инкрементом версии (для оптимистической и пессимистической комбинации).
    - Пример в HQL:
      ```java
      User user = session.createQuery("from User u where u.id = :id", User.class)
                         .setParameter("id", 1L)
                         .setLockMode(LockModeType.PESSIMISTIC_WRITE)
                         .getSingleResult();
      ```
    - Пример с `session.get`:
      ```java
      User user = session.get(User.class, 1L, LockMode.PESSIMISTIC_WRITE);
      ```
    - **Когда использовать**: Для критических операций, где конфликты недопустимы (например, финансовые транзакции).

--------------------------------------------------------------------------------------------------------------------

Какая разница в работе методов load(); и get();?

Hibernate session обладает различными методами для загрузки данных из базы данных. Наиболее часто используемые методы для этого - get() и load().

Метод load(); обычно используется когда в не уверен что запрашиваемый объект уже находится в базе данных. Если объект не найден, то метод кидает исключение Если объект найден — метод возвращает прокси объект, который является ссылкой на объект находящийся в базе данных (запрос в базу данных еще не был осуществлен, своего рода lazy изъятие), непосредственный запрос к базе данных когда мы непосредственно обращаемся к необходимому объекту через прокси объект.

Метод get(); используется тогда, вы на 100 процентов не уверены есть ли запрашиваемый объект в базе данных. В случае обращение к несуществующему объекту, метод get(); вернет null. В случае нахождения объект, метод get(); вернет сам объект и запрос в базу данных будет произведен немедленно.

--------------------------------------------------------------------------------------------------------------------

Что произойдет, если будет отсутствовать конструктор без аргументов у Entity Bean?

Hibernate использует рефлексию для создания экземпляров Entity бинов при вызове методов get() или load(). Для этого используется метод Class.newInstance(), который требует наличия конструктора без параметров. Поэтому, в случае его отсутствия, вы получите ошибку HibernateException.

--------------------------------------------------------------------------------------------------------------------

Как используется вызов метода Hibernate Session merge()?

Hibernate merge() может быть использован для обновления существующих значений, однако этот метод создает копию из переданного объекта сущности и возвращает его. Возвращаемый объект является частью контекста персистентности и отслеживает любые изменения, а переданный объект не отслеживается.

--------------------------------------------------------------------------------------------------------------------

В чем разница между Hibernate save(), saveOrUpdate() и persist()?

Hibernate save() используется для сохранения сущности в базу данных. Проблема с использованием метода save() заключается в том, что он может быть вызван без транзакции. А следовательно если у нас имеется отображение нескольких объектов, то только первичный объект будет сохранен и мы получим несогласованные данные. Также save() немедленно возвращает сгенерированный идентификатор. Hibernate persist() аналогичен save() с транзакцией. persist() не возвращает сгенерированный идентификатор сразу. Hibernate saveOrUpdate() использует запрос для вставки или обновления, основываясь на предоставленных данных. Если данные уже присутствуют в базе данных, то будет выполнен запрос обновления. Метод saveOrUpdate() можно применять без транзакции, но это может привести к аналогичным проблемам, как и в случае с методом save().


--------------------------------------------------------------------------------------------------------------------

В чем разница между sorted collection и ordered collection? Какая из них лучше?

При использовании алгоритмов сортировки из Collection API для сортировки коллекции, то он вызывает отсортированный список (sorted list). Для маленьких коллекций это не приводит к излишнему расходу ресурсов, но на больших коллекциях это может привести к потери производительности и ошибкам OutOfMemory. Так же entity бины должны реализовывать интерфейс Comparable или Comparator для работы с сортированными коллекциями. При использовании фреймворка Hibernate для загрузки данных из базы данных мы можем применить Criteria API и команду order by для получения отсортированного списка (ordered list). Ordered list является лучшим выбором к sorted list, т.к. он использует сортировку на уровне базы данных. Она быстрее и не может привести к утечке памяти.

Пример запроса к БД для получения ordered list:
List<Employee> empList = session.createCriteria(Employee.class)
.addOrder(Order.desc("id")).list();


--------------------------------------------------------------------------------------------------------------------

Почему мы не должны делать Entity class как final?

Хибернейт использует прокси классы для ленивой загрузки данных (т.е. по необходимости, а не сразу). Это достигается с помощью расширения entity bean и, следовательно, если бы он был final, то это было бы невозможно. Ленивая загрузка данных во многих случаях повышает производительность, а следовательно важна.


--------------------------------------------------------------------------------------------------------------------

Какие каскадные типы есть в Hibernate?

Наиболее часто используемые CascadeType перечисления описаны ниже.

None: без Cascading. Формально это не тип, но если мы не указали каскадной связи, то никакая операция для родителя не будет иметь эффекта для ребенка.

ALL: Cascades save, delete, update, evict, lock, replicate, merge, persist. В общем — всё.

SAVE_UPDATE: Cascades save и update. Доступно только для hibernate.

DELETE: передает в Hibernate native DELETE действие. Только для hibernate.

DETATCH, MERGE, PERSIST, REFRESH и REMOVE - для простых операций.

LOCK: передает в Hibernate native LOCK действие.

REPLICATE: передает в Hibernate native REPLICATE действие.


--------------------------------------------------------------------------------------------------------------------

Какие паттерны применяются в Hibernate?

Domain Model Pattern - объектная модель предметной области, включающая в себя как поведение так и данные.
Data Mapper - слой мапперов (Mappers), который передает данные между объектами и базой данных, сохраняя их независимыми друг от друга и себя.
Proxy Pattern - применяется для ленивой загрузки.
Factory pattern - используется в SessionFactory

--------------------------------------------------------------------------------------------------------------------

Расскажите о преимуществах использования Hibernate Criteria API.

Hibernate Criteria API является более объектно-ориентированным для запросов, которые получают результат из базы данных. Для операций update, delete или других DDL манипуляций использовать Criteria API нельзя. Критерии используются только для выборки из базы данных в более объектно-ориентированном стиле.

Вот некоторые области применения Criteria API:

Criteria API поддерживает проекцию, которую мы можем использовать для агрегатных функций вроде sum(), min(), max() и т.д.

Criteria API может использовать ProjectionList для извлечения данных только из выбранных колонок.

Criteria API может быть использована для join запросов с помощью соединения нескольких таблиц, используя методы createAlias(), setFetchMode() и setProjection().

Criteria API поддерживает выборку результатов согласно условиям (ограничениям). Для этого используется метод add() с помощью которого добавляются ограничения (Restrictions).

Criteria API позволяет добавлять порядок (сортировку) к результату с помощью метода addOrder().


--------------------------------------------------------------------------------------------------------------------

Best Practices в Hibernate

При использовании фреймворка Hibernate рекомендуется придерживаться некоторых правил.

Всегда проверяйте доступ к primary key. Если он создается базой данных, то вы не должны иметь сеттера.

По умолчанию hibernate устанавливает значения в поля напрямую без использования сеттеров. Если необходимо заставить хибернейт их применять, то проверьте использование аннотации @Access(value=AccessType.PROPERTY) над свойством.

Если тип доступа - property, то удостоверьтесь, что аннотация используется с геттером.
Избегайте смешивания использования аннотации над обоими полями и геттером.

Используйте нативный sql запрос только там, где нельзя использовать HQL.

Используйте ordered list вместо сортированного списка из Collection API, если вам необходимо получить отсортированные данные.

Применяйте именованные запросы разумно - держите их в одном месте и используйте только для часто применяющихся запросов. Для специфичных запросов пишите их внутри конкретного бина.

В веб приложениях используйте JNDI DataSource вместо файла конфигурации для соединения с БД.

Избегайте отношений многие-ко-многим, т.к. это можно заменить двунаправленной One-to-Many и Many-to-One связью.

Для collections попробуйте использовать Lists, maps и sets. Избегайте массивов (array), т.к. они не дают преимуществ ленивой загрузки.

Не обрабатывайте исключения, которые могут откатить транзакцию и закрыть сессию. Если это проигнорировать, то Hibernate не сможет гарантировать, что состояние в памяти соответствует состоянию персистентности (могут быть коллизии данных).

Применяйте шаблон DAO для методов, которые могут использоваться в entity бинах.

Предпочитайте ленивую выборку для ассоциаций.

--------------------------------------------------------------------------------------------------------------------

Что такое Hibernate? В чём разница между JPA и Hibernate?

Я думаю, чтобы ответить на данный вопрос, нам сперва нужно понять, что такое JPA. JPA — это спецификация, описывающая объектно-реляционное отображение простых Java объектов и предоставляющая API для сохранения, получения и управления такими объектами. То есть, как мы помним, реляционные базы данных (БД) представлены в виде множества связанных между собой таблиц. И JPA — общепринятый стандарт, который описывает, как объекты могут взаимодействовать с реляционными базами данных. Как видие, JPA — это что-то абстрактное и неосязаемое. Это как бы сама идея, подход.В то же время Hibernate — это конкретная библиотека, реализующая парадигмы JPA. То, есть с помощью этой библиотеки вы можете работать с реляционной базой данных через объекты, которые представляют данные с БД (Entity). Как говорят, данная библиотека очень близка к идеалам JPA и возможно, поэтому она стала популярна. А как вы понимаете, популярность использования — хороший аргумент для дальнешйей разработки и улучшений. К тому же за частым использованием стоит огромное комьюнити, которое разобрало уже все возможные и невозможные вопросы, связанные с данным инструментом.

--------------------------------------------------------------------------------------------------------------------

Что такое каскадность? Как она используется в Hibernate?

Как я и сказал ранее, в Hibernate взаимодействие ведется через объекты данных, называемые entity. Эти entity представляют какие-то конкретные таблицы в базе данных, и как вы помните, в Java классы могут содержать ссылки на другие классы. Эти отношения отражаются и на базе данных. В БД, как правило, это либо внешние ключи (для OneToOne, OneToMany, ManyToOne), либо промежуточные таблицы (для ManyToMany) Подробнее о взаимосвязи между сущностями можно почитать в этой статье. Когда в вашем entity есть ссылки на другие связанные сущности, над этими ссылками ставятся аннотации для указания типа связи: @OneToOne, @OneToMany, @ManyToOne, @ManyToMane, в чьих параметрах вы можете указать значение свойства — cascade — тип каскаданости для данной связи. У JPA есть специфические методы для взаимодействия с сущностями (persist, save, merge...). Каскадные типы как раз используются для того, чтобы показать, как должны себя вести связанные данные при использовании этих методов на целевую сущность. Итак, какие же существуют стратегии каскаскадности (типы каскадности)? Стандарт JPA подразумевает использование шести видов каскадности:
PERSIST — операции сохранения будут происходить каскадно (для методов save() и persist()). То есть, если мы сохраняем сущность, связанную с другими сущностями, они также сохраняются в БД (если их ещё там нет)

MERGE — операции обновления будут происходить каскадно (для метода merge())
REMOVE — операции удаления происходят каскадно (метод remove())
ALL — содержит сразу три каскадные операции — PERSIST - MERGE - REMOVE
В JPA есть понятие персистентная (persistence) сущность — сущность, связанная с её данными в БД, которая управляется текущей сессией (соединением). Если её изменить, но при этом не сохранить изменения в БД, всё равно её данные в БД будут изменены.
DETACH — связанные сущности не будут управляться сессией (метод detach()). То есть, при их изменении не будет автоматического изменения их данных в БД — они переводятся из состояния persistence в detached (сущность, не управляемая JPA)
REFRESH — при каждом обновлении сущности данными из БД (refresh() — обновляет detached объекты) связанные сущности обновляются так же. Например, вы изменили как-то данные, взятые из БД, и хотите вернуть их изначальные значения. В таком случае вам и пригодится данная операция.
Hibernate поддерживает все эти стандартные каскадные операции, но также привносит три свои:
REPLICATE — используется, когда у нас есть более одного источника данных и мы хотим, чтобы данные синхронизировались (метод Hibernate — replicate). У всех сущностей должны быть идентификаторы (id), чтобы не было проблем с их генерацией (чтобы для разных БД одна и та же сущность не имела разных id)
SAVE_UPDATE — каскадное сохранение/удаление (для метода Hibernate — saveOrUpdate)
LOCK — операция, обратная к DETACHED: переводит detached сущность обратно в состояние persistence, т.е. entity станет снова отслеживаемой текущей сессией
Если не выбран тип каскадирования, никакая операция с сущностью не будет иметь эффекта для связанных с ней других entity.

--------------------------------------------------------------------------------------------------------------------

N+1 SELECT problem и пути ее решения?

Проблема n + 1 может возникнуть в случае, когда одна сущность (таблица) ссылается на другую сущность (таблицу).
В такой ситуации получается, что для получения значения зависимой сущности выполняется n избыточных запросов, в то время как достаточно одного.
Никого не нужно убеждать, что это негативно влияет на производительность системы и создает ненужную нагрузку на базу данных. Особенно то, что количество запросов увеличивается с ростом n.
Сама проблема часто представляется как возникающая только в отношениях "один ко многим" (javax.persistence.OneToMany) или только в случае ленивой загрузки данных (javax.persistence.FetchType.LAZY). Это не так, и следует помнить, что эта проблема также может возникнуть в отношениях один-к-одному и при "жадной" загрузке зависимых сущностей.

Решение
1)Устранение проблемы с помощью Join Fetch
2)Добавив аннотацию @BatchSize над полем , Hibernate получит данные в рамках одного запроса. (Всего их будет два)

--------------------------------------------------------------------------------------------------------------------

Что такое Блокировка?

Блокировки - это меры по предотвращению модификации данных в реляционной базе данных между временем их чтения, и временем их использования.Стратегия блокировок может быть либо оптимистичной, либо пессимистичной.

--------------------------------------------------------------------------------------------------------------------

Какие бывают Стратегии блокировок?

Оптимистичная
Оптимистичные блокировки предполагают, что множество транзакций могут завершиться без влияния друг на друга, и таким образом могут выполнятся без блокировок тех ресурсов, на которые они влияют. Перед коммитом, каждая транзакция проверяет, что ни одна другая транзакция не модифицировала ее данные. Если проверка выявила конфликтующие модификации, транзакция, находящаяся в состоянии коммита, откатывается. В hibernate при коммите в базу данных производится сравнивание значения поля, помеченного как version, на момент получения данных и на данный момент. Если оно изменилось, то есть какая-то другая транзакция опередила нашу и успела изменить данные, то в таком случае наша транзакция выбрасывает ошибку, и необходимо заново запускать ее. При использовании оптимистичных блокировок обеспечивается более высокий уровень конкурентности при доступе к базе, но в таком случае приходится повторять транзакции, которые не успели внести изменения раньше других.

Пессимистичная
Пессимистичная стратегия подразумевает, что параллельные транзакции будут конфликтовать каждая друг с другом, и требует блокировки ресурсов после их чтения, а также ее снятия только после того, как приложение завершило использование данных.
В пессимистичных блокировках накладывается сразу же перед предполагаемой модификацией данных на все строки, которые такая модификация предположительно затрагивает
А при использовании пессимистичных блокировок гарантируется отсутствие противоречий при выполнении транзакции, за счет помещение остальных в режим ожидания(но на это тратится время), как следствие понижение уровня конкурентности.

Hibernate предоставляет механизмы для реализации обеих стратегий блокировок в вашем приложении.

--------------------------------------------------------------------------------------------------------------------

Оптимистичные блокировки описать?

Вы можете хранить версионированные данные, когда ваше приложение использует долгоживущие транзакции или диалоги, покрывающие несколько БД-транзакций. Таким образом, если одна и та же сущность будет модифицироваться двумя диалогами, последний диалог, коммитивший изменения, будет оповещен о конфликте, и не перезапишет результаты другого диалога. Этот подход гарантирует некоторую степень изоляции, но при этом хорошо масштабируется, и довольно неплохо себя показывает в ситуациях Read-Often Write-Sometimes
Hibernate предоставляет два различных механизма для хранения версионной информации - выделенный номер версии, или временную метку (timestamp).

--------------------------------------------------------------------------------------------------------------------

Выделенный номер версии для Оптимистичной блокировки

Механизм номера версии для оптимистичных блокировок предоставляется аннотацией Version

Version решает проблему с потерянными обновлениями.

@Entity
public class Flight implements Serializable { ...
@Version
@Column(name="OPTLOCK")
public Integer getVersion() { ... }
}
Здесь свойство версии маппится на колонку OPTLOCK, а менеджер сущностей (entity manager) использует ее для выявления конфликтующих обновлений, и предотвращения потери обновлений, которые были бы перезаписаны стратегией last-commit-wins
Колонка версии может быть любого типа, при условии, что вы определите и реализуете подходящий UserVersionType.
Вашему приложению запрещено изменять номер версии, проставленный Hibernate. Чтобы искусственно увеличить номер версии, см. описание свойств LockModeType.OPTIMISTIC_FORCE_INCREMENT или LockModeType.PESSIMISTIC_FORCE_INCREMENT в документации по Hibernate Entity Manager. Если номер версии сгенерирован базой данных, например триггером, используйте аннотацию org.hibernate.annotations.Generated(GenerationTime.ALWAYS).

LockModeType.OPTIMISTIC
Это оптимистическая блокировка, ну это и так логично. Как я писал выше, происходит сравнения значение поля version, если оно отличается, то бросается ошибка.

LockModeType.OPTIMISTIC_FORCE_INCREMENT
Работает по тому же алгоритму, что и LockModeType.OPTIMISTIC за тем исключением, что после commit значение поле Version принудительно увеличивается на 1. В итоге окончательно после каждого коммита поле увеличится на 2(увеличение, которое можно увидеть в Post-Update + принудительное увеличение). Вопрос. Зачем? Если после коммита мы хотим еще «поколдовать» над этими же данными, и нам не нужны сторонние транзакции, которые могут ворваться между первым коммитом и закрытием нашей транзакции.

LockModeType.PESSIMISTIC_READ — пессимистичная блокировка на чтение.

LockModeType.PESSIMISTIC_WRITE — пессимистичная блокировка на запись (и чтение).

LockModeType.PESSIMISTIC_FORCE_INCREMENT — пессимистичная блокировка на запись (и чтение) с принудительным увеличением поля Version.

--------------------------------------------------------------------------------------------------------------------

Timestamp для Оптимистичной блокировки

Временные метки (timestamps) — менее надежный способ оптимистичных блокировок чем номера версий, который также может быть использован приложениями для других целей. Временные метки используются автоматически, если вы используете аннотацию Version на свойстве типа Date или Calendar.

@Entity
public class Flight implements Serializable {
...
@Version
public Date getLastUpdate() { ... }
}

Hibernate может извлечь значение временной метки из базы данных или JVM, прочитав значение аннотации org.hibernate.annotations.Source. Значение может быть либо org.hibernate.annotations.SourceType.DB, либо org.hibernate.annotations.SourceType.VM. Поведение по-умолчанию - это использование БД, также используемое, если вы не укажете аннотацию.Временная метка также может быть сгенерирована базой данных вместо Hibernate, если вы используете аннотацию org.hibernate.annotations.Generated(GenerationTime.ALWAYS).

--------------------------------------------------------------------------------------------------------------------

Пессимистичные блокировки

Класс LockMode определяет различные уровни блокировок, которые может захватывать Hibernate.

LockMode.WRITE
Захватывается автоматически, когда Hibernate обновляет или вставляет строку.
LockMode.UPGRADE
Захватывается после явного запроса пользователя с использованием SELECT... FOR UPDATE на БД, поддерживающих данный синтаксис.
LockMode.UPGRADE_NOWAIT
Захватывается после явного запроса пользователя с использованием SELECT... FOR UPDATE NOWAIT в Oracle
LockMode.READ
Захватывается автоматически когда Hibernate читает данные под уровнями изоляции Repeatable Read или Serializable. Может быть повторно захвачен явным запросом пользователя.
LockMode.NONE
Отсутствие блокировки. Все объекты переключаются на этот режим блокировки в конце транзакции. Объекты, ассоциированные с сессиейчерез вызов update() или saveOrUpdate также начинают в этом режиме .

Явный запрос пользователя, обозначенный выше, происходит как следствие любых из следующих действий:
Вызов Session.load(), с указанием LockMode
Вызов Session.lock()
Вызов Query.setLockMode()
Если вы вызовете Session.load() с опцией UPGRADE или UPGRADE_NOWAIT, и запрошенный объект еще не подгрузился сессией, объект подгружается с помощью SELECT... FOR UPDATE. Если вы вызовете load() для объекта, которые уже подгружен с менее строгой блокировкой, чем с той, что вы запросили, Hibernate вызовет lock() для этого объекта.Session.lock() осуществляет проверку номера версии в режимах READ, UPGRADE, или UPGRADE_NOWAIT. В случаях UPGRADE или UPGRADE_NOWAIT, будет использован синтаксис SELECT... FOR UPDATE.Если запрошенный режим блокировки не поддерживается базой данных, Hibernate будет использовать подходящий альтернативный режим вместо выбрасывания исключения. Это гарантирует переносимость приложений.

--------------------------------------------------------------------------------------------------------------------