### Что такое ORM?

**ORM (Объектно-реляционное отображение)** — это технология, которая позволяет программисту работать с реляционными базами данных через объекты своего языка программирования, вместо написания SQL-запросов.

---------

### Какие паттерны применяются в Hibernate?

Основные паттерны в Hibernate:
*   **Domain Model** — объединение данных и поведения в объектах.
*   **Data Mapper** — слой, отвечающий за перенос данных между объектами и БД.
*   **Proxy** — используется для ленивой загрузки данных.
*   **Factory** — применяется в `SessionFactory` для создания сессий.

---------

### Что такое Hibernate? В чём разница между JPA и Hibernate?

*   **JPA** — это **стандарт (спецификация)**, который описывает правила взаимодействия Java-объектов с базами данных. Это "теория".
*   **Hibernate** — это **конкретная библиотека (реализация)**, которая следует правилам JPA. Это "практика" и один из самых популярных инструментов для реализации JPA.

---------

### Какие преимущества от использования Hibernate?

*   Убирает повторяющийся код (в сравнении с JDBC).
*   Предоставляет мощные инструменты: язык запросов **HQL**, **кэширование** и **ленивую загрузку** для повышения производительности.
*   Легко интегрируется с другими фреймворками (например, Spring).
*   Поддерживает чистый SQL для сложных запросов.
*   Имеет большое сообщество и много документации.

---------

### Как Hibernate помогает в программировании?

Hibernate упрощает разработку, так как:
*   Берёт на себя написание большинства SQL-запросов.
*   Автоматически генерирует таблицы в базе данных.
*   Предоставляет готовые инструменты для оптимизации (кэширование, ленивая загрузка).

---------

### Какие преимущества Hibernate над JDBC?

*   **Меньше кода:** Hibernate устраняет шаблонный код, обязательный для JDBC.
*   **Больше возможностей:** Поддерживает ООП-концепции (наследование, связи), недоступные в JDBC.
*   **Проще управление:** Автоматизирует транзакции и использует более удобные непроверяемые исключения.
*   **Выше производительность:** Предлагает кэширование, которого нет в JDBC.
*   **Гибкость:** Может сам управлять схемой БД и использует более объектно-ориентированный язык HQL.

--------------------------------------------------------------------------------------------------------------------

Что такое конфигурационный файл Hibernate?

Файл конфигурации Hibernate содержит в себе данные о базе данных и необходим для инициализации SessionFactory. В .xml файле необходимо указать вендора базы данных или JNDI ресурсы, а так же информацию об используемом диалекте, что поможет hibernate выбрать режим работы с конкретной базой данных.

--------------------------------------------------------------------------------------------------------------------

Способы конфигурации работы с Hibernate.

Существует четыре способа конфигурации работы с Hibernate

используя аннотации;
hibernate.cfg.xml;
hibernate.properties;
persistence.xml.

Самый частый способ конфигурации: через аннотации и файл persistence.xml, что касается файлов hibernate.properties и hibernate.cfg.xml, то hibernate.cfg.xml главнее (если в приложение есть оба файла, то принимаются настройки из файла hibernate.cfg.xml). Конфигурация аннотациями, хоть и удобна, но не всегда возможна, к примеру, если для разных баз данных или для разных ситуаций вы хотите иметь разные конфигурацию сущностей, то следует использовать xml файлы конфигураций.

--------------------------------------------------------------------------------------------------------------------

Какая роль интерфейса Session в Hibernate?

Объект Hibernate Session является связью между кодом java приложения и hibernate. Это основной интерфейс для выполнения операций с базой
данных. Жизненный цикл объекта session связан с началом и окончанием транзакции. Этот объект предоставляет методы для CRUD (create, read,
update, delete) операций для объекта персистентности. С помощью этого экземпляра можно выполнять HQL, SQL запросы и задавать критерии
выборки.
(персистентный объект - объект который уже находится в базе данных; объект запроса - объект который получается когда мы получаем результат
запроса в базу данных, именно с ним работает приложение). Обьект Session можно получить из SessionFactory :

Session session = sessionFactory.openSession();

Роль интерфейса Session:
является оберткой для jdbc подключения к базе данных;
является фабрикой для транзакций (согласно официальной документации transaction - аllows the application to define units of work, что , по
сути, означает что транзакция определяет границы операций связанных с базой данных).
является хранителем обязательного кэша первого уровня.

В JPA эквивалентом Session является EntityManager

--------------------------------------------------------------------------------------------------------------------

Какая роль интерфейса SessionFactory в Hibernate?

SessionFactory является фабрикой классов и используется для получения объектов session. SessionFactory отвечает за считывание параметров
конфигурации Hibernate и подключение к базе данных. Обычно в приложении имеется только один экземпляр SessionFactory и потоки, обслуживающие
клиентские запросы, получают экземпляры session с помощью объекта SessionFactory. Внутреннее состояние SessionFactory неизменно (immutable).
Internal state (внутреннее состояние) включает в себя все метаданные об Object/ Relational Mapping и задается при создании SessionFactory.
SessionFactory также предоставляет методы для получения метаданных класса и статистики, вроде данных о втором уровне кэша, выполняемых
запросах и т.д.
SessionFactory кэширует мета-дату и SQL запросы которые часто используются приложением во время работы. Так же оно кэширует информацию
которая была получена в одной из транзакций и может быть использована и в других транзакциях.

В контексте JPA используется EntityManagerFactory, которая выполняет аналогичную роль.

--------------------------------------------------------------------------------------------------------------------

Является ли Hibernate SessionFactory потокобезоспансым?

Т.к. объект SessionFactory immutable (неизменяемый), то да, он потокобезопасный. Множество потоков может обращаться к одному объекту
одновременно.

--------------------------------------------------------------------------------------------------------------------

В чем разница между openSession и getCurrentSession?

| **Характеристика**         | **`openSession()`**                                                                     | **`getCurrentSession()`**                                                                                     |
|----------------------------|-----------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------|
| **Источник создания**      | Создает **новую сессию** каждый раз при вызове.                                         | Возвращает **текущую сессию**, связанную с контекстом (например, с текущей транзакцией).                      |
| **Контекст управления**    | Не привязан к контексту, сессия полностью независима.                                   | Привязан к **контексту сессии** (Session Context), обычно управляется контейнером (например, Spring) или JTA. |
| **Закрытие сессии**        | Требует явного вызова `session.close()` для закрытия.                                   | Закрывается автоматически при завершении транзакции или контекста, если настроено.                            |
| **Потокобезопасность**     | Не привязан к потоку, можно использовать в любом потоке, но требует ручного управления. | Привязан к текущему потоку (Thread-Local) в рамках контекста, безопасен для текущего потока.                  |
| **Типичное использование** | Подходит для автономных приложений или случаев, где нужен полный контроль над сессией.  | Используется в управляемых окружениях (например, Spring, JEE), где сессия связана с транзакцией.              |
| **Конфигурация**           | Не требует специальной настройки контекста.                                             | Требует настройки свойства `hibernate.current_session_context_class` (например, `thread` или `jta`).          |

--------------------------------------------------------------------------------------------------------------------

### Расскажите про первый уровень кэша (First-Level Cache)?

**Описание**:  
Первый уровень кэша — это кэш, встроенный в сессию Hibernate (`Session`). Он автоматически включён и не требует дополнительной настройки. Этот кэш хранит сущности, загруженные в рамках одной сессии, и используется для обеспечения консистентности данных внутри сессии.

**Характеристики**:
- **Привязка к сессии**: Кэш первого уровня существует только в пределах одной сессии Hibernate. Когда сессия закрывается (или очищается с помощью `session.clear()`), кэш уничтожается.
- **Автоматическое использование**: Hibernate автоматически кэширует все сущности, загруженные через методы `get()`, `load()`, или запросы в рамках сессии.
- **Консистентность**: Гарантирует, что в рамках одной сессии все обращения к одной и той же сущности возвращают один и тот же объект (идентичность объектов).
- **Dirty Checking**: Hibernate использует кэш первого уровня для отслеживания изменений в сущностях (механизм "грязной проверки") и синхронизации их с базой данных при коммите транзакции.

**Как работает**:
- При загрузке сущности (например, `session.get(User.class, 1L)`) Hibernate сначала проверяет кэш первого уровня. Если сущность уже есть в кэше, она возвращается без обращения к базе данных.
- Если сущность отсутствует, Hibernate выполняет SQL-запрос, загружает данные из базы и помещает сущность в кэш сессии.
- Последующие обращения к той же сущности в рамках той же сессии возвращают объект из кэша.

**Пример**:
```java
Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();

// Первое обращение: SQL-запрос к базе
User user1 = session.get(User.class, 1L);

// Второе обращение: возвращается из кэша сессии, без SQL-запроса
User user2 = session.get(User.class, 1L);

assert user1 == user2; // true, это один и тот же объект
tx.commit();
session.close(); // Кэш очищается
```

**Ограничения**:
- Кэш первого уровня недоступен для других сессий или приложений, так как он локален.
- Может потреблять много памяти, если в сессии загружается большое количество объектов.
- Не подходит для долгоживущих сессий, так как кэш растёт и становится неуправляемым.

**Управление**:
- `session.evict(Object entity)`: Удаляет конкретную сущность из кэша.
- `session.clear()`: Полностью очищает кэш сессии.
- `session.contains(Object entity)`: Проверяет, находится ли объект в кэше.

**Когда использовать**:
- Всегда используется по умолчанию в Hibernate.
- Эффективен для операций в рамках одной транзакции или короткой сессии, где требуется высокая консистентность.

---

### Расскажите про второй уровень кэша (Second-Level Cache)?

Второй уровень кэша — это кэш, общий для всех сессий в рамках одного `SessionFactory`. Он хранит данные на уровне приложения и позволяет минимизировать обращения к базе данных для сущностей, которые редко изменяются. В отличие от первого уровня кэша, второй уровень кэша требует явной настройки и подключения провайдера кэша.

**Характеристики**:
- **Привязка к SessionFactory**: Кэш второго уровня существует на протяжении жизненного цикла приложения (или пока `SessionFactory` не закрыт).
- **Настраиваемость**: Можно включить кэширование для отдельных сущностей, коллекций или ассоциаций.
- **Провайдеры**: Hibernate поддерживает несколько провайдеров второго уровня кэша, таких как **EHCache**, **Infinispan**, **Hazelcast**, **Caffeine**, или другие. Каждый провайдеров имеет свои особенности и настройки.
- **Типы кэширования**:
    - **Entity Cache**: Хранит данные сущностей (их поля и идентификаторы).
    - **Collection Cache**: Хранит идентификаторы элементов коллекций (например, `@OneToMany`).
- **Стратегии кэширования**:
    - **Read-Only**: Для данных, которые никогда не изменяются.
    - **Nonstrict-Read-Write**: Для данных, которые редко обновляются, с минимальной гарантией консистентности.
    - **Read-Write**: Для данных, которые могут обновляться, с обеспечением консистентности.
    - **Transactional**: Для данных, требующих строгой транзакционной консистентности (редко используется).

**Как работает**:
- При загрузке сущности Hibernate сначала проверяет кэш первого уровня (сессии).
- Если сущность не найдена, проверяется кэш второго уровня.
- Если сущность отсутствует и во втором уровне кэша, выполняется SQL-запрос к базе данных, после чего данные помещаются в кэш второго уровня (и первого уровня для текущей сессии).
- При обновлении или удалении сущности Hibernate синхронизирует кэш второго уровня, чтобы избежать устаревших данных.

**Популярные провайдеры**:
- **EHCache**:
    - Прост в настройке, подходит для локального кэширования.
    - Ограниченная поддержка распределённого кэширования.
    - Хорошо работает для приложений с одним сервером.
- **Infinispan**:
    - Мощный распределённый кэш, поддерживает кластеризацию.
    - Подходит для масштабируемых приложений с несколькими узлами.
    - Более сложная настройка по сравнению с EHCache.
- **Hazelcast** и **Caffeine**:
    - Современные альтернативы с поддержкой распределённого кэширования (Hazelcast) или высокой производительности в однопоточном режиме (Caffeine).


**Ограничения**:
- Требует тщательной настройки стратегий кэширования, чтобы избежать устаревших данных.
- Увеличивает потребление памяти, особенно в кластеризованных средах.
- Не подходит для часто обновляемых данных (например, транзакционных записей).

**Когда использовать**:
- Для данных, которые редко изменяются (например, справочники, конфигурации).
- В приложениях с интенсивным чтением, где повторные запросы к одним и тем же данным часты.
- В распределённых системах с провайдерами, поддерживающими кластеризацию (например, Infinispan).

---

### Расскажите про кэш запросов (Query Cache)?
 
Кэш запросов (Query Cache) хранит результаты выполнения запросов (JPQL, HQL, Criteria API) и их идентификаторы. Он используется для повторного использования результатов запросов, чтобы избежать повторного обращения к базе данных. Кэш запросов работает в связке со вторым уровнем кэша.

**Характеристики**:
- **Зависимость от второго уровня кэша**: Кэш запросов хранит только идентификаторы сущностей, а сами данные сущностей берутся из второго уровня кэша. Без включённого второго уровня кэша он неэффективен.
- **Кэширование результатов запросов**: Хранит результаты запросов (например, списки идентификаторов сущностей) для повторного использования.
- **Инвалидация**: Кэш запросов автоматически инвалидируется при изменении данных в таблицах, связанных с кэшируемым запросом.
- **Настройка**: Требует явного включения и указания, какие запросы нужно кэшировать.

**Как работает**:
- При выполнении запроса Hibernate проверяет, есть ли результат в кэше запросов.
- Если результат найден, Hibernate загружает сущности по их идентификаторам из второго уровня кэша (или из базы, если их нет в кэше).
- Если результат отсутствует, запрос выполняется, а его результат кэшируется для будущих вызовов.

**Ограничения**:
- Кэш запросов чувствителен к изменениям данных: любое изменение в таблице, связанной с запросом, инвалидирует кэш.
- Неэффективен для запросов с часто меняющимися параметрами, так как кэш хранит результаты для конкретных комбинаций запроса и параметров.
- Требует включённого второго уровня кэша для хранения самих сущностей.
- Может потреблять значительное количество памяти при большом количестве кэшируемых запросов.

**Когда использовать**:
- Для запросов, которые выполняются часто с одинаковыми параметрами и возвращают редко изменяющиеся данные (например, списков категорий, стран).
- В связке со вторым уровнем кэша для максимальной эффективности.
- Избегайте для динамических запросов или данных, которые часто обновляются.


--------------------------------------------------------------------------------------------------------------------
### Расскажите про Жизненный цикл объектов в Hibernate?

В Hibernate объект может находиться в одном из четырёх состояний, каждое из которых отражает его связь с сессией (`Session`) и базой данных:

1. **Transient (Переходное состояние)**
    - **Описание**: Объект находится в состоянии `Transient`, когда он создан, но ещё не связан с сессией Hibernate и не имеет соответствующей записи в базе данных. Это просто обычный Java-объект, не управляемый Hibernate.
    - **Характеристики**:
        - Объект не имеет идентификатора (`id`), связанного с базой данных (или `id` есть, но он не соответствует записи в базе).
        - Не отслеживается Hibernate (не находится в контексте персистентности).
        - Изменения в объекте не синхронизируются с базой данных.
    - **Пример**:
      ```java
      User user = new User();
      user.setName("John");
      // Объект user в состоянии Transient, так как он не сохранён в базе данных.
      ```
    - **Переход в другое состояние**:
        - Вызов методов `persist()`, `save()`, или `saveOrUpdate()` переводит объект в состояние `Persistent`.

2. **Persistent (Управляемое состояние)**
    - **Описание**: Объект находится в состоянии `Persistent`, когда он связан с текущей сессией Hibernate и имеет соответствующую запись в базе данных. Hibernate отслеживает изменения в таких объектах и синхронизирует их с базой при коммите транзакции или вызове `flush()`.
    - **Характеристики**:
        - Объект имеет идентификатор (`id`), соответствующий записи в базе данных.
        - Все изменения в объекте автоматически отслеживаются Hibernate (механизм "dirty checking").
        - При закрытии сессии или вызове `evict()` объект переходит в состояние `Detached`.
    - **Пример**:
      ```java
      Session session = sessionFactory.openSession();
      Transaction tx = session.beginTransaction();
      User user = new User();
      user.setName("John");
      session.persist(user); // Теперь user в состоянии Persistent
      user.setName("Jane"); // Изменение автоматически сохранится при коммите
      tx.commit();
      session.close();
      ```
    - **Переход в другое состояние**:
        - Закрытие сессии или вызов `evict()` переводит объект в состояние `Detached`.
        - Вызов `remove()` переводит объект в состояние `Removed`.

3. **Detached (Отсоединённое состояние)**
    - **Описание**: Объект находится в состоянии `Detached`, когда он был ранее связан с сессией (и, возможно, базой данных), но сессия, управлявшая им, была закрыта или объект был явно отсоединён (например, через `evict()`).
    - **Характеристики**:
        - Объект имеет идентификатор (`id`), соответствующий записи в базе данных, но изменения в нём не отслеживаются Hibernate.
        - Для синхронизации изменений с базой данных требуется повторное присоединение к сессии (через `merge()`, `update()`, или `saveOrUpdate()`).
    - **Пример**:
      ```java
      Session session = sessionFactory.openSession();
      Transaction tx = session.beginTransaction();
      User user = session.get(User.class, 1L); // Persistent
      tx.commit();
      session.close(); // Теперь user в состоянии Detached
      user.setName("Jane"); // Изменения не синхронизируются с базой
      ```
    - **Переход в другое состояние**:
        - Вызов `merge()` или `update()` переводит объект в состояние `Persistent`.
        - Если объект заново привязать к сессии, он снова станет управляемым.

4. **Removed (Удалённое состояние)**
    - **Описание**: Объект находится в состоянии `Removed`, когда он помечен для удаления из базы данных с помощью метода `remove()` (или `delete()` в старых версиях Hibernate). После коммита транзакции запись, связанная с объектом, удаляется из базы данных.
    - **Характеристики**:
        - Объект всё ещё связан с сессией, но помечен как удалённый.
        - После коммита транзакции объект переходит в состояние `Transient` (если сессия закрыта) или становится недействительным.
    - **Пример**:
      ```java
      Session session = sessionFactory.openSession();
      Transaction tx = session.beginTransaction();
      User user = session.get(User.class, 1L); // Persistent
      session.remove(user); // Теперь user в состоянии Removed
      tx.commit(); // Запись удаляется из базы данных
      session.close();
      ```
    - **Переход в другое состояние**:
        - После коммита транзакции объект становится `Transient`.
        - Если отменить транзакцию (rollback), объект вернётся в состояние `Persistent`.

--------------------------------------------------------------------------------------------------------------------
### Сущность выбрана в одной транзакции, сессия закрыта, попытка взаимодействия в другой транзакции Что будет?

**Ситуация**:
```java
      User user;
      // Первая транзакция
      try (Session session1 = sessionFactory.openSession()) {
          Transaction tx1 = session1.beginTransaction();
          user = session1.get(User.class, 1L); // Persistent
          tx1.commit();
      } // Сессия закрыта, user теперь Detached
 
      // Вторая транзакция
      try (Session session2 = sessionFactory.openSession()) {
          Transaction tx2 = session2.beginTransaction();
          user.setName("Jane"); // Изменение Detached объекта
          session2.update(user); // Попытка обновления
          tx2.commit();
      }
```
- **Что происходит**:
        - После закрытия первой сессии сущность `user` становится **Detached**. Она больше не связана с контекстом персистентности и не отслеживается Hibernate.
        - Попытка изменить её свойства (например, `user.setName("Jane")`) не влияет на базу данных, так как Hibernate не отслеживает изменения в **Detached**-объектах.
        - Чтобы синхронизировать изменения с базой данных, нужно явно привязать сущность к новой сессии с помощью методов `update()`, `merge()`, или `saveOrUpdate()`.
- **Возможные проблемы**:
    - Если сущность с таким идентификатором уже загружена в новой сессии, вызов `update()` может вызвать исключение `NonUniqueObjectException`, так как Hibernate не допускает два объекта с одинаковым идентификатором в одном контексте персистентности.
    - Если сущности больше нет в базе данных (например, она была удалена), вызов `update()` выбросит исключение.
- **Решение**:
    - Используйте `merge()` вместо `update()`, так как `merge()` безопаснее: он копирует состояние **Detached**-объекта в существующий объект в контексте персистентности или создаёт новый, если объекта нет.
    - Перед вызовом `update()` убедитесь, что в новой сессии нет объекта с таким же идентификатором, или используйте `session.evict()` для удаления конфликтующего объекта из контекста.
  ```java
  try (Session session2 = sessionFactory.openSession()) {
      Transaction tx2 = session2.beginTransaction();
      user.setName("Jane");
      User mergedUser = session2.merge(user); // Безопасное обновление
      tx2.commit();
  }
  ```

--------------------------------------------------------------------------------------------------------------------
### Попытка доступа к лениво загруженным связям после закрытия сессии. Что будет?
- **Ситуация**:
```java
      User user;
      try (Session session = sessionFactory.openSession()) {
          Transaction tx = session.beginTransaction();
          user = session.get(User.class, 1L); // Persistent, связи лениво загружаемы
          tx.commit();
      } // Сессия закрыта, user теперь Detached
 
      // Попытка доступа к лениво загруженной коллекции
     user.getOrders().size(); // Lazy loading
   ```
- **Что происходит**:
        - Если коллекция `orders` в сущности `User` настроена на ленивую загрузку (`lazy loading`), она не загружается при извлечении объекта из базы, а представлена прокси-объектом.
        - После закрытия сессии прокси-объект теряет связь с базой данных, и попытка доступа к коллекции вызовет исключение `LazyInitializationException`.
- **Возможные проблемы**:
        - `LazyInitializationException` — одна из самых распространённых ошибок в Hibernate, связанная с доступом к лениво загруженным данным вне сессии.
- **Решение**:
    - **Инициализация связей в первой транзакции**:
```java
          try (Session session = sessionFactory.openSession()) {
              Transaction tx = session.beginTransaction();
              user = session.get(User.class, 1L);
              Hibernate.initialize(user.getOrders()); // Явная загрузка коллекции
              tx.commit();
          }
          user.getOrders().size(); // Теперь безопасно
```
- **Использование немедленной загрузки (eager fetching)**:
          Настройте связь как `fetch = FetchType.EAGER` в аннотации или используйте `fetch join` в HQL/JPQL-запросе.
```java
          @OneToMany(fetch = FetchType.EAGER)
         private List<Order> orders;
 ```
- **Открытие новой сессии для работы с данными**:
          Повторно привяжите сущность к новой сессии с помощью `merge()` и работайте с коллекцией в контексте новой сессии.

--------------------------------------------------------------------------------------------------------------------
### Попытка изменения сущности вне транзакции. Что будет?

- **Ситуация**:
```java
      User user;
      try (Session session = sessionFactory.openSession()) {
          Transaction tx = session.beginTransaction();
          user = session.get(User.class, 1L); // Persistent
          tx.commit();
      } // user теперь Detached
 
      user.setName("Jane"); // Изменение Detached объекта
      // Нет сессии или транзакции для сохранения изменений
```
- **Что происходит**:
        - Изменения в **Detached**-объекте не отслеживаются Hibernate и не сохраняются в базе данных, так как нет активной сессии.
        - Чтобы сохранить изменения, нужно открыть новую сессию и транзакцию и использовать `merge()`, `update()`, или `saveOrUpdate()`.
- **Возможные проблемы**:
        - Если изменения не сохраняются явно, это может привести к рассинхронизации между объектом в памяти и базой данных, что создаёт логические ошибки в приложении.
- **Решение**:
   - Всегда сохраняйте изменения в базе данных в контексте сессии и транзакции:
   ```java
          try (Session session = sessionFactory.openSession()) {
              Transaction tx = session.beginTransaction();
              session.merge(user); // Сохранение изменений
              tx.commit();
          }
    ```

--------------------------------------------------------------------------------------------------------------------
### Если сущность использует оптимистическую блокировку (например, с аннотацией `@Version`), изменения в одной транзакции могут конфликтовать с изменениями в другой. Что будет?

```java
      User user1, user2;
      // Первая транзакция
      try (Session session1 = sessionFactory.openSession()) {
          Transaction tx1 = session1.beginTransaction();
          user1 = session1.get(User.class, 1L);
          tx1.commit();
      }
 
      // Вторая транзакция
      try (Session session2 = sessionFactory.openSession()) {
          Transaction tx2 = session2.beginTransaction();
          user2 = session2.get(User.class, 1L);
          user2.setName("Jane");
          tx2.commit();
      }
 
      // Попытка обновления в третьей транзакции
      try (Session session3 = sessionFactory.openSession()) {
          Transaction tx3 = session3.beginTransaction();
          user1.setName("John");
          session3.merge(user1); // Конфликт версий
          tx3.commit();
      }
```
- **Что происходит**:
        - Hibernate использует поле `@Version` для отслеживания изменений. Если вторая транзакция обновила сущность, версия в базе данных изменилась.
        - При попытке обновления в третьей транзакции Hibernate обнаружит, что версия объекта `user1` устарела, и выбросит исключение `OptimisticLockException`.
- **Возможные проблемы**:
    - `OptimisticLockException` указывает на конфликт изменений, что требует обработки в приложении.
- **Решение**:
    - Перехватывайте исключение и уведомляйте пользователя о конфликте, предлагая перезагрузить данные:
      ```java
      try (Session session3 = sessionFactory.openSession()) {
          Transaction tx3 = session3.beginTransaction();
          try {
              session3.merge(user1);
              tx3.commit();
          } catch (OptimisticLockException e) {
              // Перезагрузить сущность и повторить попытку
              User refreshedUser = session3.get(User.class, user1.getId());
              refreshedUser.setName("John");
              session3.merge(refreshedUser);
              tx3.commit();
          }
      }
      ```
- Используйте пессимистическую блокировку (`LockMode.PESSIMISTIC_WRITE`), если конфликты недопустимы:
  ```java
  user = session.get(User.class, 1L, LockMode.PESSIMISTIC_WRITE);
  ```

--------------------------------------------------------------------------------------------------------------------
### Попытка удаления сущности в другой транзакции. Что будет?
- **Ситуация**:
```java
      User user;
      try (Session session1 = sessionFactory.openSession()) {
          Transaction tx1 = session1.beginTransaction();
          user = session1.get(User.class, 1L); // Persistent
          tx1.commit();
      } // user теперь Detached
 
      try (Session session2 = sessionFactory.openSession()) {
          Transaction tx2 = session2.beginTransaction();
          session2.remove(user); // Ошибка
          tx2.commit();
      }
  ```
- **Что происходит**:
        - Метод `remove()` требует, чтобы сущность находилась в состоянии **Persistent**. Попытка удалить **Detached**-объект вызовет исключение `IllegalArgumentException`.
- **Решение**:
    - Привяжите сущность к новой сессии перед удалением:
      ```java
      try (Session session2 = sessionFactory.openSession()) {
          Transaction tx2 = session2.beginTransaction();
          User persistentUser = session2.merge(user); // Перевод в Persistent
          session2.remove(persistentUser); // Теперь можно удалить
          tx2.commit();
      }
      ```
    - Или загрузите сущность заново:
      ```java
      try (Session session2 = sessionFactory.openSession()) {
          Transaction tx2 = session2.beginTransaction();
          User persistentUser = session2.get(User.class, user.getId());
          session2.remove(persistentUser);
          tx2.commit();
      }
      ```
---
### Расскажи про **Диалекты Hibernate**

Диалект Hibernate — это класс, который определяет, как Hibernate взаимодействует с конкретной СУБД. Диалект отвечает за генерацию SQL-запросов, учитывающих особенности базы данных (например, синтаксис, функции, поддержка функций).

- Hibernate поддерживает множество диалектов для различных СУБД, таких как MySQL, PostgreSQL, Oracle, SQL Server, H2 и других.
- Диалект определяет:
    - Синтаксис SQL (например, `LIMIT` в MySQL или `FETCH FIRST` в Oracle).
    - Поддерживаемые типы данных (например, `TEXT` в PostgreSQL или `CLOB` в Oracle).
    - Специфичные для СУБД функции (например, `JSON` в PostgreSQL).
    - Стратегии генерации первичных ключей (`IDENTITY`, `SEQUENCE`).

**Основные диалекты**:
- **MySQL**: `org.hibernate.dialect.MySQL8Dialect` (для MySQL 8.x), `org.hibernate.dialect.MySQL57Dialect` (для MySQL 5.7).
- **PostgreSQL**: `org.hibernate.dialect.PostgreSQLDialect` (универсальный), `org.hibernate.dialect.PostgreSQL10Dialect` (для PostgreSQL 10+).
- **Oracle**: `org.hibernate.dialect.Oracle12cDialect` (для Oracle 12c+), `org.hibernate.dialect.OracleDialect` (устаревший).
- **SQL Server**: `org.hibernate.dialect.SQLServer2012Dialect` (для SQL Server 2012+).
- **H2**: `org.hibernate.dialect.H2Dialect` (для в-memory базы H2, часто используется в тестах).

### Выбор диалекта
- **Автоматический выбор**: Если указать правильный JDBC-драйвер, Hibernate может автоматически определить диалект в некоторых случаях, но лучше задавать его явно для избежания ошибок.
- **Версионность**: Выбирайте диалект, соответствующий версии СУБД, чтобы использовать новые функции и оптимизации (например, `MySQL8Dialect` вместо устаревшего `MySQL5Dialect`).
- **Кастомизация**: Если требуется поддержка нестандартных функций, можно создать собственный диалект, унаследовав его от существующего:
  ```java
  public class CustomMySQLDialect extends MySQL8Dialect {
      public CustomMySQLDialect() {
          super();
          registerFunction("custom_function", new StandardSQLFunction("custom_function", StandardBasicTypes.STRING));
      }
  }
  ```
---

### **Расскажи про Пул соединений**

Пул соединений — это механизм для управления соединениями с базой данных, который повышает производительность за счёт повторного использования соединений и ограничения их количества. Hibernate поддерживает интеграцию с различными пулами соединений, такими как **C3P0**, **HikariCP** и **DBCP**.

#### *Популярные пулы соединений**
1. **C3P0**:
2. **HikariCP**:
    - Современный и высокопроизводительный пул соединений.
    - Является стандартом де-факто в Spring Boot.
    - Лёгкий, с минимальной задержкой и высокой надёжностью.
    - Зависимость (Maven):
      ```xml
      <dependency>
          <groupId>com.zaxxer</groupId>
          <artifactId>HikariCP</artifactId>
          <version>5.1.0</version>
      </dependency>
      ```
3. **DBCP (Apache Commons DBCP)**:

#### **Настройка пула соединений**
  ```properties
  spring.datasource.hikari.minimum-idle=5
  spring.datasource.hikari.maximum-pool-size=20
  spring.datasource.hikari.idle-timeout=300000
  spring.datasource.hikari.max-lifetime=1800000
  spring.datasource.hikari.connection-timeout=30000
  ```
- **Основные параметры**:
    - `min_size` / `minimum-idle`: Минимальное количество соединений в пуле.
    - `max_size` / `maximum-pool-size`: Максимальное количество соединений.
    - `timeout` / `connection-timeout`: Максимальное время ожидания соединения (в миллисекундах).
    - `idle_test_period` / `idle-timeout`: Время простоя соединения перед его закрытием.
    - `max_statements`: Максимальное количество кэшируемых подготовленных запросов (для C3P0).
    - `max-lifetime`: Максимальное время жизни соединения (для HikariCP).

#### **Рекомендации по настройке**
- **Оптимизация производительности**:
    - Установите `min_size` и `max_size` в зависимости от нагрузки приложения и доступных ресурсов сервера базы данных.
    - Для высоконагруженных приложений используйте HikariCP из-за его скорости и надёжности.
- **Тайм-ауты**:
    - Настройте `connection-timeout` (обычно 20–30 секунд), чтобы избежать длительного ожидания при недоступности базы.
    - Установите `idle-timeout` и `max-lifetime`, чтобы закрывать устаревшие соединения и предотвращать утечки.
- **Тестирование соединений**:
    - Включите проверку соединений (`test-on-borrow`, `test-on-idle`) для обеспечения их актуальности.
    - Пример для HikariCP:
      ```properties
      spring.datasource.hikari.connection-test-query=SELECT 1
      ```
- **Мониторинг**:
    - Используйте инструменты мониторинга (например, Actuator в Spring Boot) для отслеживания состояния пула соединений.
    - Логируйте ошибки соединений для диагностики проблем.
--------------------------------------------------------------------------------------------------------------------

### Какие есть Аннотации JPA и Hibernate**

JPA (Java Persistence API) предоставляет стандартные аннотации для маппинга сущностей, которые Hibernate реализует и расширяет собственными аннотациями для дополнительных возможностей. Рассмотрим основные категории аннотаций и их использование.

#### **Основные аннотации**
Эти аннотации используются для базового маппинга сущностей и их атрибутов:

- **`@Entity`**:
    - **Описание**: Помечает класс как сущность, которая соответствует таблице в базе данных.
    - **Применение**: Класс должен иметь конструктор без параметров (по умолчанию или явно определённый).

- **`@Table(name = "table_name")`**:
    - **Описание**: Указывает имя таблицы в базе данных, к которой привязана сущность. Если не указана, Hibernate использует имя класса.
    - **Параметры**:
        - `name`: Имя таблицы.
        - `schema`: Схема базы данных (опционально).

- **`@Id`**:
    - **Описание**: Помечает поле как первичный ключ сущности.
    - **Применение**: Обязательно для каждой сущности. Может быть простым (одно поле) или композитным (несколько полей).


- **`@GeneratedValue`**:
    - **Описание**: Указывает стратегию генерации значения первичного ключа.
    - **Стратегии**:
        - `GenerationType.AUTO`: Hibernate выбирает подходящую стратегию (зависит от СУБД).
        - `GenerationType.IDENTITY`: Использует автоинкремент (например, в MySQL).
        - `GenerationType.SEQUENCE`: Использует последовательности (например, в PostgreSQL).
        - `GenerationType.TABLE`: Использует таблицу для хранения идентификаторов.

- **`@Column`**:
    - **Описание**: Указывает маппинг поля на столбец в таблице.
    - **Параметры**:
        - `name`: Имя столбца.
        - `nullable`: Может ли столбец быть `null`.
        - `length`: Длина для строковых полей.
        - `unique`: Уникальность значения.

#### **Аннотации для связей**
Связные аннотации определяют отношения между сущностями (`OneToOne`, `OneToMany`, `ManyToOne`, `ManyToMany`) и управляют их поведением через каскадирование и стратегии загрузки.

- **`@OneToOne`**:
    - **Описание**: Определяет связь "один к одному" между двумя сущностями.
    - **Параметры**:
        - `mappedBy`: Указывает, какая сторона связи является владельцем (обратная сторона).
        - `cascade`: Тип каскадирования.
        - `fetch`: Стратегия загрузки (`FetchType.LAZY` или `FetchType.EAGER`).

- **`@OneToMany` и `@ManyToOne`**:
    - **Описание**: Определяют связь "один ко многим" и "многие к одному".

- **`@ManyToMany`**:
    - **Описание**: Определяет связь "многие ко многим", обычно с использованием промежуточной таблицы.

- **`@JoinColumn`**:
    - **Описание**: Указывает столбец внешнего ключа для связи.
    - **Параметры**:
        - `name`: Имя столбца внешнего ключа.
        - `referencedColumnName`: Имя столбца, на который ссылается внешный ключ.


#### **1.3. Каскадирование и стратегии загрузки**
- **`CascadeType`**:
    - **Описание**: Определяет, какие операции (сохранение, обновление, удаление) должны автоматически распространяться на связанные сущности.
    - **Типы**:
        - `CascadeType.PERSIST`: Сохранение связанной сущности при сохранении основной.
        - `CascadeType.MERGE`: Обновление связанной сущности при обновлении основной.
        - `CascadeType.REMOVE`: Удаление связанной сущности при удалении основной.
        - `CascadeType.ALL`: Включает все вышеперечисленные операции.
        - `CascadeType.DETACH`: Отсоединение связанной сущности при отсоединении основной.
        - `CascadeType.REFRESH`: Обновление связанной сущности из базы данных.
    - **Пример**:
      ```java
      @OneToMany(mappedBy = "user", cascade = CascadeType.ALL)
      private List<Order> orders;
      ```
      При сохранении объекта `User` все связанные `Order` также будут сохранены.

- **`FetchType`**:
    - **Описание**: Определяет, когда загружаются связанные данные.
    - **Типы**:
        - `FetchType.LAZY`: Данные загружаются только при обращении (ленивая загрузка). Подходит для оптимизации производительности.
        - `FetchType.EAGER`: Данные загружаются сразу вместе с сущностью. Может привести к избыточным запросам.
    - **Пример**:
      ```java
      @ManyToOne(fetch = FetchType.LAZY)
      @JoinColumn(name = "user_id")
      private User user;
      ```
    - **Рекомендации**:
        - Используйте `LAZY` для большинства связей, чтобы избежать ненужных запросов.
        - Используйте `EAGER` только для небольших и часто используемых данных.
        - Для `LAZY` избегайте `LazyInitializationException`, инициализируя данные с помощью `Hibernate.initialize()` или `fetch join` в запросах.

---

### Расскажите про Композитные ключи?

Сложные маппинги включают работу с композитными ключами, наследованием сущностей и маппингом коллекций, которые требуют более тонкой настройки.

Композитные ключи используются, когда первичный ключ сущности состоит из нескольких полей.

- **`@EmbeddedId`**:
    - **Описание**: Использует отдельный класс для представления композитного ключа.
    - **Пример**:
      ```java
      @Embeddable
      public class OrderItemKey implements Serializable {
          @Column(name = "order_id")
          private Long orderId;
  
          @Column(name = "product_id")
          private Long productId;
  
          // Геттеры, сеттеры, equals, hashCode
      }
  
      @Entity
      @Table(name = "order_items")
      public class OrderItem {
          @EmbeddedId
          private OrderItemKey id;

      }
      ```
    - **Особенности**:
        - Класс ключа должен быть помечен `@Embeddable` и реализовать `Serializable`.
        - Атрибуты ключа мапятся на столбцы с помощью `@MapsId`.

- **`@IdClass`**:
    - **Описание**: Альтернативный способ, где композитный ключ определяется через отдельный класс, но поля ключа дублируются в сущности.
    - **Пример**:
      ```java
      public class OrderItemKey implements Serializable {
          private Long orderId;
          private Long productId;
  
          // Геттеры, сеттеры, equals, hashCode
      }
  
      @Entity
      @Table(name = "order_items")
      @IdClass(OrderItemKey.class)
      public class OrderItem {
          @Id
          @Column(name = "order_id")
          private Long orderId;
  
          @Id
          @Column(name = "product_id")
          private Long productId;
          
      }
      ```
    - **Особенности**:
        - Требует дублирования полей ключа в сущности.
        - Менее гибкий, чем `@EmbeddedId`, но проще в некоторых случаях.

- **Когда использовать**:
    - `@EmbeddedId`: Для сложных ключей, где требуется чёткое разделение логики ключа.
    - `@IdClass`: Для простых ключей, где дублирование полей не создаёт проблем.

#### **Как работает наследование сущностей**?
Hibernate поддерживает три стратегии наследования для маппинга иерархий классов:

- **`SINGLE_TABLE`**:
    - **Описание**: Все классы иерархии хранятся в одной таблице с дискриминаторным столбцом.
    - **Аннотации**:
        - `@Inheritance(strategy = InheritanceType.SINGLE_TABLE)`
        - `@DiscriminatorColumn`: Указывает столбец для различения типов.
        - `@DiscriminatorValue`: Значение для конкретного подкласса.

    - **Особенности**:
        - Все данные хранятся в одной таблице, столбцы для специфичных полей подклассов могут быть `null`.
        - Высокая производительность при чтении, но может быть неэффективна для больших иерархий.

- **`TABLE_PER_CLASS`**:
    - **Описание**: Каждый класс иерархии мапится на отдельную таблицу.
    - **Аннотация**: `@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)`

    - **Особенности**:
        - Каждая таблица содержит все поля класса, включая унаследованные.
        - Может приводить к дублированию структуры таблиц.
        - Использует `UNION` для запросов к базовому классу, что снижает производительность.

- **`JOINED`**:
    - **Описание**: Базовый класс и подклассы мапятся на отдельные таблицы, связанные по первичному ключу.
    - **Аннотация**: `@Inheritance(strategy = InheritanceType.JOINED)`
    - **Особенности**:
        - Таблица базового класса содержит общие поля, а таблицы подклассов — специфичные.
        - Требует `JOIN` для загрузки подклассов, что может быть менее производительным.
        - Обеспечивает нормализацию данных и экономию пространства.

- **Когда использовать**:
    - `SINGLE_TABLE`: Для простых иерархий с небольшим количеством специфичных полей.
    - `TABLE_PER_CLASS`: Для иерархий, где подклассы сильно различаются, и нормализация не требуется.
    - `JOINED`: Для сложных иерархий, где важна нормализация и минимизация дублирования данных.

---

### **Как использовать Кастомные типы**

Hibernate позволяет работать с нестандартными типами данных (например, JSON, массивы PostgreSQL) через аннотацию `@Type` и реализацию пользовательских типов (`UserType`).

#### ** Использование `@Type`**
- **Описание**: Аннотация `@Type` указывает Hibernate, как мапить поле на нестандартный тип данных, поддерживаемый конкретной СУБД.
- **Пример**: JSON в PostgreSQL


#### **Реализация пользовательских типов через `UserType`**

- Для сложных нестандартных типов можно реализовать интерфейс `org.hibernate.usertype.UserType`, определяющий, как Hibernate мапит
  Java-объект на SQL-данные и обратно.

--------------------------------------------------------------------------------------------------------------------
### Работа с запросами в Hibernate

#### **HQL (Hibernate Query Language)**

HQL — это объектно-ориентированный язык запросов, похожий на SQL, но работающий с сущностями и их свойствами, а не с таблицами и столбцами.

- **Синтаксис**: HQL использует синтаксис, аналогичный SQL, но вместо таблиц и столбцов оперирует сущностями и их атрибутами. Например:
  ```java
  from User u where u.name = :name
  ```
  Здесь `User` — это класс сущности, а `name` — её поле.

- **Параметры в запросах**: Для безопасности и предотвращения SQL-инъекций используются именованные параметры (`:param`):
  ```java
  Query query = session.createQuery("from User u where u.id = :userId");
  query.setParameter("userId", 1L);
  User user = (User) query.getSingleResult();
  ```
  
#### **Criteria API**

Criteria API предоставляет программный, типобезопасный способ создания запросов, что особенно полезно для динамических запросов.

- **Основные компоненты**:
    - `CriteriaBuilder` — фабрика для создания условий, выражений и предикатов.
    - `CriteriaQuery` — объект, представляющий сам запрос.
    - `Root` — корень запроса, представляющий сущность.

- **Пример выборки**:
  ```java
  CriteriaBuilder cb = session.getCriteriaBuilder();
  CriteriaQuery<User> cq = cb.createQuery(User.class);
  Root<User> root = cq.from(User.class);
  cq.select(root).where(cb.equal(root.get("age"), 18));
  List<User> users = session.createQuery(cq).getResultList();
  ```

#### **JPQL (Java Persistence Query Language)**

JPQL — это стандартный язык запросов, определённый в спецификации JPA. HQL является расширением JPQL, специфичным для Hibernate.

- **Различия между HQL и JPQL**:
    - JPQL строго следует стандарту JPA, тогда как HQL включает дополнительные возможности Hibernate (например, поддержку `WITH`, `FETCH` и некоторых специфичных функций).
    - JPQL переносим между различными реализациями JPA, HQL — нет.

- **Именованные запросы**:
    - `@NamedQuery`: Определяется в аннотации сущности для повторно используемых JPQL-запросов.
      ```java
      @Entity
      @NamedQuery(name = "User.findByName", query = "SELECT u FROM User u WHERE u.name = :name")
      public class User { ... }
      ```
      ```
    - `@NamedNativeQuery`: Для нативных SQL-запросов с маппингом на сущности.
      ```java
      @NamedNativeQuery(name = "User.findByNameNative",
                        query = "SELECT * FROM users WHERE name = :name",
                        resultClass = User.class)
      ```

#### **Нативные SQL-запросы**

Нативные SQL-запросы используются, когда HQL/JPQL недостаточно гибки (например, для специфичных функций СУБД).

- **Когда использовать**:
    - Для оптимизации сложных запросов, которые трудно выразить в HQL/JPQL.
    - Для использования специфичных функций СУБД (например, оконных функций).
    - Для выполнения массовых операций, не связанных с сущностями.


--------------------------------------------------------------------------------------------------------------------
#### **Подходы управление транзакциями**

- **Разница между декларативным и программным управлением транзакциями**:
    - **Декларативное управление (`@Transactional` в Spring)**:
        - Используется аннотация `@Transactional` на уровне методов или классов для автоматического управления транзакциями через AOP.
        - Преимущества: Чистый код, централизованное управление, легко настраиваемый.
        - Пример:
          ```java
          @Service
          public class UserService {
              @Transactional(readOnly = true)
              public User findUser(Long id) {
                  return userRepository.findById(id)");
              }
    
              @Transactional
              public void updateUser(User user) {
                  userRepository.save(user);
              }
          }
          ```
        - **Программное управление**:
            - Явное управление транзакциями через API `Session` (Hibernate) или `PlatformTransactionManager` (Spring).
            - Пример с Hibernate:
              ```java
              Session session = sessionFactory.openSession();
              Transaction tx = null;
              try {
                  tx = session.beginTransaction();
                  session.save(user);
                  tx.commit();
              } catch (Exception e) {
                  if (tx != null) tx.rollback();
                  throw e;
              } finally {
                  session.close();
              }
              ```
        
            - **Сравнение**:
                - Декларативное: Лучше для большинства случаев, упрощает код.
                - Программное: Используется для сложной логики, где требуется детальный контроль (например, несколько транзакций в одном методе).

--------------------------------------------------------------------------------------------------------------------

#### Расскажите про блокировки

- **Оптимистическая блокировка**:
    - Используется для предотвращения конфликтов при одновременном обновлении одной сущности несколькими транзакциями.
    - Реализуется через аннотацию `@Version`:
      ```java
      @Entity
      public class User {
          @Id
          private Long id;
          @Version
          private Integer version; // Поле для отслеживания версии
          private String name;
      }
      ```
    - Как работает:
        - При каждом обновлении сущности Hibernate увеличивает значение `version`.
        - Если две транзакции пытаются обновить одну сущность, Hibernate проверяет `version`. Если версия изменилась, выбрасывается `OptimisticLockException`.
    - Пример обработки:
      ```java
      @Transactional
      public void updateUser(Long id, String newName) {
          try {
              User user = session.get(User.class, id);
              user.setName(newName);
              session.update(user);
          } catch (OptimisticLockException e) {
              // Обработка конфликта, например, повторная попытка или уведомление пользователя
              throw new RuntimeException("Конфликт обновления", e);
          }
      }
      ```
    - **Когда использовать**: Для приложений с высокой конкуренцией чтения и редкими обновлениями.

- **Пессимистическая блокировка**:
    - Блокирует записи в базе данных на уровне СУБД, предотвращая доступ других транзакций.
    - Поддерживаемые режимы (`LockModeType`):
        - `PESSIMISTIC_READ`: Блокировка для чтения (другие могут читать, но не записывать).
        - `PESSIMISTIC_WRITE`: Эксклюзивная блокировка (никто не может читать или записывать).
        - `PESSIMISTIC_FORCE_INCREMENT`: Блокировка с инкрементом версии (для оптимистической и пессимистической комбинации).
    - Пример в HQL:
      ```java
      User user = session.createQuery("from User u where u.id = :id", User.class)
                         .setParameter("id", 1L)
                         .setLockMode(LockModeType.PESSIMISTIC_WRITE)
                         .getSingleResult();
      ```
    - Пример с `session.get`:
      ```java
      User user = session.get(User.class, 1L, LockMode.PESSIMISTIC_WRITE);
      ```
    - **Когда использовать**: Для критических операций, где конфликты недопустимы (например, финансовые транзакции).

--------------------------------------------------------------------------------------------------------------------

Какая разница в работе методов load(); и get();?

Hibernate session обладает различными методами для загрузки данных из базы данных. Наиболее часто используемые методы для этого - get() и load().

Метод load(); обычно используется когда в не уверен что запрашиваемый объект уже находится в базе данных. Если объект не найден, то метод кидает исключение Если объект найден — метод возвращает прокси объект, который является ссылкой на объект находящийся в базе данных (запрос в базу данных еще не был осуществлен, своего рода lazy изъятие), непосредственный запрос к базе данных когда мы непосредственно обращаемся к необходимому объекту через прокси объект.

Метод get(); используется тогда, вы на 100 процентов не уверены есть ли запрашиваемый объект в базе данных. В случае обращение к несуществующему объекту, метод get(); вернет null. В случае нахождения объект, метод get(); вернет сам объект и запрос в базу данных будет произведен немедленно.

--------------------------------------------------------------------------------------------------------------------

Что произойдет, если будет отсутствовать конструктор без аргументов у Entity Bean?

Hibernate использует рефлексию для создания экземпляров Entity бинов при вызове методов get() или load(). Для этого используется метод Class.newInstance(), который требует наличия конструктора без параметров. Поэтому, в случае его отсутствия, вы получите ошибку HibernateException.

--------------------------------------------------------------------------------------------------------------------

Как используется вызов метода Hibernate Session merge()?

Hibernate merge() может быть использован для обновления существующих значений, однако этот метод создает копию из переданного объекта сущности и возвращает его. Возвращаемый объект является частью контекста персистентности и отслеживает любые изменения, а переданный объект не отслеживается.

--------------------------------------------------------------------------------------------------------------------

В чем разница между Hibernate save(), saveOrUpdate() и persist()?

Hibernate save() используется для сохранения сущности в базу данных. Проблема с использованием метода save() заключается в том, что он может быть вызван без транзакции. А следовательно если у нас имеется отображение нескольких объектов, то только первичный объект будет сохранен и мы получим несогласованные данные. Также save() немедленно возвращает сгенерированный идентификатор. Hibernate persist() аналогичен save() с транзакцией. persist() не возвращает сгенерированный идентификатор сразу. Hibernate saveOrUpdate() использует запрос для вставки или обновления, основываясь на предоставленных данных. Если данные уже присутствуют в базе данных, то будет выполнен запрос обновления. Метод saveOrUpdate() можно применять без транзакции, но это может привести к аналогичным проблемам, как и в случае с методом save().


--------------------------------------------------------------------------------------------------------------------

В чем разница между sorted collection и ordered collection? Какая из них лучше?

При использовании алгоритмов сортировки из Collection API для сортировки коллекции, то он вызывает отсортированный список (sorted list). Для маленьких коллекций это не приводит к излишнему расходу ресурсов, но на больших коллекциях это может привести к потери производительности и ошибкам OutOfMemory. Так же entity бины должны реализовывать интерфейс Comparable или Comparator для работы с сортированными коллекциями. При использовании фреймворка Hibernate для загрузки данных из базы данных мы можем применить Criteria API и команду order by для получения отсортированного списка (ordered list). Ordered list является лучшим выбором к sorted list, т.к. он использует сортировку на уровне базы данных. Она быстрее и не может привести к утечке памяти.

Пример запроса к БД для получения ordered list:
List<Employee> empList = session.createCriteria(Employee.class)
.addOrder(Order.desc("id")).list();


--------------------------------------------------------------------------------------------------------------------

Почему мы не должны делать Entity class как final?

Хибернейт использует прокси классы для ленивой загрузки данных (т.е. по необходимости, а не сразу). Это достигается с помощью расширения entity bean и, следовательно, если бы он был final, то это было бы невозможно. Ленивая загрузка данных во многих случаях повышает производительность, а следовательно важна.

--------------------------------------------------------------------------------------------------------------------

### Проблема N+1 SELECT: суть и способы решения

**Что это такое?**
Проблема N+1 SELECT — это классическая проблема производительности в ORM (Hibernate/JPA). Она возникает, когда приложение выполняет:

1. **Один** запрос для получения списка родительских сущностей (например, всех пользователей).
2. **N** дополнительных запросов для загрузки связанных «дочерних» коллекций для каждой из N сущностей (например, заказов для каждого
   пользователя).

В итоге вместо одного эффективного запроса выполняется **1 + N** запросов, что резко снижает производительность.

**Частое заблуждение: `FetchType.EAGER` не решает проблему!**
Многие ошибочно думают, что установка `FetchType.EAGER` для коллекций решает проблему. На самом деле, это лишь **скрывает** её: Hibernate
всё равно выполняет N+1 отдельных SELECT-запросов, но делает это автоматически и неконтролируемо, что ещё хуже. Правильный подход —
использовать `FetchType.LAZY` и явно управлять загрузкой.

### Эффективные способы борьбы с N+1 SELECT

1. **JOIN FETCH**
    * **Как работает:** В JPQL-запросе добавляется `JOIN FETCH`, что заставляет Hibernate загрузить связанные данные одним SQL-запросом
      с `JOIN`.
    * **Когда использовать:** Идеально для случаев, когда нужно получить сущности вместе со связанными коллекциями и пагинация не требуется.
    * **Минус:** Несовместим со стандартной пагинацией (`Pageable`), так как `LIMIT` применяется некорректно к результату `JOIN`.

2. **EntityGraph**
    * **Как работает:** Декларативный способ указать, какие связи нужно загрузить. По сути, это более гибкий и переиспользуемый
      аналог `JOIN FETCH`.
    * **Когда использовать:** Когда нужно отделить логику запроса от плана загрузки данных. Удобно для сложных графов объектов.
    * **Минус:** Те же проблемы с пагинацией, что и у `JOIN FETCH`.

3. **@BatchSize** (аннотация Hibernate)
    * **Как работает:** Уменьшает количество запросов с N до N/batch_size. Вместо N запросов по одному объекту, Hibernate делает несколько
      запросов, загружая дочерние сущности «пачками» через `WHERE id IN (...)`.
    * **Когда использовать:** Отличный компромисс, который **совместим с пагинацией**. Снижает нагрузку, не требуя переписывать запросы.

4. **@Fetch(FetchMode.SUBSELECT)** (аннотация Hibernate)
    * **Как работает:** Сводит N+1 к **двум** запросам: один — для родительских сущностей, второй — для всех дочерних, используя
      подзапрос (`WHERE id IN (SELECT ...)`).
    * **Когда использовать:** Когда нужно загрузить коллекции для всего списка сущностей сразу.
    * **Минус:** При пагинации загружает дочерние записи для **всех** родительских сущностей, а не только для текущей страницы, что может
      привести к загрузке огромного объёма лишних данных.

5. **DTO-проекции**
    * **Как работает:** Вместо загрузки полноценных сущностей выполняется запрос, который сразу выбирает только нужные данные в простые
      DTO-объекты (Data Transfer Object).
    * **Когда использовать:** Лучший выбор для сценариев «только для чтения» (отчеты, списки). Максимальная производительность, так как нет
      оверхеда ORM.

### Пагинация и N+1: как правильно?

Так как `JOIN FETCH` ломает пагинацию, самый надежный способ — **двухэтапная загрузка**:

1. **Шаг 1:** Выполнить запрос с пагинацией, чтобы получить только **ID** родительских сущностей нужной страницы.
2. **Шаг 2:** Выполнить второй запрос с `JOIN FETCH`, используя полученный список ID в условии `WHERE id IN (...)`.

Этот подход позволяет и избежать проблемы N+1, и корректно работать с пагинацией.

--------------------------------------------------------------------------------------------------------------------

**Hibernate Envers** — это модуль Hibernate для аудита и версионирования сущностей в приложениях, использующих JPA. Он автоматически отслеживает изменения в данных (создание, обновление, удаление) и сохраняет их историю в специальных таблицах аудита.

### Основные возможности:
- **Автоматический аудит**: Хранит историю изменений сущностей (какие поля изменились, когда и кем).
- **Версионирование**: Каждое изменение сущности создаёт новую ревизию с метаданными (например, временная метка, пользователь).
- **Запросы к истории**: Позволяет запрашивать состояние сущности на определённый момент времени или все её ревизии.
- **Поддержка связей**: Отслеживает изменения в связях (`@OneToMany`, `@ManyToOne` и др.).

### Как работает:
1. **Аннотации**:
    - `@Audited` на классе или поле указывает, что сущность/поле нужно аудировать.
2. **Таблицы аудита**:
    - Для каждой аудитируемой сущности создаётся таблица (например, `User_AUD`) с дополнительными столбцами: `REV` (номер ревизии) и `REVTYPE` (тип операции: 0 — добавление, 1 — обновление, 2 — удаление).
    - Метаданные ревизий хранятся в таблице `REVINFO` (временная метка, пользователь и т.д.).
3. **API для запросов**:
    - Используйте `AuditReader` для доступа к истории:
      Конечно, вот сокращенная версия статьи:

--------------------------------------------------------------------------------------------------------------------

### Entity Graphs (графы сущностей)

Entity Graphs (графы сущностей). Эта функция JPA 2.1 позволяет задавать, какие связанные объекты нужно загружать вместе с сущностью, чтобы
избежать проблемы N+1 запросов. Обычно, чтобы подгрузить связи, используют FETCH JOIN в JPQL или меняют тип загрузки на EAGER, что не всегда
оптимально. @EntityGraph – аннотация, которая задаёт набор атрибутов (ассоциаций) для подгрузки.

Пример: у Account есть коллекция Transaction (например, переводы по счету), связь @OneToMany(mappedBy="fromAccount") List<Transfer>
outgoingTransfers. По умолчанию это LAZY, и при обращении к account.getOutgoingTransfers() без подготовленного join случится N+1.

Мы можем объявить метод в репозитории с использованием @EntityGraph:

@EntityGraph(attributePaths = {"outgoingTransfers", "outgoingTransfers.toAccount"})
Optional<Account> findWithTransfersById(Long id);
Аннотация @EntityGraph(attributePaths={...}) инструктирует Hibernate сразу выполнить необходимые JOIN и заполнить коллекцию
outgoingTransfers у Account. В нашем примере мы загрузим счет, все исходящие переводы и их связанные счета получателей – всё одним запросом.
Это удобно для отображения полного контекста счета.

Spring Data JPA поддерживает @EntityGraph на уровне методов репозитория: можно как в примере указать атрибуты, либо ссылаться на заранее
определенный граф (@NamedEntityGraph в классе сущности).

--------------------------------------------------------------------------------------------------------------------
**Soft Delete (мягкое удаление) в Spring Boot JPA: ключевые моменты**

Soft delete — это подход, при котором записи в базе данных не удаляются физически, а помечаются как удаленные с помощью специального флага (
например, `is_deleted = true`). Это позволяет сохранять историю, проводить аудит и поддерживать целостность данных.

### Основные способы реализации:

1. **Статический подход: `@SQLDelete` и `@SQLRestriction`**
    * `@SQLDelete` заменяет стандартную команду `DELETE` на кастомный `UPDATE` (например, `UPDATE ... SET is_deleted = true`).
    * `@SQLRestriction` автоматически добавляет ко всем запросам выборки условие `WHERE is_deleted = false`.
    * **Итог:** Простой и надежный способ, который работает глобально для сущности. Идеален, если удаленные записи нужно скрывать **всегда**
      и для всех.

2. **Динамический подход: Hibernate-фильтры (`@Filter`)**
    * Фильтры определяются на сущности, но по умолчанию неактивны. Их нужно включать вручную в коде для конкретной
      сессии (`session.enableFilter(...)`).
    * Они поддерживают параметры, что делает их очень гибкими.
    * **Итог:** Подходит для сложных сценариев, когда нужно динамически управлять видимостью данных (например, позволять администраторам
      видеть удаленные записи или реализовывать мульти-тенанси). Главный минус — фильтр нужно не забывать активировать.

### Когда что использовать?

* **`@SQLRestriction`**: Если правила фильтрации простые и не меняются (удаленные записи скрыты всегда).
* **`@Filter`**: Если нужна гибкость: разный доступ для ролей, просмотр «корзины», фильтрация по нескольким динамическим параметрам.

### Ключевые моменты и лучшие практики:

* **Производительность:** Обязательно создавайте **индекс** для поля-флага (`is_deleted`), чтобы избежать замедления запросов на больших
  таблицах.
* **Связанные сущности:** Каскадное удаление (`CascadeType.ALL`) не работает с `@SQLDelete` так, как ожидается. «Мягкое» удаление
  родительской сущности **не удаляет** дочерние автоматически. Эту логику нужно реализовывать вручную или также настраивать `@SQLDelete` для
  дочерних сущностей. Осторожно используйте `orphanRemoval = true`.
* **Аудит:** Рекомендуется хранить не только булев флаг, но и дату удаления (`deleted_at`) для отслеживания изменений.
* **Устаревший подход:** Аннотация `@Where` считается устаревшей; вместо нее следует использовать `@SQLRestriction`.