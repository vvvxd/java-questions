Миграции баз данных — что это такое и для чего нужно

Миграция баз данных — это что-то вроде системы контроля версий для вашей схемы базы данных. Она позволяет разработчикам изменять структуру БД, сообщать другим участникам команды об этих изменениям и самим быть в курсе апдейтов, а также отслеживать историю изменений.

Зачем нужны миграции БД и как они упрощают жизнь разработчикам
По мере разработки приложения схема базы данных меняется. Добавляются новые таблицы и столбцы. Миграции позволяют упростить отслеживание этих изменений.

У современных проектов зачастую есть несколько стендов — стенд разработки, тестирования, прод и другие. Возникает проблема синхронизации базы данных — нужно передавать изменения на стенды последовательно и без конфликтов. Миграции помогают решить эту проблему.

Современные проекты работают по методологии Agile, а в ней сложно определить структуру БД на старте. Она развивается вместе с проектом от спринта к спринту. Поэтому автоматизированный рефакторинг БД должен быть таким же обязательным инструментом, как и рефакторинг любых других компонентов.

Поскольку миграции являются частью исходного кода проекта, изменение структуры БД могут быть одобрены или отклонены во время код ревью до того, как они попадут в релизную ветку.

--------------------------------------------------------------------------------------------------------------------
Что такое Liquibase

Liquibase — это открытая независимая от БД библиотека для отслеживания, управления и применения изменений схемы базы данных. Поддерживает подавляющее большинство БД, включая PostgreSQL, MySQL, Oracle, Sybase, HSQL, Apache Derby. Работает с форматами XML, YAML, JSON, SQL.

Ее преимущества: библиотека Liquibase предоставляет больше возможностей из «коробки» в отличие от того же Flyway — отмена изменений, автогенерация миграций. Имеет dry-run, то есть можно посмотреть, какие SQL-запросы будут выполнены.

В отличие от Flyway, которая поддерживает скрипты миграции только в форматах SQL и Java, Liquibase — это универсальный инструмент. Он позволяет накатывать одни и те же миграции на любые базы данных и абстрагироваться от SQL. Эта библиотека больше подходит для проектов, где необходимо работать с разными окружениями и СУБД.

Liquibase не стоит использовать, если ваш проект имеет простую структуру базы данных. А также если вам нужна возможность изменять схему БД с помощью полностью кастомного SQL или с использованием Java-кода. В таком случае удобнее обратиться к Flyway.

--------------------------------------------------------------------------------------------------------------------
Как работает Liquibase

Liquibase — кросс платформенное Java приложение, вы можете скачать JAR файл и запускать его на Windows, Mac или Linux.

Изменения для БД записываются в формате понятном Liquibase, а уже он в свою очередь выполняет запросы к базе данных. Таким образом реализуется независимость от конкретной БД.

--------------------------------------------------------------------------------------------------------------------
Что такое ChangeLog

Изменения структуры базы данных записываются в файлы, которые называются changeLog. Эти файлы могут быть описаны в разных форматах: XML, YAML, JSON или SQL.
ChangeLog файлы могут быть произвольно включены друг в друга для лучшего управления. Подробнее об этом будет ниже в примерах.

--------------------------------------------------------------------------------------------------------------------
Что такое ChangeSet

ChangeSet - это аналог коммита в системах контроля версий, таких как Git. ChangeSet может содержать одно или несколько изменений базы данных. Хорошей практикой считается одна команда для одного ChangeSet.

Каждый changeSet имеет составной идентификатор id, author и filename, который должен быть уникальным.

При первом запуске Liquibase создает две технические таблицы:
databasechangelog - Содержит список изменений схемы БД. Туда записываются уже выполненные changeSet.
databasechangelock - Используется для блокировки на время работы, чтобы гарантировать одновременную работу только одного экземпляра Liquibase.

--------------------------------------------------------------------------------------------------------------------
Как работают Блокировка в Liquibase

Если несколько экземпляров Liquibase будут выполняться одновременно с одной и той же базой данных, вы получите конфликты. Это может произойти, если несколько разработчиков используют один и тот же экземпляр базы данных, или если в кластере несколько серверов, которые автоматически запускают Liquibase при запуске.

Для защиты от таких ситуаций Liquibase создает таблицу databasechangelock, в которой есть boolean поле locked. При запуске Liquibase проверяет его состояние, и если оно true, то ожидает смены на false.

Экстренно остановив выполнение программы в самом начале, может сложиться ситуация при котором Liquibase успеет поставить флаг, но не поменяет его на false.

Чтобы исправить эту проблему, в таблице databasechangelock измените поле locked на false.

--------------------------------------------------------------------------------------------------------------------
Контрольная сумма Liquibase

Liquibase читает главный changeLog, проверяя какие изменения уже были приняты, а какие надо выполнить.

После выполнения changeSet в таблицу
databasechangelog со всем прочим записывается MD5 хэш changeSet.Хэш высчитывается на основе нормализованного содержимого XML.

При следующем запуске Liquibase будет сверять вновь рассчитанные хэш суммы, со значениями в его таблице. Если вы изменили уже выполненный changeSet, то хэш сумма будет отличаться, и приложение упадет с ошибкой при старте.

--------------------------------------------------------------------------------------------------------------------
Организация скриптов Liquibase

Создайте папку db, а в ней папку changelog. В этой папке создадим файл db.changelog-master.xml. Это будет наш главный changeLog файл. Он будет содержать ссылки на другие changeLog файлы. Пока вставляем начальное содержимое:

<?xml version="1.0" encoding="UTF-8"?> <databaseChangeLog xmlns="http://www.liquibase.org/xml/ns/dbchangelog" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-4.6.xsd"> 
// Здесь будут ссылки на другие changeLog файлы
</databaseChangeLog>

Хорошей практикой считается создавать множество changeLog и "включать" их в другие changeLog. Таким образом у вас будет множество файлов, а не один большой манускрипт, ведь changeSet-ов будет очень много со временем.
Проще разобраться на примере. Допустим у нас текущая версия приложения 1.0.0, поэтому мы создаем папку v.1.0.0 в папке db/changelog. Эта папка будет содержать только изменения схемы, которые мы будем делать для следующей версии нашего приложения. Эта папка будет содержать свой локальный главный changeLog файл, обычно я называю его cumulative-changelog.xml.
Как только версия приложения меняется, мы создаем новую папку v.*.*.* и новые changeLog создаем уже в ней. И все созданные cumulative-changelog.xml мы включаем в db.changelog-master.xml.
Итак, создайте папку v.1.0.0 в папке db/changelog, и создайте там файл cumulative-changelog.xml. Теперь сделаем в основном changeLog файле ссылку на этот локальный changeLog. Для этого в файл добавляем следующую строку

<?xml version="1.0" encoding="UTF-8"?> <databaseChangeLog xmlns="http://www.liquibase.org/xml/ns/dbchangelog" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-4.6.xsd"> 

<include file="v.1.0.0/cumulative-changelog.xml" relativeToChangelogFile="true"/> 

</databaseChangeLog>

Проще всего воспринимать тег include, как место, куда будет вставлено все содержимое того файла, который мы подключаем.
Также обратите внимание на атрибут relativeToChangelogFile="true". Он позволяет указывать путь относительно той папки, в которой располагается текущий changeLog.

--------------------------------------------------------------------------------------------------------------------
Откат изменений

Спойлер: Судя по всему откат изменений это бесполезная возможность Liquibase, которой на практике никто не пользуется.

SpringBoot например не поддерживает откат миграций. Поэтому вам необходимо либо использовать исполняемый файл, либо докер образ. В своих примерах я буду использовать исполняемый файл.

Многие операции Liquibase может откатить самостоятельно: создание таблицы, добавление колонки. Для некоторых changeSet необходимо написать скрипты отката.

Важно понимать, что откат изменений приводит к потере данных. Например, если вы откатите создание таблицы, а в ней были данные, то вы их потеряйтее.

Откат rollbackCount
Если мы вызовем Liquibase с аргументом rollbackCount 1 произойдет откат последнего changeSe

./liquibase rollbackCount 1

Откат rollback tag
Откатывать по счетчику не удобно. Допустим вы хотите откатить все ваше приложение до предыдущей версии вместе со схемой БД. С этой предыдущей версии у вас уже было выполнено множество changeSet, и считать сколько их было дело не благодарное.

Поэтому в каждом cumulative-changelog.xml я добавил tagDatabase. Это позволит откатить все изменения, которые были сделаны после этого тега, включая запись о создании этого тега. Таким образом можно откатить ваше приложение со схемой БД до необходимой версии.

./liquibase rollback v.2.0.0

--------------------------------------------------------------------------------------------------------------------
Ручные rollBack

Все операции по вставке данных не откатываются автоматически.
Поэтому просто добавляем в последний changeSet наш rollback:

<changeSet id="insert-into" author="uPagge"> 
<insert tableName="book"> 
 <column name="name" value="Капитанская дочка"/> 
 <column name="author_id" value="1"/> 
</insert> 

<rollback> 
<delete tableName="book"> 
 <where>title = 'Капитанская дочка'</where> 
</delete> 
 </rollback> 
</changeSet>

Преимущество такого подхода в том, что если один из rollback был неправильно написан, то все остальные rollback до него выполнятся.
Также вы можете использовать чистый SQL

--------------------------------------------------------------------------------------------------------------------
Как сдалать запрет на откат changeSet

озможно вы захотите, чтобы какой-либо changeSet остался после отката. То есть вы хотите откатить все изменения, кроме некоторых. Для этого добавьте пустой тег rollback.

<changeSet id="create-table-person" author="uPagge"> <createTable tableName="person"> 
 <column name="id" type="int" autoIncrement="true"> 
 <constraints nullable="false" primaryKey="true"/> 
 </column> 
 <column name="first_name" type="varchar(64)"/> </createTable>
 <rollback/> 
</changeSet>

В таком случае откатятся все изменения, кроме содержащих пустой тег rollback. Будьте аккуратны с этой функцией.

--------------------------------------------------------------------------------------------------------------------
Организация ChangeSet в проекте

БД может довольно динамично меняться, особенно в начале создания приложения, поэтому мы ожидаем множество changeSet. И чтобы наш changeLog не превратился в длинный манускрипт, стоит создавать множество ChangeLog и включать их друг в друга Далее я расскажу о своем подходе к организации changeLog структуры.

Я придерживаюсь следующего подхода:
Для каждой текущей версии приложения создаем папку в db/changelog. Например, v.1.0.0.

В этой папке у нас будет локальный главный чейджлог-файл. Я называю их cumulative-changelog.xml.

Когда вам необходимо внести набор изменений для схемы БД, то вы создаете отдельный changelog и
включаете его в cumulative-changelog.xml.

В db.changelog-master.xml мы подключаем все cumulative-changelog.xml.

Во время выпуска релиза у вас могут оказаться запросы на слияния, которые затрагивают добавления новых changeSet. В этих ПР необходимо создать новую папку для новых changeLogs с номером нового релиза и перенести туда changeLogs для этих ПРов.

--------------------------------------------------------------------------------------------------------------------
Правила именования

Правило именования файлов позволяет без просмотра кумулятивных чейнджлогов файлов понять, что за чем следовало, и не допустит случайного повторения id у changeSet.

Вы можете придумать свои правила, но вот что предлагаю я:

Каждый changelog, кроме cumulative-changelog.xml, начинается с текущей даты, а далее короткое описание всех изменений внутри. Например: 2020-03-08-create-tables.xml

Так же поступайте с id у changeSet. Например id="2020-03-08-create-table-person".

--------------------------------------------------------------------------------------------------------------------
Какой формат для написания чейнджлогов используете

Иногда хочется «облегчить» жизнь и отказаться от XML, начав использовать более краткий DSL: groovy, yaml, json. Все это очень хорошо до тех пор, пока вам не захочется иметь:

Авто дополнение в IDE

Автоматическую проверку формальной верности документа по схеме данных

Используйте скрипты в формате XML, иногда используя SQL, если невозможно использовать XML.

--------------------------------------------------------------------------------------------------------------------
Почему лучше не изменять данные с помощью Liquibase

Работа с данными в БД не входит в число ключевых фич Liquibase и ограничивается лишь простейшими операциями вставки и удаления или изменения. Исходя из своего опыта крайне не рекомендую изменять данные с помощью Liquibase.

Кто-нибудь обязательно ошибется и ошибка уедет на тестовую среду, а откатывать придется вручную.

Идентификаторы к записям чаще всего генерируются автоматически, что может привести к дополнительным конфликтам.

--------------------------------------------------------------------------------------------------------------------
Почему чейнджлоги, изменяющие схему БД, должны быть атомарными

Не могу сказать про многие базы данных, но по крайней мере в Oracle и MySQL DDL-операторы не включаются в транзакцию.Это значит, что если при запуске чейнджсета произошка ошибка, DDL-операторы, выполненные до ошибки останутся в базе.
Пример (так неправильно)
:<changeSet id="2013-03-02-initial-schema-import-1" author="eg">
<createTable tableName="HOUSES">
<column name="ID" type="BIGINT" />
</createTable>
<addPrimaryKey tableName="HOUSES" columnNames="ID" />
</changeSet>

Если при добавлении индекса произойдет ошибка, таблица HOUSES не будет удалена!Как избежать боли?Каждое изменение схемы БД должно жить в своем чейнджсете.

Пример (так правильно):
<changeSet id="2013-03-02-initial-schema-import-1" author="eg">
<createTable tableName="HOUSES">
<column name="ID" type="BIGINT" />
</createTable>
</changeSet>

<changeSet id="2013-03-02-initial-schema-import-2" author="eg"> 
<addPrimaryKey tableName="HOUSES" columnNames="ID" /> 
</changeSet>

--------------------------------------------------------------------------------------------------------------------
Почему лучше много маленьких чейнджсетов, чем один большой

Один чейнджсет — одна транзакция. Если данных меняется много, лучше, чтобы транзакции были поменьше. Работайте над ними изолированно, не добавляйте несколько изменений в один чейнджсет, думайте над содержимым тэга rollback. Лучше много простых и даже однотипных чем один сложный и невнятный.

--------------------------------------------------------------------------------------------------------------------
Зачем нужнен кумулятивный файл чейнджлогов для каждой версии

Основным файлом миграций является /db-migrations/changelog.xml. В него включаются (тэг «include») только кумулятивные файлы чейнджлогов каждой из версий.

<?xml version="1.0" encoding="UTF-8"?> <databaseChangeLog xmlns="http://www.liquibase.org/xml/ns/dbchangelog"> 
<!-- Should be only links to per-version cumulative changelog files. --> 

<include file="v-1.0/changelog-v.1.0-cumulative.xml" relativeToChangelogFile="true"/>

 <include file="v-2.0/changelog-v.2.0-cumulative.xml" relativeToChangelogFile="true"/> 

</databaseChangeLog>

В свою очередь, в кумулятивные чейнджлоги версий приложений включаются конкретные файлы с чейнджсетами.Таким образом удается не замусорить главный файл чейнджлогов.

--------------------------------------------------------------------------------------------------------------------
Если начали использовать средства миграции - не допускайте мануальных исправлений в структуре базы

Как говорится: «Один раз Persil — всегда Persil». Если база вашего приложения начала управляться средствами Liquibase — любые ручные изменения моментально приводят к неконсистентному состоянию, и уровень доверия ченджсетам становится равен нулю. Потенциальные риски — несколько потраченных часов на восстановление базы, при худшем раскладе — убитый сервер. Если в вашей команде есть DBA Architect «старой закалки», терпеливо и вдумчиво объясните ему, как всё будет плохо, если он просто отредактирует базу по своему разумению из условного SQL Developer.

--------------------------------------------------------------------------------------------------------------------
Если ченджсет уже был запушен в репозиторий, избегайте редактирования

Если другой разработчик сделал pull и применил ченджсет, который впоследствии будет отредактирован, — он обязательно помянет вас добрым словом, когда получит ошибку при старте приложения. Если редактирование ченджсета каким-то образом протечёт в девелоп — придётся идти скользкой дорожкой хотфиксов. Суть проблемы упирается в валидацию изменений по хеш-сумме — основной механизм Liquibase. При редактировании кода ченджсета меняется хеш-сумма. Редактирование ченджсетов возможно только тогда, когда присутствует возможность без потери данных развернуть всю базу с нуля. В таком случае рефакторинг SQL или XML кода может, наоборот, облегчить жизнь, сделать миграции более читаемыми. Примером может быть ситуация, когда на старте приложения схема исходной БД согласовывалась внутри команды.

--------------------------------------------------------------------------------------------------------------------
Имей проверенные бэкапы баз данных, если это возможно

Тут, думаю, всё понятно. В случае если вдруг миграция прошла неудачно, всё можно будет вернуть назад. В Liquibase есть инструмент отката изменений, но скрипты для отката пишет тоже сам разработчик, и в них могут быть проблемы с такой же вероятностью, как и в скриптах основного ченджсета. Это означает, что перестраховываться с бэкапами полезно в любом случае.

--------------------------------------------------------------------------------------------------------------------
Используй проверенные бэкапы баз данных в разработке, если это возможно

Если это не противоречит договорам и privacy, в базе нет персональных данных, и она не весит как два солнца — перед применением на живых серверах миграции можно проверить, как оно сработает на машине разработчика, и вычислить почти 100% потенциальных проблем при миграции.

--------------------------------------------------------------------------------------------------------------------
Ситуация Два разработчика пытаются одновременно добавлять новые ченджсеты

Вася и Петя хотят создать ченджсет версии 4, не зная друг о друге. Они произвели изменения в структуре БД, и выкатили pull request, с разными файлами ченджсета. Далее предлагается следующий механизм действий:

Как решать

Каким-то образом коллеги должны договориться, в каком порядке должны идти их ченджсеты, допустим, Петин должен быть применён первый.

Кто-то один должен подлить второй к себе и пометить ченджсет Васи версией 5. Это может быть сделано через Cherry Pick или аккуратный мердж.

После изменений обязательно следует проверить валидность произведённых действий.На самом деле механизмы Liquibase позволят иметь в репозитории два ченджсета версии 4, поэтому можно оставить всё как есть. То есть у вас просто будет два изменения версии 4 с разными названиями. При таком подходе впоследствии в версиях базы данных становится очень сложно ориентироваться.

Кроме того, Liquibase, как дома хоббитов, хранит в себе много секретов. Одним из них является ключ validCheckSum, который появился с версии 1.7 и позволяет указать валидное значение хеш-суммы для определенного ченджсета вне зависимости от того, что хранится в базе данных.

Да-да, такая процедура не рекомендуется. Но иногда сильный светлый маг владеет и темными техниками

--------------------------------------------------------------------------------------------------------------------
Ситуация Миграция, которая зависит от данных

Предположим, у вас нет возможности использовать резервные копии баз с живых серверов. Петя создал ченджсет, проверил его локально и с полной уверенностью своей правоты сделал pull request в девелоп. Лид проекта на всякий случай уточнил, проверил ли его Петя, и затем влил. Но развертывание на девелоп сервере упало.

На самом деле такое возможно, и от этого никто не застрахован. Это происходит в том случае, если модификации структуры таблиц каким-то образом завязаны на конкретные данные из БД. Очевидно, что если база Пети заполнена только тестовыми данными, то она может не покрывать все проблемные кейсы. Например, при удалении таблицы выясняется, что есть записи в других таблицах по Foreign Key, связанные с записями в удаляемой. Или при изменении типа колонки выясняется, что не 100% данных могут быть преобразованы к новому типу.

Как решать

Написать специальные скрипты, которые будут однократно применяться вместе с миграцией и приводить данные в надлежащий вид. Это общий путь решения проблемы переноса данных в новые структуры уже после применения миграций, но что-то подобное может быть применено и до, в частных случаях. Такой путь, конечно, не всегда доступен, ибо редактировать данные на живых серверах может быть опасно и даже губительно.

Другой сложный путь — отредактировать имеющийся ченджсет. Сложность в том, что все БД, где он в имеющемся виде уже был применён, придётся восстанавливать. Вполне возможно, что вся бэкенд-команда вынуждена будет локально накатить БД с нуля.

И самый универсальный путь — перенос проблемы с данными на environment разработчика с воссозданием той же ситуации и добавление нового ченджсета, до сломанного, который позволит обойти проблему.

В целом, чем больше база по составу данных похожа на базу продакшн сервера, тем меньше шанс, что проблемы с миграциями протекут далеко. И, конечно, прежде чем отправить ченджсет в репозиторий, стоит несколько раз подумать, не сломает ли он что-нибудь.

--------------------------------------------------------------------------------------------------------------------
Ситуация Liquibase начинает применяться уже после выхода в продакшн

Предположим, тимлид попросил Петю подключить в проект Liquibase, однако проект уже в продакшене и имеется уже существующая структура базы.

Соответственно, проблема состоит в том, чтобы на любых новых серверах или машинах разработчиков данные таблицы должны воссоздаваться с нуля, а уже существующая среда должна остаться в консистентном состоянии, будучи готовой принимать новые ченджсеты.

Как решать

Тут также имеется несколько путей:

Первый и самый очевидный — иметь отдельный скрипт, который должен быть применён вручную при инициализации нового окружения.

Второй — менее очевидный, иметь Liquibase миграцию, которая находится в другом Liquibase Context, и применять её. Подробнее про Liquibase Context можно прочитать тут:
https://www.liquibase.org/documentation/contexts.html. В целом это интересный механизм, который может быть успешно применён, например, для тестирования.

Третий путь состоит из нескольких шагов. Сначала должна быть создана миграция для уже имеющихся таблиц. Затем она должна быть применена на каком-то environment'е и таким образом будет получена её хэш-сумма. Следующим шагом следует проинициализировать на нашем не пустом сервере пустые Liquibase таблицы, и в таблицу с историей применения ченджсетов можно мануально положить запись о «как будто бы применённом» ченджсете с уже имеющимися в базе изменениями. Таким образом, на уже существующем сервере отсчёт истории пойдёт с версии 2, а все новые environments будут вести себя идентично.

--------------------------------------------------------------------------------------------------------------------
Ситуация Миграции становятся огромными и не успевают выполняться

В начале разработки сервиса, как правило, Liquibase используется как внешняя зависимость, и все миграции обрабатываются при старте приложения. Однако со временем вы можете наткнуться на следующие кейсы:

Миграции становятся огромными и выполняются долгое время.
Появляется необходимость миграции в распределенных средах, допустим, на нескольких инстансах серверов БД одновременно.В таком случае слишком долгое применение миграций приведет к таймауту при старте приложения. Кроме того, применение миграций для каждого инстанса приложения отдельно может привести к тому, что разные серверы окажутся в не синхронном состоянии.

Как решать

В таких случаях ваш проект уже большой, возможно даже совершеннолетний, и Liquibase начинает выступать как отдельный внешний инструмент. Дело в том, что Liquibase как библиотека собирается в jar файл, и может работать как зависимость внутри проекта, так и автономно.

В автономном режиме можно возложить применение миграций на вашу CI/CD среду или на крепкие плечи ваших системных администраторовспециалистов по развертыванию. Для этого понадобится командная строка Liquibase https://www.liquibase.org/documentation/command_line.html. В таком режиме появляется возможность производить запуск приложения уже после того, как все необходимые миграции были проведены.

--------------------------------------------------------------------------------------------------------------------