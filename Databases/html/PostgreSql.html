<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Вопросы по собеседованию</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .question-block {
            cursor: pointer;
            transition: background-color 0.3s ease;
            word-break: break-word;
        }
        .question-block:hover {
            background-color: #f3f4f6;
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen">

<!-- Контейнер с вопросом -->
<div id="question-container" class="bg-white shadow-lg rounded-lg p-6 w-[800px] h-[750px] flex items-center justify-center text-center relative">
    <div id="question-block" class="question-block p-4 border-b w-full h-full flex items-center justify-center text-center relative" onclick="toggleAnswer()">
        <strong class="text-lg block" id="question-text"></strong>
        <div id="answer-text" class="text-gray-700 hidden" onclick="toggleAnswer()"></div>
    </div>
</div>

<!-- Навигация -->
<div class="absolute bottom-10 flex justify-center gap-4">
    <button onclick="prevQuestion()" class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600">Назад</button>
    <button onclick="location.href='main.html'" class="bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600">На главную</button>
    <button onclick="nextQuestion()" class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600">Вперед</button>
</div>

<!-- Модальное окно -->
<div id="modal" class="fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 hidden">
    <div class="bg-white p-6 rounded-lg shadow-lg w-[900px] h-[800px] overflow-y-auto">
        <h2 class="text-lg font-semibold mb-4">Ответ</h2>
        <p id="modal-answer" class="text-gray-700"></p>
        <button onclick="closeModal()" class="mt-4 bg-red-500 text-white px-4 py-2 rounded hover:bg-red-600 w-full">Закрыть</button>
    </div>
</div>

<script>
    let currentQuestionIndex = 0;
    const MAX_ANSWER_LENGTH = 2000; // Максимальная длина ответа для отображения без модального окна

    const questions = [
        {
  question: "1)Что такое страницы?",
  answer: "В PostgreSQL данные организованы на диске в блоках, которые называются 'страницами'"
}
,{
  question: "2)Что такое версии строке?",
  answer: "Перед специальной областью располагаются строки (rows) — те самые данные, которые хранятся в базе, с добавлением некоторой служебной информации.<br>В случае таблиц мы говорим не просто о строках, а о версиях строк (row versions, tuples), поскольку многоверсионность предполагает существование нескольких версий одной и той же строки. На индексы многоверсионность не распространяется; вместо этого индексы ссылаются на все возможные табличные версии строк, среди которых по правилам видимости выбираются подходящие."
}
,{
  question: "3)Как сохраняются большие данные в PostgreSQL?",
  answer: "В PostgreSQL TOAST (The Oversized-Attribute Storage Technique) — это механизм, используемый для хранения и управления большими значениями данных в базе данных. Этот механизм применяется к столбцам, содержащим значения, которые могут быть слишком большими для хранения в обычном формате страницы. Примерами могут служить длинные текстовые строки, большие объекты (BLOBs), JSON-объекты и др.Когда размер значения превышает некоторый предопределенный порог (обычно 2 кБ), PostgreSQL автоматически применяет TOAST к этому значению. Процесс TOAST состоит в том, что PostgreSQL сжимает, разделяет и хранит большое значение в специальном формате, который затем может быть обработан более эффективно. При этом сами значения не теряются и могут быть извлечены и использованы без потери данных.TOAST помогает управлять памятью и улучшает производительность базы данных, позволяя PostgreSQL эффективно работать с большими объемами данных и предотвращать излишнее расходование ресурсов."
}
,{
  question: "4)Что такое snapshot isolation",
  answer: "Snapshot isolation (изоляция снимка) в PostgreSQL — это уровень изоляции транзакций, который гарантирует, что каждая транзакция видит когерентный 'снимок' базы данных на момент её начала. Другими словами, транзакция, работающая в режиме изоляции снимка, видит данные, как если бы они были зафиксированы на момент начала транзакции, и изменения, сделанные другими транзакциями после этого момента, не будут видны до завершения текущей транзакции."
}
,{
  question: "5)Почему в PostgreSql нет Read uncommited",
  answer: "Потому что в PostgreSQL используется Snapshot Isolation, который не позволяет видеть данные."
}
,{
  question: "6)Что такое область видимость бд?",
  answer: "Область видимости транзакции (также известная как 'scope' или 'visibility') в PostgreSQL определяет, какие данные транзакция видит и может изменять в рамках своего выполнения. Область видимости транзакции определяется с помощью изоляции транзакции.В PostgreSQL существует несколько уровней изоляции транзакций, которые определяют область видимости данных для каждой транзакции."
}
,{
  question: "7)Что такое mvcc?",
  answer: "MVCC (Multi-Version Concurrency Control) в PostgreSQL - это механизм контроля параллельности, который обеспечивает согласованное чтение и запись данных в многопользовательской среде без блокировки всей таблицы или больших диапазонов данных.Основные принципы MVCC в PostgreSQL:Множество версий данных: При изменении данных новая версия строки создается с сохранением предыдущей версии. Таким образом, в базе данных могут существовать несколько версий одной и той же строки.Идентификация версий: Каждая версия строки в PostgreSQL имеет свой собственный идентификатор транзакции (XID), который позволяет определить, когда эта версия была создана и какие транзакции могут её видеть.Контроль чтения по версиям: При выполнении запросов каждая транзакция видит только те версии данных, которые были зафиксированы на момент начала этой транзакции. Это позволяет избежать блокировок чтения и предотвращает чтение 'грязных' данных.Устранение фантомных чтений: MVCC в PostgreSQL также предотвращает фантомные чтения путем зафиксирования состояния базы данных на момент начала транзакции и гарантируя, что транзакция увидит только те данные, которые существовали на этот момент."
}
,{
  question: "8)Какие уровни памяти в PostgreSQL",
  answer: "Общая память (Shared Memory): Этот уровень памяти используется для обмена данными между различными процессами PostgreSQL и предназначен для хранения общих структур данных, таких как буферы с данными, журналы WAL (Write-Ahead Logging), информация о процессах и т. д.Буферный кэш (Buffer Cache): Буферный кэш в PostgreSQL используется для кэширования данных, считанных с диска, в оперативной памяти. Это позволяет уменьшить количество обращений к диску и увеличить скорость доступа к данным. Размер буферного кэша настраивается параметром shared_buffers.Кэш планов (Plan Cache): PostgreSQL также имеет кэш для планов выполнения запросов. Этот кэш хранит планы выполнения запросов, которые ранее были скомпилированы и выполнены, чтобы ускорить выполнение повторяющихся запросов. Размер кэша планов настраивается параметром plan_cache_mode.Рабочая память (Working Memory): Рабочая память используется в процессе выполнения запросов для сортировки, хеширования, агрегации и других операций. Размер рабочей памяти ограничивается параметрами, такими как work_mem.Кэш операторов (Operator Cache): Этот кэш хранит информацию о функциях и операторах базы данных, что позволяет избежать повторной компиляции операторов и функций во время выполнения запросов.Стековая память (Stack Memory): Этот уровень памяти используется для хранения данных о выполнении функций и процедур в рамках сессии PostgreSQL."
}
,{
  question: "9)Что такое Буферный кеш?",
  answer: "Кеширование используется в современных вычислительных системах повсеместно, как на программном, так и на аппаратном уровне. У одного только процессора можно насчитать три-четыре уровня кеша; свой кеш бывает<br>также и у контроллеров дисковых массивов, и у самих дисков.<br>Вообще, любой кеш нужен для того, чтобы компенсировать разную производительность двух типов памяти, одна из которых быстрее, но дороже и<br>меньше по объему, а другая — медленнее, но дешевле и больше. В быстрой<br>памяти невозможно разместить все данные из медленной памяти. Но в большинстве случаев активная работа ведется одновременно только с небольшой<br>выборкой, поэтому, выделив часть быстрой памяти под кеш для хранения<br>«горячих» данных, удается существенно экономить на обращениях к медленному устройству.<br>Буферный кеш PostgreSQL1<br>хранит страницы отношений, сглаживая разницу между временем доступа к оперативной памяти (наносекунды) и к дискам (миллисекунды).<br>Свой кеш, решающий ту же самую задачу, имеется и у операционной системы. Поэтому обычно при проектировании СУБД стараются избегать двойного кеширования, предпочитая обращаться к диску напрямую, минуя кеш ОС.<br>Но в случае PostgreSQL это не так: все данные читаются и записываются с помощью буферизованных файловых операций.Буферный кеш располагается в общей памяти сервера и доступен всем процессам. Он занимает б?льшую часть общей памяти и является одной из<br>самых важных и сложных структур данных. Понимание принципа работы<br>кеша важно само по себе; к тому же многие другие структуры (такие как<br>вложенные транзакции, статусы транзакций clog, журнальные записи) используют похожее, хотя и более простое кеширование.<br>Кеш называется буферным, потому что представляет собой массив буферов.<br>Каждый буфер резервирует фрагмент памяти, достаточный для одной страницы данных и ее заголовка2"
}
,{
  question: "10)Как читается большое количество записей?",
  answer: "Из-за того, что чтение большого количества данных может полностью занять всю оперативную память выделенную для PostgreSQL, <br>то применяется специальная структура 'зацикленный список', этот список имеет некоторую длину и постоянно вставляет значения в конец списка, из-за этого<br>количество данных уменьшается."
}
,{
  question: "11)Какие индексы существуют в PostgreSQL.",
  answer: "B-Tree индексы: B-Tree (Balanced Tree) индексы являются самым распространенным типом индексов в PostgreSQL. Они подходят для поиска данных по точному значению, диапазону значений или с использованием операторов сравнения (=, >, <, >=, <=). B-Tree индексы хорошо подходят для большинства запросов и обеспечивают логарифмическое время выполнения операций поиска.Hash индексы: Hash индексы используются для быстрого поиска данных по точному значению (оператор '='). Они хорошо подходят для равенственных операций, но не поддерживают операции диапазонного поиска или с использованием операторов сравнения. Hash индексы работают эффективно для поиска значений, но не гарантируют порядок результатов.GiST (Generalized Search Tree) индексы: GiST индексы предназначены для работы с данными, которые имеют многомерную или нестандартную структуру. Они поддерживают различные типы операций, такие как поиск ближайших соседей, текстовый поиск, географические запросы и т. д. GiST индексы могут быть использованы для создания индексов на столбцах, содержащих массивы, JSON-данные, геометрические объекты и другие нестандартные типы данных.GIN (Generalized Inverted Index) индексы: GIN индексы также предназначены для работы с нестандартными типами данных и поддерживают различные типы запросов, такие как полнотекстовый поиск, поиск по массивам и поиск по JSON-данным. GIN индексы хорошо подходят для создания полнотекстовых индексов и поиска по спискам или множествам.BRIN (Block Range Index) индексы: BRIN индексы используются для индексации больших таблиц с отсортированными данными, например, временных рядов или таблиц, упорядоченных по дате. Они хранят информацию о минимальных и максимальных значениях диапазонов блоков данных, что позволяет эффективно выполнить операции диапазонного поиска на больших объемах данных."
}
,{
  question: "12)Что такое журналы предзаписи?",
  answer: "Журналы предзаписи (WAL - Write-Ahead Logging) - это техника, используемая в базах данных для обеспечения целостности данных и надежности транзакций. Принцип журналов предзаписи заключается в том, что перед фактической записью данных в файлы данных, изменения записываются в журнальные файлы (WAL-файлы).В PostgreSQL, когда происходит операция вставки, обновления или удаления данных, эти изменения сначала записываются в журнал, а затем применяются к реальным файлам данных. Это гарантирует, что перед применением изменений к самим данным, они были сохранены в журнале. Если произойдет сбой или отказ системы, PostgreSQL сможет восстановить данные из журнала, применив изменения, которые были предварительно записаны, но еще не применены к файлам данных."
}
,{
  question: "13)Что такое запорозка?",
  answer: "Под номер транзакции в PostgreSQL выделено 32 бита. Четыре миллиарда<br>выглядит довольно большим числом, но при активной работе оно может<br>быть израсходовано довольно быстро. Например, при нагрузке 1000 транзакций в секунду (не считая виртуальных) это произойдет всего через полтора месяца непрерывной работы.Чтобы корректно обрабатывать переполнение счетчика, надо сравнивать не<br>номера транзакций, а их возраст (выраженный в количестве транзакций,<br>начатых с момента появления данной транзакции). Таким образом, вместо понятий «меньше» и «больше» используются «предшествует» («старше»)<br>и «следует за» («младше»).<br>В коде это естественным образом реализуется 32-битной арифметикой: надо найти разницу 32-битных номеров транзакций и сравнить полученный<br>результат с нулем1<br>.<br>Графически можно представить, что номера транзакций закольцованы. Тогда для любой транзакции половина номеров против часовой стрелки будет<br>старше (в прошлом), а половина по часовой стрелке — младше (в будущем)<br>"
}
,
    ];

    const questionText = document.getElementById('question-text');
    const answerText = document.getElementById('answer-text');
    const modal = document.getElementById('modal');
    const modalAnswer = document.getElementById('modal-answer');

    function toggleAnswer() {
        const answer = questions[currentQuestionIndex].answer;
        if (answer.length > MAX_ANSWER_LENGTH) {
            showModal(answer);
        } else {
            if (answerText.classList.contains('hidden')) {
                answerText.innerHTML = answer;
                answerText.classList.remove('hidden');
                questionText.classList.add('hidden');
            } else {
                answerText.classList.add('hidden');
                questionText.classList.remove('hidden');
            }
        }
    }

    function showModal(answer) {
        modalAnswer.innerHTML = answer;
        modal.classList.remove('hidden');
    }

    function showQuestion(index) {
        questionText.textContent = questions[index].question;
        answerText.innerHTML = ""; // Скрываем ответ при смене вопроса
        questionText.classList.remove('hidden');
        answerText.classList.add('hidden');
    }

    function nextQuestion() {
        if (currentQuestionIndex < questions.length - 1) {
            currentQuestionIndex++;
            showQuestion(currentQuestionIndex);
        }
    }

    function prevQuestion() {
        if (currentQuestionIndex > 0) {
            currentQuestionIndex--;
            showQuestion(currentQuestionIndex);
        }
    }

    function closeModal() {
        modal.classList.add('hidden');
    }

    showQuestion(currentQuestionIndex);
</script>

</body>
</html>
