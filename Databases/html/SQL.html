<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Вопросы по собеседованию</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .question-block {
            cursor: pointer;
            transition: background-color 0.3s ease;
            word-break: break-word;
        }
        .question-block:hover {
            background-color: #f3f4f6;
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen">

<!-- Контейнер с вопросом -->
<div id="question-container" class="bg-white shadow-lg rounded-lg p-6 w-[800px] h-[750px] flex items-center justify-center text-center relative">
    <div id="question-block" class="question-block p-4 border-b w-full h-full flex items-center justify-center text-center relative" onclick="toggleAnswer()">
        <strong class="text-lg block" id="question-text"></strong>
        <div id="answer-text" class="text-gray-700 hidden" onclick="toggleAnswer()"></div>
    </div>
</div>

<!-- Навигация -->
<div class="absolute bottom-10 flex justify-center gap-4">
    <button onclick="prevQuestion()" class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600">Назад</button>
    <button onclick="location.href='main.html'" class="bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600">На главную</button>
    <button onclick="nextQuestion()" class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600">Вперед</button>
</div>

<!-- Модальное окно -->
<div id="modal" class="fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 hidden">
    <div class="bg-white p-6 rounded-lg shadow-lg w-[900px] h-[800px] overflow-y-auto">
        <h2 class="text-lg font-semibold mb-4">Ответ</h2>
        <p id="modal-answer" class="text-gray-700"></p>
        <button onclick="closeModal()" class="mt-4 bg-red-500 text-white px-4 py-2 rounded hover:bg-red-600 w-full">Закрыть</button>
    </div>
</div>

<script>
    let currentQuestionIndex = 0;
    const MAX_ANSWER_LENGTH = 2000; // Максимальная длина ответа для отображения без модального окна

    const questions = [
        {
  question: "Что такое «SQL»?",
  answer: "SQL, Structured query language («язык структурированных запросов») — формальный непроцедурный язык программирования, применяемый для создания, модификации и управления данными в произвольной реляционной базе данных, управляемой соответствующей системой управления базами данных (СУБД).<br>SQL основывается на исчислении кортежей. Стандарт SQL определяется с помощью кода ANSI."
}
,{
  question: "Какие существуют операторы SQL?",
  answer: "операторы определения данных (Data Definition Language, DDL):<br>CREATE создает объект БД (базу, таблицу, представление, пользователя и т. д.),<br>ALTER изменяет объект,<br>DROP удаляет объект;операторы манипуляции данными (Data Manipulation Language, DML):<br>SELECT выбирает данные, удовлетворяющие заданным условиям,<br>INSERT добавляет новые данные,<br>UPDATE изменяет существующие данные,<br>DELETE удаляет данные;операторы определения доступа к данным (Data Control Language, DCL):<br>GRANT предоставляет пользователю (группе) разрешения на определенные операции с объектом,<br>REVOKE отзывает ранее выданные разрешения,<br>DENY задает запрет, имеющий приоритет над разрешением;операторы управления транзакциями (Transaction Control Language, TCL):<br>COMMIT применяет транзакцию,<br>ROLLBACK откатывает все изменения, сделанные в контексте текущей транзакции,<br>SAVEPOINT разбивает транзакцию на более мелкие."
}
,{
  question: "Что означает NULL в SQL?",
  answer: "NULL - специальное значение (псевдозначение), которое может быть записано в поле таблицы базы данных. NULL соответствует понятию «пустое поле», то есть «поле, не содержащее никакого значения».<br>NULL означает отсутствие, неизвестность информации. Значение NULL не является значением в полном смысле слова: по определению оно означает отсутствие значения и не принадлежит ни одному типу данных. Поэтому NULL не равно ни логическому значению FALSE, ни пустой строке, ни 0. При сравнении NULL с любым значением будет получен результат NULL, а не FALSE и не 0. Более того, NULL не равно NULL!"
}
,{
  question: "Что такое «временная таблица»? Для чего она используется?",
  answer: "Временная таблица - это объект базы данных, который хранится и управляется системой базы данных на временной основе. Они могут быть локальными или глобальными. Используется для сохранения результатов вызова хранимой процедуры, уменьшение числа строк при соединениях, агрегирование данных из различных источников или как замена курсоров и параметризованных представлений."
}
,{
  question: "Что такое «представление» (view) и для чего оно применяется?",
  answer: "Представление, View - виртуальная таблица, представляющая данные одной или более таблиц альтернативным образом.<br>В действительности представление - всего лишь результат выполнения оператора SELECT, который хранится в структуре памяти, напоминающей SQL таблицу. Они работают в запросах и операторах DML точно также как и основные таблицы, но не содержат никаких собственных данных. Представления значительно расширяют возможности управления данными. Это способ дать публичный доступ к некоторой (но не всей) информации в таблице."
}
,{
  question: "Каков общий синтаксис оператора SELECT?",
  answer: "SELECT - оператор DML SQL, возвращающий набор данных (выборку) из базы данных, удовлетворяющих заданному условию. Имеет следующую структуру:<br>SELECT<br>[DISTINCT | DISTINCTROW | ALL]<br>select_expression,...<br>FROM table_references<br>[WHERE where_definition]<br>[GROUP BY {unsigned_integer | column | formula}]<br>[HAVING where_definition]<br>[ORDER BY {unsigned_integer | column | formula} [ASC | DESC], ...]"
}
,{
  question: "Что такое JOIN?",
  answer: "JOIN - оператор языка SQL, который является реализацией операции соединения реляционной алгебры. Предназначен для обеспечения выборки данных из двух таблиц и включения этих данных в один результирующий набор.<br>Особенностями операции соединения являются следующее:<br>в схему таблицы-результата входят столбцы обеих исходных таблиц (таблиц-операндов), то есть схема результата является «сцеплением» схем операндов;<br>каждая строка таблицы-результата является «сцеплением» строки из одной таблицы-операнда со строкой второй таблицы-операнда;<br>при необходимости соединения не двух, а нескольких таблиц, операция соединения применяется несколько раз (последовательно).SELECT<br>field_name [,... n]<br>FROM<br>Table1<br>{INNER | {LEFT | RIGHT | FULL} OUTER | CROSS } JOIN<br>Table2<br>{ON <condition> | USING (field_name [,... n])}"
}
,{
  question: "Какие существуют типы JOIN?",
  answer: "(INNER) JOIN Результатом объединения таблиц являются записи, общие для левой и правой таблиц. Порядок таблиц для оператора не важен, поскольку оператор является симметричным.<br>LEFT (OUTER) JOIN Производит выбор всех записей первой таблицы и соответствующих им записей второй таблицы. Если записи во второй таблице не найдены, то вместо них подставляется пустой результат (NULL). Порядок таблиц для оператора важен, поскольку оператор не является симметричным.<br>RIGHT (OUTER) JOIN LEFT JOIN с операндами, расставленными в обратном порядке. Порядок таблиц для оператора важен, поскольку оператор не является симметричным.<br>FULL (OUTER) JOIN Результатом объединения таблиц являются все записи, которые присутствуют в таблицах. Порядок таблиц для оператора не важен, поскольку оператор является симметричным.<br>CROSS JOIN (декартово произведение) При выборе каждая строка одной таблицы объединяется с каждой строкой второй таблицы, давая тем самым все возможные сочетания строк двух таблиц. Порядок таблиц для оператора не важен, поскольку оператор является симметричным."
}
,{
  question: "Что лучше использовать JOIN или подзапросы?",
  answer: "Обычно лучше использовать JOIN, поскольку в большинстве случаев он более понятен и лучше оптимизируется СУБД (но 100% этого гарантировать нельзя). Так же JOIN имеет заметное преимущество над подзапросами в случае, когда список выбора SELECT содержит столбцы более чем из одной таблицы.<br>Подзапросы лучше использовать в случаях, когда нужно вычислять агрегатные значения и использовать их для сравнений во внешних запросах."
}
,{
  question: "Для чего используется оператор HAVING?",
  answer: "HAVING используется для фильтрации результата GROUP BY по заданным логическим условиям.Секция HAVING определяет условие, которое затем применяется к групам строк. Следовательно, это предложение имеет тот же смысл для группы строк, что и предложение WHERE в отношении соодержимого соответствующей таблицы. Синтаксис предложения HAVING HAVING condition где condition содержит агрегатные функции или константы."
}
,{
  question: "В чем различие между операторами HAVING и WHERE?",
  answer: "HAVING используется как WHERE, но в другой части SQL-выражения и, соответственно, на другой стадии формирования ответа.Важно понимать, что секции HAVING и WHERE взаимно дополняют друг друга. Сначала с помощью ограничений WHERE формируется итоговая выборка, затем выполняется разбивка на группы по значениям полей, заданных в GROUP BY. Далее по каждой группе вычисляется групповая функция и в заключение накладывается условие HAVING."
}
,{
  question: "Для чего используется оператор ORDER BY?",
  answer: "ORDER BY упорядочивает вывод запроса согласно значениям в том или ином количестве выбранных столбцов. Многочисленные столбцы упорядочиваются один внутри другого. Возможно определять возрастание ASC или убывание DESC для каждого столбца. По умолчанию установлено - возрастание."
}
,{
  question: "Для чего используется оператор GROUP BY?",
  answer: "GROUP BY используется для агрегации записей результата по заданным признакам-атрибутам."
}
,{
  question: "Как GROUP BY обрабатывает значение NULL?",
  answer: "При использовании GROUP BY все значения NULL считаются равными."
}
,{
  question: "В чем разница между операторами GROUP BY и DISTINCT?",
  answer: "DISTINCT указывает, что для вычислений используются только уникальные значения столбца. NULL считается как отдельное значение. GROUP BY создает отдельную группу для всех возможных значений (включая значение NULL).<br>Если нужно удалить только дубликаты лучше использовать DISTINCT, GROUP BY лучше использовать для определения групп записей, к которым могут применяться агрегатные функции."
}
,{
  question: "Перечислите основные агрегатные функции.",
  answer: "Агрегатных функции - функции, которые берут группы значений и сводят их к одиночному значению.<br>SQL предоставляет несколько агрегатных функций:<br>COUNT - производит подсчет записей, удовлетворяющих условию запроса; SUM - вычисляет арифметическую сумму всех значений колонки; AVG - вычисляет среднее арифметическое всех значений; MAX - определяет наибольшее из всех выбранных значений; MIN - определяет наименьшее из всех выбранных значений."
}
,{
  question: "В чем разница между COUNT(*) и COUNT({column})?",
  answer: "COUNT (*) подсчитывает количество записей в таблице, не игнорируя значение NULL, поскольку эта функция оперирует записями, а не столбцами.<br>COUNT ({column}) подсчитывает количество значений в {column}. При подсчете количества значений столбца эта форма функции COUNT не принимает во внимание значение NULL."
}
,{
  question: "Что делает оператор EXISTS?",
  answer: "EXISTS берет подзапрос, как аргумент, и оценивает его как TRUE, если подзапрос возвращает какие-либо записи и FALSE, если нет."
}
,{
  question: "Для чего используются операторы IN, BETWEEN, LIKE?",
  answer: "IN - определяет набор значений.<br>SELECT * FROM Persons WHERE name IN ('Ivan','Petr','Pavel');<br>BETWEEN определяет диапазон значений. В отличие от IN, BETWEEN чувствителен к порядку, и первое значение в предложении должно быть первым по алфавитному или числовому порядку.<br>SELECT * FROM Persons WHERE age BETWEEN 20 AND 25;<br>LIKE применим только к полям типа CHAR или VARCHAR, с которыми он используется чтобы находить подстроки. В качестве условия используются символы шаблонизации (wildkards) - специальные символы, которые могут соответствовать чему-нибудь:<br>_ замещает любой одиночный символ. Например, 'b_t' будет соответствовать словам 'bat' или 'bit', но не будет соответствовать 'brat'.<br>% замещает последовательность любого числа символов. Например '%p%t' будет соответствовать словам 'put', 'posit', или 'opt', но не 'spite'.<br>SELECT * FROM UNIVERSITY WHERE NAME LIKE '%o';"
}
,{
  question: "Для чего применяется ключевое слово UNION?",
  answer: "В языке SQL ключевое слово UNION применяется для объединения результатов двух SQL-запросов в единую таблицу, состоящую из схожих записей. Оба запроса должны возвращать одинаковое число столбцов и совместимые типы данных в соответствующих столбцах. Необходимо отметить, что UNION сам по себе не гарантирует порядок записей. Записи из второго запроса могут оказаться в начале, в конце или вообще перемешаться с записями из первого запроса. В случаях, когда требуется определенный порядок, необходимо использовать ORDER BY."
}
,{
  question: "Какие ограничения на целостность данных существуют в SQL?",
  answer: "PRIMARY KEY - набор полей (1 или более), значения которых образуют уникальную комбинацию и используются для однозначной идентификации записи в таблице. Для таблицы может быть создано только одно такое ограничение. Данное ограничение используется для обеспечения целостности сущности, которая описана таблицей.<br>CHECK используется для ограничения множества значений, которые могут быть помещены в данный столбец. Это ограничение используется для обеспечения целостности предметной области, которую описывают таблицы в базе.<br>UNIQUE обеспечивает отсутствие дубликатов в столбце или наборе столбцов.<br>FOREIGN KEY защищает от действий, которые могут нарушить связи между таблицами. FOREIGN KEY в одной таблице указывает на PRIMARY KEY в другой. Поэтому данное ограничение нацелено на то, чтобы не было записей FOREIGN KEY, которым не отвечают записи PRIMARY KEY."
}
,{
  question: "Какие отличия между ограничениями PRIMARY и UNIQUE?",
  answer: "По умолчанию ограничение PRIMARY создает кластерный индекс на столбце, а UNIQUE - некластерный. Другим отличием является то, что PRIMARY не разрешает NULL записей, в то время как UNIQUE разрешает одну (а в некоторых СУБД несколько) NULL запись."
}
,{
  question: "Может ли значение в столбце, на который наложено ограничение FOREIGN KEY, равняться NULL?",
  answer: "Может, если на данный столбец не наложено ограничение NOT NULL."
}
,{
  question: "Как создать индекс?",
  answer: "Индекс можно создать либо с помощью выражения CREATE INDEX:<br>CREATE INDEX index_name ON table_name (column_name)<br>либо указав ограничение целостности в виде уникального UNIQUE или первичного PRIMARY ключа в операторе создания таблицы CREATE TABLE."
}
,{
  question: "Что делает оператор MERGE?",
  answer: "MERGE позволяет осуществить слияние данных одной таблицы с данными другой таблицы. При слиянии таблиц проверяется условие, и если оно истинно, то выполняется UPDATE, а если нет - INSERT. При этом изменять поля таблицы в секции UPDATE, по которым идет связывание двух таблиц, нельзя."
}
,{
  question: "В чем отличие между операторами DELETE и TRUNCATE?",
  answer: "DELETE - оператор DML, удаляет записи из таблицы, которые удовлетворяют критерию WHERE при этом задействуются триггеры, ограничения и т.д.<br>TRUNCATE - DDL оператор (удаляет таблицу и создает ее заново. Причем если на эту таблицу есть ссылки FOREGIN KEY или таблица используется в репликации, то пересоздать такую таблицу не получится)."
}
,{
  question: "Что такое «хранимая процедура»?",
  answer: "Хранимая процедура — объект базы данных, представляющий собой набор SQL-инструкций, который хранится на сервере. Хранимые процедуры очень похожи на обыкновенные процедуры языков высокого уровня, у них могут быть входные и выходные параметры и локальные переменные, в них могут производиться числовые вычисления и операции над символьными данными, результаты которых могут присваиваться переменным и параметрам. В хранимых процедурах могут выполняться стандартные операции с базами данных (как DDL, так и DML). Кроме того, в хранимых процедурах возможны циклы и ветвления, то есть в них могут использоваться инструкции управления процессом исполнения.<br>Хранимые процедуры позволяют повысить производительность, расширяют возможности программирования и поддерживают функции безопасности данных. В большинстве СУБД при первом запуске хранимой процедуры она компилируется (выполняется синтаксический анализ и генерируется план доступа к данным) и в дальнейшем её обработка осуществляется быстрее."
}
,{
  question: "Что такое «триггер»?",
  answer: "Триггер (trigger) — это хранимая процедура особого типа, которую пользователь не вызывает непосредственно, а исполнение которой обусловлено действием по модификации данных: добавлением, удалением или изменением данных в заданной таблице реляционной базы данных. Триггеры применяются для обеспечения целостности данных и реализации сложной бизнес-логики. Триггер запускается сервером автоматически и все производимые им модификации данных рассматриваются как выполняемые в транзакции, в которой выполнено действие, вызвавшее срабатывание триггера. Соответственно, в случае обнаружения ошибки или нарушения целостности данных может произойти откат этой транзакции.<br>Момент запуска триггера определяется с помощью ключевых слов BEFORE (триггер запускается до выполнения связанного с ним события) или AFTER (после события). В случае, если триггер вызывается до события, он может внести изменения в модифицируемую событием запись. Кроме того, триггеры могут быть привязаны не к таблице, а к представлению (VIEW). В этом случае с их помощью реализуется механизм «обновляемого представления». В этом случае ключевые слова BEFORE и AFTER влияют лишь на последовательность вызова триггеров, так как собственно событие (удаление, вставка или обновление) не происходит."
}
,{
  question: "Что такое «курсор»?",
  answer: "Курсор — это объект базы данных, который позволяет приложениям работать с записями «по-одной», а не сразу с множеством, как это делается в обычных SQL командах.<br>Порядок работы с курсором такой:<br>Определить курсор (DECLARE)<br>Открыть курсор (OPEN)<br>Получить запись из курсора (FETCH)<br>Обработать запись...<br>Закрыть курсор (CLOSE)<br>Удалить ссылку курсора (DEALLOCATE). Когда удаляется последняя ссылка курсора, SQL освобождает структуры данных, составляющие курсор."
}
,{
  question: "Опишите разницу типов данных DATETIME и TIMESTAMP.",
  answer: "DATETIME предназначен для хранения целого числа: YYYYMMDDHHMMSS. И это время не зависит от временной зоны, настроенной на сервере. Размер: 8 байт<br>TIMESTAMP хранит значение равное количеству секунд, прошедших с полуночи 1 января 1970 года по усреднённому времени Гринвича. При получении из базы отображается с учётом часового пояса. Размер: 4 байта"
}
,{
  question: "Для каких числовых типов недопустимо использовать операции сложения/вычитания?",
  answer: "В качестве операндов операций сложения и вычитания нельзя использовать числовой тип BIT."
}
,{
  question: "Какое назначение у операторов PIVOT и UNPIVOT в Transact-SQL?",
  answer: "PIVOT и UNPIVOT являются нестандартными реляционными операторами, которые поддерживаются Transact-SQL.<br>Оператор PIVOT разворачивает возвращающее табличное значение выражение, преобразуя уникальные значения одного столбца выражения в несколько выходных столбцов, а также, в случае необходимости, объединяет оставшиеся повторяющиеся значения столбца и отображает их в выходных данных. Оператор UNPIVOT производит действия, обратные PIVOT, преобразуя столбцы возвращающего табличное значение выражения в значения столбца."
}
,{
  question: "Расскажите об основных функциях ранжирования в Transact-SQL.",
  answer: "Ранжирующие функции - это функции, которые возвращают значение для каждой записи группы в результирующем наборе данных. На практике они могут быть использованы, например, для простой нумерации списка, составления рейтинга или постраничной навигации."
}
,{
  question: "Для чего нужны операторы UNION, INTERSECT, EXCEPT?",
  answer: "Оператор UNION - применяется для объединения результатов двух SQL-запросов в единую таблицу, состоящую из похожих срок. Оба запроса Должны возвращать одинаковое число столбцов и совместимые типы данных в соответствующих столбцах.<br>Оператор INTERSECT - используется для нахождения пересечения двух множеств. Результатом его выполнения будет множество строк, которые присутствуют в обоих множествах.<br>Оператор EXCEPT - используется для нахождения разности двух множеств. Результатом выполнения является множество строк из множества 1, которые отсутствуют в множестве 2. Приоритет выполнения операторов над множествами: INTERSECT -> EXCEPT -> UNION"
}
,{
  question: "Напишите запрос...",
  answer: "CREATE TABLE table (<br>id BIGINT(20) NOT NULL AUTO_INCREMENT,<br>created TIMESTAMP NOT NULL DEFAULT 0,<br>PRIMARY KEY (id)<br>);<br>Требуется написать запрос, который вернет максимальное значение id и значение created для этого id:<br>SELECT id, created FROM table where id = (SELECT MAX(id) FROM table);CREATE TABLE track_downloads (<br>download_id BIGINT(20) NOT NULL AUTO_INCREMENT,<br>track_id INT NOT NULL,<br>user_id BIGINT(20) NOT NULL,<br>download_time TIMESTAMP NOT NULL DEFAULT 0,<br>PRIMARY KEY (download_id)<br>);<br>Напишите SQL-запрос, возвращающий все пары (download_count, user_count), удовлетворяющие следующему условию: user_count — общее ненулевое число пользователей, сделавших ровно download_count скачиваний 19 ноября 2010 года:<br>SELECT DISTINCT download_count, COUNT(*) AS user_count<br>FROM (<br>SELECT COUNT(*) AS download_count<br>FROM track_downloads WHERE download_time='2010-11-19'<br>GROUP BY user_id)<br>AS download_count<br>GROUP BY download_count;"
}
,{
  question: "Что такое DDL?",
  answer: "DDL(Data Definition Language) - Команды определения структуры данных. В состав DDL-группы входят команды, позволяющие определять внутреннюю структуру базы данных. Перед тем, как сохранять данные в БД, необходимо создать в ней таблицы и, возможно, некоторые другие сопутствующие объекты Пример некоторых DDL-команд:CREATE создаёт объект базы данных (саму базу, таблицу, представление, пользователя и так далее),<br>ALTER изменяет объект,<br>DROP удаляет объект;"
}
,{
  question: "Что такое DML?",
  answer: "DML(Data Manipulation Language) - Команды манипулирования данными. DML-группа содержит команды, позволяющие вносить, изменять, удалять и извлекать данные из таблиц. Примеры DML-команд:SELECT выбирает данные, удовлетворяющие заданным условиям,<br>INSERT добавляет новые данные,<br>UPDATE изменяет существующие данные,<br>DELETE удаляет данные;"
}
,{
  question: "Что такое DCL?",
  answer: "DCL(Data Control Language) - Команды управления доступом. DCL-команды управляют доступом пользователей к БД и отдельным объектам:GRANT предоставляет пользователю (группе) разрешения на определённые операции с объектом,<br>REVOKE отзывает ранее выданные разрешения,<br>DENY задаёт запрет, имеющий приоритет над разрешением;"
}
,{
  question: "Что такое TCL?",
  answer: "TCL(Transaction Control Language) - TCL-команды используются для управления изменениями данных, производимыми DML-командами. С их помощью несколько DML-команд могут быть объединены в единое логическое целое, называемое транзакцией. При этом все команды на изменение данных в рамках одной транзакции либо завершаются успешно, либо все могут быть отменены в случае возникновения каких-либо проблем с выполнением любой из них. TCL-команды:COMMIT применяет транзакцию,<br>ROLLBACK откатывает все изменения, сделанные в контексте текущей транзакции,<br>SAVEPOINT делит транзакцию на более мелкие участки."
}
,{
  question: "Какое практическое применение временных таблиц?",
  answer: "Временная таблица - это объект базы данных, который хранится и управляется системой базы данных на временной основе. Они могут быть локальными или глобальными. используется для сохранения результатов вызова хранимой процедуры, уменьшение числа строк при соединениях, агрегирование данных из различных источников или замена курсоров и параметризованных представлений."
}
,{
  question: "Может ли значение в столбце(ах), на который наложено ограничение foreign key, равняться null?",
  answer: "Может, если на данный столбец не наложено ограничение not null, пример: при построении таблицы дерева файловой системы, где столбец foreign key - ссылка на эту же самую таблицу, на кортеж с информацией о родительской директории, тогда для корневой директории файловой системы в столбце родительской директории будет - null."
}
,{
  question: "Что такое агрегатная функция? Приведите примеры агрегатных функций в SQL.",
  answer: "Агрегатная функция - это функция, которая возвращает одиночное значение на основании множества записей. Вот список некоторых агрегатных функций SQL:COUNT(*) - Возвращает количество строк источника записей<br>COUNT - Возвращает количество значений в указанном столбце<br>SUM - Возвращает сумму значений в указанном столбце<br>AVG - Возвращает среднее значение в указанном столбце<br>MIN - Возвращает минимальное значение в указанном столбце<br>MAX - Возвращает максимальное значение в указанном столбце"
}
,{
  question: "Что такое целостность данных? Объясните, что такое ограничения.",
  answer: "Целостность данных - важное свойство SQL. При правильном использовании оно обеспечивает корректность и валидность хранимых данных в любой момент времени. Также, с их помощью можно обнаруживать ошибки в приложениях, которые тяжело найти другими способами. Целостность данных поддерживается с помощью ограничений. В SQL стандарта ANSI есть 4 основных ограничения: PRIMARY KEY, CHECK, UNIQUE и FOREIGN KEY. Они не являются обязательными для таблицы.<br>PRIMARY KEY - набор полей (1 или более), значения которых образуют уникальную комбинацию и используются для однозначной идентификации записи в таблице. Для таблицы может быть создано только одно такое ограничение. Данное ограничение используется для обеспечения целостности сущности, которая описана таблицей.<br>CHECK используется для ограничения множества значений, которые могут быть помещены в данный столбец. Это ограничение используется для обеспечения целостности предметной области, которую описывают таблицы в базе.<br>Ограничение UNIQUE обеспечивает отсутствие дубликатов в столбце или наборе столбцов. Разница между PRIMARY KEY и UNIQUE описана в primary и unique ключи<br>Ограничение FOREIGN KEY защищает от действий, которые могут нарушить связи между таблицами. FOREIGN KEY в одной таблице указывает на PRIMARY KEY в другой. Поэтому данное ограничение нацелено на то, чтобы не было записей FOREIGN KEY, которым не отвечают записи PRIMARY KEY. Таким образом, FOREIGN KEY поддерживает ссылочную целостность данных."
}
,{
  question: "Что такое репликация базы данных?",
  answer: "Репликация — одна из техник масштабирования баз данных. Состоит эта техника в том, что данные с одного сервера базы данных постоянно копируются (реплицируются) на один или несколько других (называемые репликами). Для приложения появляется возможность использовать не один сервер для обработки всех запросов, а несколько. Таким образом появляется возможность распределить нагрузку с одного сервера на несколько.Репликация используется для достижения двух целей:<br>Повышение отказоустойчивости. Если один из серверов выйдет из строя, то остальные продолжат работу.Повышение производительности. Распределение данных по серверам в разных частях страны или мира повышает скорость доступа к данным для местных пользователей.Master-Slave репликация<br>В этом подходе выделяется один основной сервер базы данных, который называется Мастером. На нем происходят все изменения в данных (любые запросы INSERT/UPDATE/DELETE). Слейв сервер постоянно копирует все изменения с Мастера. С приложения на Слейв сервер отправляются запросы чтения данных (запросы SELECT). Таким образом Мастер сервер отвечает за изменения данных, а Слейв за чтение.Master-Master репликация<br>В этой схеме, любой из серверов может использоваться как для чтения так и для записи:"
}
,{
  question: "Что такое шардирование базы данных?",
  answer: "Шардинг (иногда шардирование) — это другая техника масштабирования работы с данными. Суть его в разделении (партиционирование) базы данных на отдельные части так, чтобы каждую из них можно было вынести на отдельный сервер. Этот процесс зависит от структуры Вашей базы данных и выполняется прямо в приложении"
}
,{
  question: "В чём отличие горизонтального от вертикального шардирования?",
  answer: "Вертикальный шардинг — это выделение таблицы или группы таблиц на отдельный сервер. Например, в приложении есть такие таблицы:<br>users — данные пользователей<br>photos — фотографии пользователей<br>albums — альбомы пользователей<br>Таблицу users Вы оставляете на одном сервере, а таблицы photos и albums переносите на другой. В таком случае в приложении Вам необходимо будет использовать соответствующее соединение для работы с каждой таблицейГоризонтальный шардинг — это разделение одной таблицы на разные сервера. Это необходимо использовать для огромных таблиц, которые не умещаются на одном сервере. Разделение таблицы на куски делается по такому принципу:<br>На нескольких серверах создается одна и та же таблица (только структура, без данных).<br>В приложении выбирается условие, по которому будет определяться нужное соединение (например, четные на один сервер, а нечетные — на другой).<br>Перед каждым обращением к таблице происходит выбор нужного соединения.<br>Допустим, наше приложение работает с огромной таблицей, которая хранит фотографии пользователей. Мы подготовили два сервера (обычно они называются шардами) для этой таблицы. Для нечетных пользователей мы будем работать с первыми сервером, а для четных — со вторым. Таким образом, на каждом из серверов будет только часть всех данных о фотках пользователейГоризонтальный шардинг — это очень мощный инструмент масштабирования данных. Но в то же время и очень нетривиальный. Читайте детально об использовании горизонтального шардинга на практике.<br>Не следует применять технику шардинга ко всем таблицам. Правильный подход — это поэтапный процесс разделения растущих таблиц. Следует задумываться о горизонтальном шардинге, когда количество записей в одной таблице переходит за пределы от нескольких десятков миллионов до сотен миллионов.<br>Общий недостаток шардирования<br>Разделение данных по разным машинам делает невозможными локальные транзакции.<br>Чтобы гарантировать атомарность изменений в распределенных системах существуют распределенные транзакции (например, использующие двухфазный коммит). Это довольно сложные штуки. Крайне не рекомендую реализовывать их самостоятельно."
}
,{
  question: "Что такое оконная функция?",
  answer: "Оконная функция в SQL - функция, которая работает с выделенным набором строк (окном, партицией) и выполняет вычисление для этого набора строк в отдельном столбце.Партиции (окна из набора строк) - это набор строк, указанный для оконной функции по одному из столбцов или группе столбцов таблицы. Партиции для каждой оконной функции в запросе могут быть разделены по различным колонкам таблицы."
}
,{
  question: "В чем заключается главное отличие оконных функций от функций агрегации с группировкой?",
  answer: "При использовании агрегирующих функций предложение GROUP BY сокращает количество строк в запросе с помощью их группировки.При использовании оконных функций количество строк в запросе не уменьшается по сравнении с исходной таблицей."
}
,{
  question: "Порядок расчета оконных функций в SQL запросе",
  answer: "SELECT list of columns, window functions<br>FROM table / joint tables / subquery<br>WHERE filtering clause<br>GROUP BY list of columns<br>HAVING aggregation filtering clause<br>ORDER BY list of columns /window functionsСначала выполняется команда выборки таблиц, их объединения и возможные подзапросы под командой FROM.<br>Далее выполняются условия фильтрации WHERE, группировки GROUP BY и возможная фильтрация c HAVING<br>Только потом применяется команда выборки столбцов SELECT и расчет оконных функций под выборкой.<br>После этого идет условие сортировки ORDER BY, где тоже можно указать столбец расчета оконной функции для сортировки.<br>Здесь важно уточнить, что партиции или окна оконных функций создаются после разделения таблицы на группы с помощью команды GROUP BY, если эта команда используется в запросе."
}
,{
  question: "Синтаксис оконных функций",
  answer: "1) Имя оконной функции одного из классов<br>2) Необязательное выражение фильтрации<br>3) Ключевое слово определения оконной ф.<br>4) Определение партиций по колонкам<br>5) Сортировка вычисления оконной функции<br>6) Указание фрейма для партиции1) FUNCTION_NAME(column_name)<br>2) [FILTER (WHERE filter_clause)]<br>3) OVER<br>4) PARTITION BY (column names),<br>5) ORDER BY (column names),<br>6) [frame clause]SELECT<br>Название функции (столбец для вычислений)<br>OVER (<br>PARTITION BY столбец для группировки<br>ORDER BY столбец для сортировки<br>ROWS или RANGE выражение для ограничения строк в пределах группы<br>)"
}
,{
  question: "OVER()",
  answer: "Откроем окно при помощи OVER() и просуммируем столбец «Conversions»:<br>SELECT<br>Date<br>, Medium<br>, Conversions<br>, SUM(Conversions) OVER() AS 'Sum'<br>FROM OrdersМы использовали инструкцию OVER() без предложений. В таком варианте окном будет весь набор данных и никакая сортировка не применяется. Появился новый столбец «Sum» и для каждой строки выводится одно и то же значение 14. Это сквозная сумма всех значений колонки «Conversions»."
}
,{
  question: "PARTITION BY",
  answer: "Теперь применим инструкцию PARTITION BY, которая определяет столбец, по которому будет производиться группировка и является ключевой в разделении набора строк на окна:<br>SELECT<br>Date<br>, Medium<br>, Conversions<br>, SUM(Conversions) OVER(PARTITION BY Date) AS 'Sum'<br>FROM OrdersИнструкция PARTITION BY сгруппировала строки по полю «Date». Теперь для каждой группы рассчитывается своя сумма значений столбца «Conversions»."
}
,{
  question: "ORDER BY",
  answer: "Попробуем отсортировать значения внутри окна при помощи ORDER BY:<br>SELECT<br>Date<br>, Medium<br>, Conversions<br>, SUM(Conversions) OVER(PARTITION BY Date ORDER BY Medium) AS 'Sum'<br>FROM OrdersК предложению PARTITION BY добавилось ORDER BY по полю «Medium». Таким образом мы указали, что хотим видеть сумму не всех значений в окне, а для каждого значения «Conversions» сумму со всеми предыдущими. То есть мы посчитали нарастающий итог."
}
,{
  question: "ROWS или RANGE",
  answer: "Инструкция ROWS позволяет ограничить строки в окне, указывая фиксированное количество строк, предшествующих или следующих за текущей.<br>Инструкция RANGE, в отличие от ROWS, работает не со строками, а с диапазоном строк в инструкции ORDER BY. То есть под одной строкой для RANGE могут пониматься несколько физических строк одинаковых по рангу.<br>Обе инструкции ROWS и RANGE всегда используются вместе с ORDER BY.<br>В выражении для ограничения строк ROWS или RANGE также можно использовать следующие ключевые слова:<br>UNBOUNDED PRECEDING — указывает, что окно начинается с первой строки группы;<br>UNBOUNDED FOLLOWING - с помощью данной инструкции можно указать, что окно заканчивается на последней строке группы;<br>CURRENT ROW - инструкция указывает, что окно начинается или заканчивается на текущей строке;<br>BETWEEN «граница окна» AND «граница окна» — указывает нижнюю и верхнюю границу окна;<br>«Значение» PRECEDING - определяет число строк перед текущей строкой (не допускается в предложении RANGE).;<br>«Значение» FOLLOWING — определяет число строк после текущей строки (не допускается в предложении RANGE).Разберем на примере:<br>SELECT<br>Date<br>, Medium<br>, Conversions<br>, SUM(Conversions) OVER(PARTITION BY Date ORDER BY Conversions ROWS BETWEEN CURRENT ROW AND 1 FOLLOWING) AS 'Sum'<br>FROM Orders"
}
,{
  question: "Виды функций",
  answer: "Оконные функции можно подразделить на следующие группы:<br>Агрегатные функции;<br>Ранжирующие функции;<br>Функции смещения;<br>Аналитические функции.<br>В одной инструкции SELECT с одним предложением FROM можно использовать сразу несколько оконных функций. Давайте подробно разберем каждую группу и пройдемся по основным функциям."
}
,{
  question: "Агрегатные функции",
  answer: "Агрегатные функции - это функции, которые выполняют на наборе данных арифметические вычисления и возвращают итоговое значение.<br>SUM - возвращает сумму значений в столбце;<br>COUNT — вычисляет количество значений в столбце (значения NULL не учитываются);<br>AVG — определяет среднее значение в столбце;<br>MAX — определяет максимальное значение в столбце;<br>MIN — определяет минимальное значение в столбце.<br>Пример использования агрегатных функций с оконной инструкцией OVER:<br>SELECT<br>Date<br>, Medium<br>, Conversions<br>, SUM(Conversions) OVER(PARTITION BY Date) AS 'Sum'<br>, COUNT(Conversions) OVER(PARTITION BY Date) AS 'Count'<br>, AVG(Conversions) OVER(PARTITION BY Date) AS 'Avg'<br>, MAX(Conversions) OVER(PARTITION BY Date) AS 'Max'<br>, MIN(Conversions) OVER(PARTITION BY Date) AS 'Min'<br>FROM Orders"
}
,{
  question: "Ранжирующие функции",
  answer: "Ранжирующие функции - это функции, которые ранжируют значение для каждой строки в окне. Например, их можно использовать для того, чтобы присвоить порядковый номер строке или составить рейтинг.<br>ROW_NUMBER - функция возвращает номер строки и используется для нумерации;<br>RANK — функция возвращает ранг каждой строки. В данном случае значения уже анализируются и, в случае нахождения одинаковых, возвращает одинаковый ранг с пропуском следующего значения;<br>DENSE_RANK — функция возвращает ранг каждой строки. Но в отличие от функции RANK, она для одинаковых значений возвращает ранг, не пропуская следующий;<br>NTILE - это функция, которая позволяет определить к какой группе относится текущая строка. Количество групп задается в скобках.<br>SELECT<br>Date<br>, Medium<br>, Conversions<br>, ROW_NUMBER() OVER(PARTITION BY Date ORDER BY Conversions) AS 'Row_number'<br>, RANK() OVER(PARTITION BY Date ORDER BY Conversions) AS 'Rank'<br>, DENSE_RANK() OVER(PARTITION BY Date ORDER BY Conversions) AS 'Dense_Rank'<br>, NTILE(3) OVER(PARTITION BY Date ORDER BY Conversions) AS 'Ntile'<br>FROM Orders"
}
,{
  question: "Функции смещения",
  answer: "Функции смещения<br>Функции смещения - это функции, которые позволяют перемещаться и обращаться к разным строкам в окне, относительно текущей строки, а также обращаться к значениям в начале или в конце окна.<br>LAG или LEAD - функция LAG обращается к данным из предыдущей строки окна, а LEAD к данным из следующей строки. Функцию можно использовать для того, чтобы сравнивать текущее значение строки с предыдущим или следующим. Имеет три параметра: столбец, значение которого необходимо вернуть, количество строк для смещения (по умолчанию 1), значение, которое необходимо вернуть если после смещения возвращается значение NULL;<br>FIRST_VALUE или LAST_VALUE — с помощью функции можно получить первое и последнее значение в окне. В качестве параметра принимает столбец, значение которого необходимо вернуть.<br>SELECT<br>Date<br>, Medium<br>, Conversions<br>, LAG(Conversions) OVER(PARTITION BY Date ORDER BY Date) AS 'Lag'<br>, LEAD(Conversions) OVER(PARTITION BY Date ORDER BY Date) AS 'Lead'<br>, FIRST_VALUE(Conversions) OVER(PARTITION BY Date ORDER BY Date) AS 'First_Value'<br>, LAST_VALUE(Conversions) OVER(PARTITION BY Date ORDER BY Date) AS 'Last_Value'<br>FROM Orders"
}
,{
  question: "Аналитические функции",
  answer: "Аналитические функции — это функции которые возвращают информацию о распределении данных и используются для статистического анализа.<br>CUME_DIST — вычисляет интегральное распределение (относительное положение) значений в окне;<br>PERCENT_RANK — вычисляет относительный ранг строки в окне;<br>PERCENTILE_CONT — вычисляет процентиль на основе постоянного распределения значения столбца. В качестве параметра принимает процентиль, который необходимо вычислить (в этой статье я рассказываю как посчитать медиану, благодаря этой функции);<br>PERCENTILE_DISC — вычисляет определенный процентиль для отсортированных значений в наборе данных. В качестве параметра принимает процентиль, который необходимо вычислить.Важно! У функций PERCENTILE_CONT и PERCENTILE_DISC, столбец, по которому будет происходить сортировка, указывается с помощью ключевого слова WITHIN GROUP.SELECT<br>Date<br>, Medium<br>, Conversions<br>, CUME_DIST() OVER(PARTITION BY Date ORDER BY Conversions) AS 'Cume_Dist'<br>, PERCENT_RANK() OVER(PARTITION BY Date ORDER BY Conversions) AS 'Percent_Rank'<br>, PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY Conversions) OVER(PARTITION BY Date) AS 'Percentile_Cont'<br>, PERCENTILE_DISC(0.5) WITHIN GROUP (ORDER BY Conversions) OVER(PARTITION BY Date) AS 'Percentile_Disc'<br>FROM Orders"
}
,
    ];

    const questionText = document.getElementById('question-text');
    const answerText = document.getElementById('answer-text');
    const modal = document.getElementById('modal');
    const modalAnswer = document.getElementById('modal-answer');

    function toggleAnswer() {
        const answer = questions[currentQuestionIndex].answer;
        if (answer.length > MAX_ANSWER_LENGTH) {
            showModal(answer);
        } else {
            if (answerText.classList.contains('hidden')) {
                answerText.innerHTML = answer;
                answerText.classList.remove('hidden');
                questionText.classList.add('hidden');
            } else {
                answerText.classList.add('hidden');
                questionText.classList.remove('hidden');
            }
        }
    }

    function showModal(answer) {
        modalAnswer.innerHTML = answer;
        modal.classList.remove('hidden');
    }

    function showQuestion(index) {
        questionText.textContent = questions[index].question;
        answerText.innerHTML = ""; // Скрываем ответ при смене вопроса
        questionText.classList.remove('hidden');
        answerText.classList.add('hidden');
    }

    function nextQuestion() {
        if (currentQuestionIndex < questions.length - 1) {
            currentQuestionIndex++;
            showQuestion(currentQuestionIndex);
        }
    }

    function prevQuestion() {
        if (currentQuestionIndex > 0) {
            currentQuestionIndex--;
            showQuestion(currentQuestionIndex);
        }
    }

    function closeModal() {
        modal.classList.add('hidden');
    }

    showQuestion(currentQuestionIndex);
</script>

</body>
</html>
