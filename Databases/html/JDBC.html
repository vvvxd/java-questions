<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Вопросы по собеседованию</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .question-block {
            cursor: pointer;
            transition: background-color 0.3s ease;
            word-break: break-word;
        }
        .question-block:hover {
            background-color: #f3f4f6;
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen">

<!-- Контейнер с вопросом -->
<div id="question-container" class="bg-white shadow-lg rounded-lg p-6 w-[800px] h-[750px] flex items-center justify-center text-center relative">
    <div id="question-block" class="question-block p-4 border-b w-full h-full flex items-center justify-center text-center relative" onclick="toggleAnswer()">
        <strong class="text-lg block" id="question-text"></strong>
        <div id="answer-text" class="text-gray-700 hidden" onclick="toggleAnswer()"></div>
    </div>
</div>

<!-- Навигация -->
<div class="absolute bottom-10 flex justify-center gap-4">
    <button onclick="prevQuestion()" class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600">Назад</button>
    <button onclick="location.href='main.html'" class="bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600">На главную</button>
    <button onclick="nextQuestion()" class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600">Вперед</button>
</div>

<!-- Модальное окно -->
<div id="modal" class="fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 hidden">
    <div class="bg-white p-6 rounded-lg shadow-lg w-[900px] h-[800px] overflow-y-auto">
        <h2 class="text-lg font-semibold mb-4">Ответ</h2>
        <p id="modal-answer" class="text-gray-700"></p>
        <button onclick="closeModal()" class="mt-4 bg-red-500 text-white px-4 py-2 rounded hover:bg-red-600 w-full">Закрыть</button>
    </div>
</div>

<script>
    let currentQuestionIndex = 0;
    const MAX_ANSWER_LENGTH = 2000; // Максимальная длина ответа для отображения без модального окна

    const questions = [
        {
  question: "Что такое JDBC?",
  answer: "JDBC, Java DataBase Connectivity (соединение с базами данных на Java) — промышленный стандарт взаимодействия Java-приложений с различными СУБД. Реализован в виде пакета java.sql, входящего в состав Java SE.<br>JDBC основан на концепции драйверов, которые позволяют получать соединение с базой данных по специально описанному URL. При загрузке драйвер регистрирует себя в системе и в дальнейшем автоматически вызывается, когда программа требует URL, содержащий протокол, за который этот драйвер отвечает."
}
,{
  question: "В чем заключаются преимущества использования JDBC?",
  answer: "Преимуществами JDBC считают:Лёгкость разработки: разработчик может не знать специфики базы данных, с которой работает;Код практически не меняется, если компания переходит на другую базу данных (количество изменений зависит исключительно от различий между диалектами SQL);Не нужно дополнительно устанавливать клиентскую программу;К любой базе данных можно подсоединиться через легко описываемый URL."
}
,{
  question: "Что из себя представляет JDBC URL?",
  answer: "JDBC URL состоит из:<protocol>: (протокола) - всегда jdbc:.<subprotocol>: (подпротокола) - это имя драйвера или имя механизма соединения с базой данных. Подпротокол может поддерживаться одним или несколькими драйверами. Лежащий на поверхности пример подпротокола - это 'odbc', отведенный для URL, обозначающих имя источника данных ODBC. В случае необходимости использовать сервис имен (т.е. имя базы данных в JDBC URL не будет действительным именем базы данных), то подпротоколом может выступать сервис имен.<subname> (подимени) - это идентификатор базы данных. Значение подимени может менятся в зависимости от подпротокола, и может также иметь под-подимя с синтаксисом, определяемым разработчиком драйвера. Назначение подимени - это предоставление всей информации, необходимой для поиска базы данных. Например, если база данных находится в Интернет, то в состав подимени JDBC URL должен быть включен сетевой адрес, подчиняющийся следующим соглашениям: //<hostname>:<port>/<subsubname.Пример JDBC URL для подключения к MySQL базе данных «Test» расположенной по адресу localhost и ожидающей соединений по порту 3306: jdbc:mysql://localhost:3306/Test"
}
,{
  question: "Из каких частей стоит JDBC?",
  answer: "JDBC состоит из двух частей:JDBC API, который содержит набор классов и интерфейсов, определяющих доступ к базам данных. Эти классы и методы объявлены в двух пакетах - java.sql и javax.sql;JDBC-драйвер, компонент, специфичный для каждой базы данных.JDBC превращает вызовы уровня API в «родные» команды того или иного сервера баз данных"
}
,{
  question: "Перечислите основные классы и интерфейсы JDBC.",
  answer: "java.sql.DriverManager - позволяет загрузить и зарегистрировать необходимый JDBC-драйвер, а затем получить соединение с базой данных.javax.sql.DataSource - решает те же задачи, что и DriverManager, но более удобным и универсальным образом. Существуют также javax.sql.ConnectionPoolDataSource и javax.sq1.XADataSource задача которых - обеспечение поддержки пула соединений.java.sql.Connection - обеспечивает формирование запросов к источнику данных и управление транзакциями. Также предусмотрены интерфейсы javax.sql.PooledConnection и javax.sql.XAConnection.java.sql.Statement , java.sql.PreparedStatement и java.sql.CallableStatement - эти интерфейсы позволяют отправить запрос к источнику данных.java.sql.ResultSet - объявляет методы, которые позволяют перемещаться по набору данных и считывать значения отдельных полей в текущей записи.java.sql.ResultSetMetaData - позволяет получить информацию о структуре набора данных.java.sql.DatabaseMetaData - позволяет получить информацию о структуре источника данных."
}
,{
  question: "Перечислите основные типы данных используемые в JDBC. Как они связаны с типами Java?",
  answer: "JDBC Type Java Object Type<br>CHAR String<br>VARCHAR String<br>LONGVARCHAR String<br>NUMERIC java.math.BigDecimal<br>DECIMAL java.math.BigDecimal<br>BIT Boolean<br>TINYINT Integer<br>SMALLINT Integer<br>INTEGER Integer<br>BIGINT Long<br>REAL Float<br>FLOAT Double<br>DOUBLE Double<br>BINARY byte[]<br>VARBINARY byte[]<br>LONGVARBINARY byte[]<br>DATE java.sql.Date<br>TIME java.sql.Time<br>TIMESTAMP java.sql.Timestamp<br>CLOB Clob<br>BLOB Blob<br>ARRAY Array<br>STRUCT Struct<br>REF Ref<br>DISTINCT сопоставление базового типа<br>JAVA_OBJECT базовый класс Java"
}
,{
  question: "пишите основные этапы работы с базой данных при использовании JDBC.",
  answer: "Регистрация драйверов;<br>Установление соединения с базой данных;<br>Создание запроса(ов) к базе данных;<br>Выполнение запроса(ов) к базе данных;<br>Обработка результата(ов);<br>Закрытие соединения с базой данных."
}
,{
  question: "Как зарегистрировать драйвер JDBC?",
  answer: "Регистрацию драйвера можно осуществить несколькими способами:<br>java.sql.DriverManager.registerDriver(%объект класса драйвера%).<br>Class.forName(«полное имя класса драйвера»).newInstance().<br>Class.forName(«полное имя класса драйвера»);"
}
,{
  question: "Как установить соединение с базой данных?",
  answer: "Для установки соединения с базой данных используется статический вызов java.sql.DriverManager.getConnection(...) .<br>В качестве параметра может передаваться:URL базы данных<br>static Connection getConnection(String url)URL базы данных и набор свойств для инициализации<br>static Connection getConnection(String url, Properties info)URL базы данных, имя пользователя и пароль<br>static Connection getConnection(String url, String user, String password)В результате вызова будет установлено соединение с базой данных и создан объект класса java.sql.Connection - своеобразная «сессия», внутри контекста которой и будет происходить дальнейшая работа с базой данных."
}
,{
  question: "Какие уровни изоляции транзакций поддерживаются в JDBC?",
  answer: "Уровень изолированности транзакций — значение, определяющее уровень, при котором в транзакции допускаются несогласованные данные, то есть степень изолированности одной транзакции от другой. Более высокий уровень изолированности повышает точность данных, но при этом может снижаться количество параллельно выполняемых транзакций. С другой стороны, более низкий уровень изолированности позволяет выполнять больше параллельных транзакций, но снижает точность данных.Во время использования транзакций, для обеспечения целостности данных, СУБД использует блокировки, чтобы заблокировать доступ других обращений к данным, участвующим в транзакции. Такие блокировки необходимы, чтобы предотвратить:«грязное» чтение (dirty read) — чтение данных, добавленных или изменённых транзакцией, которая впоследствии не подтвердится (откатится);неповторяющееся чтение (non-repeatable read) — при повторном чтении в рамках одной транзакции ранее прочитанные данные оказываются изменёнными;фантомное чтение (phantom reads) — ситуация, когда при повторном чтении в рамках одной транзакции одна и та же выборка дает разные множества строк.Уровни изоляции транзакций определены в виде констант интерфейса java.sql.Connection:TRANSACTION_NONE - драйвер не поддерживает транзакции;TRANSACTION_READ_UNCOMMITTED - позволяет транзакциям видеть несохраненные изменения данных: разрешает грязное, непроверяющееся и фантомное чтения;TRANSACTION_READ_COMMITTED - любое изменение, сделанное в транзакции, не видно вне неё, пока она не сохранена: предотвращает грязное чтение, но разрешает непроверяющееся и фантомное;TRANSACTION_REPEATABLE_READ - запрещает грязное и непроверяющееся, фантомное чтение разрешено;TRANSACTION_SERIALIZABLE - грязное, непроверяющееся и фантомное чтения запрещены.NB! Сервер базы данных может не поддерживать все уровни изоляции. Интерфейс java.sql.DatabaseMetaData предоставляет информацию об уровнях изолированности транзакций, которые поддерживаются данной СУБД.Уровень изоляции транзакции используемый СУБД можно задать с помощью метода setTransactionIsolation() объекта java.sql.Connection. Получить информацию о применяемом уровне изоляции поможет метод getTransactionIsolation()."
}
,{
  question: "При помощи чего формируются запросы к базе данных?",
  answer: "Для выполнения запросов к базе данных в Java используются три интерфейса:<br>java.sql.Statement - для операторов SQL без параметров;<br>java.sql.PreparedStatement - для операторов SQL с параметрами и часто выполняемых операторов;<br>java.sql.CallableStatement - для исполнения хранимых в базе процедур.Объекты-носители интерфейсов создаются при помощи методов объекта java.sql.Connection:<br>java.sql.createStatement() возвращает объект Statement;<br>java.sql.prepareStatement() возвращает объект PreparedStatement;<br>java.sql.prepareCall() возвращает объект CallableStatement;"
}
,{
  question: "Чем отличается Statement от PreparedStatement?",
  answer: "Statement: используется для простых случаев запроса без параметров.PreparedStatement: предварительно компилирует запрос, который может содержать входные параметры и выполняться несколько раз с разным набором этих параметров.Перед выполнением СУБД разбирает каждый запрос, оптимизирует его и создает «план» (query plan) его выполнения. Если один и тот же запрос выполняется несколько раз, то СУБД в состоянии кэшировать план его выполнения и не производить этапов разборки и оптимизации повторно. Благодаря этому запрос выполняется быстрее.<br>Суммируя: PreparedStatement выгодно отличается от Statement тем, что при повторном использовании с одним или несколькими наборами параметров позволяет получить преимущества заранее прекомпилированного и кэшированного запроса, помогая при этом избежать SQL Injection."
}
,{
  question: "Как осуществляется запрос к базе данных и обработка результатов?",
  answer: "Выполнение запросов осуществляется при помощи вызова методов объекта, реализующего интерфейс java.sql.Statement:executeQuery() - для запросов, результатом которых является один набор значений, например запросов SELECT. Результатом выполнения является объект класса java.sql.ResultSet;executeUpdate() - для выполнения операторов INSERT, UPDATE или DELETE, а также для операторов DDL (Data Definition Language). Метод возвращает целое число, показывающее, сколько записей было модифицировано;execute() - исполняет SQL-команды, которые могут возвращать различные результаты. Например, может использоваться для операции CREATE TABLE. Возвращает true, если первый результат содержит ResultSet и false, если первый результат - это количество модифицированных записей или результат отсутствует. Чтобы получить первый результат необходимо вызвать метод getResultSet() или getUpdateCount(). Остальные результаты доступны через вызов getMoreResults(), который при необходимости может быть произведён многократно.Объект с интерфейсом java.sql.ResultSet хранит в себе результат запроса к базе данных - некий набор данных, внутри которого есть курсор, указывающий на один из элементов набора данных - текущую запись.<br>Используя курсор можно перемещаться по набору данных при помощи метода next().NB! Сразу после получения набора данных его курсор находится перед первой записью и чтобы сделать её текущей необходимо вызвать метод next().Содержание полей текущей записи доступно через вызовы методов getInt(), getFloat(), getString(), getDate() и им подобных."
}
,{
  question: "Как вызвать хранимую процедуру?",
  answer: "Хранимые процедуры - это именованный набор операторов SQL хранящийся на сервере. Такую процедуру можно вызвать из Java-класса с помощью вызова методов объекта реализующего интерфейс java.sql.Statement.Выбор объекта зависит от характеристик хранимой процедуры:без параметров → Statementс входными параметрами → PreparedStatementс входными и выходными параметрами → CallableStatementЕсли неизвестно, как была определена хранимая процедура, для получения информации о хранимой процедуре (например, имен и типов параметров) можно использовать методы java.sql.DatabaseMetaData позволяющие получить информацию о структуре источника данных."
}
,{
  question: "Как закрыть соединение с базой данных?",
  answer: "Соединение с базой данной закрывается вызовом метода close() у соответствующего объекта java.sql.Connection или посредством использования механизма try-with-resources при создании такого объекта, появившегося в Java 7."
}
,{
  question: "Как установить NULL значения в JDBC PreparedStatement?",
  answer: "Используя метод setNull() для установки null переменной в качестве параметра. Этот метод принимает индекс и SQL тип в качестве аргументов: s.setNull(10, java.sql.Types.INTEGER);"
}
,{
  question: "Как используется метод getGeneratedKeys() в Statement?",
  answer: "Если в таблице используется автоматическая генерация ключей, то для их получения используется метод Statement getGeneratedKeys(), который вернет сгенерированный ключ."
}
,{
  question: "Какие преимущества в использовании PreparedStatement над Statement?",
  answer: "PreparedStatement позволяет предотвратить атаки типа SQL injection, т.к. он автоматически экранирует специальные символы.<br>PreparedStatement позволяет использовать динамические запросы с внедрением параметров.<br>PreparedStatement быстрее Statement. Это особенно заметно при частом использовании PreparedStatement или при использовании для вызова группы запросов.<br>PreparedStatement позволяет писать объектно ориентированный код с использованием сеттеров\геттеров. В то время при использовании Statement необходимо использовать конкатенацию строк для создания запроса. Для больших запросов конкатенация выглядит, как минимум, большой, а так же несет в себе большой риск ошибки в запросе."
}
,{
  question: "Какие есть ограничения PreparedStatement и как их преодолеть?",
  answer: "В PreparedStatement нельзя использовать напрямую запросы с IN (входными) параметрами. Есть некоторые обходные пути:<br>Выполнить Single Queries - низкая производительность и вообще не рекомендуется так делать.<br>Использовать Stored Procedure (хранимые процедуры) - являются специфичными для конкретной базы данных и следовательно плохи для приложений с возможностью подключения к различным БД.<br>Создание PreparedStatement Query динамически - это хорошее решение, но с потерей кэширования PreparedStatement.<br>Использование NULL в PreparedStatement Query - хорошее решение, если вы знаете максимальное число переменных IN. Можно расширить до использования неограниченного кол-во параметров с помощью разбиения на части."
}
,{
  question: "Что такое JDBC ResultSet?",
  answer: "JDBC ResultSet - интерфейс, объект которого создается в результате запроса к базе данных. Его можно представить в виде таблицы данных, которая была сформирована в ответ на запрос.Объект ResultSet поддерживает курсор, который указывает на текущую строку данных. При инициализации курсор устанавливается до первой строки. Для движение по строкам используется метод next(). При наличии строк после текущей позиции, метод next() возвращает true, что можно использовать для итерации по таблице полученных результатов.<br>По умолчанию объект ResultSet не модифицируемый и поддерживает курсор, который способен только к движение вперед. Для обхода такого ограничения можно использовать следующую конструкцию, которая даст возможность двунаправленного движения по таблице, а так же возможности обновления:Statement stmt = con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,<br>ResultSet.CONCUR_UPDATABLE);Объект ResultSet автоматически закрывается при закрытии объекта, который его сгенерировал. Так же закрытие произойдет при повторном выполнении запроса или возврату результата из другого набора результатов.<br>Для использования геттера ResultSet можно использовать имя колонки или индекс, который начинается с 1."
}
,{
  question: "Какие существуют различные типы JDBC ResultSet?",
  answer: "При создании Statement можно задать различные типы получаемого ResultSet.<br>Три типа объектов ResultSet:<br>ResultSet.TYPE_FORWARD_ONLY: тип по умолчанию. Поддерживает движение курсора только в прямом направлении.<br>ResultSet.TYPE_SCROLL_INSENSITIVE: Двунаправленный курсор. Объект не чувствителен к изменениям, которые произошли с таблицей после получения результата.<br>ResultSet.TYPE_SCROLL_SENSITIVE: Двунаправленный курсор. Объект чувствителен к изменениям, которые произошли с базой данных после создания объекта ResultSet.<br>Два типа потокобезопасных объектов ResultSet:<br>ResultSet.CONCUR_READ_ONLY: Поддерживает только чтение (read only). Применяется по умолчанию.<br>ResultSet.CONCUR_UPDATABLE: Поддерживает метод ResultSet update для обновления строк в таблице данных."
}
,{
  question: "Как используются методы setFetchSize() и SetMaxRows() в Statement?",
  answer: "Для ограничения количества строк, которые может вернуть запрос, применяется метод setMaxRows(int i). Конечно, этот результат можно получить используя SQL запрос (например для MySQL существует команда LIMIT).<br>Для понимания метода setFetchSize() необходимо разобраться с работой Statement и ResultSet. Когда выполняется запрос к базе данных, результат обрабатывается и сохраняется в кэше базы данных и возвращается в виде ResultSet. ResultSet является курсором, который ссылается на результат в базе данных. Теперь допустим мы имеем запрос, который возвращает 100 строк и мы установили setFetchSize(10). Теперь для каждого обращения к базе данных выделено только 10 строк и понадобится 10 запросов, чтобы получить все данные. Выбор оптимального количества fetchSize() может улучшить производительность выполнения большого кол-ва обращений к каждой строке и в случае большого количества строк в выходном результате.<br>Значение fetchSize можно указать внутри объекта Statement, но оно может быть переопределено в объекте ResultSet с помощью setFetchSize()."
}
,{
  question: "Что такое JDBC Batch Processing и какие его преимущества?",
  answer: "Бывает необходимо выполнить сразу группу похожих запросов, например при загрузке данных из CSV файлов реляционной базы данных. Это можно сделать просто используя Statement или PreparedStatement для пошагового выполнения этих запросов. В JDBC API существует другая возможность, которая предоставляет возможность выполнить группу запросов за один раз. Выполнение такого рода задачи происходит с помощью JDBC API Batch Processing.<br>JDBC API поддерживает пакетную обработку с помощью методов addBatch() и executeBatch() у Statement и PreparedStatement. К преимуществам такого подхода относится более быстрая работа, т.к. вызовов к базе данных может быть существенно меньше."
}
,{
  question: "Что такое JDBC Transaction Management и зачем он нужен?",
  answer: "По умолчанию, при создании подключения к базе данных будет выбран auto-commit mode. Это означает, что при каждом выполнении запроса он будет подтвержден автоматически по завершению. Каждый SQL запрос является транзакционным и выполняя какие-либо DML или DDL запросы по их завершению изменения будут приняты (сохранены) базой данных. Если у нас есть необходимость отказываться от сохранения выполнения какого-либо запроса (или групп запросов) в случае, если что-то пошло не так, то мы можем воспользоваться поддержкой транзакций в JDBC API.<br>С помощью метода setAutoCommit(boolean flag) можно отключить авто коммит в конкретном соединении. Следует отметить, что при отключении auto-commit не одно изменение не будет сохранено в базе данных до вызова метода commit() и за этим необходимо следить. Сервер базы данных будет блокировать необходимую часть базы данных до подтверждения транзакции, а так как это ресурсоёмкая задача, то подтверждать транзакцию необходимо сразу после выполнения задачи."
}
,{
  question: "Как откатить JDBC транзакцию?",
  answer: "Для этого предусмотрен метод объекта Connection rollback(), который откатывает транзакцию. Будут отменены все изменения в транзакции и отменен lock базы данных от этого объекта Connection."
}
,{
  question: "Что такое JDBC Savepoint и как он используется?",
  answer: "JDBC Savepoint позволяет создавать 'чекпоинты' в транзакции с помощью которых мы можем откатить не всю транзакцию целиком, а только часть до точки сохранения. Любая точка сохранения автоматически освобождается и становится недоступной после подтверждения транзакции или её роллбека. Откат к точке сохранения делает все последующие сейвы недоступными и к ним уже нельзя будет вернуться."
}
,{
  question: "Расскажите о JDBC DataSource. Какие преимущества он дает?",
  answer: "JDBC DataSource является интерфейсом пакета javax.sql и является более продвинутым в сравнении с DriverManager для подключения к базе данных. Мы можем использовать DataSource для создания подключения к базе данных и реализацию класса драйвера, которая будет выполнять всю работу по поддержанию соединения. В дополнение к соединению через Database, DataSource предоставляет следующие дополнительные возможности:<br>Кэширование PreparedStatement для ускорения обработки запросов<br>Настройки Connection timeout<br>Возможности логирования<br>Порог максимального размера ResultSet<br>Поддержка Connection Pooling в контейнере сервлетов, использующий поддержку JNDI."
}
,{
  question: "Что вы знаете о JDBC RowSet? Какие существуют различные типы RowSet?",
  answer: "JDBC RowSet содержит табличные данные в более гибком формате по сравнению с ResultSet. Все объекты RowSet являются производными из ResultSet, так что они имеют все возможности ResultSet с некоторыми дополнительными функциями. RowSet интерфейс определяется в javax.sql пакета. Можно выделить следующие дополнительные функции, предоставляемые RowSet:<br>Функции похожие на Java Beans со свойствами и get\set методами для работы с ними. RowSet использует модель событий JavaBeans. В результате можно посылать уведомления любого зарегистрированного компонента для таких событий, например, движение курсора, обновления / вставка / удаление из строки и изменять содержимое RowSet.<br>Объекты RowSet поддерживают скроллинг по данным (scrollable), а так же являются обновляемыми по умолчанию. Так что если СУБД не поддерживает скроллинг или обновляемый ResultSet, мы можем использовать RowSet, чтобы получить эти функции.<br>RowSet можно разделить на два типа:<br>Connected RowSet Objects - эти объекты подключаются к БД и очень похожи на объекты ResultSet. JDBC API предоставляет только одно подключение объекта RowSet - javax.sql.rowset.JdbcRowSet и это является стандартной реализации класса com.sun.rowset.JdbcRowSetImpl.<br>Disconnected RowSet Objects - эти объекты RowSet не требуют подключения к базе данных. Они более легковесные и могут быть сериализованы. Такие объекты хорошо подходят для передачи данных по сети. Существуют четыре реализации такого типа объектов (disconnected RowSet objects).<br>Кратко рассмотрим четыре реализации Disconnected RowSet Objects:<br>CachedRowSet - объекты могут получить соединение и выполнить запрос, считать данные ResultSet для заполнения данных RowSet. Мы можем управлять и обновлять данные на время отключения от БД и записать измененные данные при очередном подключении.<br>WebRowSet получены из CachedRowSet - такие объекты могут читать и записывать XML документы.<br>JoinRowSet получены из WebRowSet - могут образовывать SQL JOIN без подключения к источнику данных.<br>FilteredRowSet получены из WebRowSet - поддержка применения критериев фильтрации, поэтому видны только выбранные (полученные) данные."
}
,{
  question: "В чем разница между ResultSet и RowSet?",
  answer: "Объекты RowSet являются производными из ResultSet, так что они имеют все возможности ResultSet с некоторыми дополнительными функциями. Одним из существенных преимуществ является возможность работы с данными без соединения с базой, а так же их легковесность и возможности пересылки данных объектов по сети.<br>Следует ли использовать ResultSet или RowSet зависит от ваших требований. ResultSet, возможно, подойдет к длительным подключениям, в то время как RowSet будет лучшим выбором для подключений к базам данных с возможностью дисконекта и обработки полученных данных."
}
,{
  question: "Приведите пример наиболее распространенных исключений в JDBC.",
  answer: "Некоторые из наиболее распространенных исключений JDBC:<br>java.sql.SQLException - это базовый класс для исключений JDBC.<br>java.sql.BatchUpdateException - возникает при исключительных ситуациях пакетной обработки запросов. Может зависеть от типа драйвера JDBC, который может выбросить взамен базовый SQLException.<br>java.sql.SQLWarning - для предупреждающих сообщений различных SQL операций.<br>java.sql.DataTruncation - когда значения данных неожиданно усекаются по причинам, не зависящим от превышения MaxFieldSize."
}
,{
  question: "Расскажите о типах данных CLOB и BLOB в JDBC.",
  answer: "Character Large OBjects (CLOBs) - тип данных (внутренний символьный объект), используемый для хранения больших объектов. При выборе значения любого LOB-типа посредством оператора SELECT возвращается указатель, а не само значение; кроме того, типы LOB могут быть и внешними. Этот тип данных является подходящим для хранения текстовой информации, которая может выходить за пределы обычного типа данных VARCHAR (верхний предел 32 Кбайт).Внутренний большой двоичный объект (BLOB) - двоичный объект большого размера, который может содержать переменное количество данных. Этот тип данных может хранить данные объемом более VARBINARY (32K предел). Тип данных, предназначенный, в первую очередь, для хранения изображений, аудио и видео, а также компилированного программного кода."
}
,{
  question: "Что вы знаете о 'грязном чтении' (dirty read) в JDBC? Какой уровень изоляции предотвращает этот тип чтения?",
  answer: "Dirty Read можно предотвратить, используя следующие уровни изоляции: TRANSACTION_READ_COMMITTED, TRANSACTION_REPEATABLE_READ и TRANSACTION_SERIALIZABLE."
}
,{
  question: "Какие есть две фазы commit?",
  answer: "Когда мы работаем в распределенных системах, где участвуют несколько баз данных, мы должны использовать протокол с 2 фазами фиксации. 2 фазовый протокол фиксации является атомарным протоколом для распределенных систем. На первом этапе, менеджер транзакций передает commit-request всем ресурсам транзакции. Если все ресурсы транзакции ответили ОК, то менеджер транзакций фиксирует изменения транзакций для всех ресурсов. Если какой-либо из ресурсов транзакций уведомляет об отмене, то менеджер транзакций может откатить все изменения транзакций."
}
,{
  question: "Приведите пример различных типов блокировки в JDBC.",
  answer: "На более широком уровне есть два типа механизма блокировки для предотвращения повреждения данных из-за одновременной работы с данными несколькими пользователями. По логике реализации различают два вида блокировок.<br>Оптимистическая блокировка - не ограничивает модификацию обрабатываемых данных сторонними сессиями, однако перед началом предполагаемой модификации запрашивает значение некоторого выделенного атрибута каждой из строк данных (обычно используется наименование VERSION и целочисленный тип с инициальным значением 0). Перед записью модификаций в базу данных перепроверяется значение выделенного атрибута, и если оно изменилось, то транзакция откатывается или применяются различные схемы разрешения коллизий. Если значение выделенного атрибута не изменилось — производится фиксация модификаций с одновременным изменением значения выделенного атрибута (например, инкрементом) для сигнализации другим сессиям о том, что данные изменились.Пессимистическая блокировка - накладывается перед предполагаемой модификацией данных на все строки, которые такая модификация предположительно затрагивает. Всё время действия такой блокировки исключена модификация данных из сторонних сессий, данные из блокированных строк доступны согласно уровню изолированности транзакции. По завершению предполагаемой модификации гарантируется непротиворечивая запись результатов."
}
,{
  question: "Какая разница между java.util.Date и java.sql.Date?",
  answer: "java.util.Date содержит информацию о дате и времени, тогда как java.sql.Date содержит информацию только о дате, но не имеет информации о времени. Если необходимо сохранить информацию о времени в базе данных, то желательно использовать поля Timestamp или DateTime.Java.util.Date - основной универсальный объект. В нем просто сохраняется дата (как long).<br>java.sql.Date расширяет java.util.Date и добавляет следующую функциональность:<br>1) toString выводит дату в качестве 'yyyy-mm-dd', а не как у конкретного языкового стандарта строки (локали).<br>2) Добавлен метод valueOf для чтения строк формата 'yyyy-mm-dd' и дальнейшего разбора ее в объект sql.Date."
}
,{
  question: "Что вы можете рассказать о фантомном чтении? Какой уровень изоляции его предотвращает?",
  answer: "Phantom read можно предотвратить только на уровне изоляции - TRANSACTION_SERIALIZABLE."
}
,{
  question: "Best Practices в JDBC.",
  answer: "Всегда закрывайте ресурсы базы данных сразу после работы с ними. Connection, Statement, ResultSet и другие JDBC объекты имеют метод close(), который позволяет закрыть их.<br>Всегда явно закрывайте результирующий набор ResultSet, Statement и Connection в коде, потому что если вы используете пул соединений, то соединение может быть возвращено в пул, оставляя открытые result sets и statement objects и будет происходить утечка.<br>Закрывайте ресурсы в конце finally блока, чтобы убедиться, что они закрыты даже в случае возникновения исключения.<br>Используйте пакетную обработку (batch processing) для повторяющихся запросов.<br>Всегда используйте PreparedStatement вместо Statement, чтобы избежать SQL Injection и получить преимущества заранее прекомпилированного и кэшированного запроса PreparedStatement.<br>Если вы извлекаете большие массивы данных в result set, то заранее установите оптимальное значение fetchSize, что поможет получить лучшую производительность.<br>Сервер базы данных может не поддерживать все уровни изоляции, так что проверьте их заранее.<br>Более строгие уровни изоляции могут привести к снижению производительности, поэтому убедитесь, что вы используете оптимальный набор уровней изоляции для ваших соединений с базой данных.<br>Если вы создаете подключения к базе данных из веб-приложения, попробуйте использовать ресурсы JDBC DataSource с помощью применения контекста JNDI для возможности повторного использования соединений.<br>Попробуйте использовать отключенный (disconnected) RowSet, когда вам нужно работать с ResultSet в течение длительного времени."
}
,
    ];

    const questionText = document.getElementById('question-text');
    const answerText = document.getElementById('answer-text');
    const modal = document.getElementById('modal');
    const modalAnswer = document.getElementById('modal-answer');

    function toggleAnswer() {
        const answer = questions[currentQuestionIndex].answer;
        if (answer.length > MAX_ANSWER_LENGTH) {
            showModal(answer);
        } else {
            if (answerText.classList.contains('hidden')) {
                answerText.innerHTML = answer;
                answerText.classList.remove('hidden');
                questionText.classList.add('hidden');
            } else {
                answerText.classList.add('hidden');
                questionText.classList.remove('hidden');
            }
        }
    }

    function showModal(answer) {
        modalAnswer.innerHTML = answer;
        modal.classList.remove('hidden');
    }

    function showQuestion(index) {
        questionText.textContent = questions[index].question;
        answerText.innerHTML = ""; // Скрываем ответ при смене вопроса
        questionText.classList.remove('hidden');
        answerText.classList.add('hidden');
    }

    function nextQuestion() {
        if (currentQuestionIndex < questions.length - 1) {
            currentQuestionIndex++;
            showQuestion(currentQuestionIndex);
        }
    }

    function prevQuestion() {
        if (currentQuestionIndex > 0) {
            currentQuestionIndex--;
            showQuestion(currentQuestionIndex);
        }
    }

    function closeModal() {
        modal.classList.add('hidden');
    }

    showQuestion(currentQuestionIndex);
</script>

</body>
</html>
