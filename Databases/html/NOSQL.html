<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Вопросы по собеседованию</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .question-block {
            cursor: pointer;
            transition: background-color 0.3s ease;
            word-break: break-word;
        }
        .question-block:hover {
            background-color: #f3f4f6;
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen">

<!-- Контейнер с вопросом -->
<div id="question-container" class="bg-white shadow-lg rounded-lg p-6 w-[800px] h-[750px] flex items-center justify-center text-center relative">
    <div id="question-block" class="question-block p-4 border-b w-full h-full flex items-center justify-center text-center relative" onclick="toggleAnswer()">
        <strong class="text-lg block" id="question-text"></strong>
        <div id="answer-text" class="text-gray-700 hidden" onclick="toggleAnswer()"></div>
    </div>
</div>

<!-- Навигация -->
<div class="absolute bottom-10 flex justify-center gap-4">
    <button onclick="prevQuestion()" class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600">Назад</button>
    <button onclick="location.href='main.html'" class="bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600">На главную</button>
    <button onclick="nextQuestion()" class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600">Вперед</button>
</div>

<!-- Модальное окно -->
<div id="modal" class="fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 hidden">
    <div class="bg-white p-6 rounded-lg shadow-lg w-[900px] h-[800px] overflow-y-auto">
        <h2 class="text-lg font-semibold mb-4">Ответ</h2>
        <p id="modal-answer" class="text-gray-700"></p>
        <button onclick="closeModal()" class="mt-4 bg-red-500 text-white px-4 py-2 rounded hover:bg-red-600 w-full">Закрыть</button>
    </div>
</div>

<script>
    let currentQuestionIndex = 0;
    const MAX_ANSWER_LENGTH = 2000; // Максимальная длина ответа для отображения без модального окна

    const questions = [
        {
  question: "Определение NoSQL",
  answer: "Термин NoSQL обозначает нереляционные типы баз данных, которые хранят данные в формате, отличном от реляционных таблиц. Однако базы данных NoSQL можно запрашивать с помощью API-интерфейсов идиоматических языков, языков декларативных структурированных запросов и языков примеров запросов — вот почему их также называют «не только SQL» базами данных."
}
,{
  question: "Для чего используется база данных NoSQL?",
  answer: "Базы данных NoSQL широко используются в веб-приложениях реального времени и больших данных, поскольку их основные преимущества — это высокая масштабируемость и высокая доступность.Базы данных NoSQL предпочитают использовать разработчики, так как они естественным образом вписываются в парадигму гибкой разработки благодаря своей быстрой адаптации к меняющимся требованиям. Хранить данные в базах данных NoSQL легче и понятнее аналогично тому, как данные используются приложениями, а хранить или извлекать данные с использованием API-интерфейсов в стиле NoSQL можно без большого числа преобразований. Более того, базы данных NoSQL могут в полной мере использовать преимущества облака, обеспечивая нулевое время простоя."
}
,{
  question: "Типы баз данных NoSQL",
  answer: "Четыре основных типа баз данных NoSQLКлюч-значение (Key-value) - наиболее простой вариант хранилища данных, использующий ключ для доступа к значению в рамках большой хэш-таблицы. Такие СУБД применяются для хранения изображений, создания специализированных файловых систем, в качестве кэшей для объектов, а также в масштабируемых Big Data системах, включая игровые и рекламные приложения, а также проекты интернета вещей (Internet of Things, IoT), в т.ч. индустриального (Industrial IoT, IIoT). Наиболее известными представителями нереляционных СУБД типа key-value считаются Oracle NoSQL Database, Berkeley DB, MemcacheDB, Redis, Riak, Amazon DynamoDB, которые поддерживают высокую разделяемость, обеспечивая беспрецедентное горизонтальное масштабирование, недостижимое при использовании других типов БД.Документно-ориентированное хранилище, в котором данные, представленные парами ключ-значение, сжимаются в виде полуструктурированного документа из тегированных элементов, подобно JSON, XML, BSON и другим подобным форматам. Такая модель хорошо подходит для каталогов, пользовательские профилей и систем управления контентом, где каждый документ уникален и изменяется со временем. Поэтому чаще всего документные NoSQL-СУБД используются в CMS-системах, издательском деле и документальном поиске. Самые яркие примеры документно-ориентированных нереляционных баз данных - это CouchDB, Couchbase, MongoDB, eXist, Berkeley DB XML.Колоночное хранилище, которое хранит информацию в виде разреженной матрицы, строки и столбцы которой используются как ключи. В мире Big Data к колоночным хранилищам относятся базы типа «семейство столбцов» (Column Family). В таких системах сами значения хранятся в столбцах (колонках), представленных в отдельных файлах. Благодаря такой модели данных можно хранить большое количество атрибутов в сжатом виде, что ускоряет выполнение запросов к базе, особенно операции поиска и агрегации данных. Наличие временных меток (timestamp) позволяет использовать такие СУБД для организации счётчиков, регистрации и обработки событий, связанных со временем: системы биржевой аналитики, IoT/IIoT-приложения, систему управления содержимым и т.д. Самой известной колоночной базой данных является Google Big Table, а также основанные на ней Apache HBase и Cassandra. Также к этому типу относятся менее популярные ScyllaDB, Apache Accumulo и Hypertable.Графовое хранилище представляют собой сетевую базу, которая использует узлы и рёбра для отображения и хранения данных. Поскольку рёбра графа являются хранимыми, его обход не требует дополнительных вычислений (как соединение в SQL). При этом для нахождения начальной вершины обхода необходимы индексы. Обычно графовые СУБД поддерживают ACID-требования и специализированные языки запросов (Gremlin, Cypher, SPARQL, GraphQL и т.д.). Такие СУБД используются в задачах, ориентированных на связи: социальные сети, выявление мошенничества, маршруты общественного транспорта, дорожные карты, сетевые топологии. Примеры графовых баз: InfoGrid, Neo4j, Amazon Neptune, OrientDB, AllegroGraph, Blazegraph, InfiniteGraph, FlockDB, Titan, ArangoDB. О том, как проанализировать граф в Neo4j средствами языка запросов Cypher, читайте в нашей отдельной статье."
}
,{
  question: "Чем хороши и плохи нереляционные базы данных: главные достоинства и недостатки",
  answer: "По сравнению с классическими SQL-базами, нереляционные СУБД обладают следующими преимуществами:линейная масштабируемость - добавление новых узлов в кластер увеличивает общую производительность системы;гибкость, позволяющая оперировать полуструктирированные данные, реализуя, в. т.ч. полнотекстовый поиск по базе;возможность работать с разными представлениями информации, в т.ч. без задания схемы данных;высокая доступность за счет репликации данных и других механизмов отказоустойчивости, в частности, шаринга - автоматического разделения данных по разным узлам сети, когда каждый сервер кластера отвечает только за определенный набор информации, обрабатывая запросы на его чтение и запись. Это увеличивает скорость обработки данных и пропускную способность приложения.производительность за счет оптимизации для конкретных видов моделей данных (документной, графовой, колоночной или «ключ‑значение») и шаблонов доступа;широкие функциональные возможности - собственные SQL-подобные языки запросов, RESTful-интерфейсы, API и сложные типы данных, например, map, list и struct, позволяющие обрабатывать сразу множество значений.Обратной стороной вышеуказанных достоинств являются следующие недостатки:ограниченная емкость встроенного языка запросов. Например, HBase предоставляет всего 4 функции работы с данными (Put, Get, Scan, Delete), в Cassandra отсутствуют операции Insert и Join, несмотря на наличие SQL-подобного языка запросов. Для решения этой проблемы используются сторонние средства трансляции классических SQL-выражений в исполнительный код для конкретной нереляционной базы. Например, Apache Phoenix для HBase или универсальный Drill.сложности в поддержке всех ACID-требований к транзакциям (атомарность, консистентность, изоляция, долговечность) из-за того, что NoSQL-СУБД вместо CAP-модели (согласованность, доступность, устойчивость к разделению) скорее соответствуют модели BASE (базовая доступность, гибкое состояние и итоговая согласованность). Впрочем, некоторые нереляционные СУБД пытаются обойти это ограничение с помощью настраиваемых уровней согласованности, о чем мы рассказывали на примере Cassandra. Аналогичным образом Riak позволяет настраивать требуемые характеристики доступности-согласованности даже для отдельных запросов за счет задания количества узлов, необходимых для подтверждения успешного завершения транзакциисильная привязка приложения к конкретной СУБД из-за специфики внутреннего языка запросов и гибкой модели данных, ориентированной на конкретный случай;недостаток специалистов по NoSQL-базам по сравнению с реляционными аналогами."
}
,{
  question: "ACID-транзакции NoSQL",
  answer: "При разработке NoSQL были смягчены жесткие требования к транзакциям. Основные принципы ACID гарантируют, что целостность и согласованность данных в реляционных хранилищах будет обеспечена даже при сбоях. Поскольку для ряда задач в строгом следовании ACID нет никакой необходимости, NoSQL-базы чаще всего предлагают компромисс и принципы BASE:система обеспечивает базовую доступность (Basic Availability), т. е. каждый запрос будет обязательно завершён, успешно или нет;система пребывает в гибком состоянии (Soft-state) — очерёдность записей соблюдать необязательно, реплики могут какое-то время находиться в несогласованном состоянии, а система может самостоятельно изменяться для достижения согласованности;все данные всё равно достигнут согласованности (Eventual Consistency)."
}
,{
  question: "Основные принципы BASE",
  answer: "базы данных NoSQL охватывают ситуации, когда модель ACID является избыточной или фактически препятствует работе базы данных. Вместо этого NoSQL полагается на более мягкую модель, известную, соответственно, как модель BASE. Эта модель учитывает гибкость, предлагаемую NoSQL, и аналогичные подходы к управлению и хранению неструктурированных данных. BASE состоит из трех принципов:Базовая доступность . Подход к базе данных NoSQL фокусируется на доступности данных даже при наличии множества сбоев. Это достигается путем использования распределенного подхода к управлению базами данных. Вместо того чтобы поддерживать одно большое хранилище данных и сосредоточиться на отказоустойчивости этого хранилища, базы данных NoSQL распределяют данные по многим системам хранения с высокой степенью репликации. В маловероятном случае, если сбой нарушает доступ к сегменту данных, это не обязательно приводит к полному отключению базы данных.Мягкое состояние . Базы данных BASE почти полностью отказываются от требований согласованности модели ACID. Одна из основных концепций, лежащих в основе BASE, заключается в том, что согласованность данных является проблемой разработчика и не должна обрабатываться базой данных.Возможная последовательность . Единственное требование, которое базы данных NoSQL имеют в отношении согласованности, - это требование, чтобы в какой-то момент в будущем данные конвергировались в согласованное состояние. Однако никаких гарантий относительно того, когда это произойдет, не дается. Это полное отклонение от требования немедленной согласованности ACID, которое запрещает выполнение транзакции до тех пор, пока предыдущая транзакция не будет завершена и база данных не приблизится к согласованному состоянию."
}
,{
  question: "Что такое MapReduce?",
  answer: "это модель распределённых вычислений от компании Google, используемая в технологиях Big Data для параллельных вычислений над очень большими (до нескольких петабайт) наборами данных в компьютерных кластерах, и фреймворк для вычисления распределенных задач на узлах (node) кластера"
}
,{
  question: "Назначение и области применения MapReduce",
  answer: "MapReduce можно по праву назвать главной технологией Big Data, т.к. она изначально ориентирована на параллельные вычисления в распределенных кластерах. Суть MapReduce состоит в разделении информационного массива на части, параллельной обработки каждой части на отдельном узле и финального объединения всех результатов.<br>Программы, использующие MapReduce, автоматически распараллеливаются и исполняются на распределенных узлах кластера, при этом исполнительная система сама заботится о деталях реализации (разбиение входных данных на части, разделение задач по узлам кластера, обработка сбоев и сообщение между распределенными компьютерами). Благодаря этому программисты могут легко и эффективно использовать ресурсы распределённых Big Data систем.<br>Технология практически универсальна: она может использоваться для индексации веб-контента, подсчета слов в большом файле, счётчиков частоты обращений к заданному адресу, вычисления объём всех веб-страниц с каждого URL-адреса конкретного хост-узла, создания списка всех адресов с необходимыми данными и прочих задач обработки огромных массивов распределенной информации. Также к областям применения MapReduce относится распределённый поиск и сортировка данных, обращение графа веб-ссылок, обработка статистики логов сети, построение инвертированных индексов, кластеризация документов, машинное обучение и статистический машинный перевод. Также MapReduce адаптирована под многопроцессорные системы, добровольные вычислительные, динамические облачные и мобильные сред"
}
,{
  question: "Как устроен mapreduce: принцип работы",
  answer: "Прежде всего, еще раз поясним смысл основополагающих функций вычислительной модели:<br>map - принимает на вход список значений и некую функцию, которую затем применяет к каждому элементу списка и возвращает новый список;<br>reduce (свёртка) — преобразует список к единственному атомарному значению при помощи заданной функции, которой на каждой итерации передаются новый элемент списка и промежуточный результат.Для обработки данных в соответствии с вычислительной моделью MapReduce следует определить обе эти функции, указать имена входных и выходных файлов, а также параметры обработки.<br>Сама вычислительная модель состоит из 3-хшаговой комбинации вышеприведенных функций:Map - предварительная обработка входных данных в виде большого список значений. При этом главный узел кластера (master node) получает этот список, делит его на части и передает рабочим узлам (worker node). Далее каждый рабочий узел применяет функцию Map к локальным данным и записывает результат в формате «ключ-значение» во временное хранилище.Shuffle, когда рабочие узлы перераспределяют данные на основе ключей, ранее созданных функцией Map, таким образом, чтобы все данные одного ключа лежали на одном рабочем узле.Reduce - параллельная обработка каждым рабочим узлом каждой группы данных по порядку следования ключей и «склейка» результатов на master node. Главный узел получает промежуточные ответы от рабочих узлов и передаёт их на свободные узлы для выполнения следующего шага. Получившийся после прохождения всех необходимых шагов результат - это и есть решение исходной задачи."
}
,
    ];

    const questionText = document.getElementById('question-text');
    const answerText = document.getElementById('answer-text');
    const modal = document.getElementById('modal');
    const modalAnswer = document.getElementById('modal-answer');

    function toggleAnswer() {
        const answer = questions[currentQuestionIndex].answer;
        if (answer.length > MAX_ANSWER_LENGTH) {
            showModal(answer);
        } else {
            if (answerText.classList.contains('hidden')) {
                answerText.innerHTML = answer;
                answerText.classList.remove('hidden');
                questionText.classList.add('hidden');
            } else {
                answerText.classList.add('hidden');
                questionText.classList.remove('hidden');
            }
        }
    }

    function showModal(answer) {
        modalAnswer.innerHTML = answer;
        modal.classList.remove('hidden');
    }

    function showQuestion(index) {
        questionText.textContent = questions[index].question;
        answerText.innerHTML = ""; // Скрываем ответ при смене вопроса
        questionText.classList.remove('hidden');
        answerText.classList.add('hidden');
    }

    function nextQuestion() {
        if (currentQuestionIndex < questions.length - 1) {
            currentQuestionIndex++;
            showQuestion(currentQuestionIndex);
        }
    }

    function prevQuestion() {
        if (currentQuestionIndex > 0) {
            currentQuestionIndex--;
            showQuestion(currentQuestionIndex);
        }
    }

    function closeModal() {
        modal.classList.add('hidden');
    }

    showQuestion(currentQuestionIndex);
</script>

</body>
</html>
