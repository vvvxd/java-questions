1)Что такое оптимизация SQL запросов и зачем она нужна?

Оптимизация SQL запросов - это преобразование имеющегося запроса или системы улучшающее производительность.

В нынешнем мире задержка запросов играет очень важную роль, многие пользователи уже не хотят ждать по несколько секунд загрузку экрана или данных. Бизнес может потерять клиентов из-за какого-то медленного запроса, это недопустимо.

--------------------------------------------------------------------------------------------------------------------
2)Оптимизатор PostgreSql, его плюсы и минусы.

Плюсы оптимизатора PostgreSql можно описать одним предложением - оптимизатора PostgreSql является одним из самых лучших оптимизаторов SQL на рынке баз данных.

У оптимизатора PostgreSql есть один существенный минус - ему нельзя давать подсказки для оптимизации, как например в Oracle. Из-за того, что время оптимизации ограничено, оптимизатор может выбрать не самый лучший вариант кода.

--------------------------------------------------------------------------------------------------------------------
3)Какие шаги выполняет PostgreSql для выполнения?

    компилирует и преобразует инструкцию SQL в выражение, состоящее из логических операций высокого уровня, называемое логический план;
    оптимизирует логический план и превращает его в план выполнения;
    выполняет (интерпретирует) план и возвращает результаты
--------------------------------------------------------------------------------------------------------------------
4)Как PostgreSql выполняет SQL?

PostgreSql последовательно выполняет план и передаёт выполненные значения, как входное для нового действия.

--------------------------------------------------------------------------------------------------------------------
5)Каким правилам эквивалентности удовлетворяют реляционные преобразования?

коммутативность – JOIN(R,S) = JOIN (S,R).
Коммутативность означает, что порядок двух отношений не важен.
Если у нас есть два отношения, R и S, то R JOIN S даст тот же результат, что и S JOIN R;

ассоциативность – JOIN(R, JOIN(S,T) = JOIN(JOIN(R,S), T).
Ассоциативность означает, что если у нас есть три отношения, R, S и T, мы можем сначала выполнить R JOIN S, а затем присоединить T к результату, или сначала выполнить S JOIN T, а затем присоединить R к результату первого соединения, и  результаты будут эквивалентны в  обоих
случаях;

дистрибутивность – JOIN(R, UNION(S, T)) = UNION(JOIN(R,S), JOIN(R, T)).
Дистрибутивность означает, что если мы соединим отношение с объединением двух других отношений, результат будет таким же, как если
бы мы выполнили два соединения, R JOIN S и R JOIN T, по отдельности, а затем объединили результаты.

--------------------------------------------------------------------------------------------------------------------
6)Алгоритмы доступа к данным в PostgreSql.

Полное (последовательное) сканирование:
При полном сканировании движок базы данных последовательно считывает все строки в таблице и для каждой строки проверяет условие фильтрации. 

Доступ к таблицам на основе индексов:
Если условие (или условия) фильтрации поддерживается индексом в таблице, индекс можно использовать для доступа к данным из этой таблицы.
Алгоритм извлекает список указателей на блоки, содержащие строки со значениями, удовлетворяющими условию фильтрации, и только эти блоки читаются из таблицы.

Сканирование только индекса:
Операции доступа к  данным не обязательно возвращают полные строки.
Если некоторые столбцы не нужны для запроса, их можно опустить, как только строка пройдет условия фильтрации (если таковые имеются). Говоря более формально, это означает, что логическая проекция сочетается с доступом к данным. Такое сочетание особенно полезно, если индекс, используемый для фильтрации, содержит все столбцы, необходимые для запроса.

Bitmap Index Scan

Чтобы не тратить ресурсы на повторный просмотр табличных страниц, применяется еще один способ доступа — сканирование по битовой карте. Он похож на обычный индексный доступ, но происходит в два этапа.Сначала сканируется индекс (Bitmap Index Scan) и в локальной памяти процесса строится битовая карта. Битовая карта состоит из фрагментов. Фрагменты соответствуют табличным страницам,а каждый бит фрагмента соответствует версии строки в этой странице. При построении битовой карты в ней отмечаются те версии строк, которые удовлетворяют условию и должны быть прочитаны.За счет разделения битовой карты на фрагменты карта, в которой отмечено немного версий, будет занимать мало места.

--------------------------------------------------------------------------------------------------------------------
7)Что такое индекс и индексы на B-деревьях.

Индекс - это некоторая избыточная структура в базе данных, в которой данные находятся в определённом порядке, нужным для быстроты поиска.
Минусы индексов: замедленное обновление и вставка данных, хотя этот минус в нынешних системах не играет большую роль, его всё равно нужно учитывать.

B-деревья:

Самая распространенная индексная структура  – это B-дерево. Структура B-дерева показана на рис. 3.6; коды аэропортов являются индексными ключами. Дерево состоит из иерархически организованных узлов, связанных
с блоками, хранящимися на диске.
Листовые узлы (показанные на рис. 3.6 в нижней строке) содержат точно такие же записи индекса, как на рис. 3.5; эти записи состоят из индексного
ключа и указателя на строку таблицы.
Нелистовые узлы (расположенные на всех уровнях, кроме нижнего) содержат записи, состоящие из наименьшего ключа (на рис. 3.5 это наименьшее буквенно-цифровое значение) в блоке, расположенном на следующем
уровне, и  указателя на этот блок. Все записи во всех блоках упорядочены,
и в каждом блоке используется не менее половины доступного объема.
Любой поиск ключа K начинается с  корневого узла B-дерева. Во время поиска по блоку будет найден самый большой ключ P, не превышающий K,
и затем поиск продолжается в блоке, на который ссылается указатель, связанный с P. Поиск продолжается, пока мы не дойдем до листового узла, где указатели ссылаются на строки таблицы.


--------------------------------------------------------------------------------------------------------------------
8)Что вы знаее о Gist индекс

GiST расшифровывается как generalized search tree — обобщенное дерево поиска.Идею работы GiST-индексов рассмотрим на примере точек на плоскости.Плоскость разбивается на несколько прямоугольников, которыев сумме покрывают все индексируемые точки. Эти прямоугольники составляют верхний уровень дерева.

На следующем уровне дерева каждый из больших прямоугольников распадается на прямоугольники меньшего размера

На последнем уровне дерева каждый ограничивающий прямоугольник будет содержать столько точек, сколько помещается на одну индексную страницу.Общее условие разбиения таково: прямоугольник родительской вершины охватывает все прямоугольники соответствующего поддерева. Это позволяет, например, быстро находить точки, лежащие внутри определенной области:1) находим прямоугольники, пересекающиеся с заданной областью,на верхнем уровне индекса;2) спускаемся в выбранные поддеревья и повторяем поиск в них.Такой алгоритм индексирования называется R-деревом.

--------------------------------------------------------------------------------------------------------------------
9)Что вы знаете о GIN?

GIN — generalized inverted index, обобщенный инвертированный индекс.Идею этого индексного метода проще всего понять на примере предметного указателя в обычной книге. На страницах книги встречаются термины, а в предметном указателе перечисленыв алфавитном порядке все термины с указанием номеров страниц,на которых они присутствуют.Индекс GIN в первую очередь используется для индексациидокументов с целью ускорения полнотекстового поиска. По сути,это обычное B-дерево, но в него помещены не сами документы,а составляющие их слова. GIN-индекс оптимизирован с учетом того,что каждое слово может встречаться во многих документах. Если «список страниц» очень велик, он может храниться не в самой индексной странице, а в отдельном B-дереве.

--------------------------------------------------------------------------------------------------------------------
10)Что такое Битовая карта?

Битовая карта – это вспомогательная структура данных, которая используется внутри PostgreSQL с разными целями. Битовые карты можно рассматривать как своего рода индекс: они созданы для облегчения доступа к другим структурам данных, содержащим несколько блоков. Обычно битовые
карты используются для компактного представления свойств табличных данных.
Чаще всего битовая карта содержит по одному биту для каждого блока
(8192 байта). Значение бита равно 1, если блок обладает нужным свойством,
и 0, если нет. На рис. 3.7 показано, как битовые карты используются для доступа к данным по нескольким индексам

--------------------------------------------------------------------------------------------------------------------
11)Что такое Неточные фрагменты и как они образуются?

Если карта перестает помещаться в work_mem, часть ее фрагментов «огрубляется» — каждый бит начинает соответствовать целой странице, а не отдельной версии строки (lossy bitmap). Стоимость обработки таких фрагментов увеличивается.  Освободившееся место используется для того, чтобы продолжить строить карту.В принципе, при сильно ограниченном work_mem и большой выборке битовая карта может не поместиться в памяти, даже если в ней совсем не останется информации на уровне версий строк. В таком случае ограничение work_mem нарушается — под карту будет дополнительно выделено столько памяти, сколько необходимо. Неточные фрагменты требуют перепроверки условий для всех версий строк в табличной странице, а это сказывается на производительности. 

--------------------------------------------------------------------------------------------------------------------
12)Типы индексов:Кластеризированные 

Если данные в таблице физически упорядочены, обычное индексное сканирование не будет читать табличную страницу повторно

Кластеризированные индексы - это индекс при котором, данные в таблице будут упорядоченны по индексу, но он не гарантирует того, что в будущем данные будут отсортированны

Некластеризованный индекс - это индекс, который ссылается на данные, а они находятся в любом порядке.

--------------------------------------------------------------------------------------------------------------------
13)Типы индексов:Покрывающий

Если в запросе требуются только проиндексированные данные, они уже есть в самом индексе и к таблице обращаться не надо. Такой индекс называется покрывающим для запроса.Это хорошая оптимизация, исключающая обращения к табличным страницам. Но, к сожалению, индексные страницы не содержат информацию о видимости строк — чтобы проверить, надо ли показывать найденную в индексе строку, мы вынуждены заглянутьи в табличную страницу, что сводит оптимизацию на нет

--------------------------------------------------------------------------------------------------------------------
14)Типы индексов:Многоколоночный индекс

Индекс можно создать по нескольким столбцам. В этом случае имеет значение порядок следования столбцов и порядок сортировки

--------------------------------------------------------------------------------------------------------------------
15)Почему важен порядок колонок в многоколоночном индексе?

Порядок важен потому что, при доступе мы сначала сортируем по первой колонке, а потом только по второй.

При доступе только по первой колонке, индекс сможет увидеть данные и они будут находиться близко друг к другу

При доступе только во второй колонке, данные будут находится в разных блоках и непонятно где, поэтому это не эффективно и оптимизатор не возьмёт его.

--------------------------------------------------------------------------------------------------------------------
16)Типы индексов:Include индексы

Это индекс в котором дополнительно хранятся значения, чтобы возможно получить Index Only scan

Значения таких столбцов не формируют дерево индекса, а просто хранятся как дополнительные сведения в индексных записях листовых страниц. Поиск по неключевым столбцам не работает, но их значения могут быть получены без обращения к таблице.

--------------------------------------------------------------------------------------------------------------------
17)Типы отношений в PostgreSql.

Вложенные циклы
Первый алгоритм предназначен для получения декартова произведения, то
есть множества всех пар строк из входных таблиц. Самый простой способ
вычислить произведение – перебрать строки таблицы R и для каждой строки
из R перебрать строки таблицы S.

Алгоритмы на основе хеширования
Результат естественного соединения состоит из пар строк из таблиц R и  S, которые имеют равные значения атрибутов, по которым выполняется соединение. Идея алгоритма соединения хешированием проста: если значения
равны, то и хеш-значения тоже равны.
Алгоритм разбивает обе входные таблицы по корзинам в соответствии со значениями хеш-функции, а затем независимо соединяет строки в каждой корзине

Базовая версия алгоритма соединения хешированием включает две фазы:

    на этапе построения все кортежи таблицы R сохраняются в корзинах
    согласно значениям хеш-функции;
    на этапе проверки каждая строка таблицы S направляется в  соответствующую ей корзину. Если подходящие строки таблицы R находятся
    в этой корзине, порождаются выходные строки.

Сортировка слиянием
На первом этапе алгоритма обе входные таблицы сортируются в порядке
возрастания по атрибутам соединения.
После того как таблицы правильно упорядочены, на этапе слияния обе
таблицы сканируются один раз и для каждого значения атрибута соединения вычисляется декартово произведение строк, содержащих это значение.
Обратите внимание, что это произведение является необходимой частью
результата соединения. Новые строки с таким же значением атрибута не
могут появиться в оставшейся части входных данных, потому что таблицы
упорядочены
--------------------------------------------------------------------------------------------------------------------
18)Что такое план выполнения?

План выполнения - это некоторый понятный PostgreSQL формат, с оптимизированным SQL кодом, который будет последовательно выполнен.

Для построения плана оптимизатор использует правила преобразования, эвристики и алгоритмы оптимизации на основе стоимости.

--------------------------------------------------------------------------------------------------------------------
19)PostgreSQL перебирает все планы? Если да, оптимально ли это?

Нет, оптимизатор PostgreSQL не перебирает все планы выполнения. Все планы выполнения представляют собой дерево и если одно под ветвь оптимальнее другой, то оптимизатор возьмёт более лучшую, и будет дальще идти по ней, а другую откинет и не будет просматривать.
Таким образом он и не будет перебирать все варианты.

--------------------------------------------------------------------------------------------------------------------
20)Как получить план выполнения в PostgreSQL?

План выполнения можно получить с помощью команды 

    EXPLAIN SELECT ***

Она выведет план выполнения, который сделал оптимизатор. В каждой строке есть cost - это стоимость запроса для PostgreSQL в неких величинах(не в реальном времени).
Сумма всех значений является стоимостью всего запроса.

Читать план нужно с листом к корню дерева.

--------------------------------------------------------------------------------------------------------------------
21)Чем отличаются EXPLAIN от EXPLAIN ANALYZE?

EXPLAIN ANALYZE добавляет к EXPLAIN реальное время выполнения всех действий

--------------------------------------------------------------------------------------------------------------------
22)Селективность индексов, что это?

Селективность индексов - это сколько записей будет на 1 значение условия.

Чем меньше селективность, тем выше скорость работы индекса.
Если селективность будет достаточно большой, то оптимизатор PostgreSQL посчитает этот выриант не оптимальным и откинет его.

--------------------------------------------------------------------------------------------------------------------
23)Использование индексов для оптимизации.

Добавить индексы - это первый вариант ускорение запроса, но так ли он хорош?

В 90% случаях, да, в 10% он не будет применён.

Индекс позволит нам быстро найти наши данные по условию с операторами > < = >= <=, LIKE, BETWEEN (b-map)

Но мы можем ускорить даже обычные индексы.

1)Индексы бывают 2 типов - составные и одинарные.

Для ускорения индексов мы можем проверить для нашего условия, какой из этих типов(если у нас больше 1 условия) для нас быстрее.

2)Использование индексов для получения данных, если нам нужны данные только из индекса, то лучше взять только их, ведь будет использоваться  сканированием только индекса.

3)Частичные индексы - это индексы, которые строятся только на определённых данных описанных в WHERE

Так же при соединении таблиц стоит использовать индексы, для более быстрого соединения.

--------------------------------------------------------------------------------------------------------------------
24)Не Использование индексов для оптимизации.


Избегание использования индексов может быть целесообразным в определенных сценариях. Разработчики баз данных часто считают, что индексы улучшают производительность запросов, но это не всегда так. Существуют две основные причины, по которым может быть желательно избегать индексов:

Полностью считываемая в память таблица:

Если таблица относительно небольшая и может полностью поместиться в оперативной памяти, использование индексов может быть излишним и даже снижать производительность.
Запрос требует большую часть строк таблицы:

В случаях, когда выполнение запроса требует обработки большого количества строк таблицы, индексы могут только замедлить выполнение запроса.
В некоторых случаях оптимизатор базы данных автоматически определит, когда использовать индексы, но иногда его решения могут быть неоптимальными. В таких случаях можно изменить критерии фильтрации или воспользоваться преобразованиями столбцов, чтобы предотвратить использование индексов.

Примеры преобразований столбцов включают добавление нуля к числовому столбцу или использование функции coalesce для блокировки использования индексов. Например, условие attr1 + 0 = p_value предотвращает использование индекса для столбца attr1. Также, при использовании функции coalesce, например, coalesce(t1.attr2, '0') = coalesce(t2.attr2, '0'), можно блокировать индексы для столбца attr2, предполагая, что он не содержит неопределенных значений.

--------------------------------------------------------------------------------------------------------------------
25)Что такое длинные запросы?

Длинный запрос - это запрос в котором от действия к действию передаётся большое количество записей

--------------------------------------------------------------------------------------------------------------------
26)Длинные запросы и полное сканирование

Почему предпочтительно использовать полное сканирование таблицы для длинных запросов? Это связано с тем, что при индексном доступе, особенно когда количество необходимых строк велико (как показано на рис. 3.1), требуется больше операций ввода-вывода. Термин "достаточно большим" зависит от различных факторов и может изменяться с развитием аппаратного обеспечения. Важно отметить, что PostgreSQL обычно правильно вычисляет этот процент.

В предыдущей главе было сказано схожее о коротких запросах, однако оценить "достаточно велико" сложнее, чем "достаточно мало". Эта верхняя граница изменяется в зависимости от развития аппаратного обеспечения, дисков и процессоров. Поэтому в книге избегается указания конкретных числовых значений порогов, которые могут с течением времени измениться. Для иллюстрации в этой главе использованы таблицы с сотнями миллионов строк данных, но даже они могут стать недостаточными для некоторых примеров через несколько лет.

--------------------------------------------------------------------------------------------------------------------
27)Длинные запросы и соединения хешированием


Большинство примеров в данной главе используют алгоритм соединения хешированием, предпочитая его для выполнения длинных запросов. Этот выбор обоснован тем, что стоимость соединения хешированием, как было показано в главе 3, обычно меньше стоимости вложенного цикла для длинных запросов. Размер таблиц R и S, а также количество уникальных значений атрибута соединения JA, влияют на разницу в стоимости: чем больше таблицы и JA, тем более выгодно использовать соединение хешированием.

Соединения хешированием работают наилучшим образом, когда первая таблица помещается в оперативную память, и размер доступной памяти может быть настроен с помощью параметров сервера.

--------------------------------------------------------------------------------------------------------------------
28)Длинные запросы и порядок соединений

Для коротких запросов предпочтительным является порядок соединений, в котором в первую очередь используются индексы с более низкой селективностью. Несмотря на то, что не предполагается использование индексов в длинных запросах, порядок соединений имеет значение. Размеры больших таблиц могут значительно различаться, и даже при отсутствии использования индексов порядок соединений важен для минимизации размера промежуточных наборов данных.

Существенное значение имеет порядок соединений даже тогда, когда индексы не используются, так как важно, чтобы промежуточные наборы данных были минимальными при выборе "почти всех записей", где "почти" может означать как 30%, так и 100%. Оптимальный порядок соединений включает выполнение наиболее ограничительных соединений (т.е., тех, которые сильнее всего уменьшают количество результирующих строк) в первую очередь. Хотя в большинстве случаев оптимизатор автоматически выбирает правильный порядок, разработчик должен убедиться, что оптимизатор сделал правильный выбор.

--------------------------------------------------------------------------------------------------------------------
29)Длинные запросы: Что такое полусоединение и антисоединение?

Полусоединение:

Полусоединение – особый вид соединения, удовлетворяющий двум условиям. 
Во-первых, в результирующем множестве появляются только столбцы из первой таблицы. 
Во-вторых, строки из первой таблицы не дублируются, если во второй таблице для них есть несколько соответствий. Чаще всего полусоединение вообще не предполагает ключевое слово JOIN. Первый и наиболее распространенный способ получить полусоединение представлен в листинге 6.3. Этот запрос находит всю информацию о рейсах с по крайней мере одним бронированием.

        SELECT * FROM flight f WHERE EXISTS
        (SELECT flight_id FROM booking_leg WHERE flight_id = f.flight_id)

Антисоединение:

Антисоединение двух таблиц R и S возвращает строки из таблицы R, для которых в таблице S нет строк с совпадающим значением в столбце соединения.

        SELECT * FROM flight f WHERE NOT EXISTS
        (SELECT flight_id FROM booking_leg WHERE flight_id = f.flight_id)

--------------------------------------------------------------------------------------------------------------------
30)Длинные запросы: Использование операций над множествами

Иногда операции над множествами позволяют выбрать эффективный альтернативный план выполнения и повысить удобочитаемость.

Часто можно:
    использовать EXCEPT вместо NOT EXISTS и NOT IN;
    использовать INTERSECT вместо EXISTS и IN;
    использовать UNION вместо сложных критериев выбора с OR.

--------------------------------------------------------------------------------------------------------------------
31)Длинные запросы: Избегаем многократного сканирования


Еще одна причина медленных запросов - многократные сканирования таблиц, часто обусловленные неудачным дизайном схемы данных. Эту проблему можно теоретически исправить, но в случаях, когда это невозможно, мы предлагаем эффективные методы написания запросов при несовершенной схеме.

Моделируемая в нашей схеме postgres_air ситуация, где требуется хранить дополнительную информацию для уже существующих объектов в базе данных, не уникальна. Часто при использовании таблицы сущность-атрибут-значение (EAV) решаются подобные задачи. В схеме postgres_air этот шаблон реализован в таблице custom_field, где хранятся атрибуты, такие как номер паспорта, срок действия и название страны выдачи.

Представим, что необходим отчет, отображающий имена пассажиров и их паспортные данные. Однако, типичное предложенное решение в листинге 6.26 включает три сканирования таблицы custom_field, что сказывается на производительности запроса. Эффективный способ выполнения этой задачи можно представить, избегая многократного сканирования таблицы и оптимизируя процесс.

--------------------------------------------------------------------------------------------------------------------
32)Временные таблицы

Длинная цепочка временных таблиц может вызвать ряд проблем, включая следующие:

Индексы: После сохранения данных во временной таблице нельзя использовать индексы из исходной таблицы. Это может привести к необходимости обхода индексов или созданию новых во временных таблицах, требующих дополнительных ресурсов.

Статистика: Поскольку создана новая таблица, оптимизатор не может использовать статистические данные из исходной таблицы. Это может потребовать отказа от статистики или выполнения команды ANALYZE для временной таблицы.

Место на диске: Временные таблицы сохраняются на диске, если промежуточные результаты не помещаются в оперативной памяти. Большие запросы с соединениями, сортировками и группировками могут конкурировать за пространство с временными таблицами, что может привести к отмене запросов.

Чрезмерный ввод-вывод: Временные таблицы требуют дополнительного времени для записи и чтения с диска, что может привести к чрезмерному вводу-выводу.

Однако основной негативный эффект чрезмерного использования временных таблиц заключается в том, что такая практика ограничивает способность оптимизатора переписывать запросы. Сохранение результатов каждого соединения во временную таблицу фиксирует порядок создания временных таблиц и мешает оптимизатору выбирать оптимальный порядок соединений.

--------------------------------------------------------------------------------------------------------------------
33)Общие табличные выражения (CTE)

В плане выполнения зависит от версии PostgreSQL. Для версий ниже 12 общее табличное выражение (CTE) обрабатывалось так же, как временная таблица, результаты материализовались в памяти с возможным сбросом на диск. Это означало, что использование CTE не приносило преимуществ перед временной таблицей.

CTE было предназначено для более эффективного использования в случаях, когда вложенный подзапрос используется несколько раз в запросе. В таких случаях PostgreSQL мог вычислить результаты один раз и использовать их повторно.

Оптимизатор планировал выполнение CTE отдельно, не перемещая условия соединения внутрь CTE. Это было важно, особенно при использовании CTE в командах INSERT, DELETE или UPDATE, а также в рекурсивных вызовах CTE. В PostgreSQL 12 изменена оптимизация CTE: если нерекурсивное CTE используется один раз, то оно встраивается во внешний запрос. Если CTE используется несколько раз, сохраняется старое поведение.

Это поведение можно изменить с использованием ключевых слов MATERIALIZED и NOT MATERIALIZED. Ключевое слово MATERIALIZED вызывает старое поведение, а NOT MATERIALIZED – встраивание, независимо от других соображений.

--------------------------------------------------------------------------------------------------------------------
34)Представления

Представление – это объект базы данных, в котором хранится запрос, определяющий виртуальную таблицу.

С одной стороны, представление обычно создают именно для инкапсуляции, чтобы другие могли использовать его, не разбираясь в логике запроса.
С другой стороны, эта непрозрачность приводит к низкой производительности. Это особенно ярко проявляется, когда некоторые столбцы в представлении являются результатами преобразования.
Ещё одна проблема представлений - невозможность создания индексов, при больших количествах записей, выборка может быть не оптимальна.

Однако они не дают никакого преимущества в плане производительности.
Лучшее и,  возможно, единственно оправданное использование представлений – это построение уровня безопасности или определение элементов
отчетов, гарантирующих, что все соединения и бизнес-логика определены
правильно.

--------------------------------------------------------------------------------------------------------------------
35)Материализованные представления

Материализованное представление – это объект базы данных, который объединяет
в себе и определение запроса, и таблицу для хранения результатов этого запроса, когда
он выполнен.

Когда можно использовать?

Можно использовать, когда есть запрос, которому не нужно 100% актуальная информация.

Какое преимущество в отличие от обычного представления?

Главное преимущество в том, что запрос сохраняет данные, которые мы можем проиндексировать и ускорить выполнение.

--------------------------------------------------------------------------------------------------------------------
36)Секционирование


Секционирование таблиц - форма организации данных, где таблица разбивается на несколько секций, каждая из которых представляет собой отдельную таблицу. Каждая строка хранится в соответствующей секции в соответствии с определенными правилами. Поддержка секций в PostgreSQL появилась с версии 10, и с каждым выпуском вносятся улучшения для упрощения их использования.

Наиболее распространенный случай - секционирование по диапазонам, где каждая секция содержит строки с значениями атрибута в определенном диапазоне. Секции не пересекаются, и строки, не попадающие в ни одну секцию, не могут быть вставлены.

Секции могут быть добавлены и удалены, причем операция DROP выполняется быстрее, чем DELETE. Это часто используется, например, при добавлении новой секции в конце каждого месяца к таблице, разделенной по диапазонам дат.

Секционирование также может быть использовано для распределения данных по нескольким серверам баз данных. С точки зрения производительности, секционирование может уменьшить время полного сканирования таблицы, ограничив сканирование только подходящими секциями. Это особенно полезно для длинных запросов, часто требующих полного сканирования.

--------------------------------------------------------------------------------------------------------------------
37)Два способа оптимизации модификации данных

Команды DML (Data Manipulation Language) включают выбор записей и их изменение. В случае INSERT первая часть может быть опущена при вставке констант, но при использовании INSERT-SELECT необходимо сначала найти записи для вставки.

Оптимизация DML состоит из оптимизации выборки и оптимизации изменения данных. Если проблема связана с выборкой, следует оптимизировать часть SELECT. Эта глава фокусируется на второй части - оптимизации записи данных.

В большинстве случаев системы OLTP выполняют гораздо меньше команд DML по сравнению с командами SELECT. Это основная причина того, что редко обсуждается оптимизация DML. Однако длительные операции DML могут вызвать проблемы, так как обновленные данные могут задерживаться и из-за возможного появления блокирующих замков, замедляющих выполнение других команд.

--------------------------------------------------------------------------------------------------------------------
38)Функции

При создании функции PostgreSQL выполняет только начальный разбор текста, обнаруживая только тривиальные синтаксические ошибки. В отличие от Oracle, PostgreSQL не компилирует функции, а хранит их в виде исходного кода, интерпретируя их во время выполнения.

Интерпретатор PL/pgSQL создает внутреннее дерево инструкций при первом вызове функции в каждом сеансе. Выражения SQL и команды не транслируются сразу, а анализируются и создается подготовленный оператор только при выполнении определенной команды. Это может привести к тому, что синтаксические ошибки в коде не будут обнаружены до момента выполнения.

При создании функции в PL/pgSQL:

План выполнения не сохраняется.
Не выполняются проверки на наличие таблиц, столбцов или других функций.
Работу функции можно определить только при ее выполнении, и часто это требуется несколько раз для различных путей выполнения.

Функции PostgreSQL также являются "атомарными" в нескольких смыслах. Нельзя начинать транзакции внутри функций, поэтому инструкции DML выполняются как "все или ничего". Планировщик PostgreSQL не учитывает пользовательские функции при оптимизации плана выполнения запроса.

Время выполнения функции составляет 3,5 секунды, в то время как аналогичная инструкция SQL выполняется примерно за 900 мс. Это значительное различие объясняется тем, что функции в PostgreSQL не оптимизируются так же эффективно, как представления или общие табличные выражения.

Функции действуют как черные ящики для внешней инструкции SQL, и PostgreSQL выполняет каждый вызов функции столько раз, сколько выбрано строк. Экономия времени за счет использования подготовленного оператора при последующих вызовах может как ускорить, так и замедлить выполнение, так как план выполнения может игнорировать различия в статистике между вызовами функций.

Разница между временем выполнения 0,9 секунды и 3,5 секунды может показаться незначительной, но это критичное значение времени ожидания пользователя. Важно отметить, что в данном примере запрос внутри функции легкий и быстро выполняется.

Таким образом, выполнение запросов, встроенных в инструкцию SELECT, не является оптимальным. Даже для функций, выполняющих простые преобразования данных, разница в производительности может быть заметной, особенно при возвращении большого количества строк.

--------------------------------------------------------------------------------------------------------------------
39)Пошаговое руководство

Шаг 1: Определите, является ли запрос коротким или длинным, учитывая бизнес-требования и приоритеты. Рассмотрите необходимость работы с владельцами бизнеса и бизнес-аналитиками.

Шаг 2 (для коротких запросов):
Шаг 2.1: Найдите самые ограничительные критерии запроса, уточняя их с владельцами бизнеса.
Шаг 2.2: Проверьте наличие поддерживающих индексов и создайте их при необходимости.
Шаг 2.3: Рассмотрите добавление избыточного критерия отбора, если запрос включает соединение таблиц с различными критериями.
Шаг 2.4: Постройте запрос, начиная с самых ограничительных критериев, проверяя производительность на каждом этапе. Обратите внимание на использование общих табличных выражений при необходимости.

Шаг 3 (для длинных запросов):
Шаг 3.1: Рассмотрите возможность инкрементального обновления, работая с владельцами бизнеса для определения обновляемых данных.

Шаг 4 (при использовании инкрементального обновления):
Применяйте шаги оптимизации коротких запросов к новым или обновленным записям. Разработайте стратегию хранения и обновления данных для оптимизации времени выполнения.

Шаг 5 (если инкрементальное обновление невозможно):
Шаг 5.1: Найдите наиболее ограничительное соединение и убедитесь, что оно выполняется первым, оптимизируя порядок выполнения.
Шаг 5.2: Постепенно соединяйте таблицы, проверяя производительность и план выполнения. Оптимизируйте порядок соединения.
Шаг 5.3: Убедитесь, что большие таблицы читаются только один раз, рассматривая возможность кэширования или временного хранения промежуточных результатов.
Шаг 5.4: Отложите группировку до последнего шага, если возможно. Рассмотрите использование оконных функций для эффективной группировки данных.

--------------------------------------------------------------------------------------------------------------------
40)Источник

Оптимизация запросов в PostgreSQL

Генриэтта Домбровская
Борис Новиков
Анна Бейликов