### **Основы Lombok**

Что такое Lombok- Это библиотека, которая автоматически генерирует стандартный код (геттеры, сеттеры, конструкторы,
методы `toString`, `equals`, `hashCode` и т.д.) во время компиляции, используя аннотации.

- **Преимущества**: Уменьшает boilerplate-код, повышает читаемость, снижает вероятность ошибок.
- **Недостатки**: Зависимость от инструмента, потенциальные сложности с дебаггингом, ограниченная поддержка в некоторых IDE.

### **Ключевых аннотаций**

- **@Getter / @Setter**: Генерируют методы доступа (геттеры и сеттеры) для полей класса.
    - Пример: `@Getter @Setter private String name;` создаст `getName()` и `setName(String)`.
    - Настройка: Можно указать уровень доступа (`AccessLevel`) или исключить поля с помощью `@Getter(AccessLevel.NONE)`.
- **@ToString**: Генерирует метод `toString()`.
    - Настройка: `@ToString(exclude = {"fieldName"})` или `@ToString(of = {"field1", "field2"})`.
- **@EqualsAndHashCode**: Генерирует методы `equals()` и `hashCode()`.
    - Настройка: Можно исключить поля или использовать только указанные.
- **@Data**: Комбинированная аннотация, включающая `@Getter`, `@Setter`, `@ToString`, `@EqualsAndHashCode`, `@RequiredArgsConstructor`.
- **@NoArgsConstructor / @AllArgsConstructor / @RequiredArgsConstructor**: Генерируют конструкторы:
    - `@NoArgsConstructor`: Конструктор без аргументов.
    - `@AllArgsConstructor`: Конструктор со всеми полями.
    - `@RequiredArgsConstructor`: Конструктор для полей, помеченных `final` или `@NonNull`.
- **@Builder**: Реализует паттерн Builder для создания объектов.
    - Пример: `@Builder` позволяет создавать объекты с помощью fluent API: `MyClass.builder().field1(value).build()`.
- **@NonNull**: Проверяет поле на `null` и генерирует проверку в конструкторах/сеттерах.
- **@Value**: Создает неизменяемый (immutable) класс (аналог `@Data` для immutable объектов).
- **@SneakyThrows**: Упрощает обработку проверяемых исключений, оборачивая их в `RuntimeException`.
- **@Log / @Slf4j / @Log4j2**: Добавляет логгер в класс (например, `private static final Logger log = ...`).
- **@Cleanup**: Автоматически вызывает метод `close()` для ресурсов (например, потоков).
- **@With**: Генерирует методы для создания копии объекта с измененным значением одного поля.
- **@SuperBuilder**: Расширенная версия `@Builder`, поддерживающая наследование. Изучите, как использовать `@SuperBuilder` для создания
  сложных иерархий классов.
- **@FieldDefaults**: Устанавливает модификаторы доступа для полей по умолчанию (
  например, `@FieldDefaults(makeFinal = true, level = AccessLevel.PRIVATE)`).
- **Экспериментальные аннотации**: Lombok предлагает экспериментальные функции, такие как `@UtilityClass` или `@ExtensionMethod`. Они менее
  стабильны, но могут быть полезны для специфических задач.

---

### **Annotation Processing: Как Lombok встраивается в компиляцию**

**Annotation Processing** — это механизм в Java, который позволяет обрабатывать аннотации на этапе компиляции и генерировать дополнительный
код или выполнять другие действия. Lombok использует **Java Annotation Processing API** (определенный в JSR 269) для автоматической
генерации таких элементов, как геттеры, сеттеры, конструкторы и т.д., без необходимости писать их вручную.

1. **Компиляция Java**:
    - Когда вы компилируете Java-код (например, с помощью `javac` или Eclipse Compiler for Java, ECJ), компилятор анализирует исходный код и
      создает **Abstract Syntax Tree (AST)** — внутреннее представление программы в виде дерева.
    - На этапе обработки аннотаций компилятор вызывает зарегистрированные процессоры аннотаций, включая Lombok.

2. **Роль Lombok**:
    - Lombok регистрируется как процессор аннотаций в компиляторе через файл `META-INF/services/javax.annotation.processing.Processor` в
      своей JAR-библиотеке.
    - Когда компилятор встречает аннотации Lombok (например, `@Getter`, `@Data`), он передает управление процессору Lombok.
    - Lombok анализирует классы, поля и методы, помеченные его аннотациями, и модифицирует AST, добавляя необходимые элементы (например,
      метод `getName()` для поля `private String name` с аннотацией `@Getter`).

3. **Модификация AST**:
    - Вместо создания новых исходных файлов Lombok напрямую изменяет AST, добавляя узлы для сгенерированных методов, конструкторов и т.д.
    - После модификации AST компилятор продолжает работу и преобразует его в байт-код, как если бы сгенерированный код был частью исходного
      файла.

4. **Поддержка компиляторов**:
    - **Javac** (стандартный компилятор Java): Lombok использует стандартный API обработки аннотаций, что делает его интеграцию относительно
      простой.
    - **ECJ** (Eclipse Compiler for Java): Lombok взаимодействует с внутренними API ECJ, что требует более сложной реализации, но позволяет
      поддерживать реальное время в IDE, такой как Eclipse.
    - Lombok также частично поддерживает другие компиляторы, такие как `kapt` (для Kotlin), но основная поддержка сосредоточена на javac и
      ECJ.

---

### **Delombok: Преобразование кода в "чистый" Java**

**Delombok** — это инструмент, входящий в состав Lombok, который преобразует код с аннотациями Lombok в эквивалентный Java-код без
аннотаций. Это позволяет увидеть, что именно генерирует Lombok, и использовать этот код для отладки, миграции или анализа.

#### Как работает Delombok:

1. Delombok выполняет те же шаги, что и Lombok во время компиляции, но вместо модификации AST он создает новые Java-файлы.
2. Он:
    - Анализирует исходный код с аннотациями Lombok.
    - Генерирует эквивалентный код, заменяя аннотации на соответствующие методы, конструкторы и т.д.
    - Сохраняет результат в указанную директорию.
3. Полученный код можно компилировать без зависимости от Lombok.

### **Ограничений и подводных камней**

- **Совместимость с другими инструментами**: Некоторые инструменты (например, старые версии JaCoCo или Checkstyle) могут некорректно
  работать с Lombok, так как они не видят сгенерированный код.
- **Дебаггинг**: Сгенерированный код может усложнить отладку, так как стек вызовов может включать методы, которых нет в исходном коде.
- **Аннотации и наследование**: Например, `@EqualsAndHashCode` по умолчанию включает поля суперкласса, что может привести к неожиданным
  результатам. Используйте `@EqualsAndHashCode(callSuper = true/false)` для контроля.
- **Читаемость и поддержка**: Код с Lombok может быть менее понятным для разработчиков, не знакомых с библиотекой. Убедитесь, что команда
  согласна с ее использованием.

