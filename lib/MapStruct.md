### Фундаментальная основа: MapStruct — это не магия, а кодогенерация

Это самый важный пункт для понимания. В отличие от библиотек, использующих рефлексию (например, ModelMapper), MapStruct **не работает во время выполнения (runtime)**.

*   **Как это работает:** MapStruct — это **процессор аннотаций** (Annotation Processor). Он подключается к процессу компиляции Java (`javac`).
*   **Что он делает:** Когда вы компилируете свой проект, MapStruct находит ваши интерфейсы с аннотацией `@Mapper`, анализирует их методы, аннотации `@Mapping` и генерирует **реализацию** этого интерфейса в виде `.java` файла.
*   **Результат:** В вашем проекте появляется обычный Java-класс (например, `UserMapperImpl.java`), который содержит простой, читаемый и производительный код для маппинга. Без рефлексии, без динамических вызовов.

**Что это дает для глубокого понимания:**
*   **Производительность:** Вы понимаете, почему MapStruct так быстр. Сгенерированный код ничем не отличается от того, который вы бы написали вручную — прямые вызовы `get/set`.
*   **Отладка:** Если что-то идет не так, вы всегда можете найти сгенерированный класс (обычно в `target/generated-sources/annotations`) и посмотреть, какой именно код был создан. Это лучший способ разобраться в сложных случаях.
*   **Безопасность типов (Compile-time safety):** Если маппинг невозможен (например, несовпадение типов, которые MapStruct не может преобразовать), вы получите **ошибку на этапе компиляции**, а не `ClassCastException` в продакшене.


### Компонентная модель (`componentModel`)

Атрибут `@Mapper(componentModel = "...")` — ключ к удобной интеграции.
*   `"spring"`: MapStruct сгенерирует класс с аннотацией `@Component`. Вы сможете внедрять (`@Autowired`) маппер как любой другой бин.
*   `"cdi"`: Для Jakarta EE / CDI.
*   `"default"` (по умолчанию): Вам придется получать экземпляр маппера вручную через `Mappers.getMapper(MyMapper.class)`.

###  Лучшие практики и что делать дальше

1.  **Читайте сгенерированный код.** Это лучший совет. Когда сомневаетесь или что-то не работает, откройте `...Impl.java` файл. Все сразу станет на свои места.
2.  **Тестируйте свои мапперы.** Да, код генерируется, но *конфигурацию* пишете вы. Нужно убедиться, что `source` и `target` указаны верно, кастомная логика работает как надо, а `null` обрабатываются корректно. Используйте JUnit и AssertJ для простых и понятных тестов.
3.  **Не помещайте бизнес-логику в мапперы.** Маппер — это преобразователь данных (DTO <-> Entity). Сложные бизнес-правила, проверки, вызовы других сервисов должны находиться в сервисном слое. Если ваш `default`-метод или `expression` становится слишком сложным, это сигнал, что логику нужно вынести.
4.  **Изучите официальную документацию.** Она превосходна. В ней есть примеры почти на все случаи жизни.
5.  **Посмотрите на репозиторий с примерами MapStruct на GitHub.** Это кладезь готовых решений для сложных сценариев (маппинг коллекций, `Map`, `Enum` и т.д.).

