1)Что такое Gradle?

Gradle — это система автоматизации сборки, которая является полностью открытым исходным кодом и использует концепции, которые вы видите в Apache Maven и Apache Ant. Она использует специфический язык, основанный на языке программирования Groovy, что отличает ее от Apache Maven, который использует XML для конфигурации проекта. Она также определяет порядок выполнения задач с помощью направленного ациклического графа.

Несколько разработчиков создали Gradle и впервые выпустили его в 2007 году, а в 2013 году он был принят компанией Google в качестве системы сборки для проектов Android. Она была разработана для поддержки многопроектных больших сборок. Она также позволяет дополнять вашу сборку, поскольку знает, какие части вашего проекта обновляются. Задачи, которые зависят от обновленных частей повторно не выполняются. На данный момент последним стабильным релизом является версия 3.4, которая была выпущена в феврале 2017 года. Она поддерживает разработку и последующее развертывание с использованием Java, Scala и Groovy, а в будущем будут представлены другие рабочие процессы и языки.

--------------------------------------------------------------------------------------------------------------------
2)Структура проекта gradle.

project
├── gradle                              
│   ├── libs.versions.toml              
│   └── wrapper
│       ├── gradle-wrapper.jar
│       └── gradle-wrapper.properties
├── gradlew                             
├── gradlew.bat                         
├── settings.gradle(.kts)               
├── subproject-a
│   ├── build.gradle(.kts)              
│   └── src                             
└── subproject-b
├── build.gradle(.kts)              
└── src

--------------------------------------------------------------------------------------------------------------------
3)Gradle Daemon

Непосредственным выполнением сборки занимается Gradle Daemon. Он включен по умолчанию для Gradle версии 3.0 и выше. Gradle Daemon является долгоживущим системным процессом, периодически осуществляющим сборку, когда мы этого хотим. Внутри него происходит много in-memory кеша, оптимизации работы с файловой системой и оптимизации кода выполнения сборки. Если коротко - всё идет на пользу. Пожалуй, исключение только одно - он довольно прожорлив, и Gradle любит держать несколько демонов на разные случаи жизни. Если система начинает ощутимо лагать, всегда можно всех за раз прибить командой

--------------------------------------------------------------------------------------------------------------------
4)Gradle Wrapper

Gradle Wrapper — предпочтительный способ запуска сборки Gradle. Wrapper загружает (при необходимости), а затем вызывает определенную версию Gradle, объявленную в сборке.

В новом проекте сначала просмотрите файлы, используемые Gradle Wrapper. Он состоит из сценария оболочки для macOS и Linux.и пакетный скрипт для Windows.

Эти сценарии позволяют запускать сборку Gradle, не требуя установки Gradle в вашей системе. Это также помогает гарантировать, что одна и та же версия Gradle используется для сборок разными разработчиками, а также между локальными компьютерами и компьютерами CI.

С этого момента вы никогда не будете вызывать Gradle напрямую; вместо этого вы будете использовать обертку Gradle .

Используйте оболочку, введя следующую команду:

$ ./gradlew build
В Windows это команда:

$ .\gradlew.bat build

--------------------------------------------------------------------------------------------------------------------
5)Этапы сборки

Gradle выполняет эти фазы по порядку:

Этап 1. Инициализация
Обнаруживает settings.gradle(.kts)файл.

Создает Settings экземпляр.

Оценивает файл настроек, чтобы определить, какие проекты (и включенные сборки) составляют сборку.

Создает Project экземпляр для каждого проекта.

Этап 2. Настройка
Оценивает сценарии сборки build.gradle(.kts)каждого проекта, участвующего в сборке.

Создает граф задач для запрошенных задач.

Этап 3. Исполнение
Планирует и выполняет выбранные задачи.

Зависимости между задачами определяют порядок выполнения.

Выполнение задач может происходить параллельно.

--------------------------------------------------------------------------------------------------------------------
6)Расскажите о buildSrc

Модуль buildSrc собирается каждый раз перед конфигурацией нашего рутового проекта и поставляется на этап конфигурации в виде jar. Его довольно удобно использовать для объявления зависимостей, а также содержать общую логику для билдскриптов. Подробнее о том, как использовать buildSrc в Gradle-проекте хорошо описано в этой статье.
Но, к сожалению, не всё так гладко, как хотелось бы. У buildSrc есть одна достаточно весомая проблема - при любом его изменении мы теряем наш билд-кеш, и как следствие, заставляем проект пересобираться "на холодную". Если проект большой, это может быть особенно критично. О том, как решать проблему buildSrc, можно почитать в статье от ребят из Badoo. (Спойлер - решается миграцией на композитный билд).

--------------------------------------------------------------------------------------------------------------------
7)Расскажите о settings.gradle.

Основная цель файла настроек — добавление подпроектов в вашу сборку.

Gradle поддерживает одиночные и многопроектные сборки.

Для сборок одного проекта файл настроек не является обязательным.

Для многопроектных сборок файл настроек является обязательным и объявляет все подпроекты.

Жизненный цикл сборки Gradle начинается с этапа инициализации, где файл настроек settings.gradle(.kts) находится в корневом каталоге вашего проекта.

Когда файл settings.gradle обнаружен, Gradle создает экземпляр объекта Settings.

Основная цель объекта Settings - позволить вам объявить все проекты, которые будут включены в сборку.

Скрипты настроек:
Скрипты настроек могут быть либо файлами settings.gradle на Groovy, либо файлами settings.gradle.kts на Kotlin.

Перед тем как Gradle соберет проекты для сборки, он создает экземпляр объекта Settings и выполняет для него скрипт настроек.

Настройки:
По мере выполнения скрипта настроек, он настраивает объект Settings. Таким образом, файл настроек фактически определяет объект Settings.

Объект Settings:
Объект Settings является частью API Gradle. Он предоставляет стандартный набор свойств и блоков верхнего уровня в скрипте настроек.

Часто используемые свойства включают buildCache, plugins, rootDir, rootProject и settings.

Стандартные свойства Settings:
Объект Settings предоставляет стандартные свойства, такие как buildCache, plugins, rootDir, rootProject и settings. Эти свойства часто используются в скрипте настроек.

Скрипты настроек:

Сценарии файла настроек представляют собой серию вызовов методов API Gradle, часто используя специальный синтаксис { … } в Groovy и Kotlin.

Сценарии файла настроек могут быть написаны с использованием краткого синтаксиса Groovy или Kotlin, и каждый элемент сценария вызывает метод объекта Settings в API Gradle.

--------------------------------------------------------------------------------------------------------------------
8)Расскажите build.gradle

Каждая сборка Gradle включает один или несколько проектов ; корневой проект и подпроекты .

Проект обычно соответствует программному компоненту, который необходимо создать, например библиотеке или приложению. Он может представлять собой JAR-файл библиотеки, веб-приложение или ZIP-файл дистрибутива, собранный из JAR-файлов, созданных другими проектами.

С другой стороны, это может представлять собой что-то, что необходимо сделать, например развертывание вашего приложения в промежуточной или производственной среде.

Скрипты Gradle написаны либо на Groovy DSL, либо на Kotlin DSL (предметно-ориентированный язык).

Сценарий сборки настраивает проект и связывается с объектом типа Project.

Стандартные свойства проекта:
name
path
description
dependencies
repositories
layout
group
version

В build.gradle можно описывать зависимости, плагины, добавление функциональности к задачам или задачи, указывать репозитории, создавать переменные.

--------------------------------------------------------------------------------------------------------------------
9)Задача, что это?

Задача представляет собой некую независимую единицу работы, которую выполняет сборка. Это может быть компиляция некоторых классов, создание JAR-файла, создание Javadoc или публикация некоторых архивов в репозиторий.

Когда пользователь запускается ./gradlew build в командной строке, Gradle выполнит build задачу вместе с любыми другими задачами, от которых она зависит

Существует два класса задач, которые можно выполнить:

К практическим задачам прикреплены некоторые действия, необходимые для выполнения работы в вашей сборке: compileJava.

Задачи жизненного цикла — это задачи без прикрепленных действий: assemble, build.

Обычно задачи жизненного цикла зависят от множества выполняемых задач и используются для одновременного выполнения многих задач.

Написание собственных задач:

tasks.register("hello") { //регистрация задачи
group = "Custom" //группа задач
description = "A lovely greeting task." // описание
doFirst{ // добавление логики в начало задачи
}
doLast { // добавление логики в конец задачи
println("Hello world!")
}
dependsOn tasks.hello //зависимость от задачи
}

dependsOn - зависимость от задачи, чтобы выполнить эту задачу, мы должны выполнить зависимую

tasks.named("hello") - поиск задач

--------------------------------------------------------------------------------------------------------------------
10)Копирование файлов

Вы копируете файл, создавая экземпляр встроенной задачи копирования Gradle и настраивая его с указанием местоположения файла и места, куда вы хотите его поместить. Этот пример имитирует копирование созданного отчета в каталог, который будет упакован в архив, например ZIP или TAR:

tasks.register('copyReport', Copy) {
from layout.buildDirectory.file("reports/my-report.pdf")
into layout.buildDirectory.dir("toArchive")
}

--------------------------------------------------------------------------------------------------------------------
11)Основные задачи

Задачи сборки

assemble: Собирает результаты этого проекта.
build: Собирает и тестирует этот проект.
buildDependents: Собирает и тестирует этот проект и все проекты, которые зависят от него.
buildNeeded: Собирает и тестирует этот проект и все проекты, от которых он зависит.
classes: Собирает основные классы.
clean: Удаляет директорию сборки.
jar: Собирает JAR-архив, содержащий основные классы.
testClasses: Собирает тестовые классы.

Настройка сборки

init: Инициализирует новую сборку Gradle.
wrapper: Генерирует файлы обертки Gradle.

Задачи документации

javadoc: Генерирует Javadoc API-документацию для основного исходного кода.

Задачи помощи

buildEnvironment: Отображает все зависимости скрипта сборки, объявленные в корневом проекте 'untitled3'.
dependencies: Отображает все зависимости, объявленные в корневом проекте 'untitled3'.
dependencyInsight: Отображает информацию о конкретной зависимости в корневом проекте 'untitled3'.
help: Отображает справочное сообщение.
javaToolchains: Отображает обнаруженные инструменты Java.
outgoingVariants: Отображает исходящие варианты корневого проекта 'untitled3'.
projects: Отображает подпроекты корневого проекта 'untitled3'.
properties: Отображает свойства корневого проекта 'untitled3'.
tasks: Отображает задачи, которые можно выполнить из корневого проекта 'untitled3'.

Задачи верификации

check: Запускает все проверки.
test: Запускает набор тестов.
--------------------------------------------------------------------------------------------------------------------
12)Конфигурация плагинов Gradle

Далее мы можем определить блок pluginManagement, где есть возможность сконфигурировать плагины, которые используются в нашем приложении.
Внутри блока pluginsесть возможность указать дефолтную версию для плагина, если не используется никакая другая. При этом эту версию можно брать извне, например, из gradle.properties:

val helloPluginVersion: String by settings

pluginManagement {
plugins {
id("com.example.hello") version "${helloPluginVersion}"
}
}

По умолчанию все наши плагины подключаются из gradlePluginPortal. Если же плагин необходимо достать из другого репозитория, в блоке repositories

В блоке resolutionStrategy мы можем определить правила для подключения плагинов, используемых проекте

--------------------------------------------------------------------------------------------------------------------
13)Создание собственных плагинов

Плагин — это любой класс, реализующий Pluginинтерфейс.

В приведенном ниже примере показан самый простой плагин — плагин «Привет, мир» :

build.gradle.kts
import org.gradle.api.Plugin
import org.gradle.api.Project

abstract class SamplePlugin : Plugin<Project> {
override fun apply(project: Project) {
project.tasks.create("SampleTask") {
println("Hello world!")
}
}
}
--------------------------------------------------------------------------------------------------------------------
14)Логирование

Gradle также предоставляет loggerсвойство для сценария сборки, которое является экземпляром Logger . Этот интерфейс расширяет интерфейс SLF4J Loggerи добавляет к нему несколько методов, специфичных для Gradle. Ниже приведен пример того, как это используется в сценарии сборки:

logger.quiet('An info log message which is always logged.')
logger.error('An error log message.')
logger.warn('A warning log message.')
logger.lifecycle('A lifecycle info log message.')
logger.info('An info log message.')
logger.debug('A debug log message.')
logger.trace('A trace log message.') // Gradle never logs TRACE level logs

--------------------------------------------------------------------------------------------------------------------
15)Скрипт инициализации

Как и сценарий сборки Gradle, сценарий инициализации представляет собой сценарий Groovy или Kotlin. С каждым сценарием инициализации связан экземпляр Gradle . Любая ссылка на свойство и вызов метода в сценарии инициализации будут делегированы этому Gradleэкземпляру.

Каждый сценарий инициализации также реализует интерфейс Script .

init.gradle

allprojects {
repositories {
mavenLocal()
}
}

--------------------------------------------------------------------------------------------------------------------
16)Что такое каталог версий?

Каталоги версий позволяют централизовать объявления зависимостей в libs.versions.tomlфайле.

Каталог упрощает обмен зависимостями и конфигурациями версий между подпроектами. Это также позволяет командам применять версии библиотек и плагинов в крупных проектах.

Каталог версий обычно содержит четыре раздела:

[версии] для объявления номеров версий, на которые будут ссылаться плагины и библиотеки.

[libraries] для определения библиотек, используемых в файлах сборки.

[bundles] для определения набора зависимостей.

[plugins] для определения плагинов.

Пример:
[versions]
androidGradlePlugin = "7.4.1"
mockito = "2.16.0"

[libraries]
google-material = { group = "com.google.android.material", name = "material", version = "1.1.0-alpha05" }
mockito-core = { module = "org.mockito:mockito-core", version.ref = "mockito" }

[plugins]
android-application = { id = "com.android.application", version.ref = "androidGradlePlugin" }
Файл находится в gradleкаталоге, поэтому Gradle и IDE могут автоматически использовать его. Каталог версий должен быть проверен в системе контроля версий: gradle/libs.versions.toml.

--------------------------------------------------------------------------------------------------------------------
17)Управление зависимостями Gradle?

Для подключения зависимостей в Gradle-проект существует два ключевых блока: repositoriesи dependencies.

repositories {
mavenCentral()
maven(url = "https://www.myrepo.io")
flatDir {
dirs("lib1", "lib2")
}
}

dependencies {
implementation(kotlin("stdlib"))
}

В блоке repositories определяем список репозиториев, в которые нужно сходить для загрузки зависимостей. Gradle предоставляет возможности использовать внешние репозитории, внутренние репозитории, и локальные в виде путей к папкам. Возможности для конфигурации здесь достаточно большие.
При поиске зависимостей Gradle осуществляет поиск по репозиториям в том порядке, в котором мы эти репозитории у себя объявили. Из этого вытекает, что репозитории с максимальным числом зависимостей стоит выносить в самый верх, и в целом стараться держать как можно меньше репозиториев.
Сами зависимости мы определяем в блоке dependencies. Здесь правило похожее - чем меньше, тем лучше.
В блоке buildscript определяются зависимости, которые необходимо загрузить и положить в classpath для их доступности на этапе конфигурации:

buildscript {
repositories { //... }
dependencies { classpath("com.android.tools.build:gradle:$agpVersion")
}
}

Для подключения зависимостей на этапе сборки, блоки dependencies и repositories добавляются в корень билдскрипта build.gradle

--------------------------------------------------------------------------------------------------------------------
18)Типы зависимостей Gradle

compileOnly — для зависимостей, которые необходимы для компиляции вашего производственного кода, но не должны быть частью пути к классам во время выполнения.

implementation(заменяет compile) — используется для компиляции и выполнения

runtimeOnly(заменяет runtime) — используется только во время выполнения, а не для компиляции.

testCompileOnly — то же самое, compileOnly за исключением тестов

testImplementation— тестовый эквивалент implementation

testRuntimeOnly— тестовый эквивалент runtimeOnly

--------------------------------------------------------------------------------------------------------------------
19)Разрешение конфликтов

Разрешение конфликта версий
Конфликт версий возникает, когда два компонента:

Зависят от одного и того же модуля, скажемcom.google.guava:guava

Но на разных версиях, скажем 20.0так и25.1-android

Сам наш проект зависит отcom.google.guava:guava:20.0

Наш проект также зависит от того com.google.inject:guice:4.2.2, от чего зависит самcom.google.guava:guava:25.1-android

Стратегия разрешения
Учитывая описанный выше конфликт, существует несколько способов его разрешения: либо путем выбора версии, либо путем отказа от разрешения. Различные инструменты управления зависимостями имеют разные способы разрешения конфликтов такого типа.

Gradle рассмотрит все запрошенные версии, где бы они ни появлялись в графе зависимостей. Из этих версий он выберет самую высокую

--------------------------------------------------------------------------------------------------------------------
20)Инкрементная сборка

В рамках инкрементальной сборки Gradle проверяет, изменились ли какие-либо входные или выходные данные задачи с момента последней сборки. Если это не так, Gradle может считать задачу актуальной и, следовательно, пропустить выполнение ее действий. Также обратите внимание, что инкрементальная сборка не будет работать, если задача не имеет хотя бы одного выходного сигнала, хотя обычно у задач также есть хотя бы один входной параметр.

Для авторов сборок это означает просто: вам нужно указать Gradle, какие свойства задачи являются входными, а какие — выходными. Если свойство задачи влияет на выходные данные, обязательно зарегистрируйте его как входное, иначе задача будет считаться актуальной, если это не так. И наоборот, не регистрируйте свойства в качестве входных данных, если они не влияют на выходные данные, иначе задача потенциально будет выполнена, когда в этом нет необходимости. Также будьте осторожны с недетерминированными задачами, которые могут генерировать разные выходные данные для одних и тех же входных данных: их не следует настраивать для инкрементной сборки, поскольку проверки на актуальность не будут работать.

Прежде чем задача будет выполнена в первый раз, Gradle снимает отпечатки входных данных. Этот отпечаток содержит пути к входным файлам и хэш содержимого каждого файла. Затем Gradle выполняет задачу. Если задача завершается успешно, Gradle снимает отпечатки выходных данных. Этот отпечаток содержит набор выходных файлов и хэш содержимого каждого файла. Gradle сохраняет оба отпечатка пальца при следующем выполнении задачи.

Каждый раз после этого, перед выполнением задачи, Gradle снимает новый отпечаток входных и выходных данных. Если новые отпечатки пальцев такие же, как и предыдущие, Gradle предполагает, что выходные данные актуальны, и пропускает задачу. Если они не совпадают, Gradle выполняет задачу. Gradle сохраняет оба отпечатка пальца при следующем выполнении задачи.

--------------------------------------------------------------------------------------------------------------------
21)Кеш

Кэш сборки Gradle — это механизм кэширования, целью которого является экономия времени за счет повторного использования результатов, полученных в результате других сборок. Кэш сборки работает, сохраняя (локально или удаленно) выходные данные сборки и позволяя сборкам извлекать эти выходные данные из кеша, когда определяется, что входные данные не изменились, что позволяет избежать дорогостоящей работы по их повторному созданию.

Первой функцией, использующей кэш сборки, является кэширование вывода задач . По сути, кэширование выходных данных задачи использует тот же интеллект, что и проверки актуальности , которые Gradle использует, чтобы избежать работы, когда предыдущая локальная сборка уже создала набор выходных данных задачи. Но вместо того, чтобы ограничиваться предыдущей сборкой в ​​той же рабочей области, кэширование выходных данных задачи позволяет Gradle повторно использовать выходные данные задачи из любой более ранней сборки в любом месте на локальном компьютере. При использовании общего кэша сборки для кэширования выходных данных задачи это работает даже на компьютерах разработчиков и агентах сборки.

Помимо задач, преобразования артефактов также могут использовать кэш сборки и повторно использовать свои выходные данные аналогично кэшированию выходных данных задачи.

--------------------------------------------------------------------------------------------------------------------
22)Gradle в сравнении с Maven

Существуют некоторые фундаментальные различия в подходе этих двух систем к сборке. Gradle основан на графе зависимостей задач, в котором задачи — это то, что выполняет работу, в то время как Maven основан на фиксированной и линейной модели фаз. В Maven цели привязываются к фазам проекта, и цели выполняют ту же функцию, что и задачи в Gradle, являясь "элементами, которые выполняют работу".

С точки зрения производительности, обе программы позволяют параллельно выполнять многомодульные сборки. Однако Gradle позволяет выполнять инкрементные сборки, поскольку проверяет, какие задачи обновлены, а какие нет. Если это так, то задача не выполняется, что дает вам гораздо меньшее время сборки. Другие отличительные особенности производительности, которые можно найти в Gradle, включают:

Инкрементная компиляция для классов Java
Избегание компиляции для Java
Использование API для инкрементальных подзадач
Демон компилятора, который также значительно ускоряет компиляцию.

Что касается управления зависимостями, то и Gradle, и Maven могут работать с динамическими и переходными зависимостями, использовать сторонние кэши зависимостей и читать формат метаданных POM. Вы также можете объявлять версии библиотек через центральное определение версий и обеспечивать централизованное версионирование. Оба продукта загружают переходные зависимости из своих репозиториев артефактов. Maven имеет Maven Central, а Gradle — JCenter, кроме того, вы можете определить свой собственный репозиторий компании. Если требуется несколько зависимостей, Maven может загружать их одновременно.

Gradle, однако, выигрывает, когда речь идет о зависимостях API и реализации, а также о возможности одновременного безопасного кэширования. Он также хранит метаданные репозитория вместе с кэшированными зависимостями, гарантируя, что два или более проектов, использующих один и тот же кэш, не перезапишут друг друга, а также имеет кэш на основе контрольной суммы и может синхронизировать кэш с репозиторием. Кроме того, Gradle совместим с IVY Metadata, что позволяет определять пользовательские правила для указания версии для динамической зависимости и разрешать конфликты версий. Эти возможности недоступны в Maven.

Ниже приведены другие возможности управления зависимостями, которые вы можете найти только в Gradle:

Использование правил подстановки для совместимых библиотек
Использование правил ReplacedBy
Более качественное управление метаданными
Возможность динамической замены проектных зависимостей на внешние и наоборот.

Gradle также облегчает работу с составными сборками, позволяя работать со специальными и постоянными составными сборками, а также объединять различные сборки и импортировать составную сборку в Eclipse или IntelliJ IDEA.

Что касается моделей выполнения, то обе имеют группы задач и описания. Обе позволяют собирать только указанный проект и его зависимости. Gradle, однако, имеет полностью настраиваемую DAG, в то время как в Maven цель может быть привязана только к одной другой цели. Несколько целей имеют форму упорядоченного списка. Gradle также позволяет исключать задачи, делать переходные исключения и определять зависимости между задачами. По сравнению с другими решениями Gradle также имеет расширенные возможности для упорядочивания задач и финализаторов.

Администрирование инфраструктуры сборки - еще одна сильная сторона Gradle, поскольку он использует обертки, позволяющие автоматическую инициализацию, в то время как для Maven необходимо расширение для поддержки самостоятельной инициализации сборок. Gradle также позволяет настраивать среды сборки на основе версий без необходимости настраивать их вручную. Он также допускает создание пользовательских дистрибутивов.

--------------------------------------------------------------------------------------------------------------------
23)Как выбрать между Maven и Gradle?

В целом, оба инструмента имеют свои сильные и слабые стороны.

Индивидуальные сборки. С помощью Maven вы можете легко определить метаданные и зависимости вашего проекта, но создание очень индивидуальной сборки может стать кошмаром для пользователей Maven. Файл POM может легко раздуться по мере роста проекта и впоследствии превратиться в нечитаемый XML-файл.

Управление зависимостями и структура каталогов. Тем не менее, Maven обеспечивает простое, но эффективное управление зависимостями, а поскольку он имеет структуру каталогов для ваших проектов, у вас есть своего рода стандартная схема для всех ваших проектов. Он использует декларативный XML-файл для своего POM-файла и имеет множество плагинов, которые вы можете использовать. Gradle использует структуру каталогов, которую вы видите в Maven, но она может быть настроена. Он также использует тот же формат GAV, который Maven использует для идентификации артефактов.

Плагины и интеграции. Maven также поддерживает широкий спектр этапов жизненного цикла сборки и легко интегрируется со сторонними инструментами, такими как CI-серверы, плагины покрытия кода, системы репозиториев артефактов и др. Что касается плагинов, то в настоящее время количество доступных плагинов растет, и есть крупные поставщики, у которых есть плагины, совместимые с Gradle. Тем не менее, количество доступных плагинов для Maven все еще больше, чем для Gradle.

Гибкость. Gradle, с другой стороны, очень гибкий и основан на скрипте. Пользовательские сборки было бы легко делать на Gradle. Однако, поскольку Gradle практически недавно появился, количество разработчиков, знающих Gradle изнутри, может быть ограничено.

В конечном счете, выбор будет зависеть в первую очередь от того, что вам нужно. Gradle более мощный. Однако бывает так, что вам не нужно большинство возможностей и функций, которые он предлагает. Maven может подойти для небольших проектов, а Gradle — для более крупных.
