<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Вопросы по собеседованию</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .question-block {
            cursor: pointer;
            transition: background-color 0.3s ease;
            word-break: break-word;
        }
        .question-block:hover {
            background-color: #f3f4f6;
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen">

<!-- Контейнер с вопросом -->
<div id="question-container" class="bg-white shadow-lg rounded-lg p-6 w-[800px] h-[750px] flex items-center justify-center text-center relative">
    <div id="question-block" class="question-block p-4 border-b w-full h-full flex items-center justify-center text-center relative" onclick="toggleAnswer()">
        <strong class="text-lg block" id="question-text"></strong>
        <div id="answer-text" class="text-gray-700 hidden" onclick="toggleAnswer()"></div>
    </div>
</div>

<!-- Навигация -->
<div class="absolute bottom-10 flex justify-center gap-4">
    <button onclick="prevQuestion()" class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600">Назад</button>
    <button onclick="location.href='main.html'" class="bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600">На главную</button>
    <button onclick="nextQuestion()" class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600">Вперед</button>
</div>

<!-- Модальное окно -->
<div id="modal" class="fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 hidden">
    <div class="bg-white p-6 rounded-lg shadow-lg w-[900px] h-[800px] overflow-y-auto">
        <h2 class="text-lg font-semibold mb-4">Ответ</h2>
        <p id="modal-answer" class="text-gray-700"></p>
        <button onclick="closeModal()" class="mt-4 bg-red-500 text-white px-4 py-2 rounded hover:bg-red-600 w-full">Закрыть</button>
    </div>
</div>

<script>
    let currentQuestionIndex = 0;
    const MAX_ANSWER_LENGTH = 2000; // Максимальная длина ответа для отображения без модального окна

    const questions = [
        {
  question: "Что такое Spring Boot Actuator?",
  answer: "Spring Boot Actuator является подпроектом (sub-project) в проекте Spring Boot. Он построен для собрания и мониторинга инфомации приложения. Вы можете внедрить его в свое приложение и использовать его свойства. Для мониторинга приложения вам нужно получить доступ в endpoint (Конечные точки) построенные в Spring Boot Actuator, одновременно, вы можете создать свои отдельные endpoint если хотите."
}
,{
  question: "Что делает endpoint /health?",
  answer: "Конечная точка health даёт общий статус приложения: запущено и работает или нет. Это очень важно для мониторинга состояния приложения, когда оно находится в продакшене. Эта конечная точка может быть интегрирована с приложениями мониторинга и будет очень полезна для определения работоспособности приложений в реальном времени.Объем информации, предоставляемой конечной точкой health, зависит от свойства management.endpoint.health.show-details в файле application.properties.Если management.endpoint.health.show-details=never, то никакая дополнительная информация не отображается.Если management.endpoint.health.show-details=always, то дополнительная информация показывается всем пользователям.Если management.endpoint.health.show-details=when-authorized, то дополнительная информация будет показана только авторизованным пользователям.{<br>'status': 'UP',<br>'details':<br>{ 'diskSpace':<br>{ 'status': 'UP',<br>'details': {<br>'total': 75812040704,<br>'free': 8067600384,<br>'threshold': 10485760<br>}<br>}<br>}<br>}"
}
,{
  question: "Преднастроенные индикаторы в Spring Boot Actuator",
  answer: "Spring Boot Actuator имеет множество автоматически настроенных 'индикаторов здоровья' (HeathIndicators)для проверки работоспособности различных частей приложения. Например, DiskspaceHealthIndicator предоставляет информацию о дисковом пространстве. Если вы используете MongoDB, то MongoHealthIndicator проверит работоспособность БД Mongo (запущен сервер или нет) и отобразит соответствующую информацию. По умолчанию окончательный статус приложения определяет HealthAggregator, который просто сортирует список статусов, предоставленных каждым HealthIndicator. Первый статус в отсортированном списке используется как окончательный статус приложения."
}
,{
  question: "Как написать свой индикатор?",
  answer: "Наряду со встроенными HealthIndicator, предоставляемыми Spring Boot Actuator, мы можем создавать собственные индикаторы состояния. Для этого вам нужно создать класс, который реализует интерфейс HealthIndicator, реализовать его метод health() и вернуть Health в качестве ответа с соответствующей информацией,"
}
,{
  question: "Что делает endpoint /info?",
  answer: "Конечная точка info предоставляет общую информацию о приложении, которую она получает из файлов, таких как build-info.properties или git.properties, или из свойств, указанных в application.properties.Spring Boot Actuator отображает информацию о сборке, если присутствует файл META-INF/build-info.properties. Этот файл с информацией о проекте создается время сборки целью build-info. Здесь также можно добавить произвольное количество дополнительных свойств."
}
,{
  question: "Что делает endpoint /beans?",
  answer: "Конечная точка beans показывает все бины, определенные в Spring-контейнере со следующей информацией о каждом бине:aliases : названия всех псевдонимов<br>scope : область видимости<br>type : полное имя бина<br>resource : ресурс (класс), в котором определён бин<br>dependencies : имена зависимых бинов"
}
,{
  question: "Что делает endpoint /configprops?",
  answer: "Конечная точка configProps показывает все бины, аннотированные @ConfigurationProperties."
}
,{
  question: "Что делает endpoint /env?",
  answer: "Конечная точка env предоставляет всю информацию, относящуюся ксистемное окружение или переменные окружения (зависит от операционной системы (зависит от платформы)),настройки уровня приложения (определены вapplication.properties)"
}
,{
  question: "Что делает endpoint /heapdump?",
  answer: "Конечная точка heapdump делает дамп кучи приложения. Эта конечная точка возвращает двоичные данные в формате HPROF. Поскольку обычно возвращается много данных, вы должны их сохранить и проанализировать."
}
,{
  question: "Что делает endpoint /loggers?",
  answer: "Конечная точка loggers предоставляет логгеры приложения с информацией об их настроенном уровне логирования (configuredLevel) и эффективном уровне (effectiveLevel). Если для логера и его родителя настроенный уровень не указан (null), то эффективным уровнем будет уровень корневого логера."
}
,{
  question: "Что делает endpoint /metrics?",
  answer: "Конечная точка metrics показывает все метрики, которые вы можете отслеживать для вашего приложения.{ 'names':<br>[ 'jvm.memory.committed',<br>'jvm.buffer.memory.used',<br>'jvm.buffer.count',<br>'logback.events',<br>'process.uptime',<br>'jvm.memory.max',<br>'jvm.memory.used',<br>'jvm.buffer.total.capacity',<br>'system.cpu.count',<br>'process.start.time'<br>]<br>}И вы можете посмотреть информацию определенного metric.actuator/metrics/{requiredMetricName}"
}
,
    ];

    const questionText = document.getElementById('question-text');
    const answerText = document.getElementById('answer-text');
    const modal = document.getElementById('modal');
    const modalAnswer = document.getElementById('modal-answer');

    function toggleAnswer() {
        const answer = questions[currentQuestionIndex].answer;
        if (answer.length > MAX_ANSWER_LENGTH) {
            showModal(answer);
        } else {
            if (answerText.classList.contains('hidden')) {
                answerText.innerHTML = answer;
                answerText.classList.remove('hidden');
                questionText.classList.add('hidden');
            } else {
                answerText.classList.add('hidden');
                questionText.classList.remove('hidden');
            }
        }
    }

    function showModal(answer) {
        modalAnswer.innerHTML = answer;
        modal.classList.remove('hidden');
    }

    function showQuestion(index) {
        questionText.textContent = questions[index].question;
        answerText.innerHTML = ""; // Скрываем ответ при смене вопроса
        questionText.classList.remove('hidden');
        answerText.classList.add('hidden');
    }

    function nextQuestion() {
        if (currentQuestionIndex < questions.length - 1) {
            currentQuestionIndex++;
            showQuestion(currentQuestionIndex);
        }
    }

    function prevQuestion() {
        if (currentQuestionIndex > 0) {
            currentQuestionIndex--;
            showQuestion(currentQuestionIndex);
        }
    }

    function closeModal() {
        modal.classList.add('hidden');
    }

    showQuestion(currentQuestionIndex);
</script>

</body>
</html>
