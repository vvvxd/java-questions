<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Вопросы по собеседованию</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .question-block {
            cursor: pointer;
            transition: background-color 0.3s ease;
            word-break: break-word;
        }
        .question-block:hover {
            background-color: #f3f4f6;
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen">

<!-- Контейнер с вопросом -->
<div id="question-container" class="bg-white shadow-lg rounded-lg p-6 w-[800px] h-[750px] flex items-center justify-center text-center relative">
    <div id="question-block" class="question-block p-4 border-b w-full h-full flex items-center justify-center text-center relative" onclick="toggleAnswer()">
        <strong class="text-lg block" id="question-text"></strong>
        <div id="answer-text" class="text-gray-700 hidden" onclick="toggleAnswer()"></div>
    </div>
</div>

<!-- Навигация -->
<div class="absolute bottom-10 flex justify-center gap-4">
    <button onclick="prevQuestion()" class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600">Назад</button>
    <button onclick="location.href='main.html'" class="bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600">На главную</button>
    <button onclick="nextQuestion()" class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600">Вперед</button>
</div>

<!-- Модальное окно -->
<div id="modal" class="fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 hidden">
    <div class="bg-white p-6 rounded-lg shadow-lg w-[900px] h-[800px] overflow-y-auto">
        <h2 class="text-lg font-semibold mb-4">Ответ</h2>
        <p id="modal-answer" class="text-gray-700"></p>
        <button onclick="closeModal()" class="mt-4 bg-red-500 text-white px-4 py-2 rounded hover:bg-red-600 w-full">Закрыть</button>
    </div>
</div>

<script>
    let currentQuestionIndex = 0;
    const MAX_ANSWER_LENGTH = 2000; // Максимальная длина ответа для отображения без модального окна

    const questions = [
        {
  question: "Что такое Логирование?",
  answer: "Логирование Java — это процесс, при котором программа на Java-языке записывает сведения о своем исполнении в некий файл или базу данных. Логирование дает возможность отслеживать ход исполнения программы и конкретно кода."
}
,{
  question: "Какие существуют типы логов?",
  answer: "системы (System);<br>безопасности (Security);<br>приложения (Application, Buisness).Пользователь входит в приложение, проверяется пароль. Это действие относится к безопасности (Security). Дальше он запускает какой-нибудь модуль. Это событие уровня приложения (Application). Модуль при старте обращается к другому модулю за какими-то дополнительными данными, производит какие-либо еще вызовы - это уже системные действия (System)."
}
,{
  question: "Для чего нужно логирование?",
  answer: "По сути логирование - это то, что позволяет следить за ходом выполнения вашего приложения, вашего кода.<br>При работе приложения надо понимать, что вообще происходит внутри, особенно при разборе ошибок и инцидентов. В этом как раз и помогают логи - это как запись черного ящика на самолетах.<br>Нет информации о происходящих событий в приложении - мы ничего не знаем о том, что происходит. И если такое поведение может устраивать в случае, когда все идеально работает (да и то сомнительно), то во всех остальных случаях такое поведение категорически не устраивает никого.<br>Поэтому 'логи всякие нужны, логи всякие важны'."
}
,{
  question: "Что такое уровни логирования?",
  answer: "Для того, чтоб как-то ранжировать логи, нужно было дать определенные обозначения и разграничения. Для этого ввели уровни логирования. Уровень задается в приложении. Если запись относится к уровню ниже обозначенного, она не вносится в лог. Например, у нас есть логи, с помощью которых дебажат приложение. В нормальной работе на продакшене (когда приложение используют по назначению), такие логи не нужны. Поэтому уровень логирования будет выше, чем для дебага."
}
,{
  question: "Перечислите уровни журналирования? Назовите порядок их приоритетности.",
  answer: "OFF: никакие логи не записываются, все будут проигнорированы;<br>FATAL: ошибка, после которой приложение уже не сможет работать и будет остановлено, например, JVM out of memory error;<br>ERROR: уровень ошибок, когда есть проблемы, которые нужно решить. Ошибка не останавливает работу приложения в целом. Остальные запросы могут работать корректно;<br>WARN: обозначаются логи, которые содержат предостережение. Произошло неожиданное действие, несмотря на это система устояла и выполнила запрос;<br>INFO: лог, который записывает важные действия в приложении. Это не ошибки, это не предостережение, это ожидаемые действия системы;<br>DEBUG: логи, необходимые для отладки приложения. Для уверенности в том, что система делает именно то, что от нее ожидают, или описания действия системы: 'method1 начал работу';<br>TRACE: менее приоритетные логи для отладки, с наименьшим уровнем логирования;<br>ALL: уровень, при котором будут записаны все логи из системы.OFF< TRACE< DEBUG< INFO< WARN< ERROR< FATAL< ALL"
}
,{
  question: "Что нужно логировать?",
  answer: "Разумеется, логировать все подряд не стоит. Иногда это и не нужно, и даже опасно. Например, если залогировать чьи-то личные данные и это каким-то образом всплывет на поверхность, будут реальные проблемы, особенно на проектах, ориентированных на Запад. Но есть и то, что логировать обязательно:Начало/конец работы приложения. Нужно знать, что приложение действительно запустилось, как мы и ожидали, и завершилось так же ожидаемо.Вопросы безопасности. Здесь хорошо бы логировать попытки подбора пароля, логирование входа важных юзеров и т.д.Некоторые состояния приложения. Например, переход из одного состояния в другое в бизнес процессе.Некоторая информация для дебага, с соответственным уровнем логирования.Некоторые SQL скрипты. Есть реальные случаи, когда это нужно. Опять-таки, умелым образом регулируя уровни, можно добиться отличных результатов.<br>Выполняемые нити(Thread) могут быть логированы в случаях с проверкой корректной работы."
}
,{
  question: "Популярные ошибки в логировании?",
  answer: "Нюансов много, но можно выделить несколько частых ошибок:Избыток логирования. Не стоит логировать каждый шаг, который чисто теоретически может быть важным. Есть правило: логи могут нагружать работоспособность не более, чем на 10%. Иначе будут проблемы с производительностью.Логирование всех данных в один файл. Это приведет к тому, что в определенный момент чтение/запись в него будет очень сложной, не говоря о том, что есть ограничения по размеру файлов в определенных системах.Использование неверных уровней логирования. У каждого уровня логирования есть четкие границы, и их стоит соблюдать. Если граница расплывчатая, можно договориться какой из уровней использовать."
}
,{
  question: "Что такое Logger?",
  answer: "Логер - это объект, область ответственности которого - вывод данных в лог и управление уровнем (детализацией) этого вывода.<br>Логер создается с помощью фабрики и на этапе создания ему присваивается имя. Имя может быть любым, но по стандарту имя должно быть сопряжено с именем класса, в котором вы собираетесь что-то логировать:<br>Logger logger = LoggerFactory.getLogger(SomeClass.class.getName());Это дает нам имя логера в виде: ru.aarexer.example.SomeClass.Почему так рекомендуется делать?<br>Потому что важным свойством логгеров является то, что они организованы иерархично. Каждый логгер имеет имя, описывающее иерархию, к которой он принадлежит. Разделитель - точка. Принцип полностью аналогичен формированию имени пакета в Java.<br>Получается выстраивается следующая иерархия логеров:root <- ru <- aarexer <- example <- SomeClassИ каждому логеру можно выставить свой уровень. Установленный логгеру уровень вывода распространяется на все его дочерние логгеры, для которых явно не выставлен уровень.<br>При этом во главе иерархии логеров всегда стоит некотрый дефолтный рутовый(корневой) логер.<br>Поэтому у всех логеров будет уровень логирования, даже если явно мы не прописали для ru.aarexer.example.SomeClass его, то он унаследуется от рутового."
}
,{
  question: "Мы установили рутовый уровень в INFO, а ru.aarexer в DEBUG, остальным в иерархии уровень не назначен, т.е:Логер root ru ru.aarexer ru.aarexer.exampleЛогер Назначенный уровеньroot -> INFOru -> Не назначенru.aarexer -> DEBUGru.aarexer.example -> Не назначен",
  answer: "Какой у какого логера будет уровень логирования?Вспоминаем, что, если уровень логирования не назначен для логера, то он унаследует его от родительского, смотрим на иерархию:<br>root <- ru <- aarexer <- example<br>И получаем ответ:Logger -> Назначенный уровень-> Уровень, который будетroot -> Все сообщения -> INFO<br>ru -> Не назначен -> INFO<br>ru.aarexer -> DEBUG -> DEBUG<br>ru.aarexer.example -> Не назначен -> DEBUGПодход с иерархией логеров очень гибкий - можно для всех выставить требуемый уровень, например, ERROR, а для необходимых логеров его менять, причем как в сторону понижения, так и в сторону повышения уровня."
}
,{
  question: "Что такое Appender?",
  answer: "Аппендер - это та точка, куда события приходят в конечном итоге. Это может быть файл, БД, консоль, сокет и т.д.Здесь нас никто не ограничивает - можно написать свой аппендер, который пишет сообщения куда-угодно.<br>Получается у нас есть две точки, первая - это логгер, это начало пути, вторая - аппендер, это уже конечная точка.Логеры и аппендеры связаны в отношении many-to-many.У одного логгера может быть несколько аппендеров, а к одному аппендеру может быть привязано несколько логгеров.Логеры при этому наследуют от родительских не только уровни логирования, но и аппендеры.<br>Например, если к root-логгеру привязан аппендер A1, а к логгеру ru.aarexer - A2, то вывод в логгер ru.aarexer попадет в A2 и A1, а вывод в ru - только в A1."
}
,{
  question: "Пусть у нас есть несколько аппендеров и логеров",
  answer: "Logger Appender<br>root -> А1<br>ru.aarexer -> А2<br>ru.aarexer.example.SomeClass -> А3В какой аппендер попадет лог-сообщение:<br>LoggerFactory.getLogger(SomeClass.class.getName()).info('hello');У логеров есть такое свойство как additivity. По умолчанию она установлена в true.<br>Это говорит о том, что логер-наследник будет свои события передавать логеру-родителю.<br>Смотрим на иерархию:<br>root <- ru <- aarexer <- example<br>Из всего вышесказанного делаем вывод, что событие 'hello' с уровнем Level.INFO попадет во все три аппендера.Но такое наследование аппендеров можно отключить через конфигурацию, для этого стоит посмотреть в сторону выставления флага additivity='false' на логгерах."
}
,{
  question: "Что такое Layout?",
  answer: "Layout - это формат вывода данных.<br>Т.е как лог-сообщения будут отформативарованы, соответственно тут у каждой библиотеки свой набор доступных форматов.<br>Теперь пришла пора посмотреть - что вообще есть в Java."
}
,{
  question: "Что такое Apache log4j?",
  answer: "Это самая первая библиотека логирования, появилась еще в 1999 году.<br>Конфигурируется через xml, либо через properties.<br>Поддерживает большое количество способов вывода логов: от консоли и файла до записи в БД.<br>Также имеет поддержку обширного формата логирования: от обычного текстового вывода до html.<br>Именно он ввел понятие appender - кто пишет в лог, layout - форматирование. В конфигурации задаются эти самые appender-ы и какого уровня сообщения попадают к какому appender-у.<br>Ввел соответствие иерархичности категорий и пакетов: например, можно логгировать все сообщения из org.hibernate и заглушить всё из org.hibernate.type.Проект сейчас не развивается и по сути заброшен, с версией Java 9 уже не совместим.<br>Поэтому на данный момент рекомендуется использовать log4j2, о котором речь пойдет ниже."
}
,{
  question: "Что такое Logback?",
  answer: "Logback - одна из наиболее широко используемых сред ведения журналов в сообществе Java. Logback написал тот же разработчик, что и log4j, чтобы создать ему преемника. В основе была та же идея, что и в log4j. Отличия были в том, что в logback:улучшена производительность;добавлена нативная поддержка slf4j;расширена опция фильтрации.Стандартно logback не требует каких-либо настроек и записывает все логи начиная от уровня DEBUG и выше. Если нужна настройка, ее можно выполнить через xml конфигурацию:<configuration> <appender name='FILE' class='ch.qos.logback.core.FileAppender'> <file>app.log</file> <br><encoder> <br><pattern>%d{HH:mm:ss,SSS} %-5p [%c] - %m%n</pattern> <br></encoder> <br></appender> <logger name='org.hibernate.SQL' level='DEBUG' /> <br><logger name='org.hibernate.type.descriptor.sql' level='TRACE' /> <root level='info'><br> <appender-ref ref='FILE' /> <br></root> <br></configuration>"
}
,{
  question: "Что такое SLF4J?",
  answer: "SLF4J является оберткой над logback, а также над JUL, log4j, или JCL, а также над любым логгером, который реализует ее интерфейс.<br>Для работы с SLF4J нужны библиотека slf4j-api-1.x.x.jar и реализация одного из логгеров либо заглушка. Как правило реализации всех логгеров ( кроме logback) поставляются вместе с SLF4J и имеют названия на подобии slf4j-jcl-1.x.jar, slf4j-log4j12-1.x.jar, slf4j-nop-1.x.jar и т.п.<br>Если в classpath не будет найдена реализация логгера ( или заглушка nop) SLF4J гневно ругнется и работать откажется. Конфигурация соответственно будет искаться в зависимости от положенной в classpath реализации.<br>В идеальном мире мы должны выводить сообщения через интерфейс обертки, и тогда у нас все будет хорошо, но реальный жестокий мир говорит о том, что всем нам приходится взаимодействовать со сторонними библиотеками или кодом, в которых используются другие логгеры и которые знать не знают о SLF4J. Что бы не подстраиваться под каждый логгер, а пустить все сообщения через одну реализацию интерфейса SLF4J, можно использовать bridging. В поставке обертки содержаться библиотеки jcl-over-slf4j.jar, log4j-over-slf4j.jar и jul-to-slf4j.jar, которые переопределяют поведение соответствующих логгеров и перенаправляют сообщения в обертку."
}
,
    ];

    const questionText = document.getElementById('question-text');
    const answerText = document.getElementById('answer-text');
    const modal = document.getElementById('modal');
    const modalAnswer = document.getElementById('modal-answer');

    function toggleAnswer() {
        const answer = questions[currentQuestionIndex].answer;
        if (answer.length > MAX_ANSWER_LENGTH) {
            showModal(answer);
        } else {
            if (answerText.classList.contains('hidden')) {
                answerText.innerHTML = answer;
                answerText.classList.remove('hidden');
                questionText.classList.add('hidden');
            } else {
                answerText.classList.add('hidden');
                questionText.classList.remove('hidden');
            }
        }
    }

    function showModal(answer) {
        modalAnswer.innerHTML = answer;
        modal.classList.remove('hidden');
    }

    function showQuestion(index) {
        questionText.textContent = questions[index].question;
        answerText.innerHTML = ""; // Скрываем ответ при смене вопроса
        questionText.classList.remove('hidden');
        answerText.classList.add('hidden');
    }

    function nextQuestion() {
        if (currentQuestionIndex < questions.length - 1) {
            currentQuestionIndex++;
            showQuestion(currentQuestionIndex);
        }
    }

    function prevQuestion() {
        if (currentQuestionIndex > 0) {
            currentQuestionIndex--;
            showQuestion(currentQuestionIndex);
        }
    }

    function closeModal() {
        modal.classList.add('hidden');
    }

    showQuestion(currentQuestionIndex);
</script>

</body>
</html>
