### Что такое тесты и зачем они нужны?
**Тесты** — это инструменты для проверки качества кода. Их основная цель — убедиться, что программа работает как задумано, находить ошибки (дефекты) и защищать код от поломок в будущем (регрессии).

---

### Пирамида тестирования и основные виды тестов
Это метафора, описывающая идеальное соотношение тестов в проекте:

*   **Модульные (Unit) тесты (основание пирамиды):** Проверяют самую маленькую, изолированную часть кода (метод, класс). Их должно быть больше всего.
*   **Интеграционные тесты (середина):** Проверяют взаимодействие нескольких модулей друг с другом или с внешними системами (БД, API). Их меньше, чем модульных.
*   **UI-тесты / E2E-тесты (вершина):** Проверяют систему целиком через пользовательский интерфейс. Они самые медленные и хрупкие, поэтому их должно быть меньше всего.

---

### Unit-тесты (Модульные тесты)
Это автоматизированные тесты, которые являются фундаментом качественного кода.

**Зачем они нужны:**
*   **Защита от регрессии:** Помогают убедиться, что новые изменения не сломали старый функционал.
*   **Исполняемая документация:** Хорошо названные тесты объясняют, как должен работать код.
*   **Улучшение архитектуры:** Код, который легко тестировать, обычно имеет более простую и слабую связанность.
*   **Скорость:** Выполняются за миллисекунды, позволяя быстро получать обратную связь.

**Характеристики хорошего Unit-теста (FIRST):**
*   **Быстрый (Fast):** Выполняется очень быстро.
*   **Изолированный (Isolated):** Не зависит от внешних систем (БД, сети, файлов).
*   **Повторяемый (Repeatable):** Всегда дает одинаковый результат при одинаковых условиях.
*   **Самопроверяемый (Self-validating):** Тест сам определяет, пройден он или нет.
*   **Уместный (Timely):** Написание теста не должно занимать значительно больше времени, чем написание самого кода.

**Шаблоны написания тестов:**
*   **AAA (Arrange, Act, Assert):**
    *   **Arrange (Подготовка):** Создание объектов и настройка условий.
    *   **Act (Действие):** Вызов тестируемого метода.
    *   **Assert (Проверка):** Сравнение полученного результата с ожидаемым.
*   **BDD (Given, When, Then):**
    *   **Given (Дано):** Начальное состояние.
    *   **When (Когда):** Происходит событие.
    *   **Then (Тогда):** Проверяется ожидаемый результат. (Фокусируется на поведении системы).

---

### Тестовые двойники (Mocks, Stubs и др.)
Это "объекты-заглушки", которые заменяют реальные зависимости в тестах.

*   **Dummy:** "Пустышка", передается в метод, но не используется.
*   **Fake:** Упрощенная, но рабочая реализация (например, база данных в памяти).
*   **Stub:** "Заглушка", которая на предопределенный вызов возвращает заранее заданный ответ. Проверяет **состояние**.
*   **Mock:** "Шпион", который не только может возвращать ответы, но и отслеживает, как с ним взаимодействовали (сколько раз вызвали, с какими параметрами). Проверяет **поведение**.

**Ключевое отличие Stub от Mock:**
*   **Stub** используется, чтобы "подсунуть" данные в тест.
*   **Mock** используется, чтобы проверить, что тестируемый объект правильно **взаимодействует** со своими зависимостями.

---

### Ключевые подходы и термины
*   **TDD (Test-Driven Development):** Подход к разработке "через тестирование". Цикл:
    1.  **Написать падающий тест** (Red).
    2.  **Написать минимальный код**, чтобы тест прошел (Green).
    3.  **Улучшить код** (Refactor).
*   **Покрытие кода (Test Coverage):** Метрика, показывающая, какой процент кода был выполнен во время тестов. Чтобы обеспечить хорошее покрытие, нужно тестировать:
    *   Нормальные (позитивные) сценарии.
    *   Граничные значения и ошибки (например, выход за пределы массива).
    *   Пустые или `null` входные данные.
*   **Фикстуры (Fixtures):** Подготовленное, известное состояние среды (объекты, данные в БД), необходимое для запуска теста.
*   **Автоматизация:** В первую очередь автоматизируют **регрессионное**, **нагрузочное** и **кросс-браузерное** тестирование, так как это избавляет от рутинных и многократных проверок.

---

### Автоматизация и типы тестирования

*   **Автоматизация:** В первую очередь автоматизируют **регрессионное тестирование** — проверку того, не сломалась ли уже работающая функциональность после внесения изменений в код.
*   **Когда писать тесты:** Рекомендуется писать тесты для стабильных, уже протестированных и критически важных частей программы (модулей), от которых зависит другой функционал.

**Основные типы тестирования:**
*   **Функциональное:** Проверяет, что каждая отдельная функция системы работает согласно требованиям.
*   **Интеграционное:** Тестирует взаимодействие между крупными модулями системы или со сторонними сервисами (платежные системы, email-рассылки).
*   **Модульное (Unit):** Тестирует отдельные, изолированные части программы (классы, методы).
*   **Производительности (Нагрузочное):** Проверяет стабильность и скорость работы системы под высокой нагрузкой.
---
### Что такое JUnit?

**JUnit** — это самый популярный фреймворк для написания и запуска автоматизированных тестов для Java-кода. Актуальная версия — **JUnit 5**, которая тесно интегрирована в современные IDE (например, IntelliJ IDEA).

### Жизненный цикл теста и основные аннотации

Тест проходит три фазы: **Setup** (настройка), **Test Execution** (выполнение) и **Cleanup** (очистка). Этими фазами управляют аннотации:

*   `@BeforeAll`: Метод выполняется **один раз перед всеми тестами** в классе. Должен быть `static`. Используется для "тяжелой" настройки (например, подключение к БД).
*   `@AfterAll`: Метод выполняется **один раз после всех тестов** в классе. Должен быть `static`. Используется для глобальной очистки ресурсов.
*   `@BeforeEach`: Метод выполняется **перед каждым тестовым методом**. Используется для подготовки данных для каждого отдельного теста.
*   `@AfterEach`: Метод выполняется **после каждого тестового метода**. Используется для очистки после каждого теста.

**Другие важные аннотации:**
*   `@Test`: Помечает метод как основной исполняемый тест.
*   `@DisplayName("...")`: Задает человекочитаемое имя для теста или класса.
*   `@Disabled`: Временно отключает тест или класс тестов.
*   `@RepeatedTest(N)`: Повторяет выполнение теста `N` раз.
*   `@Timeout(...)`: Устанавливает максимальное время на выполнение теста. Если время превышено, тест считается проваленным.
*   `@ExtendWith`: Позволяет подключать расширения (плагины), например, для интеграции с фреймворками вроде Spring.
*   `@Nested`: Создает вложенный тестовый класс для лучшей организации тестов.

### Ассерты (Assertions) — Проверки в тестах

Ассерты — это статические методы, которые проверяют условия внутри теста. Если проверка не проходит, выбрасывается исключение, и тест считается проваленным.

**Основные ассерты:**
*   `assertEquals(expected, actual)`: Проверяет, что два значения равны.
*   `assertNotEquals(unexpected, actual)`: Проверяет, что значения не равны.
*   `assertTrue(condition)` / `assertFalse(condition)`: Проверяет, что условие истинно или ложно.
*   `assertNull(object)` / `assertNotNull(object)`: Проверяет, что объект `null` или не `null`.
*   `assertSame(obj1, obj2)`: Проверяет, что две переменные ссылаются на один и тот же объект.

**Специальные ассерты:**
*   `assertAll()`: Позволяет сгруппировать несколько проверок. Выполняются все проверки внутри группы, даже если предыдущие не прошли, и в отчете отображаются все ошибки.
    ```java
    assertAll("Проверка адреса",
        () -> assertEquals("Вашингтон", address.getCity()),
        () -> assertEquals("Oracle Parkway", address.getStreet())
    );
    ```
*   `assertThrows()`: Проверяет, что при выполнении кода выбрасывается исключение определенного типа.
    ```java
    // Проверяем, что код бросает ArithmeticException
    assertThrows(ArithmeticException.class, () -> {
        int result = 10 / 0;
    });
    ```


### `@ExtendWith`

1.  **Регистрирует расширение:** Вы пишете `@ExtendWith(MockitoExtension.class)`. JUnit 5 видит это и понимает: "Ага, для этого теста мне нужно активировать расширение для Mockito".

2.  **Делегирует ему задачи:** После активации JUnit позволяет этому расширению выполнять дополнительную работу на разных этапах жизненного цикла теста.

### Конкретные примеры, что делают такие "плагины":

*   **`@ExtendWith(MockitoExtension.class)`:**
    *   **До теста:** Пробегается по вашему классу, находит все поля с аннотациями `@Mock` и `@Spy` и автоматически создает для них объекты-заглушки.
    *   **Вам не нужно писать:** `myService = Mockito.mock(MyService.class);` — расширение сделает это за вас.

*   **`@ExtendWith(SpringExtension.class)`:**
    *   **До теста:** Запускает мини-версию вашего Spring-приложения.
    *   Позволяет вам использовать аннотацию `@Autowired`, чтобы внедрять реальные компоненты (бины) прямо в тестовый класс.


---

### Что такое Mockito и зачем он нужен?

**Mockito** — это Java-библиотека для создания **"объектов-заглушек" (моков)**. Она используется в модульном тестировании, чтобы **изолировать тестируемый код от его внешних зависимостей**.

**Проблема:** Ваш код часто зависит от других систем: базы данных, сетевых сервисов, файловой системы. При тестировании не хочется делать реальные запросы к базе или отправлять настоящие SMS.

**Решение Mockito:** Вместо реальных объектов вы подставляете их "двойников" — моки. Эти моки полностью под вашим контролем: вы можете указать, что должен вернуть тот или иной метод, или проверить, был ли он вызван.

### Как подключить Mockito?

Для интеграции с JUnit 5 достаточно добавить одну аннотацию над тестовым классом:
`@ExtendWith(MockitoExtension.class)`

### Основные типы "заглушек"

1.  **@Mock (Макет)**
    *   Создает **полностью фальшивый, "пустой" объект**.
    *   По умолчанию все его методы ничего не делают (возвращают `null`, `0` или `false`).
    *   Вы должны явно "научить" его, как себя вести в тесте.
    *   Идеально, когда вам не нужна реальная логика объекта.

2.  **@Spy (Шпион)**
    *   Создает **обертку над реальным объектом**.
    *   По умолчанию **все вызовы делегируются настоящему объекту**, и его методы работают как обычно.
    *   Вы можете выборочно переопределить поведение только нужных вам методов.
    *   Идеально, когда вам нужна большая часть реальной логики объекта, но нужно изменить или отследить лишь малую ее часть.

### Как управлять поведением моков (Stubbing)?

Чтобы "запрограммировать" мок, используются специальные конструкции.

*   **Задать возвращаемое значение:**
    ```java
    // Способ 1: "Когда вызовут метод, верни результат"
    Mockito.when(mockList.size()).thenReturn(100);

    // Способ 2 (более безопасный): "Сделай так, чтобы при вызове метода вернулся результат"
    Mockito.doReturn(100).when(mockList).size();
    ```

*   **Заставить метод выбросить исключение:**
    ```java
    Mockito.when(mockList.get(0)).thenThrow(new RuntimeException());
    ```

*   **Использование матчеров для аргументов:**
    Если вам неважно, с каким именно аргументом будет вызван метод, используйте матчеры:
    ```java
    // Для любого целого числа
    Mockito.when(mockList.get(anyInt())).thenReturn("элемент");
    // Для любой строки
    Mockito.when(mockList.contains(anyString())).thenReturn(true);
    // Для любого объекта определенного класса
    Mockito.when(mockList.add(any(MyObject.class))).thenReturn(false);
    ```

### Как проверять вызовы методов (Verification)?

Mockito позволяет убедиться, что нужные методы были вызваны.

*   **Проверить сам факт вызова:**
    ```java
    // Проверяем, что метод get() был вызван с аргументом 0
    Mockito.verify(mockList).get(0);
    ```

*   **Проверить количество вызовов:**
    ```java
    // Проверить, что метод get() вызывался ровно 3 раза
    Mockito.verify(mockList, times(3)).get(anyInt());

    // Другие варианты:
    // never() - не вызывался никогда
    // atLeast(2) - вызывался как минимум 2 раза
    // atMost(5) - вызывался не более 5 раз
    ```

*   **Проверить порядок вызовов:**
    Для этого создается специальный объект `InOrder`.
    ```java
    InOrder inOrder = Mockito.inOrder(mockList);
    inOrder.verify(mockList).add("первый"); // Сначала должен быть вызван этот
    inOrder.verify(mockList).size();      // А потом этот
    ```

### Мокирование статических методов

Мокировать статические методы сложнее, так как они не принадлежат объекту. Для этого Mockito использует специальную конструкцию в блоке `try-with-resources`:

```java
// Указываем класс, чьи статические методы хотим мокировать
try (MockedStatic<Utils> mockedUtils = Mockito.mockStatic(Utils.class)) {
    // Задаем поведение для статического метода
    mockedUtils.when(Utils::getAppName).thenReturn("Тестовое Приложение");

    // Выполняем код, который использует этот статический метод
    assertEquals("Тестовое Приложение", service.getFormattedName());
}
```

---

### Что такое Spring Test?

**Spring Test** — это библиотека Spring Framework для интеграционного тестирования. Её ключевые задачи:
1.  **Управление IoC контейнером**: создание и кэширование контекста приложения между тестами.
2.  **Внедрение зависимостей**: предоставление бинов для тестовых классов.
3.  **Управление транзакциями**: автоматический откат изменений в БД после каждого теста.
4.  **Вспомогательные классы**: упрощение написания интеграционных тестов.

### Жизненный цикл и получение контекста

Для получения `ApplicationContext` в тесте JUnit 5 используются аннотации `@ExtendWith(SpringExtension.class)` и `@ContextConfiguration(...)`. Их можно заменить одной аннотацией `@SpringJUnitConfig` (или `@SpringJUnitWebConfig` для веб-тестов).

Процесс запуска теста выглядит так:
1.  Расширение фреймворка (например, `SpringExtension`) создает `TestContext`, который управляет состоянием теста.
2.  `TestContext` внедряет зависимости в тестовый класс и настраивает тестовое окружение (например, транзакции).
3.  `Context Loader` создает контекст приложения, объединяя основную и тестовую конфигурации.
4.  **Контекст кэшируется** с использованием ключа, который описывает его конфигурацию (набор бинов, профилей, свойств).
5.  Тест выполняется.

### Кэширование контекста

Spring Test **не перезапускает приложение на каждый тест**. Он переиспользует (кэширует) контекст для всех тестов с одинаковой конфигурацией. Это значительно ускоряет выполнение тестов.

Новый контекст будет создан, если в тесте используются аннотации, изменяющие конфигурацию:
*   `@DirtiesContext`: принудительно помечает контекст как "грязный", запрещая его кэширование после теста.
*   `@MockBean` / `@SpyBean`: заменяет реальный бин на мок, что изменяет состав контекста.
*   `@TestPropertySource`: изменяет свойства приложения.
*   `@ActiveProfiles`: изменяет активные профили.
*   `@ContextConfiguration`: указывает другой класс конфигурации.

унифицируйте конфигурацию тестов, чтобы Spring мог переиспользовать один и тот же контекст.

1.  **Создайте общий базовый класс.** Вынесите все общие аннотации (`@SpringBootTest`, `@ActiveProfiles`, `@TestPropertySource`) в один абстрактный класс, от которого будут наследоваться ваши тесты.

2.  **Группируйте тесты по конфигурации.** Тесты, требующие одинаковый набор `@MockBean` или одинаковые свойства, помещайте в один тестовый класс. Не создавайте новый класс для каждого маленького теста с уникальным моком.

3.  **Избегайте `@DirtiesContext`.** Эта аннотация — гарантия создания нового контекста. Вместо неё:
    *   Для очистки БД используйте `@Transactional`.
    *   Для сброса состояния моков используйте `Mockito.reset()` в методе с аннотацией `@BeforeEach`.

4.  **Используйте профили вместо `@MockBean`.** Для подмены бинов создайте `@TestConfiguration` с моками и активируйте её через `@ActiveProfiles`. Это позволит всем тестам с этим профилем использовать один контекст.

### Сфокусированные интеграционные тесты: `@DataJpaTest`

Для тестирования только слоя работы с данными (JPA) используется аннотация `@DataJpaTest`. Она не загружает всё приложение, а настраивает только необходимые компоненты, комбинируя несколько аннотаций:

*   `@AutoConfigureDataJpa`: настраивает репозитории, Hibernate, DataSource и инструменты миграции (Flyway/Liquibase).
*   `@AutoConfigureTestDatabase`: автоматически подменяет основную базу данных на встраиваемую in-memory базу (например, H2).
*   `@AutoConfigureCache`: отключает кэширование второго уровня, чтобы избежать неожиданного поведения в тестах.
*   `@AutoConfigureTestEntityManager`: предоставляет `TestEntityManager` — хелпер для принудительного выполнения операций с БД (например, `persistAndFlush()`) в тестах.
*   `@Transactional`: оборачивает каждый тест в транзакцию, которая автоматически откатывается по его завершении. Это обеспечивает чистоту БД для каждого теста.

**Внимание**: автоматический откат транзакции может скрыть проблемы, если "боевой" код сам не управляет транзакциями.

### Полноценные интеграционные тесты: `@SpringBootTest`

Аннотация `@SpringBootTest` запускает приложение "как есть", загружая полный контекст.
1.  Она ищет основной класс конфигурации (`@SpringBootConfiguration`), поднимаясь по иерархии пакетов от тестового класса.
2.  Затем сканирует все компоненты, как при обычном запуске приложения.
3.  Можно точечно заменять бины с помощью `@MockBean`, чтобы изолировать тест от внешних систем.

Используйте `@SpringBootTest`, когда нужно протестировать взаимодействие нескольких компонентов в условиях, близких к реальным. Если же тест с `@SpringBootTest` требует слишком много моков, лучше выбрать более сфокусированную аннотацию (например, `@DataJpaTest` или `@WebMvcTest`).

### Unit-тесты для веб-слоя: `@WebMvcTest`

Для unit-тестирования контроллеров используется аннотация `@WebMvcTest(YourController.class)`.
*   Она создает только веб-слой Spring MVC (контроллеры, обработчики, Jackson), **не загружая сервисы и репозитории**.
*   Все зависимости контроллера (сервисы, репозитории) необходимо предоставлять в виде моков с помощью `@MockBean`.
*   Для выполнения и проверки HTTP-запросов используется бин `MockMvc`.

---

### Что такое Testcontainers?

**Testcontainers** — это Java-библиотека, которая позволяет запускать Docker-контейнеры прямо из ваших автоматических тестов (например, JUnit). Она предоставляет программный API для управления жизненным циклом контейнеров с любыми сервисами: базами данных, брокерами сообщений, веб-серверами, кэшами и т.д.

**Основная идея:** вместо использования встраиваемых баз данных (вроде H2) или моков, ваши интеграционные тесты будут работать с **реальным программным обеспечением**, которое будет использоваться в продакшене (например, PostgreSQL, Kafka, Redis), но в изолированной и одноразовой среде.

---

### Зачем использовать Testcontainers? (Ключевые преимущества)

1.  **Высокая надежность тестов (High-fidelity testing).**
    *   Вы тестируете приложение на том же стеке, который будет в продакшене. Если вы используете PostgreSQL в проде, ваши тесты тоже будут работать с настоящим PostgreSQL, а не с его эмуляцией (H2), которая может иметь отличия в синтаксисе SQL, типах данных или поведении. Это устраняет класс ошибок "на тестах работало, а в проде упало".

2.  **Полная изоляция и чистота.**
    *   Каждый тестовый запуск (или тестовый класс) получает свой собственный, абсолютно чистый экземпляр сервиса. Больше никаких проблем с "грязными" данными, оставшимися от предыдущих тестов. После завершения теста контейнер автоматически уничтожается.

3.  **Простота и автоматизация.**
    *   Вам не нужно вручную запускать Docker-контейнеры через `docker-compose up` перед тестами и останавливать их после. Библиотека делает всё за вас. Это идеально для локальной разработки и особенно для CI/CD-пайплайнов, где настройка окружения должна быть полностью автоматизирована.

4.  **Портативность.**
    *   Любой разработчик или CI-сервер, на котором установлен Docker, сможет запустить ваши тесты без дополнительной настройки.

---

### Как это работает?

1.  **Связь с Docker:** Ваше тестовое приложение через библиотеку Testcontainers обращается к Docker-демону на вашей машине.
2.  **Загрузка образа:** Если нужного Docker-образа (например, `postgres:14`) нет локально, он будет автоматически скачан.
3.  **Запуск контейнера:** Testcontainers запускает новый контейнер из этого образа, назначая ему **случайный свободный порт**. Это позволяет избежать конфликтов портов при параллельном запуске тестов.
4.  **Ожидание готовности:** Библиотека ждет, пока сервис внутри контейнера полностью запустится и будет готов принимать подключения (например, пока порт базы данных не начнет отвечать).
5.  **Передача настроек:** Testcontainers предоставляет вашему тесту динамически полученные данные для подключения (хост, порт, имя пользователя, пароль).
6.  **Очистка:** После завершения тестов Testcontainers автоматически останавливает и **удаляет** контейнер с помощью специального сервисного контейнера "Ryuk".

---

### Основные компоненты и примеры

#### 1. Модули (Modules)
Для популярных сервисов есть готовые модули, которые упрощают настройку.

*   `PostgreSQLContainer`, `MySQLContainer`, `OracleContainer`
*   `KafkaContainer`
*   `RabbitMQContainer`
*   `RedisContainer`


**Кратко об использовании в Spring Boot:**

2. **Конфигурация**: Используйте аннотации и API Testcontainers для запуска контейнера. Например, для PostgreSQL:
   ```java
   @SpringBootTest
   @Testcontainers
   class MyIntegrationTest {
       @Container
       static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:15")
           .withDatabaseName("test")
           .withUsername("user")
           .withPassword("password");

       @DynamicPropertySource
       static void configureProperties(DynamicPropertyRegistry registry) {
           registry.add("spring.datasource.url", postgres::getJdbcUrl);
           registry.add("spring.datasource.username", postgres::getUsername);
           registry.add("spring.datasource.password", postgres::getPassword);
       }

       @Test
       void test() {
           // Ваш тест с доступом к БД
       }
   }
   ```

3. **Аннотации**:
    - `@Testcontainers` — активирует поддержку Testcontainers.
    - `@Container` — указывает, что контейнер должен управляться Testcontainers.
    - `@DynamicPropertySource` — динамически задаёт свойства для Spring (например, URL базы данных).


Если для вашего сервиса нет готового модуля, вы можете использовать `GenericContainer` для запуска любого Docker-образа.

```java
@Container
static GenericContainer<?> redis = new GenericContainer<>("redis:6-alpine")
        .withExposedPorts(6379); // Указываем, какой порт контейнера нужно пробросить

// В @DynamicPropertySource
registry.add("spring.redis.host", redis::getHost);
registry.add("spring.redis.port", () -> redis.getMappedPort(6379));
```

Для сложных сценариев с несколькими взаимосвязанными сервисами можно запустить их из `docker-compose.yml` файла.

```java
@Container
public static DockerComposeContainer<?> compose = 
    new DockerComposeContainer<>(new File("src/test/resources/docker-compose.yml"))
        .withExposedService("postgres_1", 5432)
        .withExposedService("kafka_1", 9092);
```

---

### Лучшие практики и советы

1.  **Переиспользуйте контейнеры.** Объявляйте контейнер как `static`. В этом случае он запустится один раз для всех тестов в классе, а не для каждого метода. Это **значительно** ускоряет выполнение тестов.
2.  **Фиксируйте версии образов.** Вместо `postgres:latest` используйте конкретную версию, например, `postgres:14.5-alpine`. Это гарантирует воспроизводимость тестов и защищает от неожиданных изменений в новых версиях образа.
3.  **Используйте легкие образы.** Образы с тегом `-alpine` обычно меньше и быстрее запускаются.
4.  **Настройте "Wait Strategy".** Иногда простого ожидания открытия порта недостаточно. Можно настроить ожидание определенной строки в логах контейнера: `withLogMessage(".*database system is ready to accept connections.*", 1)`.
5.  **Для локальной разработки:** Можно включить режим переиспользования контейнеров между запусками тестов, добавив в файл `~/.testcontainers.properties` строку `testcontainers.reuse.enable=true`. Это ускоряет локальные прогоны, но не рекомендуется для CI.

### Когда НЕ стоит использовать Testcontainers?

*   **Для Unit-тестов.** Если вы тестируете бизнес-логику одного класса в изоляции, вам не нужен Docker. Используйте моки.
*   **Когда скорость — абсолютный приоритет.** Запуск Docker-контейнера всегда медленнее, чем запуск in-memory базы вроде H2. Если у вас тысячи тестов и каждая миллисекунда на счету, возможно, для самых простых CRUD-тестов H2 будет приемлемым компромиссом. Но для всех остальных случаев надежность Testcontainers предпочтительнее.
*   **В окружениях без Docker.** Если ваша CI/CD-система по каким-то причинам не поддерживает Docker, использовать библиотеку не получится.
