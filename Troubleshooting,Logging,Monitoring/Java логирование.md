Что такое Логирование?

Логирование Java — это процесс, при котором программа на Java-языке записывает сведения о своем исполнении в некий файл или базу данных. Логирование дает возможность отслеживать ход исполнения программы и конкретно кода.

--------------------------------------------------------------------------------------------------------------------

Какие существуют типы логов?

системы (System);
безопасности (Security);
приложения (Application, Buisness).

Пользователь входит в приложение, проверяется пароль. Это действие относится к безопасности (Security). Дальше он запускает какой-нибудь модуль. Это событие уровня приложения (Application). Модуль при старте обращается к другому модулю за какими-то дополнительными данными, производит какие-либо еще вызовы - это уже системные действия (System).

--------------------------------------------------------------------------------------------------------------------

Для чего нужно логирование?

По сути логирование - это то, что позволяет следить за ходом выполнения вашего приложения, вашего кода.
При работе приложения надо понимать, что вообще происходит внутри, особенно при разборе ошибок и инцидентов. В этом как раз и помогают логи - это как запись черного ящика на самолетах.
Нет информации о происходящих событий в приложении - мы ничего не знаем о том, что происходит. И если такое поведение может устраивать в случае, когда все идеально работает (да и то сомнительно), то во всех остальных случаях такое поведение категорически не устраивает никого.
Поэтому "логи всякие нужны, логи всякие важны".

--------------------------------------------------------------------------------------------------------------------

Что такое уровни логирования?

Для того, чтоб как-то ранжировать логи, нужно было дать определенные обозначения и разграничения. Для этого ввели уровни логирования. Уровень задается в приложении. Если запись относится к уровню ниже обозначенного, она не вносится в лог. Например, у нас есть логи, с помощью которых дебажат приложение. В нормальной работе на продакшене (когда приложение используют по назначению), такие логи не нужны. Поэтому уровень логирования будет выше, чем для дебага.

--------------------------------------------------------------------------------------------------------------------

Перечислите уровни журналирования? Назовите порядок их приоритетности.

OFF: никакие логи не записываются, все будут проигнорированы;
FATAL: ошибка, после которой приложение уже не сможет работать и будет остановлено, например, JVM out of memory error;
ERROR: уровень ошибок, когда есть проблемы, которые нужно решить. Ошибка не останавливает работу приложения в целом. Остальные запросы могут работать корректно;
WARN: обозначаются логи, которые содержат предостережение. Произошло неожиданное действие, несмотря на это система устояла и выполнила запрос;
INFO: лог, который записывает важные действия в приложении. Это не ошибки, это не предостережение, это ожидаемые действия системы;
DEBUG: логи, необходимые для отладки приложения. Для уверенности в том, что система делает именно то, что от нее ожидают, или описания действия системы: "method1 начал работу";
TRACE: менее приоритетные логи для отладки, с наименьшим уровнем логирования;
ALL: уровень, при котором будут записаны все логи из системы.

OFF< TRACE< DEBUG< INFO< WARN< ERROR< FATAL< ALL

--------------------------------------------------------------------------------------------------------------------

Что нужно логировать?

Разумеется, логировать все подряд не стоит. Иногда это и не нужно, и даже опасно. Например, если залогировать чьи-то личные данные и это каким-то образом всплывет на поверхность, будут реальные проблемы, особенно на проектах, ориентированных на Запад. Но есть и то, что логировать обязательно:

Начало/конец работы приложения. Нужно знать, что приложение действительно запустилось, как мы и ожидали, и завершилось так же ожидаемо.

Вопросы безопасности. Здесь хорошо бы логировать попытки подбора пароля, логирование входа важных юзеров и т.д.

Некоторые состояния приложения. Например, переход из одного состояния в другое в бизнес процессе.

Некоторая информация для дебага, с соответственным уровнем логирования.

Некоторые SQL скрипты. Есть реальные случаи, когда это нужно. Опять-таки, умелым образом регулируя уровни, можно добиться отличных результатов.
Выполняемые нити(Thread) могут быть логированы в случаях с проверкой корректной работы.

--------------------------------------------------------------------------------------------------------------------

Популярные ошибки в логировании?

Нюансов много, но можно выделить несколько частых ошибок:

Избыток логирования. Не стоит логировать каждый шаг, который чисто теоретически может быть важным. Есть правило: логи могут нагружать работоспособность не более, чем на 10%. Иначе будут проблемы с производительностью.

Логирование всех данных в один файл. Это приведет к тому, что в определенный момент чтение/запись в него будет очень сложной, не говоря о том, что есть ограничения по размеру файлов в определенных системах.

Использование неверных уровней логирования. У каждого уровня логирования есть четкие границы, и их стоит соблюдать. Если граница расплывчатая, можно договориться какой из уровней использовать.

--------------------------------------------------------------------------------------------------------------------

Что такое Logger?

Логер - это объект, область ответственности которого - вывод данных в лог и управление уровнем (детализацией) этого вывода.
Логер создается с помощью фабрики и на этапе создания ему присваивается имя. Имя может быть любым, но по стандарту имя должно быть сопряжено с именем класса, в котором вы собираетесь что-то логировать:
Logger logger = LoggerFactory.getLogger(SomeClass.class.getName());

Это дает нам имя логера в виде: ru.aarexer.example.SomeClass.

Почему так рекомендуется делать?
Потому что важным свойством логгеров является то, что они организованы иерархично. Каждый логгер имеет имя, описывающее иерархию, к которой он принадлежит. Разделитель - точка. Принцип полностью аналогичен формированию имени пакета в Java.
Получается выстраивается следующая иерархия логеров:

root <- ru <- aarexer <- example <- SomeClass

И каждому логеру можно выставить свой уровень. Установленный логгеру уровень вывода распространяется на все его дочерние логгеры, для которых явно не выставлен уровень.
При этом во главе иерархии логеров всегда стоит некотрый дефолтный рутовый(корневой) логер.
Поэтому у всех логеров будет уровень логирования, даже если явно мы не прописали для ru.aarexer.example.SomeClass его, то он унаследуется от рутового.

--------------------------------------------------------------------------------------------------------------------

Мы установили рутовый уровень в INFO, а ru.aarexer в DEBUG, остальным в иерархии уровень не назначен, т.е:
Логер root ru ru.aarexer ru.aarexer.example
Логер Назначенный уровень
root -> INFO
ru -> Не назначен
ru.aarexer -> DEBUG
ru.aarexer.example -> Не назначен

Какой у какого логера будет уровень логирования?

Вспоминаем, что, если уровень логирования не назначен для логера, то он унаследует его от родительского, смотрим на иерархию:
root <- ru <- aarexer <- example
И получаем ответ:

Logger -> Назначенный уровень-> Уровень, который будет

root -> Все сообщения -> INFO
ru -> Не назначен -> INFO
ru.aarexer -> DEBUG -> DEBUG
ru.aarexer.example -> Не назначен -> DEBUG

Подход с иерархией логеров очень гибкий - можно для всех выставить требуемый уровень, например, ERROR, а для необходимых логеров его менять, причем как в сторону понижения, так и в сторону повышения уровня.

--------------------------------------------------------------------------------------------------------------------

Что такое Appender?

Аппендер - это та точка, куда события приходят в конечном итоге. Это может быть файл, БД, консоль, сокет и т.д.

Здесь нас никто не ограничивает - можно написать свой аппендер, который пишет сообщения куда-угодно.
Получается у нас есть две точки, первая - это логгер, это начало пути, вторая - аппендер, это уже конечная точка.

Логеры и аппендеры связаны в отношении many-to-many.

У одного логгера может быть несколько аппендеров, а к одному аппендеру может быть привязано несколько логгеров.

Логеры при этому наследуют от родительских не только уровни логирования, но и аппендеры.
Например, если к root-логгеру привязан аппендер A1, а к логгеру ru.aarexer - A2, то вывод в логгер ru.aarexer попадет в A2 и A1, а вывод в ru - только в A1.

--------------------------------------------------------------------------------------------------------------------

Пусть у нас есть несколько аппендеров и логеров

Logger Appender
root -> А1
ru.aarexer -> А2
ru.aarexer.example.SomeClass -> А3

В какой аппендер попадет лог-сообщение:
LoggerFactory.getLogger(SomeClass.class.getName()).info("hello");

У логеров есть такое свойство как additivity. По умолчанию она установлена в true.
Это говорит о том, что логер-наследник будет свои события передавать логеру-родителю.
Смотрим на иерархию:
root <- ru <- aarexer <- example
Из всего вышесказанного делаем вывод, что событие "hello" с уровнем Level.INFO попадет во все три аппендера.

Но такое наследование аппендеров можно отключить через конфигурацию, для этого стоит посмотреть в сторону выставления флага additivity="false" на логгерах.

--------------------------------------------------------------------------------------------------------------------

Что такое Layout?

Layout - это формат вывода данных.
Т.е как лог-сообщения будут отформативарованы, соответственно тут у каждой библиотеки свой набор доступных форматов.
Теперь пришла пора посмотреть - что вообще есть в Java.

--------------------------------------------------------------------------------------------------------------------

Что такое Apache log4j?

Это самая первая библиотека логирования, появилась еще в 1999 году.
Конфигурируется через xml, либо через properties.
Поддерживает большое количество способов вывода логов: от консоли и файла до записи в БД.
Также имеет поддержку обширного формата логирования: от обычного текстового вывода до html.
Именно он ввел понятие appender - кто пишет в лог, layout - форматирование. В конфигурации задаются эти самые appender-ы и какого уровня сообщения попадают к какому appender-у.
Ввел соответствие иерархичности категорий и пакетов: например, можно логгировать все сообщения из org.hibernate и заглушить всё из org.hibernate.type.

Проект сейчас не развивается и по сути заброшен, с версией Java 9 уже не совместим.
Поэтому на данный момент рекомендуется использовать log4j2, о котором речь пойдет ниже.

--------------------------------------------------------------------------------------------------------------------

Что такое Logback?

Logback - одна из наиболее широко используемых сред ведения журналов в сообществе Java. Logback написал тот же разработчик, что и log4j, чтобы создать ему преемника. В основе была та же идея, что и в log4j. Отличия были в том, что в logback:

улучшена производительность;

добавлена нативная поддержка slf4j;

расширена опция фильтрации.

Стандартно logback не требует каких-либо настроек и записывает все логи начиная от уровня DEBUG и выше. Если нужна настройка, ее можно выполнить через xml конфигурацию:

<configuration> 

<appender name="FILE" class="ch.qos.logback.core.FileAppender"> <file>app.log</file> 
<encoder> 
<pattern>%d{HH:mm:ss,SSS} %-5p [%c] - %m%n</pattern> 
</encoder> 
</appender>

 <logger name="org.hibernate.SQL" level="DEBUG" /> 
<logger name="org.hibernate.type.descriptor.sql" level="TRACE" /> 

<root level="info">
 <appender-ref ref="FILE" /> 
</root> 
</configuration>

--------------------------------------------------------------------------------------------------------------------

Что такое SLF4J?

SLF4J является оберткой над logback, а также над JUL, log4j, или JCL, а также над любым логгером, который реализует ее интерфейс.
Для работы с SLF4J нужны библиотека slf4j-api-1.x.x.jar и реализация одного из логгеров либо заглушка. Как правило реализации всех логгеров ( кроме logback) поставляются вместе с SLF4J и имеют названия на подобии slf4j-jcl-1.x.jar, slf4j-log4j12-1.x.jar, slf4j-nop-1.x.jar и т.п.
Если в classpath не будет найдена реализация логгера ( или заглушка nop) SLF4J гневно ругнется и работать откажется. Конфигурация соответственно будет искаться в зависимости от положенной в classpath реализации.
В идеальном мире мы должны выводить сообщения через интерфейс обертки, и тогда у нас все будет хорошо, но реальный жестокий мир говорит о том, что всем нам приходится взаимодействовать со сторонними библиотеками или кодом, в которых используются другие логгеры и которые знать не знают о SLF4J. Что бы не подстраиваться под каждый логгер, а пустить все сообщения через одну реализацию интерфейса SLF4J, можно использовать bridging. В поставке обертки содержаться библиотеки jcl-over-slf4j.jar, log4j-over-slf4j.jar и jul-to-slf4j.jar, которые переопределяют поведение соответствующих логгеров и перенаправляют сообщения в обертку.

--------------------------------------------------------------------------------------------------------------------