Что такое Логирование?

Логирование Java — это процесс, при котором программа на Java-языке записывает сведения о своем исполнении в некий файл или базу данных. Логирование дает возможность отслеживать ход исполнения программы и конкретно кода.

--------------------------------------------------------------------------------------------------------------------

Какие существуют типы логов?

системы (System);
безопасности (Security);
приложения (Application, Buisness).

Пользователь входит в приложение, проверяется пароль. Это действие относится к безопасности (Security). Дальше он запускает какой-нибудь модуль. Это событие уровня приложения (Application). Модуль при старте обращается к другому модулю за какими-то дополнительными данными, производит какие-либо еще вызовы - это уже системные действия (System).

--------------------------------------------------------------------------------------------------------------------

Для чего нужно логирование?

По сути логирование - это то, что позволяет следить за ходом выполнения вашего приложения, вашего кода.
При работе приложения надо понимать, что вообще происходит внутри, особенно при разборе ошибок и инцидентов. В этом как раз и помогают логи - это как запись черного ящика на самолетах.
Нет информации о происходящих событий в приложении - мы ничего не знаем о том, что происходит. И если такое поведение может устраивать в случае, когда все идеально работает (да и то сомнительно), то во всех остальных случаях такое поведение категорически не устраивает никого.
Поэтому "логи всякие нужны, логи всякие важны".

--------------------------------------------------------------------------------------------------------------------

Что такое уровни логирования?

Для того, чтоб как-то ранжировать логи, нужно было дать определенные обозначения и разграничения. Для этого ввели уровни логирования. Уровень задается в приложении. Если запись относится к уровню ниже обозначенного, она не вносится в лог. Например, у нас есть логи, с помощью которых дебажат приложение. В нормальной работе на продакшене (когда приложение используют по назначению), такие логи не нужны. Поэтому уровень логирования будет выше, чем для дебага.

--------------------------------------------------------------------------------------------------------------------

Перечислите уровни журналирования? Назовите порядок их приоритетности.

OFF: никакие логи не записываются, все будут проигнорированы;
FATAL: ошибка, после которой приложение уже не сможет работать и будет остановлено, например, JVM out of memory error;
ERROR: уровень ошибок, когда есть проблемы, которые нужно решить. Ошибка не останавливает работу приложения в целом. Остальные запросы могут работать корректно;
WARN: обозначаются логи, которые содержат предостережение. Произошло неожиданное действие, несмотря на это система устояла и выполнила запрос;
INFO: лог, который записывает важные действия в приложении. Это не ошибки, это не предостережение, это ожидаемые действия системы;
DEBUG: логи, необходимые для отладки приложения. Для уверенности в том, что система делает именно то, что от нее ожидают, или описания действия системы: "method1 начал работу";
TRACE: менее приоритетные логи для отладки, с наименьшим уровнем логирования;
ALL: уровень, при котором будут записаны все логи из системы.

OFF< TRACE< DEBUG< INFO< WARN< ERROR< FATAL< ALL

--------------------------------------------------------------------------------------------------------------------

Что нужно логировать?

Разумеется, логировать все подряд не стоит. Иногда это и не нужно, и даже опасно. Например, если залогировать чьи-то личные данные и это каким-то образом всплывет на поверхность, будут реальные проблемы, особенно на проектах, ориентированных на Запад. Но есть и то, что логировать обязательно:

Начало/конец работы приложения. Нужно знать, что приложение действительно запустилось, как мы и ожидали, и завершилось так же ожидаемо.

Вопросы безопасности. Здесь хорошо бы логировать попытки подбора пароля, логирование входа важных юзеров и т.д.

Некоторые состояния приложения. Например, переход из одного состояния в другое в бизнес процессе.

Некоторая информация для дебага, с соответственным уровнем логирования.

Некоторые SQL скрипты. Есть реальные случаи, когда это нужно. Опять-таки, умелым образом регулируя уровни, можно добиться отличных результатов.
Выполняемые нити(Thread) могут быть логированы в случаях с проверкой корректной работы.

--------------------------------------------------------------------------------------------------------------------

Популярные ошибки в логировании?

Нюансов много, но можно выделить несколько частых ошибок:

Избыток логирования. Не стоит логировать каждый шаг, который чисто теоретически может быть важным. Есть правило: логи могут нагружать работоспособность не более, чем на 10%. Иначе будут проблемы с производительностью.

Логирование всех данных в один файл. Это приведет к тому, что в определенный момент чтение/запись в него будет очень сложной, не говоря о том, что есть ограничения по размеру файлов в определенных системах.

Использование неверных уровней логирования. У каждого уровня логирования есть четкие границы, и их стоит соблюдать. Если граница расплывчатая, можно договориться какой из уровней использовать.

--------------------------------------------------------------------------------------------------------------------

### 1. Как работает Logger в Java?

Представьте логгер не как простую команду "напечатать", а как целую систему для ведения журнала событий в приложении. Аналогия — бортовой
журнал корабля. В него записывают всё: от "всё спокойно" до "пробоина в правом борту!", причем с указанием времени, важности и того, кто
сделал запись.

Java-логгер работает по схожему принципу и состоит из нескольких ключевых компонентов:

**1. Logger (Сам Логгер):**
Это объект, через который вы отправляете сообщения. Вы получаете его для каждого класса, обычно так:

```java
// Используем фасад SLF4J - это лучшая практика

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class MyService {

  // Получаем логгер, привязанный к этому классу
  private static final Logger logger = LoggerFactory.getLogger(MyService.class);

  public void doSomething() {
    // Используем логгер для записи события
    logger.info("Метод doSomething начал свою работу.");
    // ...
    logger.debug("Промежуточное значение переменной X = {}", 123);
  }
}
```

**2. Log Level (Уровень логирования):**
Это "важность" сообщения. Самый главный инструмент контроля. Стандартные уровни (от самого низкого к самому высокому):

* **TRACE:** Самая детальная информация для отслеживания шагов алгоритма.
* **DEBUG:** Информация для отладки (значения переменных, состояние объектов).
* **INFO:** Информационные сообщения о ходе работы приложения (запуск сервиса, успешное завершение операции).
* **WARN:** Предупреждения. Ситуации, которые не являются ошибками, но могут ими стать (заканчивается место на диске, не найден
  необязательный конфиг).
* **ERROR:** Ошибки, которые не привели к остановке всего приложения, но сломали конкретную операцию (не удалось подключиться к внешнему
  сервису, ошибка обработки запроса).

**Главная идея:** Вы настраиваете минимальный уровень для всего приложения. Например, если вы установите уровень **INFO**, то
сообщения `TRACE` и `DEBUG` будут **полностью проигнорированы** и не вызовут никаких накладных расходов.

**3. Appender (Аппендер, или "писатель"):**
Это компонент, который решает, **КУДА** записать сообщение. Один и тот же лог можно одновременно отправлять в разные места:

* **ConsoleAppender:** Выводит в консоль (похоже на `System.out`).
* **FileAppender:** Пишет в файл.
* **RollingFileAppender:** Пишет в файл, но умеет автоматически архивировать старые логи по достижении размера или по дате (
  например, `app.log`, `app.2023-10-27.log.gz` и т.д.).
* Другие: в базу данных, в системы сбора логов (ELK, Graylog), по сети и т.д.

**4. Layout/Formatter (Форматтер, или "макет"):**
Он решает, **КАК** будет выглядеть итоговая запись в логе. `System.out.println` просто печатает строку. Логгер же форматирует ее, добавляя
полезный контекст:

* Дата и время с точностью до миллисекунд.
* Уровень логирования (INFO, ERROR).
* Имя потока (Thread), в котором произошло событие (критически важно для многопоточных приложений).
* Имя класса, который сделал запись.
* Само сообщение.

Пример отформатированной записи:
`2023-10-27 15:30:12.123 [main] INFO com.myapp.MyService - Метод doSomething начал свою работу.`

#### Схема работы:

1. Вы вызываете `logger.info("Сообщение")`.
2. Логгер проверяет: "Уровень INFO выше или равен настроенному минимальному уровню?".
3. **Если нет** -> Ничего не происходит. Вызов метода почти мгновенно завершается.
4. **Если да** -> Создается объект `LogEvent` (сообщение, уровень, время и т.д.).
5. Этот объект передается всем настроенным **Аппендерам**.
6. Каждый Аппендер с помощью своего **Форматтера** превращает `LogEvent` в строку.
7. Отформатированная строка записывается в место назначения (консоль, файл...).

--------------------------------------------------------------------------------------------------------------------

Что такое Apache log4j?

Это самая первая библиотека логирования, появилась еще в 1999 году.
Конфигурируется через xml, либо через properties.
Поддерживает большое количество способов вывода логов: от консоли и файла до записи в БД.
Также имеет поддержку обширного формата логирования: от обычного текстового вывода до html.
Именно он ввел понятие appender - кто пишет в лог, layout - форматирование. В конфигурации задаются эти самые appender-ы и какого уровня сообщения попадают к какому appender-у.
Ввел соответствие иерархичности категорий и пакетов: например, можно логгировать все сообщения из org.hibernate и заглушить всё из org.hibernate.type.

Проект сейчас не развивается и по сути заброшен, с версией Java 9 уже не совместим.
Поэтому на данный момент рекомендуется использовать log4j2, о котором речь пойдет ниже.

--------------------------------------------------------------------------------------------------------------------

Что такое Logback?

Logback - одна из наиболее широко используемых сред ведения журналов в сообществе Java. Logback написал тот же разработчик, что и log4j, чтобы создать ему преемника. В основе была та же идея, что и в log4j. Отличия были в том, что в logback:

улучшена производительность;

добавлена нативная поддержка slf4j;

расширена опция фильтрации.

Стандартно logback не требует каких-либо настроек и записывает все логи начиная от уровня DEBUG и выше. Если нужна настройка, ее можно выполнить через xml конфигурацию:

<configuration> 

<appender name="FILE" class="ch.qos.logback.core.FileAppender"> <file>app.log</file> 
<encoder> 
<pattern>%d{HH:mm:ss,SSS} %-5p [%c] - %m%n</pattern> 
</encoder> 
</appender>

 <logger name="org.hibernate.SQL" level="DEBUG" /> 
<logger name="org.hibernate.type.descriptor.sql" level="TRACE" /> 

<root level="info">
 <appender-ref ref="FILE" /> 
</root> 
</configuration>

--------------------------------------------------------------------------------------------------------------------

Что такое SLF4J?

SLF4J является оберткой над logback, а также над JUL, log4j, или JCL, а также над любым логгером, который реализует ее интерфейс.
Для работы с SLF4J нужны библиотека slf4j-api-1.x.x.jar и реализация одного из логгеров либо заглушка. Как правило реализации всех логгеров ( кроме logback) поставляются вместе с SLF4J и имеют названия на подобии slf4j-jcl-1.x.jar, slf4j-log4j12-1.x.jar, slf4j-nop-1.x.jar и т.п.
Если в classpath не будет найдена реализация логгера ( или заглушка nop) SLF4J гневно ругнется и работать откажется. Конфигурация соответственно будет искаться в зависимости от положенной в classpath реализации.
В идеальном мире мы должны выводить сообщения через интерфейс обертки, и тогда у нас все будет хорошо, но реальный жестокий мир говорит о том, что всем нам приходится взаимодействовать со сторонними библиотеками или кодом, в которых используются другие логгеры и которые знать не знают о SLF4J. Что бы не подстраиваться под каждый логгер, а пустить все сообщения через одну реализацию интерфейса SLF4J, можно использовать bridging. В поставке обертки содержаться библиотеки jcl-over-slf4j.jar, log4j-over-slf4j.jar и jul-to-slf4j.jar, которые переопределяют поведение соответствующих логгеров и перенаправляют сообщения в обертку.

--------------------------------------------------------------------------------------------------------------------

### Что работает быстрее: Logger или System.out.println (sout)?

**1. Стоимость выключенного лога**

Это главное преимущество логгеров.

* **sout:**
  ```java
  // Эта строка ВСЕГДА будет выполняться
  // Конкатенация строк произойдет в любом случае
  System.out.println("Processing user: " + user.getName() + " with ID: " + user.getId());
  ```
  Даже если вы не смотрите в консоль, сборка этой строки (конкатенация) и вызов метода `println` происходят всегда, тратя ресурсы CPU и
  память.

* **logger:**
  ```java
  // Если уровень DEBUG выключен, эта строка НЕ БУДЕТ выполняться
  logger.debug("Processing user: {} with ID: {}", user.getName(), user.getId());
  ```
  Современные логгеры (через фасад SLF4J) сначала проверяют, включен ли нужный уровень (`isDebugEnabled()`). Если нет, то
  методы `user.getName()` и `user.getId()` даже **не будут вызваны**, и строка не будет формироваться. Экономия огромна, особенно если для
  получения данных нужно выполнить какие-то операции.

**2. Блокировки и многопоточность**

* **sout:** `System.out` — это синхронизированный поток (`PrintStream`). Это значит, что если несколько потоков одновременно попытаются
  что-то напечатать, они будут ждать в очереди. В высоконагруженном приложении это может стать "бутылочным горлышком" и серьезно замедлить
  работу.

* **logger:** Современные фреймворки (Log4j2, Logback) поддерживают **асинхронные логгеры**. Они работают так:
    1. Ваш поток вызывает `logger.info(...)`.
    2. Логгер немедленно помещает событие в быструю очередь в памяти и **сразу возвращает управление вашему потоку**.
    3. Отдельный, фоновый поток забирает события из очереди и занимается "медленной" работой — форматированием и записью на диск/в сеть.

В итоге, ваши основные рабочие потоки почти не тратят время на ожидание записи лога, что кардинально повышает пропускную способность
приложения.

**3. I/O (Ввод-вывод)**

Самая медленная операция — это запись на диск или в сеть. И `sout`, и логгер в конечном счете выполняют I/O. Но, как сказано выше,
асинхронный логгер делает это в отдельном потоке, не блокируя основную логику вашего приложения.
