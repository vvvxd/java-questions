Что такое мониторинг?

Мониторинг — это постоянный сбор и анализ различных параметров (метрик) поведения системы. С его помощью можно описать и измерить в числовом выражении каждый важный аспект проекта.

Данные из разных точек среды собираются системой мониторинга, которая отвечает за хранение, агрегацию, визуализацию данных и автоматические реагирует на изменения, когда значения соответствует заданным условиям.

Системы мониторинга выполняют множество взаимосвязанных функций. Их первая обязанность - принимать и хранить входящие данные и историю. Текущие значения более полезно видеть в сравнении с прошлыми значениями, чтобы сформировать контекст изменений и тенденций. Это означает, что система мониторинга должна быть способна управлять данными в течение определенного периода времени, а так же визуализировать.

Помните, задача мониторинга — предоставлять информацию о сбоях в работе. Она не выполняется разово, изменения должны внедряться вместе с изменениями самого приложения.

--------------------------------------------------------------------------------------------------------------------
Ключевые концепции и метрики SRE

SLI (Service Level Indicator): Индикатор уровня обслуживания. Это конкретная, измеряемая метрика. Примеры: задержка ответа (latency), процент ошибок, доступность (availability).
SLO (Service Level Objective): Целевой уровень обслуживания. Это цель, которую вы ставите для вашего SLI на определенный период. Пример: "99.9% запросов должны обрабатываться менее чем за 200 мс в течение месяца".
SLA (Service Level Agreement): Соглашение об уровне обслуживания. Это юридический контракт с пользователем, который определяет последствия (обычно финансовые) при несоблюдении SLO. SRE фокусируется на SLO, а не на SLA.

--------------------------------------------------------------------------------------------------------------------

Какие есть системы для мониторинга приложения?

Grafana — универсальная обертка для работы с аналитическими данными, которые хранятся в разных источниках. Она сама ничего не хранит и не собирает, а является лишь универсальным клиентом для систем хранения метрик. Например, с помощью нее можно ходить за цифрами как в традиционную базу PostgreSQL, так и в специализированные аналитические системы типа Prometheus.

Prometheus — Система сбора данных временных рядов, разработанная музыкальной компанией SoundCloud для решения внутренних потребностей в быстрой и гибкой обработке продуктовых метрик. Продукт с задачей справился настолько хорошо, что был выпущен за границы SoundCloud и теперь доступен как opensource для всех желающих.

Zabbix — свободная система мониторинга и отслеживания статусов разнообразных сервисов компьютерной сети, серверов и сетевого оборудования

--------------------------------------------------------------------------------------------------------------------

Что можно и нужно мониторить в приложениях (какие основные метрики)?

Memory Usage - Общий объем памяти, используемый самой JVM.

Threads - Количество тредов, находящихся в статусах: new, runnable, timed-waiting, waiting или blocked.

Heap Memory - Общее использование heap memory самой JVM.

Memory Pools - Использование memory pools

Garbage Collection - Значение garbage collection и время его выполнения

--------------------------------------------------------------------------------------------------------------------

Что такое база данных временных рядов?

Базы данных временных рядов предназначены для хранения данных, которые изменяются со временем. Это могут быть абсолютно любые данные, собранные с течением времени. Это могут быть метрические показатели, собранные из некоторых систем - все системы трендов являются примерами данных временных рядов.
Каждый раз, когда вы смотрите на информационные панели в ClusterControl, на самом деле вы видите визуальное представление временных рядов, хранящихся в Prometheus - базе данных временных рядов.
Временные ряды не ограничиваются метрическими показателями базы данных. Метриками может быть что угодно - изменение потока людей, входящих в торговый центр, с течением времени, изменение трафика в городе, использование общественного транспорта в течение дня, течение воды в реке или ручье, количество энергии, вырабатываемое водной установкой - все это и все остальное, что можно измерить во времени, является примером временных рядов. Такие данные можно запросить, построить, проанализировать, чтобы найти корреляционную зависимость между различными метриками.

--------------------------------------------------------------------------------------------------------------------

Что такое Prometheus?

Prometheus — это база данных временных рядов.
Prometheus хранит наши метрические данные в виде временных рядов в памяти, периодически извлекая их через HTTP (скрейпинг).

Prometheus сам решает, где и как часто проводить скрейпинг.
Если объекты сами отправляют данные, есть риск, что таких данных будет слишком много, и на сервере произойдет сбой. Когда система собирает данные, можно контролировать частоту сбора и создавать несколько конфигураций скрейпинга, чтобы выбирать разную частоту для разных объектов.

Prometheus хранит агрегированные метрики.
Prometheus не основан на событиях и этим сильно отличается от других баз данных временных рядов. Он не перехватывает отдельные события с привязкой ко времени (например, перебои с сервисом), а собирает предварительно агрегированные метрики о ваших сервисах.

--------------------------------------------------------------------------------------------------------------------

Как Prometheus может извлекать метрики из систем?

Инструментирование приложения, то есть ваше приложение будет предоставлять совместимые с Prometheus метрики по заданному URL. Prometheus определит его как целевой объект и будет скрейпить с указанным интервалом.

Использование готовых экспортеров. В Prometheus есть целая коллекция экспортеров для существующих технологий. Например, готовые экспортеры для мониторинга машин Linux (Node Exporter), для распространенных баз данных (SQL Exporter или MongoDB Exporter) и даже для балансировщиков нагрузки HTTP (например, HAProxy Exporter).

Использование Pushgateway. Иногда приложения или задания не предоставляют метрики напрямую. Они могут быть не предназначены для этого (например, пакетные задания) или вы сами решили не предоставлять метрики напрямую через приложение.

--------------------------------------------------------------------------------------------------------------------

Инструменты расширяющие функционал Prometheus?

По сути Prometheus — база данных временных рядов.
Но при работе с такими базами данных часто нужно визуализировать данные, анализировать их и настраивать по ним оповещения.

Prometheus поддерживает следующие инструменты, расширяющие его функционал:

Alertmanager. Prometheus отправляет оповещения в Alertmanager на основе кастомных правил, определенных в файлах конфигурации. Оттуда их можно экспортировать в разные конечные точки (например, Pagerduty или Slack).

Визуализация данных. Как и в Grafana, вы можете визуализировать временные ряды прямо в пользовательском веб-интерфейсе Prometheus. Вы можете фильтровать данные и составлять конкретные обзоры происходящего в разных целевых объектах.

Обнаружение сервисов. Prometheus динамически обнаруживает целевые объекты и автоматически скрейпит новые цели по запросу. Это особенно удобно, если вы работаете с контейнерами, которые динамически меняют адреса в зависимости от спроса.

--------------------------------------------------------------------------------------------------------------------

Prometheus - формат данных

Формат, в котором метрики пишутся приложением и отдаются Prometheus-ом из БД, достаточно простой и сделан, чтобы легко читаться глазами. Подсчет и форматирование метрик из приложения не нужно делать вручную — для этого есть библиотеки. Вот так выглядит страничка, которую приложение должно отдать на GET /metrics:

# HELP http_requests_total Requests made to public API # TYPE http_requests_total counter http_requests_total{method="POST", url="/messages"} 1 http_requests_total{method="GET", url="/messages"} 3 http_requests_total{method="POST", url="/login"} 2

Что здесь есть:
HELP — описание для помощи человекам
TYPE — тип метрики
http_requests_total — имя метрики
набор key-value лейблов (можно еще называть их тегами)
значение метрики (64-bit float aka double)
после сбора в БД добавляется еще timestamp

Хранение работает так: имя метрики - на самом деле тоже лейбл с именем __name__. Все лейблы вместе описывают собой time series (временной ряд), т.е. это как бы имя таблицы, составленное из всех key-value. В этом ряду лежат значения [(timestamp1, double1), (timestamp2, double2), ...]. Из примера выше, у нас одна метрика, но в базе есть три таблицы: для GET /messages, POST /messages и POST /login. В каждую таблицу раз в 30 секунд пишется очередное число, которое момент scrape-а показало приложение.

--------------------------------------------------------------------------------------------------------------------

Типы метрик Prometheus


*   **Counter (Счетчик):** Монотонно растущее значение. Например, `http_requests_total` — общее число HTTP-запросов с момента старта приложения. Он может только увеличиваться или сбрасываться до нуля при перезапуске. Идеально для подсчета событий.
*   **Gauge (Датчик):** Значение, которое может как увеличиваться, так и уменьшаться. Например, `cpu_temperature_celsius` (температура процессора), `go_goroutines` (количество активных горутин), `memory_usage_bytes` (использование памяти).
*   **Histogram (Гистограмма):** Измеряет распределение значений. Классический пример — `http_request_duration_seconds`. Она не просто хранит среднее время ответа, а распределяет все замеры по "корзинам" (бакетам): сколько запросов выполнилось быстрее 0.1с, сколько быстрее 0.5с, и т.д. Это позволяет считать перцентили (например, 95-й или 99-й перцентиль времени ответа), что гораздо важнее среднего значения.
*   **Summary (Сводка):** Похожа на гистограмму, но перцентили считаются на стороне клиента (в приложении), а Prometheus получает уже готовые значения (`..._quantile{quantile="0.99"}`). Используется реже, так как сложнее в агрегации.

--------------------------------------------------------------------------------------------------------------------

Что такое Grafana?

Grafana — свободная программная система визуализации данных, ориентированная на данные систем ИТ-мониторинга. Реализована как веб-приложение в стиле «приборных панелей» с диаграммами, графиками, таблицами, предупреждениями.

Grafana предоставляет богатый пользовательский интерфейс, позволяющий создавать, исследовать и совместно использовать дашборды, содержащие несколько графиков.

--------------------------------------------------------------------------------------------------------------------

Термины Grafana

Панель — базовый элемент визуализации выбранных показателей. Grafana поддерживает панели с графиками, единичными статусами, таблицами, тепловыми картами кликов и произвольным текстом, а также интеграцию с официальными и созданными сообществом плагинами (например, карта мира или часы) и приложениями, которые также можно визуализировать. Можно настроить стиль и формат каждой панели; все панели можно перетаскивать на новое место, перестраивать и изменять их размер.

Дашборд — набор отдельных панелей, размещенных в сетке с набором переменных (например, имя сервера, приложения и датчика). Изменяя переменные, можно переключать данные, отображаемые на дашборде (например, данные с двух отдельных серверов). Все дашборды можно настраивать, а также секционировать и фрагментировать представленные в них данные в соответствии с потребностями пользователя. В проекте Grafana участвует большое сообщество разработчиков кода и пользователей, поэтому существует большой выбор готовых дашбордов для разных типов данных и источников.

В дашбордах можно использовать аннотации для отображения определенных событий на разных панелях. Аннотации добавляются настраиваемыми запросами в Elasticsearch; на графике аннотация отображается вертикальной красной линией. При наведении курсора на аннотацию можно получить описание события и теги, например, для отслеживания ответа сервера с кодом ошибки 5xx или перезапуска системы. Благодаря этому можно легко сопоставить время, конкретное событие и его последствия в приложении и исследовать поведение системы.

--------------------------------------------------------------------------------------------------------------------
Что такое Micrometer?

Micrometer — это фасад (abstraction layer) для работы с метриками, который позволяет разработчикам собирать метрики в приложении, не привязываясь к конкретной системе мониторинга. Основная идея Micrometer — предоставить единый API для создания метрик, а затем использовать различные "бэкенды" (регистры) для экспорта этих метрик в нужные системы.

### Основные особенности Micrometer:
- **Vendor-agnostic**: Поддерживает множество систем мониторинга через плагины (Prometheus, InfluxDB, StatsD, JMX и др.).
- **Простота интеграции**: Особенно удобен для Spring Boot, где интеграция настраивается автоматически.
- **Гибкость**: Поддерживает разные типы метрик (счётчики, гистограммы, таймеры, датчики).
- **Иерархическая и теговая модель**: Метки (tags) позволяют детализировать метрики, что идеально для систем вроде Prometheus.
- **Высокая производительность**: Минимальная нагрузка на приложение при сборе метрик.
- **Экосистема Spring**: Глубокая интеграция с Spring Boot Actuator для автоматического мониторинга.

Micrometer часто называют "SLF4J для метрик", так как он предоставляет абстракцию, аналогичную тому, как SLF4J абстрагирует логирование.

Micrometer состоит из следующих ключевых компонентов:

### 2.1. MeterRegistry
`MeterRegistry` — это центральный компонент, который управляет сбором и экспортом метрик. Каждый регистр соответствует определённой системе мониторинга. Например:
- `PrometheusMeterRegistry` для экспорта в Prometheus.
- `InfluxMeterRegistry` для InfluxDB.
- `SimpleMeterRegistry` для хранения метрик в памяти (полезно для тестирования).

Вы можете использовать несколько регистров одновременно, чтобы отправлять метрики в разные системы.

### 2.2. Метрики (Meters)
Метрики — это объекты, которые собирают данные. Micrometer поддерживает несколько типов метрик:
1. **Counter**: Монотонно возрастающий счётчик (например, количество HTTP-запросов).
2. **Gauge**: Значение, которое может увеличиваться или уменьшаться (например, текущий размер пула соединений).
3. **Timer**: Измеряет время выполнения операций и их частоту (например, время обработки запроса).
4. **DistributionSummary**: Гистограмма для анализа распределения значений (например, размер ответа API).
5. **LongTaskTimer**: Измеряет длительность долгих задач.
6. **FunctionCounter/Timer**: Метрики, основанные на функции, которая вычисляет значение.

### 2.3. Метки (Tags)
Метки — это пары ключ-значение, которые добавляют контекст к метрикам. Например:
```
http_requests_total{method="GET", endpoint="/api/users", status="200"} 100
```
Здесь метки `method`, `endpoint` и `status` уточняют, к какому запросу относится метрика. Это особенно важно для Prometheus, который использует метки для фильтрации и агрегации.

### 2.4. MeterBinder
`MeterBinder` — это интерфейс для автоматической регистрации метрик. Например, в Spring Boot `MeterBinder` используется для мониторинга JVM, HTTP-запросов, пулов соединений и других компонентов.

--------------------------------------------------------------------------------------------------------------------
## Что такое Grafana Loki?

**Loki** — это open-source система агрегации логов, разработанная Grafana Labs в 2018 году и вдохновлённая Prometheus. Она предназначена для эффективного сбора, хранения и анализа логов в современных облачных и распределённых системах, таких как Kubernetes. Loki часто называют «Prometheus, но для логов», так как он использует схожую модель меток (labels) и интеграцию с Grafana для визуализации.[](https://github.com/grafana/loki)

Основные характеристики:
- **Горизонтальная масштабируемость**: Loki может обрабатывать от небольших локальных установок до петабайт данных в день.
- **Экономичность**: Не индексирует содержимое логов, а только метаданные (метки), что снижает затраты на хранение.
- **Интеграция с Grafana**: Позволяет визуализировать логи рядом с метриками и трассировками.
- **Мультитенантность**: Поддерживает разделение данных для разных пользователей или команд.
- **Простота**: Минимальные зависимости, возможность запуска в виде одного бинарного файла.

## Архитектура Loki
Loki состоит из трёх основных компонентов, которые работают вместе для сбора, хранения и визуализации логов:

1. **Агент (например, Grafana Alloy или Promtail)**:
    - **Роль**: Собирает логи из источников (файлы, Docker, Kubernetes Pods) и отправляет их в Loki.
    - **Promtail**: Специализированный агент для Loki, который добавляет метки к логам (например, `pod_name`, `namespace`) и отправляет их через HTTP API. Promtail заменяется Alloy, так как Grafana считает Promtail завершённым, а Alloy — более универсальным агентом.[](https://github.com/grafana/loki)
    - **Пример**: Promtail читает `/var/log/*.log` или логи контейнеров Docker и отправляет их в Loki.

2. **Loki Server**:
    - **Роль**: Принимает логи, хранит их и обрабатывает запросы.
    - **Компоненты**:
        - **Distributor**: Принимает логи от агентов, хеширует их по меткам и распределяет между Ingester'ами.
        - **Ingester**: Создаёт сжатые чанки (chunks) логов и временно хранит их в памяти, затем сбрасывает в объектное хранилище (например, S3, GCS).
        - **Querier**: Обрабатывает запросы, извлекая данные из чанков или Ingester'ов.
        - **Index Store**: Хранит индексы меток (не содержимое логов) для быстрого поиска.
        - **Chunk Store**: Хранит сжатые логи в объектном хранилище.
    - **Особенность**: Loki не индексирует текст логов, только метки, что уменьшает размер индекса и ускоряет запросы.
3. **Grafana**:
    - **Роль**: Визуализирует логи через дашборды, позволяет выполнять запросы на языке LogQL.
    - **Интеграция**: Логи отображаются рядом с метриками (Prometheus) и трассировками (Tempo), обеспечивая целостную картину системы.

## Как работает Loki?
1. **Сбор логов**:
    - Агент (Promtail/Alloy) читает логи из файлов, контейнеров или других источников.
    - Логи группируются в **потоки (streams)** на основе меток (например, `{app="frontend", env="prod"}`).
    - Логи отправляются в Loki через HTTP API в сжатом виде.

2. **Хранение**:
    - Логи сжимаются в чанки (gzip) и хранятся в объектном хранилище (S3, GCS, MinIO или локальная файловая система для тестов).
    - Метки индексируются в отдельном хранилище (например, DynamoDB, BoltDB или Cassandra).
    - Отсутствие индексации текста логов снижает затраты на хранение (до 75% по сравнению с ELK).
   
3. **Запросы**:
    - Пользователь пишет запрос на LogQL (например, `{job="nginx"} |~ "error"`) в Grafana или LogCLI.
    - Loki ищет нужные чанки по меткам, распаковывает их и фильтрует по условиям.
    - Результаты отображаются в Grafana или возвращаются через CLI/API.
