<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Вопросы по собеседованию</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .question-block {
            cursor: pointer;
            transition: background-color 0.3s ease;
            word-break: break-word;
        }
        .question-block:hover {
            background-color: #f3f4f6;
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen">

<!-- Контейнер с вопросом -->
<div id="question-container" class="bg-white shadow-lg rounded-lg p-6 w-[800px] h-[750px] flex items-center justify-center text-center relative">
    <div id="question-block" class="question-block p-4 border-b w-full h-full flex items-center justify-center text-center relative" onclick="toggleAnswer()">
        <strong class="text-lg block" id="question-text"></strong>
        <div id="answer-text" class="text-gray-700 hidden" onclick="toggleAnswer()"></div>
    </div>
</div>

<!-- Навигация -->
<div class="absolute bottom-10 flex justify-center gap-4">
    <button onclick="prevQuestion()" class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600">Назад</button>
    <button onclick="location.href='main.html'" class="bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600">На главную</button>
    <button onclick="nextQuestion()" class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600">Вперед</button>
</div>

<!-- Модальное окно -->
<div id="modal" class="fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 hidden">
    <div class="bg-white p-6 rounded-lg shadow-lg w-[900px] h-[800px] overflow-y-auto">
        <h2 class="text-lg font-semibold mb-4">Ответ</h2>
        <p id="modal-answer" class="text-gray-700"></p>
        <button onclick="closeModal()" class="mt-4 bg-red-500 text-white px-4 py-2 rounded hover:bg-red-600 w-full">Закрыть</button>
    </div>
</div>

<script>
    let currentQuestionIndex = 0;
    const MAX_ANSWER_LENGTH = 2000; // Максимальная длина ответа для отображения без модального окна

    const questions = [
        {
  question: "Расскажите о модели памяти Java?",
  answer: "Модель памяти Java (Java Memory Model, JMM) описывает поведение потоков в среде исполнения Java. Это часть семантики языка Java, набор правил, описывающий выполнение многопоточных программ и правил, по которым потоки могут взаимодействовать друг с другом посредством основной памяти.<br>Формально модель памяти определяет набор действий межпоточного взаимодействия (эти действия включают в себя, в частности, чтение и запись переменной, захват и освобождений монитора, чтение и запись volatile переменной, запуск нового потока), а также модель памяти определяет отношение между этими действиями -happens-before - абстракции обозначающей, что если операция X связана отношением happens-before с операцией Y, то весь код следуемый за операцией Y, выполняемый в одном потоке, видит все изменения, сделанные другим потоком, до операции X.Существует несколько основных правил для отношения happens-before:В рамках одного потока любая операция happens-before любой операцией, следующей за ней в исходном коде;Освобождение монитора (unlock) happens-before захват того же монитора (lock);Выход из synchronized блока/метода happens-before вход в synchronized блок/метод на том же мониторе;Запись volatile поля happens-before чтение того же самого volatile поля;Завершение метода run() экземпляра класса Thread happens-before выход из метода join() или возвращение false методом isAlive() экземпляром того же потока;Вызов метода start() экземпляра класса Thread happens-before начало метода run() экземпляра того же потока;Завершение конструктора happens-before начало метода finalize() этого класса;Вызов метода interrupt() на потоке happens-before обнаружению потоком факта, что данный метод был вызван либо путем выбрасывания исключения InterruptedException, либо с помощью методов isInterrupted() или interrupted().<br>Связь happens-before транзитивна, т.е. если X happens-before Y, а Y happens-before Z, то X happens-before Z.<br>Освобождение/захват монитора и запись/чтение в volatile переменную связаны отношением happens-before, только если операции проводятся над одним и тем же экземпляром объекта.<br>В отношении happens-before участвуют только два потока, о поведении остальных потоков ничего сказать нельзя, пока в каждом из них не наступит отношение happens-before с другим потоком.<br>Можно выделить несколько основных областей, имеющих отношение к модели памяти:<br>Видимость (visibility). Один поток может в какой-то момент временно сохранить значение некоторых полей не в основную память, а в регистры или локальный кэш процессора, таким образом второй поток, выполняемый на другом процессоре, читая из основной памяти, может не увидеть последних изменений поля. И наоборот, если поток на протяжении какого-то времени работает с регистрами и локальными кэшами, читая данные оттуда, он может сразу не увидеть изменений, сделанных другим потоком в основную память.<br>К вопросу видимости имеют отношение следующие ключевые слов языка Java: synchronized, volatile, final.<br>С точки зрения Java все переменные (за исключением локальных переменных, объявленных внутри метода) хранятся в главной памяти, которая доступна всем потокам, кроме этого, каждый поток имеет локальную—рабочую—память, где он хранит копии переменных, с которыми он работает, и при выполнении программы поток работает только с этими копиями. Надо отметить, что это описание не требование к реализации, а всего лишь модель, которая объясняет поведение программы, так, в качестве локальной памяти не обязательно выступает кэш память, это могут быть регистры процессора или потоки могут вообще не иметь локальной памяти.<br>При входе в synchronized метод или блок поток обновляет содержимое локальной памяти, а при выходе из synchronized метода или блока поток записывает изменения, сделанные в локальной памяти, в главную. Такое поведение synchronized методов и блоков следует из правил для отношения «происходит раньше»: так как все операции с памятью происходят раньше освобождения монитора и освобождение монитора происходит раньше захвата монитора, то все операции с памятью, которые были сделаны потоком до выхода из synchronized блока должны быть видны любому потоку, который входит в synchronized блок для того же самого монитора. Очень важно, что это правило работает только в том случае, если потоки синхронизируются, используя один и тот же монитор!<br>Что касается volatile переменных, то запись таких переменных производится в основную память, минуя локальную. и чтение volatile переменной производится также из основной памяти, то есть значение переменной не может сохраняться в регистрах или локальной памяти потока и операция чтения этой переменной гарантированно вернёт последнее записанное в неё значение.<br>Также модель памяти определяет дополнительную семантику ключевого слова final, имеющую отношение к видимости: после того как объект был корректно создан, любой поток может видеть значения его final полей без дополнительной синхронизации. «Корректно создан» означает, что ссылка на создающийся объект не должна использоваться до тех пор, пока не завершился конструктор объекта. Наличие такой семантики для ключевого слова final позволяет создание неизменяемых (immutable) объектов, содержащих только final поля, такие объекты могут свободно передаваться между потоками без обеспечения синхронизации при передаче.<br>Есть одна проблема, связанная с final полями: реализация разрешает менять значения таких полей после создания объекта (это может быть сделано, например, с использованием механизма reflection). Если значение final поля—константа, чьё значение известно на момент компиляции, изменения такого поля могут не иметь эффекта, так-как обращения к этой переменной могли быть заменены компилятором на константу. Также спецификация разрешает другие оптимизации, связанные с final полями, например, операции чтения final переменной могут быть переупорядочены с операциями, которые потенциально могут изменить такую переменную. Так что рекомендуется изменять final поля объекта только внутри конструктора, в противном случае поведение не специфицировано.<br>Reordering (переупорядочивание). Для увеличения производительности процессор/компилятор могут переставлять местами некоторые инструкции/операции. Вернее, с точки зрения потока, наблюдающего за выполнением операций в другом потоке, операции могут быть выполнены не в том порядке, в котором они идут в исходном коде. Тот же эффект может наблюдаться, когда один поток кладет результаты первой операции в регистр или локальный кэш, а результат второй операции попадает непосредственно в основную память. Тогда второй поток, обращаясь к основной памяти может сначала увидеть результат второй операции, и только потом первой, когда все регистры или кэши синхронизируются с основной памятью. Еще одна причина reordering, может заключаться в том, что процессор может решить поменять порядок выполнения операций, если, например, сочтет что такая последовательность выполнится быстрее.<br>Вопрос reordering также регулируется набором правил для отношения «происходит раньше» и у этих правил есть следствие, касающееся порядка операций, используемое на практике: операции чтения и записи volatile переменных не могут быть переупорядочены с операциями чтения и записи других volatile и не-volatile переменных. Это следствие делает возможным использование volatile переменной как флага, сигнализирующем об окончании какого-либо действия. В остальном правила, касающиеся порядка выполнения операций, гарантируют упорядоченность операций для конкретного набора случаев (таких как, например, захват и освобождение монитора), во всех остальных случаях оставляя компилятору и процессору полную свободу для оптимизаций.<br>"
}
,{
  question: "Что такое «потокобезопасность»?",
  answer: "Потокобезопасность - свойство объекта или кода, которое гарантирует, что при исполнении или использовании несколькими потоками, код будет вести себя, как предполагается. Например потокобезопасный счётчик не пропустит ни один счёт, даже если один и тот же экземпляр этого счётчика будет использоваться несколькими потоками."
}
,{
  question: "В чём разница между «конкуренцией» и «параллелизмом»?",
  answer: "Конкуренция — это способ одновременного решения множества задач.<br>Признаки:<br>Наличие нескольких потоков управления (например, Thread в Java, корутина в Kotlin), если поток управления один, то конкурентного выполнения быть не может<br>Недетерминированный результат выполнения. Результат зависит от случайных событий, реализации и того, как была проведена синхронизация. Даже если каждый поток полностью детерминированный, итоговый результат будет недетерминированнымПараллелизм — это способ выполнения разных частей одной задачи.<br>Признаки:<br>Необязательно имеет несколько потоков управления<br>Может приводить к детерминированному результату, так, например, результат умножения каждого элемента массива на число, не изменится, если умножать его по частям параллельно.<br>"
}
,{
  question: "Что такое «кооперативная многозадачность»? Какой тип многозадачности использует Java? Чем обусловлен этот выбор?",
  answer: "Кооперативная многозадачность - это способ деления процессорного времени между потоками, при котором каждый поток обязан отдавать управление следующему добровольно.<br>Преимущества такого подхода - простота реализации, меньшие накладные расходы на переключение контекста.<br>Недостатки - если один поток завис или ведет себя некорректно, то зависает целиком вся система и другие потоки никогда не получат управление.<br>Java использует вытесняющую многозадачность, при которой решение о переключении между потоками процесса принимает операционная система.<br>В отличие от кооперативной многозадачности управление операционной системе передаётся вне зависимости от состояния работающих приложений, благодаря чему, отдельные зависшие потоки процесса, как правило, не «подвешивают» всю систему целиком. За счёт регулярного переключения между задачами также улучшается отзывчивость приложения и повышается оперативность освобождения ресурсов, которые больше не используются.<br>В реализации вытесняющая многозадачность отличается от кооперативной, в частности, тем, что требует обработки системного прерывания от аппаратного таймера.<br>"
}
,{
  question: "Что такое ordering, as-if-serial semantics, sequential consistency, visibility, atomicity, happens-before, mutual exclusion, safe publication?",
  answer: "ordering механизм, который определяет, когда один поток может увидеть out-of-order (неверный) порядок исполнения инструкций другого потока. CPU для для повышения производительности может переупорядочивать процессорные инструкции и выполнять их в произвольном порядке до тех пор пока для потока внутри не будет видно никаких отличий. Гарантия, предоставляемая этим механизмом, называется as-if-serial semantics.sequential consistency - то же что и as-if-serial semantics, гарантия того, что в рамках одного потока побочные эффекты от всех операций будут такие, как будто все операции выполняются последовательно.<br>visibility определяет, когда действия в одном потоке становятся видны из другого потока.happens-before - логическое ограничение на порядок выполнения инструкций программы. Если указывается, что запись в переменную и последующее ее чтение связаны через эту зависимость, то как бы при выполнении не переупорядочивались инструкции, в момент чтения все связанные с процессом записи результаты уже зафиксированы и видны.atomicity — атомарность операций. Атомарная операция выглядит единой и неделимой командой процессора, которая может быть или уже выполненной или ещё невыполненной.mutual exclusion (взаимоисключающая блокировка, семафор с одним состоянием) - механизм, гарантирующий потоку исключительный доступ к ресурсу. Используется для предотвращения одновременного доступа к общему ресурсу. В каждый момент времени таким ресурсом может владеть только один поток. Простейший пример:<br>synchronized(obj) { ... }.<br>safe publication? - показ объектов другим потокам из текущего, не нарушая ограничений visibility. Способы такой публикации в Java:<br>static{} инициализатор;<br>volatile переменные;<br>atomic переменные;<br>сохранение в разделяемой переменной, корректно защищенной с использованием synchronized(), синхронизаторов или других конструкций, создающих read/write memory barrier;<br>final переменные в разделяемом объекте, который был корректно проинициализирован.<br>"
}
,{
  question: "Чем отличается процесс от потока?",
  answer: "Процесс — экземпляр программы во время выполнения, независимый объект, которому выделены системные ресурсы (например, процессорное время и память). Каждый процесс выполняется в отдельном адресном пространстве: один процесс не может получить доступ к переменным и структурам данных другого. Если процесс хочет получить доступ к чужим ресурсам, необходимо использовать межпроцессное взаимодействие. Это могут быть конвейеры, файлы, каналы связи между компьютерами и многое другое.<br>Для каждого процесса ОС создает так называемое «виртуальное адресное пространство», к которому процесс имеет прямой доступ. Это пространство принадлежит процессу, содержит только его данные и находится в полном его распоряжении. Операционная система же отвечает за то, как виртуальное пространство процесса проецируется на физическую память.<br>Поток(thread) — определенный способ выполнения процесса, определяющий последовательность исполнения кода в процессе. Потоки всегда создаются в контексте какого-либо процесса, и вся их жизнь проходит только в его границах. Потоки могут исполнять один и тот же код и манипулировать одними и теми же данными, а также совместно использовать описатели объектов ядра, поскольку таблица описателей создается не в отдельных потоках, а в процессах. Так как потоки расходуют существенно меньше ресурсов, чем процессы, в процессе выполнения работы выгоднее создавать дополнительные потоки и избегать создания новых процессов.<br>"
}
,{
  question: "Каким образом можно создать поток?",
  answer: "Создать потомка класса Thread и переопределить его метод run();Создать объект класса Thread, передав ему в конструкторе экземпляр класса, реализующего интерфейс Runnable. Эти интерфейс содержит метод run(), который будет выполняться в новом потоке. Поток закончит выполнение, когда завершится его метод run().Вызвать метод submit() у экземпляра класса реализующего интерфейс ExecutorService, передав ему в качестве параметра экземпляр класса реализующего интерфейс Runnable или Callable (содержит метод call(), в котором описывается логика выполнения)."
}
,{
  question: "Чем различаются Thread и Runnable?",
  answer: "Thread - это класс, некоторая надстройка над физическим потоком.<br>Runnable - это интерфейс, представляющий абстракцию над выполняемой задачей.<br>Помимо того, что Runnable помогает разрешить проблему множественного наследования, несомненный плюс от его использования состоит в том, что он позволяет логически отделить логику выполнения задачи от непосредственного управления потоком.<br>"
}
,{
  question: "В чём заключается разница между методами start() и run()?",
  answer: "Несмотря на то, что start() вызывает метод run() внутри себя, это не то же самое, что просто вызов run(). Если run() вызывается как обычный метод, то он вызывается в том же потоке и никакой новый поток не запускается, как это происходит, в случае, когда вы вызываете метод start()."
}
,{
  question: "Как принудительно запустить поток?",
  answer: "Никак. В Java не существует абсолютно никакого способа принудительного запуска потока. Это контролируется JVM и Java не предоставляет никакого API для управления этим процессом."
}
,{
  question: "Что такое «монитор» в Java?",
  answer: "Монитор, мьютекс (mutex) - это средство обеспечения контроля за доступом к ресурсу. У монитора может быть максимум один владелец в каждый текущий момент времени. Следовательно, если кто-то использует ресурс и захватил монитор для обеспечения единоличного доступа, то другой, желающий использовать тот же ресурс, должен подождать освобождения монитора, захватить его и только потом начать использовать ресурс.<br>Удобно представлять монитор как id захватившего его объекта. Если этот id равен 0 - ресурс свободен. Если не 0 - ресурс занят. Можно встать в очередь и ждать его освобождения.<br>В Java у каждого экземпляра объекта есть монитор, который контролируется непосредственно виртуальной машиной. Используется он так: любой нестатический synchronized-метод при своем вызове прежде всего пытается захватить монитор того объекта, у которого он вызван (на который он может сослаться как на this). Если это удалось - метод исполняется. Если нет - поток останавливается и ждет, пока монитор будет отпущен.<br>"
}
,{
  question: "Как работает synchronized для статического метода?",
  answer: "Если метод, в котором содержится критически важная «многопоточная» логика, статический, синхронизация будет осуществляться по классу."
}
,{
  question: "Дайте определение понятию «синхронизация».",
  answer: "Синхронизация - это процесс, который позволяет выполнять потоки параллельно.<br>В Java все объекты имеют одну блокировку, благодаря которой только один поток одновременно может получить доступ к критическому коду в объекте. Такая синхронизация помогает предотвратить повреждение состояния объекта. Если поток получил блокировку, ни один другой поток не может войти в синхронизированный код, пока блокировка не будет снята. Когда поток, владеющий блокировкой, выходит из синхронизированного кода, блокировка снимается. Теперь другой поток может получить блокировку объекта и выполнить синхронизированный код. Если поток пытается получить блокировку объекта, когда другой поток владеет блокировкой, поток переходит в состояние Блокировки до тех пор, пока блокировка не снимется.<br>"
}
,{
  question: "Какие существуют способы синхронизации в Java?",
  answer: "Системная синхронизация с использованием wait()/notify(). Поток, который ждет выполнения каких-либо условий, вызывает у этого объекта метод wait(), предварительно захватив его монитор. На этом его работа приостанавливается. Другой поток может вызвать на этом же самом объекте метод notify() (опять же, предварительно захватив монитор объекта), в результате чего, ждущий на объекте поток «просыпается» и продолжает свое выполнение. В обоих случаях монитор надо захватывать в явном виде, через synchronized-блок, потому как методы wait()/notify() не синхронизированы!Системная синхронизация с использованием join(). Метод join(), вызванный у экземпляра класса Thread, позволяет текущему потоку остановиться до того момента, как поток, связанный с этим экземпляром, закончит работу.Использование классов из пакета java.util.concurrent, который предоставляет набор классов для организации межпоточного взаимодействия. Примеры таких классов - Lock, Semaphore и пр.. Концепция данного подхода заключается в использовании атомарных операций и переменных."
}
,{
  question: "В каких состояниях может находиться поток?",
  answer: "Потоки могут находиться в одном из следующих состояний:<br>Новый (New). После создания экземпляра потока, он находится в состоянии Новый до тех пор, пока не вызван метод start(). В этом состоянии поток не считается живым.Работоспособный<br>(Runnable). Поток переходит в состояние Работоспособный, когда вызывается метод start(). Поток может перейти в это состояние также из состоянияРаботающий или из состояния Блокирован. Когда поток находится в этом состоянии, он считается живым.<br>Работающий (Running). Поток переходит из состояния Работоспособный в состояние Работающий, когда Планировщик потоков выбирает его как работающий в данный момент.Живой, но не работоспособный (Alive, but not runnable). Поток может быть живым, но не работоспособным по нескольким причинам:Ожидание (Waiting). Поток переходит в состояние Ожидания, вызывая метод wait(). Вызов notify() или notifyAll() может перевести поток из состояния Ожидания в состояние Работоспособный.Сон (Sleeping). Метод sleep() переводит поток в состояние Сна на заданный промежуток времени в миллисекундах.Блокировка (Blocked). Поток может перейти в это состояние, в ожидании ресурса, такого как ввод/вывод или из-за блокировки другого объекта. В этом случае поток переходит в состояние Работоспособный, когда ресурс становится доступен.Мёртвый (Dead). Поток считается мёртвым, когда его метод run() полностью выполнен. Мёртвый поток не может перейти ни в какое другое состояние, даже если для него вызван метод start()."
}
,{
  question: "Можно ли создавать новые экземпляры класса, пока выполняется static synchronized метод?",
  answer: "Да, можно создавать новые экземпляры класса, так как статические поля не принадлежат к экземплярам класса."
}
,{
  question: "Как работают методы wait() и notify()/notifyAll()?",
  answer: "Эти методы определены у класса Object и предназначены для взаимодействия потоков между собой при межпоточной синхронизации.<br>wait(): освобождает монитор и переводит вызывающий поток в состояние ожидания до тех пор, пока другой поток не вызовет метод notify()/notifyAll();<br>notify(): продолжает работу потока, у которого ранее был вызван метод wait();<br>notifyAll(): возобновляет работу всех потоков, у которых ранее был вызван метод wait().<br>Когда вызван метод wait(), поток освобождает блокировку на объекте и переходит из состояния Работающий (Running) в состояние Ожидания (Waiting). Метод notify() подаёт сигнал одному из потоков, ожидающих на объекте, чтобы перейти в состояние Работоспособный (Runnable). При этом невозможно определить, какой из ожидающих потоков должен стать работоспособным. Метод notifyAll() заставляет все ожидающие потоки для объекта вернуться в состояние Работоспособный (Runnable). Если ни один поток не находится в ожидании на методе wait(), то при вызове notify() или notifyAll() ничего не происходит.<br>Поток может вызвать методы wait() или notify() для определённого объекта, только если он в данный момент имеет блокировку на этот объект. wait(), notify() и notifyAll() должны вызываться только из синхронизированного кода.<br>"
}
,{
  question: "В чем разница между notify() и notifyAll()?",
  answer: "Дело в том, что «висеть» на методе wait() одного монитора могут сразу несколько потоков. При вызове notify() только один из них выходит из wait() и пытается захватить монитор, а затем продолжает работу со следующего после wait() оператора. Какой из них выйдет - заранее неизвестно. А при вызове notifyAll(), все висящие на wait() потоки выходят из wait(), и все они пытаются захватить монитор. Понятно, что в любой момент времени монитор может быть захвачен только одним потоком, а остальные ждут своей очереди. Порядок очереди определяется планировщиком потоков Java."
}
,{
  question: "Почему методы wait() и notify() вызываются только в синхронизированном блоке?",
  answer: "Монитор надо захватывать в явном виде (через synchronized-блок), потому что методы wait() и notify() не синхронизированы."
}
,{
  question: "Чем отличается работа метода wait() с параметром и без параметра?",
  answer: "wait()<br>без параметров освобождает монитор и переводит вызывающий поток в состояние ожидания до тех пор, пока другой поток не вызовет метод notify()/notifyAll(),<br>с параметрами заставит поток ожидать заданное количество времени или вызова notify()/notifyAll().<br>"
}
,{
  question: "Чем отличаются методы Thread.sleep() и Thread.yield()?",
  answer: "Метод yield() служит причиной того, что поток переходит из состояния работающий (running) в состояние работоспособный (runnable), давая возможность другим потокам активизироваться. Но следующий выбранный для запуска поток может и не быть другим.<br>Метод sleep() вызывает засыпание текущего потока на заданное время, состояние изменяется с работающий (running) на ожидающий (waiting).<br>"
}
,{
  question: "Как работает метод Thread.join()?",
  answer: "Когда поток вызывает join() для другого потока, текущий работающий поток будет ждать, пока другой поток, к которому он присоединяется, не будет завершён:<br>void join()<br>void join(long millis)<br>void join(long millis, int nanos)<br>"
}
,{
  question: "Что такое deadlock?",
  answer: "Взаимная блокировка (deadlock) - явление, при котором все потоки находятся в режиме ожидания. Происходит, когда достигаются состояния:<br>взаимного исключения: по крайней мере один ресурс занят в режиме неделимости и, следовательно, только один поток может использовать ресурс в любой данный момент времени.<br>удержания и ожидания: поток удерживает как минимум один ресурс и запрашивает дополнительные ресурсов, которые удерживаются другими потоками.<br>отсутствия предочистки: операционная система не переназначивает ресурсы: если они уже заняты, они должны отдаваться удерживающим потокам сразу же.<br>цикличного ожидания: поток ждёт освобождения ресурса, другим потоком, который в свою очередь ждёт освобождения ресурса заблокированного первым потоком.<br>Простейший способ избежать взаимной блокировки - не допускать цикличного ожидания. Этого можно достичь, получая мониторы разделяемых ресурсов в определённом порядке и освобождая их в обратном порядке.<br>"
}
,{
  question: "Что такое livelock?",
  answer: "livelock - тип взаимной блокировки, при котором несколько потоков выполняют бесполезную работу, попадая в зацикленность при попытке получения каких-либо ресурсов. При этом их состояния постоянно изменяются в зависимости друг от друга. Фактической ошибки не возникает, но КПД системы падает до 0. Часто возникает в результате попыток предотвращения deadlock.<br>Реальный пример livelock, - когда два человека встречаются в узком коридоре и каждый, пытаясь быть вежливым, отходит в сторону, и так они бесконечно двигаются из стороны в сторону, абсолютно не продвигаясь в нужном им направлении.<br>"
}
,{
  question: "Как проверить, удерживает ли поток монитор определённого ресурса?",
  answer: "Метод Thread.holdsLock(lock) возвращает true, когда текущий поток удерживает монитор у определённого объекта."
}
,{
  question: "На каком объекте происходит синхронизация при вызове static synchronized метода?",
  answer: "У синхронизированного статического метода нет доступа к this, но есть доступ к объекту класса Class, он присутствует в единственном экземпляре и именно он выступает в качестве монитора для синхронизации статических методов. Таким образом, следующая конструкция:<br>public class SomeClass { public static synchronized void someMethod() { //code } }<br>эквивалентна такой:<br>public class SomeClass { public static void someMethod(){ synchronized(SomeClass.class){ //code } } }<br>"
}
,{
  question: "Для чего используется ключевое слово volatile, synchronized, transient, native?",
  answer: "volatile - этот модификатор вынуждает потоки отключить оптимизацию доступа и использовать единственный экземпляр переменной. Если переменная примитивного типа - этого будет достаточно для обеспечения потокобезопасности. Если же переменная является ссылкой на объект - синхронизировано будет исключительно значение этой ссылки. Все же данные, содержащиеся в объекте, синхронизированы не будут!<br>synchronized - это зарезервированное слово позволяет добиваться синхронизации в помеченных им методах или блоках кода.<br>Ключевые слова transient и native к многопоточности никакого отношения не имеют, первое используется для указания полей класса, которые не нужно сериализовать, а второе - сигнализирует о том, что метод реализован в платформо-зависимом коде.<br>"
}
,{
  question: "В чём различия между volatile и Atomic переменными?",
  answer: "volatile принуждает использовать единственный экземпляр переменной, но не гарантирует атомарность. Например, операция count++ не станет атомарной просто потому, что count объявлена volatile. C другой стороны class AtomicInteger предоставляет атомарный метод для выполнения таких комплексных операций атомарно, например getAndIncrement() - атомарная замена оператора инкремента, его можно использовать, чтобы атомарно увеличить текущее значение на один. Похожим образом сконструированы атомарные версии и для других типов данных."
}
,{
  question: "В чём заключаются различия между java.util.concurrent.Atomic*.compareAndSwap() и java.util.concurrent.Atomic*.weakCompareAndSwap()",
  answer: "weakCompareAndSwap() не создает memory barrier и не дает гарантии happens-before;<br>weakCompareAndSwap() сильно зависит от кэша/CPU, и может возвращать false без видимых причин;<br>weakCompareAndSwap(), более легкая, но поддерживаемая далеко не всеми архитектурами и не всегда эффективная операция.<br>"
}
,{
  question: "Что значит «приоритет потока»?",
  answer: "Приоритеты потоков используются планировщиком потоков для принятия решений о том, когда какому из потоков будет разрешено работать. Теоретически высокоприоритетные потоки получают больше времени процессора, чем низкоприоритетные. Практически объем времени процессора, который получает поток, часто зависит от нескольких факторов помимо его приоритета.<br>Чтобы установить приоритет потока, используется метод класса Thread: final void setPriority(int level). Значение level изменяется в пределах от Thread.MIN_PRIORITY = 1 до Thread.MAX_PRIORITY = 10. Приоритет по умолчанию - Thread.NORM_PRlORITY = 5.<br>Получить текущее значение приоритета потока можно вызвав метод: final int getPriority() у экземпляра класса Thread<br>"
}
,{
  question: "Что такое «потоки-демоны»?",
  answer: "Потоки-демоны работают в фоновом режиме вместе с программой, но не являются неотъемлемой частью программы. Если какой-либо процесс может выполняться на фоне работы основных потоков выполнения и его деятельность заключается в обслуживании основных потоков приложения, то такой процесс может быть запущен как поток-демон с помощью метода setDaemon(boolean value), вызванного у потока до его запуска. Метод boolean isDaemon() позволяет определить, является ли указанный поток демоном или нет. Базовое свойство потоков-демонов заключается в возможности основного потока приложения завершить выполнение потока-демона (в отличие от обычных потоков) с окончанием кода метода main(), не обращая внимания на то, что поток-демон еще работает."
}
,{
  question: "Можно ли сделать основной поток программы демоном?",
  answer: "Нет. Потоки-демоны позволяют описывать фоновые процессы, которые нужны только для обслуживания основных потоков выполнения и не могут существовать без них."
}
,{
  question: "Что значит «усыпить» поток?",
  answer: "Это значит приостановить его на определенный промежуток времени, вызвав в ходе его выполнения статический метод Thread.sleep() передав в качестве параметра необходимое количество времени в миллисекундах. До истечения этого времени поток может быть выведен из состояния ожидания вызовом interrupt() с выбрасыванием InterruptedException."
}
,{
  question: "Чем отличаются два интерфейса Runnable и Callable?",
  answer: "Интерфейс Runnable появился в Java 1.0, а интерфейс Callable был введен в Java 5.0 в составе библиотеки java.util.concurrent;<br>Классы, реализующие интерфейс Runnable для выполнения задачи должны реализовывать метод run(). Классы, реализующие интерфейс Callable - метод call();<br>Метод Runnable.run() не возвращает никакого значения, Callable.call() возвращает объект Future, который может содержать результат вычислений;<br>Метод run() не может выбрасывать проверяемые исключения, в то время как метод call() может.<br>"
}
,{
  question: "Что такое FutureTask?",
  answer: "FutureTask представляет собой отменяемое асинхронное вычисление в параллельном Java приложении. Этот класс предоставляет базовую реализацию Future, с методами для запуска и остановки вычисления, методами для запроса состояния вычисления и извлечения результатов. Результат может быть получен только когда вычисление завершено, метод получения будет заблокирован, если вычисление ещё не завершено. Объекты FutureTask могут быть использованы для обёртки объектов Callable и Runnable. Так как FutureTask реализует Runnable, его можно передать в Executor на выполнение."
}
,{
  question: "Как остановить поток?",
  answer: "На данный момент в Java принят уведомительный порядок остановки потока (хотя JDK 1.0 и имеет несколько управляющих выполнением потока методов, например stop(), suspend() и resume() - в следующих версиях JDK все они были помечены как deprecated из-за потенциальных угроз взаимной блокировки).<br>Для корректной остановки потока можно использовать метод класса Thread - interrupt(). Этот метод выставляет некоторый внутренний флаг-статус прерывания. В дальнейшем состояние этого флага можно проверить с помощью метода isInterrupted() или Thread.interrupted() (для текущего потока). Метод interrupt() также способен вывести поток из состояния ожидания или спячки. Т.е. если у потока были вызваны методы sleep() или wait() - текущее состояние прервется и будет выброшено исключение InterruptedException. Флаг в этом случае не выставляется.<br>Схема действия при этом получается следующей:<br>Реализовать поток.<br>В потоке периодически проводить проверку статуса прерывания через вызов isInterrupted().<br>Если состояние флага изменилось или было выброшено исключение во время ожидания/спячки, следовательно поток пытаются остановить извне.<br>Принять решение - продолжить работу (если по каким-то причинам остановиться невозможно) или освободить заблокированные потоком ресурсы и закончить выполнение.<br>Возможная проблема, которая присутствует в этом подходе - блокировки на потоковом вводе-выводе. Если поток заблокирован на чтении данных - вызов interrupt() из этого состояния его не выведет. Решения тут различаются в зависимости от типа источника данных. Если чтение идет из файла - долговременная блокировка крайне маловероятна и тогда можно просто дождаться выхода из метода read(). Если же чтение каким-то образом связано с сетью - стоит использовать неблокирующий ввод-вывод из Java NIO.<br>Второй вариант реализации метода остановки (а также и приостановки) - сделать собственный аналог interrupt(). Т.е. объявить в классе потока флаги - на остановку и/или приостановку и выставлять их путем вызова заранее определённых методов извне. Методика действия при этом остаётся прежней - проверять установку флагов и принимать решения при их изменении. Недостатки такого подхода. Во-первых, потоки в состоянии ожидания таким способом не «оживить». Во-вторых, выставление флага одним потоком совсем не означает, что второй поток тут же его увидит. Для увеличения производительности виртуальная машина использует кеш данных потока, в результате чего обновление переменной у второго потока может произойти через неопределенный промежуток времени (хотя допустимым решением будет объявить переменную-флаг как volatile).<br>"
}
,{
  question: "Что происходит, когда в потоке выбрасывается исключение?",
  answer: "Если исключение не поймано - поток «умирает» (переходит в состяние мёртв (dead)).<br>Если установлен обработчик непойманных исключений, то он возьмёт управление на себя. Thread.UncaughtExceptionHandler - интерфейс, определённый как вложенный интерфейс для других обработчиков, вызываемых, когда поток внезапно останавливается из-за непойманного исключения. В случае, если поток собирается остановиться из-за непойманного исключения, JVM проверяет его на наличие UncaughtExceptionHandler, используя Thread.getUncaughtExceptionHandler(), и если такой обработчик найдет, то вызовет у него метод uncaughtException(), передав этот поток и исключение в виде аргументов.<br>"
}
,{
  question: "В чем разница между interrupted() и isInterrupted()?",
  answer: "Механизм прерывания работы потока в Java реализован с использованием внутреннего флага, известного как статус прерывания. Прерывание потока вызовом Thread.interrupt() устанавливает этот флаг. Методы Thread.interrupted() и isInterrupted() позволяют проверить, является ли поток прерванным.<br>Когда прерванный поток проверяет статус прерывания, вызывая статический метод Thread.interrupted(), статус прерывания сбрасывается.<br>Нестатический метод isInterrupted() используется одним потоком для проверки статуса прерывания у другого потока, не изменяя флаг прерывания.<br>"
}
,{
  question: "Что такое «пул потоков»?",
  answer: "Создание потока является затратной по времени и ресурсам операцией. Количество потоков, которое может быть запущено в рамках одного процесса также ограниченно. Чтобы избежать этих проблем и в целом управлять множеством потоков более эффективно в Java был реализован механизм пула потоков (thread pool), который создаётся во время запуска приложения и в дальнейшем потоки для обработки запросов берутся и переиспользуются уже из него. Таким образом, появляется возможность не терять потоки, сбалансировать приложение по количеству потоков и частоте их создания.Начиная с Java 1.5 Java API предоставляет фреймворк Executor, который позволяет создавать различные типы пула потоков:Executor - упрощенный интерфейс пула, содержит один метод для передачи задачи на выполнение;ExecutorService - расширенный интерфейс пула, с возможностью завершения всех потоков;AbstractExecutorService - базовый класс пула, реализующий интерфейс ExecutorService;Executors - фабрика объектов связанных с пулом потоков, в том числе позволяет создать основные типы пулов;ThreadPoolExecutor - пул потоков с гибкой настройкой, может служить базовым классом для нестандартных пулов;ForkJoinPool - пул для выполнения задач типа ForkJoinTask;<br>... и другие.Методы Executors для создания пулов:newCachedThreadPool() - если есть свободный поток, то задача выполняется в нем, иначе добавляется новый поток в пул. Потоки не используемые больше минуты завершаются и удалются и кэша. Размер пула неограничен. Предназначен для выполнения множество небольших асинхронных задач;newCachedThreadPool(ThreadFactory threadFactory) - аналогично предыдущему, но с собственной фабрикой потоков;newFixedThreadPool(int nThreads) - создает пул на указанное число потоков. Если новые задачи добавлены, когда все потоки активны, то они будут сохранены в очереди для выполнения позже. Если один из потоков завершился из-за ошибки, на его место будет запущен другой поток. Потоки живут до тех пор, пока пул не будет закрыт явно методом shutdown().newFixedThreadPool(int nThreads, ThreadFactory threadFactory) - аналогично предыдущему, но с собственной фабрикой потоков;newSingleThreadScheduledExecutor() - однопотоковый пул с возможностью выполнять задачу через указанное время или выполнять периодически. Если поток был завершен из-за каких-либо ошибок, то для выполнения следующей задачи будет создан новый поток.newSingleThreadScheduledExecutor(ThreadFactory threadFactory) - аналогично предыдущему, но с собственной фабрикой потоков;<br>newScheduledThreadPool(int corePoolSize) - пул для выполнения задач через указанное время или переодически;newScheduledThreadPool(int corePoolSize, ThreadFactory threadFactory) - аналогично предыдущему, но с собственной фабрикой потоков;unconfigurableExecutorService(ExecutorService executor) - обертка на пул, запрещающая изменять его конфигурацию;"
}
,{
  question: "Что делает метод shutdown() и shutdownNow() у ExecutorService?",
  answer: "shutdown()<br>метода инициирует остановку ExecutorService. Все задачи, которые уже были отправлены на обработку, будут завершены, новые задачи приниматься не будут.List<Runnable> shutdownNow()<br>Вызов метода инициирует остановку ExecutorService. Все задачи, которые уже были отправлены на обработку, получат команду Thread.interrupt. Задачи, находящиеся в очереди, возвращаются в виде списка как результат вызова метода.<br>Метод не ожидает завершения всех задач, которые находятся 'в работе' на момент вызова метода.<br>"
}
,{
  question: "Какого размера должен быть пул потоков?",
  answer: "Настраивая размер пула потоков, важно избежать двух ошибок: слишком мало потоков (очередь на выполнение будет расти, потребляя много памяти) или слишком много потоков (замедление работы всей систему из-за частых переключений контекста).<br>Оптимальный размер пула потоков зависит от количества доступных процессоров и природы задач в рабочей очереди. На N-процессорной системе для рабочей очереди, которая будет выполнять исключительно задачи с ограничением по скорости вычислений, можно достигнуть максимального использования CPU с пулом потоков, в котором содержится N или N+1 поток. Для задач, которые могут ждать осуществления I/O (ввода - вывода) - например, задачи, считывающей HTTP-запрос из сокета - может понадобиться увеличение размера пула свыше количества доступных процессоров, потому, что не все потоки будут работать все время. Используя профилирование, можно оценить отношение времени ожидания (WT) ко времени обработки (ST) для типичного запроса. Если назвать это соотношение WT/ST, то для N-процессорной системе понадобится примерно N*(1 + WT/ST) потоков для полной загруженности процессоров.<br>Использование процессора - не единственный фактор, важный при настройке размера пула потоков. По мере возрастания пула потоков, можно столкнуться с ограничениями планировщика, доступной памяти, или других системных ресурсов, таких, как количество сокетов, дескрипторы открытого файла, или каналы связи базы данных.<br>"
}
,{
  question: "Что будет, если очередь пула потоков уже заполнена, но подаётся новая задача?",
  answer: "Если очередь пула потоков заполнилась, то поданная задача будет «отклонена». Например - метод submit() у ThreadPoolExecutor выкидывает RejectedExecutionException, после которого вызывается RejectedExecutionHandler."
}
,{
  question: "В чём заключается различие между методами submit() и execute() у пула потоков?",
  answer: "Оба метода являются способами подачи задачи в пул потоков, но между ними есть небольшая разница.<br>execute(Runnable command) определён в интерфейсе Executor и выполняет поданную задачу и ничего не возвращает.<br>submit() - перегруженный метод, определённый в интерфейсе ExecutorService. Способен принимать задачи типов Runnable и Callable и возвращать объект Future, который можно использовать для контроля и управления процессом выполнения, получения его результата.<br>"
}
,{
  question: "В чем заключаются различия между cтеком (stack) и кучей (heap) с точки зрения многопоточности?",
  answer: "Cтек - участок памяти, тесно связанный с потоками. У каждого потока есть свой стек, которые хранит локальные переменные, параметры методов и стек вызовов. Переменная, хранящаяся в стеке одного потока, не видна для другого.<br>Куча - общий участок памяти, который делится между всеми потоками. Объекты, неважно локальные или любого другого уровня, создаются в куче. Для улучшения производительности, поток обычно кэширует значения из кучи в свой стек, в этом случае для того, чтобы указать потоку, что переменную следует читать из кучи используется ключевое слово volatile.<br>"
}
,{
  question: "Как поделиться данными между двумя потоками?",
  answer: "Данными между потоками возможно делиться, используя общий объект или параллельные структуры данных, например BlockingQueue."
}
,{
  question: "Какой параметр запуска JVM используется для контроля размера стека потока?",
  answer: "-Xss"
}
,{
  question: "Как получить дамп потока?",
  answer: "Среды исполнения Java на основе HotSpot генерируют только дамп в формате HPROF. В распоряжении разработчика имеется несколько интерактивных методов генерации дампов и один метод генерации дампов на основе событий.<br>Интерактивные методы:Использование Ctrl+Break: если для исполняющегося приложения установлена опция командной строки -XX:+HeapDumpOnCtrlBreak, то дамп формата HPROF генерируется вместе с дампом потока при наступлении события Ctrl+Break или SIGQUIT (обычно генерируется с помощью kill -3), которое инициируется посредством консоли. Эта опция может быть недоступна в некоторых версиях. В этом случае можно попытаться использовать следующую опцию: -Xrunhprof:format=b,file=heapdump.hprofИспользование инструмента jmap: утилита jmap, поставляемая в составе каталога /bin/ комплекта JDK, позволяет запрашивать дамп HPROF из исполняющегося процесса.Использование операционной системы: Для создания файла ядра можно воспользоваться неразрушающей командой gcore или разрушающими командами kill -6 или kill -11. Затем извлечь дамп кучи из файла ядра с помощью утилиты jmap.Использование инструмента JConsole. Операция dumpHeap предоставляется в JConsole как MBean-компонент HotSpotDiagnostic. Эта операция запрашивает генерацию дампа в формате HPROF.Метод на основе событий:Событие OutOfMemoryError: Если для исполняющегося приложения установлена опция командной строки -XX:+HeapDumpOnOutOfMemoryError, то при возникновении ошибки OutOfMemoryError генерируется дамп формата HPROF. Это идеальный метод для «production» систем, поскольку он практически обязателен для диагностирования проблем памяти и не сопровождается постоянными накладными расходами с точки зрения производительности. В старых выпусках сред исполнения Java на базе HotSpot для этого события не устанавливается предельное количество дампов кучи в пересчете на одну JVM; в более новых выпусках допускается не более одного дампа кучи для этого события на каждый запуск JVM."
}
,{
  question: "Что такое ThreadLocal-переменная?",
  answer: "ThreadLocal - класс, позволяющий имея одну переменную, иметь различное её значение для каждого из потоков.<br>У каждого потока - т.е. экземпляра класса Thread - есть ассоциированная с ним таблица ThreadLocal-переменных. Ключами таблицы являются cсылки на объекты класса ThreadLocal, а значениями - ссылки на объекты, «захваченные» ThreadLocal-переменными, т.е. ThreadLocal-переменные отличаются от обычных переменных тем, что у каждого потока свой собственный, индивидуально инициализируемый экземпляр переменной. Доступ к значению можно получить через методы get() или set().<br>Например, если мы объявим ThreadLocal-переменную: ThreadLocal<Object> locals = new ThreadLocal<Object>();. А затем, в потоке, сделаем locals.set(myObject), то ключом таблицы будет ссылка на объект locals, а значением - ссылка на объект myObject. При этом для другого потока существует возможность «положить» внутрь locals другое значение.<br>Следует обратить внимание, что ThreadLocal изолирует именно ссылки на объекты, а не сами объекты. Если изолированные внутри потоков ссылки ведут на один и тот же объект, то возможны коллизии.<br>Так же важно отметить, что т.к. ThreadLocal-переменные изолированы в потоках, то инициализация такой переменной должна происходить в том же потоке, в котором она будет использоваться. Ошибкой является инициализация такой переменной (вызов метода set()) в главном потоке приложения, потому как в данном случае значение, переданное в методе set(), будет «захвачено» для главного потока, и при вызове метода get() в целевом потоке будет возвращен null.<br>"
}
,{
  question: "Назовите различия между synchronized и ReentrantLock?",
  answer: "В Java 5 появился интерфейс Lock предоставляющий возможности более эффективного и тонкого контроля блокировки ресурсов. ReentrantLock - распространённая реализация Lock, которая предоставляет Lock с таким же базовым поведением и семантикой, как у synchronized, но расширенными возможностями, такими как опрос о блокировании (lock polling), ожидание блокирования заданной длительности и прерываемое ожидание блокировки. Кроме того, он предлагает гораздо более высокую эффективность функционирования в условиях жесткой состязательности.<br>Что понимается под блокировкой с повторным входом (reentrant)? Просто то, что есть подсчет сбора данных, связанный с блокировкой, и если поток, который удерживает блокировку, снова ее получает, данные отражают увеличение, и тогда для реального разблокирования нужно два раза снять блокировку. Это аналогично семантике synchronized; если поток входит в синхронный блок, защищенный монитором, который уже принадлежит потоку, потоку будет разрешено дальнейшее функционирование, и блокировка не будет снята, когда поток выйдет из второго (или последующего) блока synchronized, она будет снята только когда он выйдет из первого блока synchronized, в который он вошел под защитой монитора.<br>Lock lock = new ReentrantLock(); lock.lock(); try { // update object state } finally { lock.unlock(); }<br>Реализация ReentrantLock гораздо более масштабируема в условиях состязательности, чем реализация synchronized. Это значит, что когда много потоков соперничают за право получения блокировки, общая пропускная способность обычно лучше у ReentrantLock, чем у synchronized. JVM требуется меньше времени на установление очередности потоков и больше времени на непосредственно выполнение.<br>У ReentrantLock (как и у других реализаций Lock) блокировка должна обязательно сниматься в finally блоке (иначе, если бы защищенный код выбросил исключение, блокировка не была бы снята). Используя синхронизацию, JVM гарантирует, что блокировка автоматически снимаются.<br>Резюмируя, можно сказать, что когда состязания за блокировку нет либо оно очень мало, то synchronized возможно будет быстрее. Если присутствует заметное состязание за доступ к ресурсу, то скорее всего ReentrantLock даст некое преимущество.<br>"
}
,{
  question: "Что такое ReadWriteLock?",
  answer: "ReadWriteLock - это интерфейс расширяющий базовый интерфейс Lock. Используется для улучшения производительности в многопоточном процессе и оперирует парой связанных блокировок (одна - для операций чтения, другая - для записи). Блокировка чтения может удерживаться одновременно несколькими читающими потоками, до тех пор, пока не появится записывающий. Блокировка записи является эксклюзивеной.<br>Существует реализующий интерфейс ReadWriteLock класс ReentrantReadWriteLock, который поддерживает до 65535 блокировок записи и до стольки же блокировок чтения.<br>ReadWriteLock rwLock = new ReentrantReadWriteLock(); Lock rLock = rwLock.readLock(); Lock wLock = rwLock.writeLock(); wLock.lock();<br>try { // exclusive write } finally { wLock.unlock(); } rLock.lock();<br>try { // shared reading } finally { rLock.unlock(); }<br>"
}
,{
  question: "Что такое «блокирующий метод»?",
  answer: "Блокирующий метод - метод, который блокируется, до тех пор, пока задание не выполнится, например метод accept() у ServerSocket блокируется в ожидании подключения клиента. Здесь блокирование означает, что контроль не вернётся к вызывающему методу до тех пор, пока не выполнится задание. Так же существуют асинхронные или неблокирующиеся методы, которые могут завершится до выполнения задачи."
}
,{
  question: "то такое «фреймворк Fork/Join»?",
  answer: "Фреймворк Fork/Join, представленный в JDK 7, - это набор классов и интерфейсов позволяющих использовать преимущества многопроцессорной архитектуры современных компьютеров. Он разработан для выполнения задач, которые можно рекурсивно разбить на маленькие подзадачи, которые можно решать параллельно.<br>Этап Fork: большая задача разделяется на несколько меньших подзадач, которые в свою очередь также разбиваются на меньшие. И так до тех пор, пока задача не становится тривиальной и решаемой последовательным способом.<br>Этап Join: далее (опционально) идёт процесс «свёртки» - решения подзадач некоторым образом объединяются пока не получится решение всей задачи.<br>Решение всех подзадач (в т.ч. и само разбиение на подзадачи) происходит параллельно.<br>Для решения некоторых задач этап Join не требуется. Например, для параллельного QuickSort — массив рекурсивно делится на всё меньшие и меньшие диапазоны, пока не вырождается в тривиальный случай из 1 элемента. Хотя в некотором смысле Join будет необходим и тут, т.к. всё равно остаётся необходимость дождаться пока не закончится выполнение всех подзадач.<br>Ещё одно замечательное преимущество этого фреймворка заключается в том, что он использует work-stealing алгоритм: потоки, которые завершили выполнение собственных подзадач, могут «украсть» подзадачи у других потоков, которые всё ещё заняты.<br>"
}
,{
  question: "Что такое double checked locking Singleton?",
  answer: "double checked locking Singleton - это один из способов создания потокобезопасного класса реализующего шаблон Одиночка. Данный метод пытается оптимизировать производительность, блокируясь только случае, когда экземпляр одиночки создаётся впервые.class DoubleCheckedLockingSingleton { private static volatile DoubleCheckedLockingSingleton instance; static DoubleCheckedLockingSingleton getInstance() { DoubleCheckedLockingSingleton current = instance; if (current == null) { synchronized (DoubleCheckedLockingSingleton.class) { current = instance; if (current == null) { instance = current = new DoubleCheckedLockingSingleton(); } } } return current; } }Следует заметить, что требование volatile обязательно. Проблема Double Checked Lock заключается в модели памяти Java, точнее в порядке создания объектов, когда возможна ситуация, при которой другой поток может получить и начать использовать (на основании условия, что указатель не нулевой) не полностью сконструированный объект. Хотя эта проблема была частично решена в JDK 1.5, однако рекомендация использовать volatile для Double Cheсked Lock остаётся в силе."
}
,{
  question: "Как создать потокобезопасный Singleton?",
  answer: "Static field<br>public class Singleton { public static final Singleton INSTANCE = new Singleton(); }Enum<br>public enum Singleton { INSTANCE; }Synchronized Accessor<br>public class Singleton { private static Singleton instance; public static synchronized Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } }Double Checked Locking & volatile<br>public class Singleton { private static volatileSingleton instance; public static Singleton getInstance() { Singleton localInstance = instance; if (localInstance == null) { synchronized (Singleton.class) { localInstance = instance; if (localInstance == null) { instance = localInstance = new Singleton(); } } } return localInstance; } }On Demand Holder Idiom<br>public class Singleton { public static class SingletonHolder { public static final Singleton HOLDER_INSTANCE = new Singleton(); } public static Singleton getInstance() { return SingletonHolder.HOLDER_INSTANCE; } }<br>"
}
,{
  question: "Чем полезны неизменяемые объекты?",
  answer: "Неизменяемость (immutability) помогает облегчить написание многопоточного кода. Неизменяемый объект может быть использован без какой-либо синхронизации. К сожалению, в Java нет аннотации @Immutable, которая делает объект неизменяемым, для этого разработчикам нужно самим создавать класс с необходимыми характеристиками. Для этого необходимо следовать некоторым общим принципам: инициализация всех полей только в конструкторе, отсутствие методов setX() вносящих изменения в поля класса, отсутствие утечек ссылки, организация отдельного хранилища копий изменяемых объектов и т.д."
}
,{
  question: "Что такое busy spin?",
  answer: "busy spin - это техника, которую программисты используют, чтобы заставить поток ожидать при определённом условии. В отличие от традиционных методов wait(), sleep() или yield(), которые подразумевают уступку процессорного времени, этот метод вместо уступки выполняет пустой цикл. Это необходимо, для того, чтобы сохранить кэш процессора, т.к. в многоядерных системах, существует вероятность, что приостановленный поток продолжит своё выполнение уже на другом ядре, а это повлечет за собой перестройку состояния процессорного кэша, которая является достаточно затратной процедурой."
}
,{
  question: "Перечислите принципы, которым вы следуете в многопоточном программировании?",
  answer: "При написании многопоточных программ следует придерживаться определённых правил, которые помогают обеспечить достойную производительность приложения в сочетании с удобной отладкой и простотой дальнейшей поддержки кода.Всегда давайте значимые имена своим потокам. Процесс отладки, нахождения ошибок или отслеживание исключения в многопоточном коде - довольно сложная задача. OrderProcessor, QuoteProcessor или TradeProcessor намного информативнее, чем Thread1, Thread2 и Thread3. Имя должно отражать задачу, выполняемую данным потоком.Избегайте блокировок или старайтесь уменьшить масштабы синхронизации. Блокировка затратна, а переключение контекста ещё более ресурсоёмко. Пытайтесь избегать синхронизации и блокировки насколько это возможно, и организуйте критическую секцию в минимально необходимом объёме. Поэтому синхронизированный блок всегда предпочительней синхронизированного метода, дополнительно наделяя возможностью абсолютного контроля над масштабом блокировки.Обрабатывайте прерывание потока с особой тщательностью. Нет ничего хуже оставшегося заблокированным ресурса или системы в неконстистентном, по причине неподтверждённой транзакции, состоянии.Помните об обработке исключений. Выброшенные InterruptedException должны быть адекватно обработаны, а не просто подавлены. Так же не стоит пренебрегать Thread.UncaughtExceptionHandler. При использовании пула потоков необходимо помнить, что он зачастую просто «проглатывает» исключения. Так, если вы отправили на выполнение Runnable нужно обязательно поместить код выполнения задачи внутрь блока try-catch. Если в очередь пула помещается Callable, необходимо удостоверится, что результат выполнения всегда изымается помощью блокирующего get(), чтобы в случае возникновения существовала возможнотсь заново выбросить произошедшее исключение.Между синхронизаторами и wait() и notify() следует выбирать синхронизаторы. Во-первых, синхронизаторы, типа CountDownLatch, Semaphore, CyclicBarrier или Exchanger упрощают написание кода. Очень сложно реализовывать комплексный управляющий поток, используя wait() и notify(). Во-вторых, эти классы написаны и поддерживаются настоящими мастерами своего дела и есть шанс, что в последующих версиях JDK они будут оптимизированы изнутри или заменены более производительной внешней реализацией.Почти всегда использование Concurrent сollection выгоднее использования Synchronized сollection, т.к. первые более современны (используют все доступные на момент их написания новшества языка) и масштабируемы, чем их синхронизированые аналоги."
}
,{
  question: "Какое из следующих утверждений о потоках неверно?",
  answer: "1) Если метод start() вызывается дважды для одного и того же объекта Thread, во время выполнения генерируется исключение.2) Порядок, в котором запускались потоки, может не совпадать с порядком их фактического выполнения.3) Если метод run() вызывается напрямую для объекта Thread, во время выполнения генерируется исключение.4) Если метод sleep() вызывается для потока, во время выполнения синхронизированного кода, блокировка не снимается.Правильный ответ: 3. Если метод run() вызывается напрямую для объекта Thread, во время выполнения исключение не генерируется. Однако, код, написанный в методе run() будет выполняться текущим, а не новым потоком. Таким образом, правильный способ запустить поток - это вызов метода start(), который приводит к выполнению метода run() новым потоком.<br>Вызов метода start() дважды для одного и того же объекта Thread приведёт к генерированию исключения IllegalThreadStateException во время выполнения, следовательно, утверждение 1 верно. Утверждение 2 верно, так как порядок, в котором выполняются потоки, определяется Планировщиком потоков, независимо от того, какой поток запущен первым. Утверждение 4 верно, так как поток не освободит блокировки, которые он держит, когда он переходит в состояние Ожидания.<br>"
}
,{
  question: "Даны 3 потока Т1, Т2 и Т3? Как реализовать выполнение в последовательности Т1, Т2, Т3?",
  answer: "Такой последовательности выполнения можно достичь многими способами, например просто воспользоваться методом join(), чтобы запустить поток в момент, когда другой уже закончит своё выполнение. Для реализации заданной последовательности, нужно запустить последний поток первым, и затем вызывать метод join() в обратном порядке, то есть Т3 вызывает Т2.join, а Т2 вызывает Т1.join, таким образом Т1 закончит выполнение первым, а Т3 последним."
}
,{
  question: "Что такое race condition?",
  answer: "Состояние гонки (race condition) - ошибка проектирования многопоточной системы или приложения, при которой эта работа напрямую зависит от того, в каком порядке выполняются потоки. Состояние гонки возникает, когда поток, который должен исполнится в начале, проиграл гонку и первым исполняется другой поток: поведение кода изменяется, из-за чего возникают недетерменированные ошибки."
}
,{
  question: "Существует ли способ решения проблемы race condition?",
  answer: "Синхронизация"
}
,{
  question: "Что мы понимаем под операцией CAS?",
  answer: "CAS означает сравнение и замена и означает, что процессор предоставляет отдельную инструкцию, которая обновляет значение регистра, только если предоставленное значение равно текущему значению. Операции CAS можно использовать, чтобы избежать синхронизации, поскольку поток может попытаться обновить значение, предоставив его текущее значение и новое значение для операции CAS. Если другой поток тем временем обновил значение, значение потока не равно текущему значению, и операция обновления завершается неудачно. Затем поток читает новое значение и пытается снова. Таким образом, необходимая синхронизация сменяется оптимистическим ожиданием вращения."
}
,{
  question: "Какие классы Java используют операцию CAS?",
  answer: "Классы SDK в пакете java.util.concurrent.atomic<br>похожи AtomicIntege rили AtomicBoolean используют внутреннюю операцию CAS для реализации одновременного увеличения.public class CounterAtomic {<br>private AtomicLong counter = new AtomicLong();<br>public void increment() {<br>counter.incrementAndGet();<br>}<br>public long get() {<br>return counter.get();<br>}<br>}<br>"
}
,{
  question: "С какими распространенными проблемами вы столкнулись в многопоточной среде?",
  answer: "Deadlock — два потока A и B, удерживайте lock_A и lock_B соответственно. Они оба хотят получить доступ к ресурсу R. Для безопасного доступа к R требуются и lock_A, и lock_B. Но поток A нуждается в lock_B, а поток B — в lock_A. Но оба они не готовы отказаться от замков, которые они держат. Следовательно, нет прогресса. Это тупик!Условия гонки — Рассмотрим классический пример производителя-потребителя. Что если вы забудете заблокировать перед добавлением или удалением элемента из очереди? Представьте, что два потока A и B пытаются добавить элемент без блокировки. Поток A обращается к задней части очереди. Затем планировщик дает возможность запустить поток B, который успешно добавляет элемент и обновляет хвостовой указатель. Теперь указатель хвоста, прочитанный потоком A, устарел, но он думает, что это хвост, и добавляет элемент. Таким образом, пункт, добавленный B, потерян! Структура данных повреждена! Хуже того, это может также привести к утечке памяти во время очистки.Гонка данных — представьте переменную флага, которую следует установить. Предположим, что вы установили замки, чтобы избежать условий гонки. Теперь разные потоки хотят устанавливать разные значения. Поскольку планировщик может планировать выполнение потока любым способом, вы не знаете, каково значение флага в конце.Голодание — это проблема, вызванная<br>планировщиком потоков. Некоторые потоки не имеют возможности запустить и завершить или не могут получить требуемые блокировки, потому что другим потокам предоставляется более высокий приоритет. Они «жаждут» циклов ЦП или других ресурсов.<br>Инверсия приоритетов. Представьте себе два потока A и B. A имеет более высокий приоритет, чем B, и, следовательно, получает больше циклов ЦП, чем B. Но при доступе к общему ресурсу B удерживает блокировку, которая также требуется для A, и возвращает. Теперь A не может ничего сделать без блокировки, и много циклов ЦП тратится впустую, потому что B не получает достаточно циклов, но имеет блокировку.<br>"
}
,{
  question: "Можно ли улучшить производительность приложения, используя многопоточность? Назовите несколько примеров.",
  answer: "Если у нас имеется более одного доступного ядра ЦП, производительность приложения можно повысить с помощью многопоточности, если возможно распараллелить вычисления на доступных ядрах ЦП. Примером может служить приложение, которое должно масштабировать все изображения, хранящиеся в структуре локального каталога. Вместо того, чтобы перебирать все изображения одно за другим, реализация производителя / потребителя может использовать один поток для сканирования структуры каталогов и группу рабочих потоков, которые выполняют фактическую операцию масштабирования. Другим примером может быть приложение, которое отображает некоторую веб-страницу. Вместо загрузки одной HTML-страницы за другой поток производителя может проанализировать первую HTML-страницу и выдать найденные ссылки в очередь. Рабочие потоки отслеживают очередь и загружают веб-страницы, найденные анализатором. Пока рабочие потоки ждут полной загрузки страницы, другие потоки могут использовать ЦП для анализа уже загруженных страниц и выдачи новых запросов."
}
,{
  question: "Приведите пример, почему улучшения производительности для однопоточных приложений могут привести к снижению производительности многопоточных приложений.",
  answer: "Ярким примером такой оптимизации является реализация List , в которой количество элементов хранится в виде отдельной переменной. Это повышает производительность для однопоточных приложений, поскольку операция size() не должна повторяться по всем элементам, но может возвращать текущее количество элементов напрямую. В многопоточном приложении дополнительный счетчик должен защищаться блокировкой, поскольку несколько параллельных потоков могут вставлять элементы в список. Эта дополнительная блокировка может стоить производительности, когда в списке больше обновлений, чем вызовов операции size() ."
}
,{
  question: "Что такое ключевое слово volatile в Java и чем оно отличается от синхронизированного метода в Java?",
  answer: "Использование volatile заставляет поток читать и записывать переменные непосредственно из оперативной памяти. Поэтому, когда многие потоки используют одну и ту же переменную переменную, все они видят последнюю версию, которая присутствует в оперативной памяти, а не возможную старую копию в кэше. Когда поток входит в синхронизированный блок, он должен получить контроль над переменной монитора. Все остальные потоки ожидают выхода первого потока из синхронизированного блока. Чтобы все потоки могли видеть одинаковые изменения, все переменные, используемые в синхронизированном блоке, считываются и записываются непосредственно из памяти RAM, а не из копии кэша."
}
,{
  question: "Может ли конструктор быть синхронизирован?",
  answer: "Нет, конструктор не может быть синхронизирован. Причина, по которой это приводит к синтаксической ошибке, заключается в том, что только конструирующий поток должен иметь доступ к создаваемому объекту."
}
,{
  question: "Если два потока одновременно вызывают синхронизированный метод для разных экземпляров объекта, может ли один из этих потоков блокировать?",
  answer: "Оба метода блокируют один и тот же монитор. Следовательно, вы не можете одновременно выполнять их на одном и том же объекте из разных потоков (один из двух методов будет блокироваться, пока другой не будет завершен)."
}
,{
  question: "Future vs CompletableFuture - концепция и отличия",
  answer: "Future - интерфейс, который представляет пока еще недовычисленный результат. Когда породившая его асинхронная операция заканчивается, он заполняется значением. Метод get блокирует выполнение до получения результата, isDone проверяет его наличие. К примеру результат выполнения задач в ExecutorService, ForkJoinTask, реализует интерфейс Future.CompletableFuture появился в Java 8. Это класс-реализация старого интерфейса Future, а значит всё сказанное выше справедливо и для него. Вдобавок к этому, CompletableFuture реализует работу с отложенными результатами посредством коллбэков. Метод thenApply регистрирует код обработки значения, который будет автоматически вызван позже, когда это значение появится.<br>CompletableFutures были введены в Java 8 (2014). На самом деле они представляют собой эволюцию обычных Futures, вдохновленных Google Listenable Futures , частью библиотеки Guava . Это фьючерсы, которые также позволяют вам связывать задачи в цепочку. Вы можете использовать их, чтобы сказать некоторому рабочему потоку «иди и выполни задачу X, а когда закончишь, иди делай другую вещь, используя результат X». Используя CompletableFutures, вы можете что-то сделать с результатом операции, фактически не блокируя поток для ожидания результата.<br>"
}
,{
  question: "Объект синхронизации Semaphore",
  answer: "Синхронизатор Semaphore реализует шаблон синхронизации Семафор. Чаще всего, семафоры необходимы, когда нужно ограничить доступ к некоторому общему ресурсу. В конструктор этого класса (Semaphore(int permits) или Semaphore(int permits, boolean fair)) обязательно передается количество потоков, которому семафор будет разрешать одновременно использовать заданный ресурс.<br>Доступ управляется с помощью счётчика: изначально значение счётчика равно int permits, когда поток заходит в заданный блок кода, то значение счётчика уменьшается на единицу, когда поток его покидает, то увеличивается. Если значение счётчика равно нулю, то текущий поток блокируется, пока кто-нибудь не выйдет из блока (в качестве примера из жизни с permits = 1, можно привести очередь в кабинет в поликлинике: когда пациент покидает кабинет, мигает лампа, и заходит следующий пациент).<br>"
}
,{
  question: "Объект синхронизации CountDownLatch",
  answer: "CountDownLatch (замок с обратным отсчетом) предоставляет возможность любому количеству потоков в блоке кода ожидать до тех пор, пока не завершится определенное количество операций, выполняющихся в других потоках, перед тем как они будут «отпущены», чтобы продолжить свою деятельность. В конструктор CountDownLatch (CountDownLatch(int count)) обязательно передается количество операций, которое должно быть выполнено, чтобы замок «отпустил» заблокированные потоки.Блокировка потоков снимается с помощью счётчика: любой действующий поток, при выполнении определенной операции уменьшает значение счётчика. Когда счётчик достигает 0, все ожидающие потоки разблокируются и продолжают выполняться (примером CountDownLatch из жизни может служить сбор экскурсионной группы: пока не наберется определенное количество человек, экскурсия не начнется)."
}
,{
  question: "Объект синхронизации CyclicBarrier",
  answer: "CyclicBarrier реализует шаблон синхронизации Барьер. Циклический барьер является точкой синхронизации, в которой указанное количество параллельных потоков встречается и блокируется. Как только все потоки прибыли, выполняется опционное действие (или не выполняется, если барьер был инициализирован без него), и, после того, как оно выполнено, барьер ломается и ожидающие потоки «освобождаются». В конструктор барьера (CyclicBarrier(int parties) и CyclicBarrier(int parties, Runnable barrierAction)) обязательно передается количество сторон, которые должны «встретиться», и, опционально, действие, которое должно произойти, когда стороны встретились, но перед тем когда они будут «отпущены».Барьер похож на CountDownLatch, но главное различие между ними в том, что вы не можете заново использовать «замок» после того, как его счётчик достигнет нуля, а барьер вы можете использовать снова, даже после того, как он сломается. CyclicBarrier является альтернативой метода join(), который «собирает» потоки только после того, как они выполнились."
}
,{
  question: "Объект синхронизации Exchanger",
  answer: "Exchanger (обменник) может понадобиться, для того, чтобы обменяться данными между двумя потоками в определенной точки работы обоих потоков. Обменник — обобщенный класс, он параметризируется типом объекта для передачи.Обменник является точкой синхронизации пары потоков: поток, вызывающий у обменника метод exchange() блокируется и ждет другой поток. Когда другой поток вызовет тот же метод, произойдет обмен объектами: каждая из них получит аргумент другой в методе exchange(). Стоит отметить, что обменник поддерживает передачу null значения. Это дает возможность использовать его для передачи объекта в одну сторону, или, просто как точку синхронизации двух потоков."
}
,{
  question: "Объект синхронизации Phaser",
  answer: "Phaser (фазер), как и CyclicBarrier, является реализацией шаблона синхронизации Барьер, но, в отличии от CyclicBarrier, предоставляет больше гибкости. Этот класс позволяет синхронизировать потоки, представляющие отдельную фазу или стадию выполнения общего действия. Как и CyclicBarrier, Phaser является точкой синхронизации, в которой встречаются потоки-участники. Когда все стороны прибыли, Phaser переходит к следующей фазе и снова ожидает ее завершения.Если сравнить Phaser и CyclicBarrier, то можно выделить следующие важные особенности Phaser:<br>Каждая фаза (цикл синхронизации) имеет номер;Количество сторон-участников жестко не задано и может меняться: поток может регистрироваться в качестве участника и отменять свое участие;Участник не обязан ожидать, пока все остальные участники соберутся на барьере. Чтобы продолжить свою работу достаточно сообщить о своем прибытии;Случайные свидетели могут следить за активностью в барьере;Поток может и не быть стороной-участником барьера, чтобы ожидать его преодоления;У фазера нет опционального действия."
}
,{
  question: "Что такое Lock?",
  answer: "Lock — Базовый интерфейс из lock framework, предоставляющий более гибкий подход по ограничению доступа к ресурсам/блокам нежели при использовании synchronized. Так, при использовании нескольких локов, порядок их освобождения может быть произвольный. Плюс имеется возможность пойти по альтернативному сценарию, если лок уже кем то захвачен."
}
,{
  question: "Что такое ReentrantLock?",
  answer: "ReentrantLock — Лок на вхождение. Только один поток может зайти в защищенный блок. Класс поддерживает «честную» (fair) и «нечестную» (non-fair) разблокировку потоков. При «честной» разблокировке соблюдается порядок освобождения потоков, вызывающих lock(). При «нечестной» разблокировке порядок освобождения потоков не гарантируется, но, как бонус, такая разблокировка работает быстрее. По умолчанию, используется «нечестная» разблокировка."
}
,{
  question: "Как использовать ReadWriteLock?",
  answer: "Стандартный интерфейс ReadWriteLock предоставляет потокобезопасный разделенный доступ на чтение и на запись. Для этих целей в нём объявлены два метода: readLock() и writeLock(). Они возвращают объекты под интерфейсом Lock.<br>Оба типа блокировок одного экземпляра ReadWriteLock связаны. Пока какой-то поток не заберет блокировку на запись, сколько угодно потоков могут читать не мешая друг другу. Блокировкой readLock закрывается часть кода с семантикой «только чтения» некоторого условного «ресурса». В критической секции кода writeLock осуществляется модификация ресурса.<br>Свойства этих локов защищают программу от ситуаций конкурентной записи ресурса и чтения во время записи. Подобно copy-on-write коллекциям, этот подход становится выгодным, когда ресурс читают сильно чаще чем модифицируют.Интерфейс реализуется классом ReentrantReadWriteLock, который во многом похож на обычный ReentrantLock.<br>"
}
,{
  question: "Когда используется StampedLock?",
  answer: "StampedLock - примитив синхронизации, добавленный в Java с версии 8. Общий принцип его работы точно такой же, как у ReadWriteLock: захват неэксклюзивной блокировки (на чтение), и эксклюзивной (на запись). Но есть у этих классов ряд различий в деталях.Во-первых, если блокировка ReadWriteLock возвращает объекты типа Lock, то StampedLock возвращает числа типа long, которые и называется «штампами». Штамп служит идентификатором лока, он передается параметром в методы по работе с ранее захваченной блокировкой чтения или записи. Специальный штамп 0 означает неудавшийся захват.<br>StampedLock в отличие от ReentrantReadWriteLock - не реентрант. Это накладывает бóльшую ответственность на программиста: можно устроить дедлок на одном потоке.В StampedLock расширена функциональность. Новые методы с префиксом try* не висят в ожидании. Методы tryOptimistic* реализуют оптимистичную блокировку. Методы tryConvert* дают возможность изменять «уровень» заблокированности: можно попытаться превратить readLock во writeLock, и наоборот.<br>Не смотря на похожесть, StampedLock не наследуется от ReadWriteLock. Но для совместимости в нём предусмотрены методы-адаптеры asReadWriteLock, asReadLock и asWriteLock.<br>Итого, блокировка на штампах решает те же задачи, что ReadWriteLock, но дает больше возможностей и лучшую производительность.<br>"
}
,{
  question: "Зачем выбирать ReentrantLock вместо synchronized?",
  answer: "Объект класса ReentrantLock решает те же задачи, что и блок synchronized. Поток висит на вызове метода lock() в ожидании своей очереди занять этот объект. Владеть локом, как и находиться внутри блока synchronized может только один поток одновременно. unlock(), подобно выходу из блока синхронизации, освобождает объект-монитор для других потоков.В отличие от блока синхронизации, ReentrantLock дает расширенный интерфейс для получения информации о состоянии блокировки. Методы лока позволяют еще до блокировки узнать, занят ли он сейчас, сколько потоков ждут его в очереди, сколько раз подряд текущий поток завладел им.Шире и возможные режимы блокировки. Кроме обычного ожидающего lock(), вариант tryLock() с параметром ожидает своей очереди только заданное время, а без параметра - вообще не ждет, а только захватывает свободный лок.Еще одно отличие - свойство fair. Лок с этим свойством обеспечивает «справедливость» очереди: пришедший раньше поток захватывает объект раньше. Блок synchronized не дает никаких гарантий порядка."
}
,{
  question: "Что такое Executor?",
  answer: "Executor - интерфейс, который может выполнять подтвержденные задачи. Интерфейс предоставляет возможность избежать вникания в механику выполнения задачи и деталей использования выполняемого потока. Executor обычно используется для явного создания нитей. Например так://Вместо<br>Thread(new(RunnableTask())).start():<br>//Лучше использовать<br>Executor executor = anExecutor;<br>executor.execute(new RunnableTask1());<br>executor.execute(new RunnableTask2());<br>"
}
,{
  question: "Что такое ExecutorService?",
  answer: "ExecutorService исполняет асинхронный код в одном или нескольких потоках. Создание инстанса ExecutorService'а делается либо вручную через конкретные имплементации (ScheduledThreadPoolExecutor или ThreadPoolExecutor), но проще будет использовать фабрики класса Executors. Например, если надо создать пул с 2мя потоками, то делается это так:<br>1<br>ExecutorService service = Executors.newFixedThreadPool(2);<br>Если требуется использовать кэширующий пул потоков, который создает потоки по мере необходимости, но переиспользует неактивные потоки (и подчищает потоки, которые были неактивные некоторое время), то это задается следующим образом:ExecutorService service = Executors.newCachedThreadPool();Если требуется запустить асинхронный код несколько раз, то это будет выполняться так:ExecutorService service = Executors.newCachedThreadPool();<br>for(int i = 0; i < 10; i++) {<br>service.submit(new Runnable() {<br>public void run() {<br>// snip... piece of code<br>}<br>});<br>}<br>Метод submit также возвращает объект Future, который содержит информацию о статусе исполнения переданного Runnable или Callable (который может возвращать значение). Из него можно узнать выполнился ли переданный код успешно, или он еще выполняется. Вызов метода get на объекте Future возвратит значение, который возвращает Callable (или null, если используется Runnable). Метод имеет 2 checked-исключения: InterruptedException, который бросается, когда выполнение прервано через метод interrupt(), или ExecutionException если код в Runnable или Callable бросил RuntimeException, что решает проблему поддержки исключений между потоками.<br>"
}
,{
  question: "Что такое ThreadPoolExecutor и зачем он нужен?",
  answer: "ThreadPoolExecutor - реализация ExecutorService. Он выполняет переданную задачу (Callable или Runnable), используя одну из внутренних доступных нитей из пула. Пул потоков содержит в себе ThreadPoolExecutor, который может содержать изменяющееся число нитей. Число нитей в пуле задается с помощью corePoolSize и maximumPoolSize."
}
,{
  question: "Зачем нужен ScheduledExecutorService?",
  answer: "Иногда требуется выполнение кода асихронно и периодически или требуется выполнить код через некоторое время, тогда на помощь приходит ScheduledExecutorService. Он позволяет поставить код выполняться в одном или нескольких потоках и сконфигурировать интервал или время, на которое выполненение будет отложено. Интервалом может быть время между двумя последовательными запусками или время между окончанием одного выполнения и началом другого. Методы ScheduledExecutorService возвращают ScheduledFuture, который также содержит значение отсрочки для выполнения ScheduledFuture.<br>Если требуется отложить выполнение на 5 секунд, потребуется следующий код:ScheduledExecutorService service = Executors.newSingleThreadScheduledExecutor();<br>service.schedule(new Runnable() { ... }, 5, TimeUnit.SECONDS);<br>Если требуется назначить выполнение каждую секунду:ScheduledExecutorService service = Executors.newSingleThreadScheduledExecutor();<br>service.scheduleAtFixedRate(new Runnable() { ... }, 0, 1, TimeUnit.SECONDS);<br>И, наконец, если требуется назначить выполнение кода с промежутком 1 секунда между выполнениями:<br>JavaScheduledExecutorService service = Executors.newSingleThreadScheduledExecutor();<br>service.scheduleWithFixedDelay(new Runnable() { ... }, 0, 1, TimeUnit.SECONDS);<br>"
}
,{
  question: "Что такое ForkJoinPool?",
  answer: "ForkJoinPool - специальный вид ExecutorService (пулла потоков), который появился в Java с версии 7. Предназначен для выполнения рекурсивных задач.Задача для сервиса представляется экземпляром класса ForkJoinTask. В основном используются подклассы RecursiveTask и RecursiveAction, для задач с результатом и без соответственно. Аналогично интерфейсам Callable и Runnable обычного ExecutorService.Тело рекурсивной операции задается в реализации метода compute() задачи ForkJoinTask. Здесь же создаются новые подзадачи, и запускаются параллельно методом fork(). Чтобы дождаться завершения выполнения задачи, на каждой форкнутой подзадаче вызывается блокирующий метод join(), результат выполнения при необходимости агрегируется.С точки зрения использования метод ForkJoinTask.join() похож на аналогичный метод класса Thread. Но в случае fork-join поток может на самом деле не заснуть, а переключиться на выполнение другой задачи. Такая стратегия называется work stealing, и позволяет эффективнее использовать ограниченное количество потоков. Это похоже на переиспользование потоков корутинах Kotlin (green threads)."
}
,{
  question: "Какими коллекциями пользоваться в многопоточной среде?",
  answer: "Первый вариант - превратить в синхронизированную обычную коллекцию, вызвав соответствующий ее типу метод Collections.synchronized*(). Самый общий и самый примитивный способ, создает обертку с синхронизацией всех операций с помощью synchronized.Если работа с коллекцией состоит в основном из чтения, лучшая в плане производительности альтернатива - CopyOnWriteArrayList, и содержащий его в реализации CopyOnWriteArraySet. Потокобезопасность достигается копированием внутреннего массива при любой модификации, оригинальный массив остается immutable. Program order достигается модификатором volatile на внутреннем массиве.Третий вариант - использование Concurrent-коллекций:<br>• Неблокирующие хэш-таблицы ConcurrentSkipListMap, ConcurrentHashMap и ConcurrentSkipListSet (хэш-таблица в основе реализации)<br>• Неблокирующие очереди ConcurrentLinkedQueue и ConcurrentLinkedDeque<br>• Большой набор различных блокирующих очередей<br>"
}
,{
  question: "Что знаете про ConcurrentHashMap?",
  answer: "Класс ConcurrentHashMap — это хешированный ассоциативный массив<br>Мар, аналогичный хеш-массиву HashMap, но использующий другую замковую<br>стратегию. Вместо синхронизации каждого метода на общем замке<br>и ограничения доступа одним потоком за раз он использует замковое<br>расщепление на полосы lock striping, расширяющее<br>возможности совместного доступа к ассоциативному массиву. Оно обеспечивает<br>конкурентность между читающими потоками, между читателями<br>и писателями и между писателями. Результатом является высокая<br>пропускная способность в рамках конкурентного доступа с небольшим<br>штрафом на производительность для однопоточного доступа.Также класс ConcurrentHashMap предоставляет итераторы, которые не выдают<br>исключение ConcurrentModif icationException, являются не быстро<br>отказывающими, а слабо непротиворечивыми (weakly consistent). Они<br>допускают конкурентное выполнение изменений, перебирают элементы<br>в том порядке, в каком они существовали при конструировании итератора,<br>и могут (не обязательно) отражать изменения в коллекцию.<br>"
}
,{
  question: "Какие же основные идеи реализации ConcurrentHashMap?",
  answer: "1. Элементы карты<br>   В отличие от элементов HashMap, Entry в ConcurrentHashMap объявлены как volatile. Это важная особенность, также связанная с изменениями в JMM.static final class HashEntry<K, V> {<br>final K key;<br>final int hash;<br>volatile V value;<br>final HashEntry<K, V> next;<br>}2. Хэш-функция<br>   В ConcurrentHashMap также используется улучшенная функция хэширования. Таблицы в хэш-карте имеют длину, определяемую степенью двойки. Для хэш-кодов, двоичные представления которых не различаются в младшей и старшей позиции, мы будем иметь коллизии. Усложнение хэш-функции как раз решает данную проблему, уменьшая вероятность коллизий в карте.3. Сегменты<br>   Карта делится на N различных сегментов (16 по умолчанию, максимальное значение может быть 16-битным и представлять собой степень двойки). Каждый сегмент представляет собой потокобезопасную таблицу элементов карты. Между хэш-кодами ключей и соответствующими им сегментами устанавливается зависимость на основе применения к старшим разрядам хэш-кода битовой маски.final Segment<K, V>[] segments;<br>transient Set<K> keySet;<br>transient Set<Map.Entry<K, V>> entrySet;<br>transient Collection<V> values;static final class Segment<K, V> extends ReentrantLock implements Serializable {<br>private static final long serialVersionUID = 2249069246763182397L;<br>transient volatile int count;<br>transient int modCount;<br>transient int threshold;<br>transient volatile HashEntry<K, V>[] table;<br>}4. ConcurrencyLevel<br>   Данный параметр влияет на использование картой памяти и количество сегментов в карте. Количество сегментов будет выбрано как ближайшая степень двойки, большая чем concurrencyLevel. Ёмкость каждого сегмента, соответственно, будет определяться как отношение округлённого до ближайшей большей степени двойки значения ёмкости карты по умолчанию, к полученному количеству сегментов.Очень важно понимать две следующие вещи. Занижение concurrencyLevel ведёт к тому, что более вероятны блокировки потоками сегментов карты при записи. Завышение показателя ведёт к неэффективному использованию памяти.<br>"
}
,{
  question: "Как выбрать concurrencyLevel?",
  answer: "Если лишь один поток будет изменять карту, а остальные будут производить чтение — рекомендуется использовать значение 1. Необходимо помнить, что resize таблиц для хранения внутри карти — опреация, требующая дополнительного времени (и, зачастую, выполняемая не быстро). Поэтому при создании карты требуется иметь некоторые приблизительные оценки по статистике выполнения возможных операций чтения и записи."
}
,{
  question: "Что знаете про CopyOnWriteArrayList?",
  answer: "CopyOnWriteArrayList - это потокобезопасный вариант of ArrayList. Подобно ArrayList, CopyOnWriteArray, он управляет массивом для хранения его элементов. Разница в том, что все мутативные операции, такие как add, set, remove, clear,... создают новую копию массива, которым он управляет.Стоимость использования CopyOnWriteArrayList очень высока, вам придется платить больше за ресурс и производительность. Однако CopyOnWriteArrayList пригодится, когда вы не можете или не хотите синхронизировать при обходе (traversal) элементов списка.Для лучшего понимания рассмотрим ситуацию, когда два Thread используют один и тот же объект List. В то время как Thread-A обходит (traversal) элементы List, он замораживает действия вставки или обновления в List для целостности данных, но, очевидно, это влияет на действия Thread-B.Когда вы создаете объект Iterator из CopyOnWriteArrayList, он помогает вам пройти через элементы текущего массива (когда был создан Iterator). Элементы этого массива не изменяются за время существования Iterator. Это возможно потому, что любые действия add, set, remove, clear, .. на CopyOnWriteArrayList создают другой массив, который является копией текущего массива."
}
,{
  question: "Что знаете про BlockingQueue?",
  answer: "Интерфейс BlockingQueue определяет блокирующую очередь, наследующую свойства интерфейса Queue, в которой элементы хранятся в порядке «первый пришел, первый вышел» (FIFO - first in, first out). Реализация данного интерфейса обеспечивает блокировку потока в двух случаях :при попытке получения элемента из пустой очереди;<br>при попытке размещения элемента в полной очереди.take(): Возвращает верхний элемент и удаляет его из очереди. Если очередь пуста, метод будет ждать, пока элемент не станет доступен в очереди.poll(timeout,unit): Возвращает головной элемент и удаляет его из очереди. Если очередь пуста, метод будет ждать, пока элемент будет доступен в течение указанного промежутка времени. Если время ожидания заканчивается без доступных элементов, метод вернет значение null.put(e): Вставить элемент в очередь. Если очередь заполнена, этот метод будет ждать, пока не появится свободное место для вставки.offer(e,timeout,unit): Вставить элемент в очередь. Если очередь заполнена, метод будет ждать, пока освободится место для вставки в течение указанного промежутка времени. Если тайм-аут заканчивается без свободного места, никаких действий предпринято не будет, и метод вернет значение false.BlockingQueue изящно решает проблему передачи собранных одним потоком элементов для обработки в другой поток без явных хлопот о проблемах синхронизации.Библиотека классов содержит несколько реализаций блокирующей очереди<br>BlockingQueue. Очереди LinkedBlockingQueue и ArrayBlockingQueue<br>являются очередями с дисциплиной доступа FIFO, аналогичными связному<br>списку LinkedList и массиву-списку ArrayList, но с лучшей конкурентной<br>производительностью, чем синхронизированный список List.<br>Очередь PriorityBlockingQueue является очередью с приоритетом, которая<br>полезна при обработке элементов в порядке, отличном от FIFO.<br>"
}
,
    ];

    const questionText = document.getElementById('question-text');
    const answerText = document.getElementById('answer-text');
    const modal = document.getElementById('modal');
    const modalAnswer = document.getElementById('modal-answer');

    function toggleAnswer() {
        const answer = questions[currentQuestionIndex].answer;
        if (answer.length > MAX_ANSWER_LENGTH) {
            showModal(answer);
        } else {
            if (answerText.classList.contains('hidden')) {
                answerText.innerHTML = answer;
                answerText.classList.remove('hidden');
                questionText.classList.add('hidden');
            } else {
                answerText.classList.add('hidden');
                questionText.classList.remove('hidden');
            }
        }
    }

    function showModal(answer) {
        modalAnswer.innerHTML = answer;
        modal.classList.remove('hidden');
    }

    function showQuestion(index) {
        questionText.textContent = questions[index].question;
        answerText.innerHTML = ""; // Скрываем ответ при смене вопроса
        questionText.classList.remove('hidden');
        answerText.classList.add('hidden');
    }

    function nextQuestion() {
        if (currentQuestionIndex < questions.length - 1) {
            currentQuestionIndex++;
            showQuestion(currentQuestionIndex);
        }
    }

    function prevQuestion() {
        if (currentQuestionIndex > 0) {
            currentQuestionIndex--;
            showQuestion(currentQuestionIndex);
        }
    }

    function closeModal() {
        modal.classList.add('hidden');
    }

    showQuestion(currentQuestionIndex);
</script>

</body>
</html>
