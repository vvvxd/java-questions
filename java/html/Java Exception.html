<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Вопросы по собеседованию</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .question-block {
            cursor: pointer;
            transition: background-color 0.3s ease;
            word-break: break-word;
        }
        .question-block:hover {
            background-color: #f3f4f6;
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen">

<!-- Контейнер с вопросом -->
<div id="question-container" class="bg-white shadow-lg rounded-lg p-6 w-[800px] h-[750px] flex items-center justify-center text-center relative">
    <div id="question-block" class="question-block p-4 border-b w-full h-full flex items-center justify-center text-center relative" onclick="toggleAnswer()">
        <strong class="text-lg block" id="question-text"></strong>
        <div id="answer-text" class="text-gray-700 hidden" onclick="toggleAnswer()"></div>
    </div>
</div>

<!-- Навигация -->
<div class="absolute bottom-10 flex justify-center gap-4">
    <button onclick="prevQuestion()" class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600">Назад</button>
    <button onclick="location.href='main.html'" class="bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600">На главную</button>
    <button onclick="nextQuestion()" class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600">Вперед</button>
</div>

<!-- Модальное окно -->
<div id="modal" class="fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 hidden">
    <div class="bg-white p-6 rounded-lg shadow-lg w-[900px] h-[800px] overflow-y-auto">
        <h2 class="text-lg font-semibold mb-4">Ответ</h2>
        <p id="modal-answer" class="text-gray-700"></p>
        <button onclick="closeModal()" class="mt-4 bg-red-500 text-white px-4 py-2 rounded hover:bg-red-600 w-full">Закрыть</button>
    </div>
</div>

<script>
    let currentQuestionIndex = 0;
    const MAX_ANSWER_LENGTH = 2000; // Максимальная длина ответа для отображения без модального окна

    const questions = [
        {
  question: "Дайте определение понятию 'исключение'",
  answer: "Исключение - это проблема(ошибка) возникающая во время выполнения программы. Исключения могут возникать во многих случаях, например:Пользователь ввел некорректные данные.<br>Файл, к которому обращается программа, не найден.<br>Сетевое соединение с сервером было утеряно во время передачи данных. И т.д.Все исключения в Java являются объектами. Поэтому они могут порождаться не только автоматически при возникновении исключительной ситуации, но и создаваться самим разработчиком."
}
,{
  question: "Опишите иерархию исключений",
  answer: "Все классы-исключения расширяют класс Throwable - непосредственное расширение класса object. У класса Throwable и у всех его расширений по традиции два конструктора:<br>Throwable о - конструктор по умолчанию;<br>Throwable (String message) - создаваемый объект будет содержать произвольное сообщение message.<br>Записанное в конструкторе сообщение можно получить затем методом getMessage (). Если объект создавался конструктором по умолчанию, то данный метод возвратит null. Метод toString возвращает краткое описание события, именно он работал в предыдущих листингах.<br>Три метода выводят сообщения обо всех методах, встретившихся по пути 'полета' исключения:<br>printstackTrace() - выводит сообщения в стандартный вывод, как правило, это консоль;<br>printStackTrace(PrintStream stream) - выводит сообщения в байтовый поток stream;<br>printStackTrace(PrintWriter stream) - выводит сообщения в символьный поток stream.<br>У класса Throwable два непосредственных наследника - классы Error и Exception. Они не добавляют новых методов, а служат для разделения классов-исключений на два больших семейства - семейство классов-ошибок (error) и семейство собственно классов-исключений (exception).<br>Классы-ошибки, расширяющие класс Error, свидетельствуют о возникновении сложных ситуаций в виртуальной машине Java. Их обработка требует глубокого понимания всех тонкостей работы JVM. Ее не рекомендуется выполнять в обычной программе. Не советуют даже выбрасывать ошибки оператором throw. He следует делать свои классы-исключения расширениями класса Error или какого-то его подкласса.<br>Имена классов-ошибок, по соглашению, заканчиваются словом Error.<br>Классы-исключения, расширяющие класс Exception, отмечают возникновение обычной нештатной ситуации, которую можно и даже нужно обработать. Такие исключения следует выбросить оператором throw. Классов-исключений очень много, более двухсот. Они разбросаны буквально по всем пакетам J2SDK. В большинстве случаев вы способны подобрать готовый класс-исключение для обработки исключительных ситуаций в своей программе. При желании можно создать и свой класс-исключение, расширив класс Exception или любой его подкласс.<br>Среди классов-исключений выделяется класс RuntimeException - прямое расширение класса Exception. В нем и его подклассах отмечаются исключения, возникшие при работе JVM, но не столь серьезные, как ошибки. Их можно обрабатывать и выбрасывать, расширять своими классами, но лучше доверить это JVM, поскольку чаще всего это просто ошибка в программе, которую надо исправить. Особенность исключений данного класса в том, что их не надо отмечать в заголовке метода пометкой throws.<br>Имена классов-исключений, по соглашению, заканчиваются словом Exception."
}
,{
  question: "Какие виды исключений в Java вы знаете, чем они отличаются?",
  answer: "Все исключительные ситуации можно разделить на две категории: проверяемые(checked) и непроверяемые(unchecked).<br>Все исключения, порождаемые от Throwable, можно разбить на три группы. Они определяются тремя базовыми типами: наследниками Throwable - классами Errorи Exception, а также наследником Exception - RuntimeException.<br>Ошибки, порожденные от Exception (и не являющиеся наследниками RuntimeException ), являются проверяемыми. Т.е. во время компиляции проверяется, предусмотрена ли обработка возможных исключительных ситуаций. Как правило, это ошибки, связанные с окружением программы (сетевым, файловым вводом-выводом и др.), которые могут возникнуть вне зависимости от того, корректно написан код или нет. Например, открытие сетевого соединения или файла может привести к возникновению ошибки и компилятор требует от программиста предусмотреть некие действия для обработки возможных проблем. Таким образом повышается надежность программы, ее устойчивость при возможных сбоях.<br>Исключения, порожденные от RuntimeException, являются непроверяемыми и компилятор не требует обязательной их обработки.<br>Как правило, это ошибки программы, которые при правильном кодировании возникать не должны (например, IndexOutOfBoundsException- выход за границы массива, java.lang.ArithmeticException- деление на ноль). Поэтому, чтобы не загромождать программу, компилятор оставляет на усмотрение программиста обработку таких исключений с помощью блоков try-catch.<br>Исключения, порожденные от Error, также не являются проверяемыми. Они предназначены для того, чтобы уведомить приложение о возникновении фатальной ситуации, которую программным способом устранить практически невозможно (хотя формально обработчик допускается). Они могут свидетельствовать об ошибках программы, но, как правило, это неустранимые проблемы на уровне JVM. В качестве примера можно привести StackOverflowError (переполнение стека), OutOfMemoryError (нехватка памяти).<br>Методы, код которых может порождать проверяемые исключения, должны либо сами их обрабатывать, либо в заголовке метода должно быть указано ключевое слово throws с перечислением необрабатываемых проверяемых исключений. На непроверяемые ошибки это правило не распространяется.<br>Переопределенный (overridden) метод не может расширять список возможных исключений исходного метода."
}
,{
  question: "Лучший способ работать с исключениями",
  answer: "Если исключение может быть правильно обработано, его надо ловить, иначе, оно должно быть проброшено дальше."
}
,{
  question: "Почему переменные, определенные в try не могут быть использованы в catch или finally?",
  answer: "В следующем куске кода строку s, объявленную в блоке try, нельзя использовать в блоке catch. Этот код не скомпилируется.try {<br>File file = new File('path');<br>FileInputStream fis = new FileInputStream(file);<br>String s = 'inside';<br>}<br>catch (FileNotFoundException e) {<br>e.printStackTrace(); System.out.println(s);<br>}Причина в том, что неизвестно, где именно в блоке try могло быть вызвано исключение. Вполне возможно, что исключение было вызвано до того, как был объявлен объект. И именно для данного примера это справедливо."
}
,{
  question: "Как написать собственное («пользовательское») исключение?",
  answer: "Необходимо унаследоваться от базового класса требуемого типа исключений (например, от Exception или RuntimeException).class CustomException extends Exception {<br>public CustomException() { super(); }<br>public CustomException(final String string) { super(string + ' is invalid'); }<br>public CustomException(final Throwable cause) { super(cause);<br>} }"
}
,{
  question: "Какие существуют unchecked exception?",
  answer: "Наиболее часто встречающиеся: ArithmeticException, ClassCastException, ConcurrentModificationException, IllegalArgumentException, IllegalStateException, IndexOutOfBoundsException, NoSuchElementException, NullPointerException, UnsupportedOperationException."
}
,{
  question: "О чем говорит ключевое слово throws?",
  answer: "Модификатор throws прописывается в заголовке метода и указывает на то, что метод потенциально может выбросить исключение с указанным типом."
}
,{
  question: "Какой оператор позволяет принудительно выбросить исключение?",
  answer: "Это оператор throw:<br>throw new Exception();"
}
,{
  question: "Что такое Error?",
  answer: "Исключения, порожденные от Error, не являются проверяемыми. Они предназначены для того, чтобы уведомить приложение о возникновении фатальной ситуации, которую программным способом устранить практически невозможно (хотя формально обработчик допускается). Они могут свидетельствовать об ошибках программы, но, как правило, это неустранимые проблемы на уровне JVM. В качестве примера можно привести StackOverflowError (переполнение стека), OutOfMemoryError (нехватка памяти).<br>Методы, код которых может порождать проверяемые исключения, должны либо сами их обрабатывать, либо в заголовке метода должно быть указано ключевое слово throws с перечислением необрабатываемых проверяемых исключений. На непроверяемые ошибки это правило не распространяется."
}
,{
  question: "Что вы знаете о OutOfMemoryError?",
  answer: "OutOfMemoryError выбрасывается, когда виртуальная машина Java не может создать (разместить) объект из-за нехватки памяти, а сборщик мусора не может высвободить достаточное её количество.<br>Область памяти, занимаемая java процессом, состоит из нескольких частей. Тип OutOfMemoryError зависит от того, в какой из них не хватило места:<br>- java.lang.OutOfMemoryError: Java heap space: Не хватает места в куче, а именно, в области памяти в которую помещаются объекты, создаваемые в приложении программно. Обычно проблема кроется в утечке памяти. Размер задается параметрами -Xms и -Xmx.<br>- java.lang.OutOfMemoryError: PermGen space: (до версии Java 8) Данная ошибка возникает при нехватке места в Permanent области, размер которой задается параметрами -XX:PermSize и -XX:MaxPermSize.<br>- java.lang.OutOfMemoryError: GC overhead limit exceeded: Данная ошибка может возникнуть как при переполнении первой, так и второй областей. Связана она с тем, что памяти осталось мало и сборщик мусора постоянно работает, пытаясь высвободить немного места. Данную ошибку можно отключить с помощью параметра -XX:-UseGCOverheadLimit.<br>- java.lang.OutOfMemoryError: unable to create new native thread: Выбрасывается, когда нет возможности создавать новые потоки."
}
,{
  question: "Опишите работу блока try-catch-finally.",
  answer: "try — данное ключевое слово используется для отметки начала блока кода, который потенциально может привести к ошибке. catch — ключевое слово для отметки начала блока кода, предназначенного для перехвата и обработки исключений в случае их возникновения. finally — ключевое слово для отметки начала блока кода, который является дополнительным. Этот блок помещается после последнего блока catch. Управление передаётся в блок finally в любом случае, было выброшено исключение или нет."
}
,{
  question: "Что такое механизм try-with-resources?",
  answer: "Данная конструкция, которая появилась в Java 7, позволяет использовать блок try-catch не заботясь о закрытии ресурсов, используемых в данном сегменте кода. Ресурсы объявляются в скобках сразу после try, а компилятор уже сам неявно создаёт секцию finally, в которой и происходит освобождение занятых в блоке ресурсов. Под ресурсами подразумеваются сущности, реализующие интерфейс java.lang.Autocloseable.<br>Стоит заметить, что блоки catch и явный finally выполняются уже после того, как закрываются ресурсы в неявном finally."
}
,{
  question: "Возможно ли использование блока try-finally (без catch)?",
  answer: "Такая запись допустима, но смысла в такой записи не так много, всё же лучше иметь блок catch, в котором будет обрабатываться необходимое исключение."
}
,{
  question: "Может ли один блок catch отлавливать сразу несколько исключений?",
  answer: "В Java 7 стала доступна новая языковая конструкция, с помощью которой можно перехватывать несколько исключений одним блоком catch:<br>try { //... }<br>catch(IOException | SQLException ex)<br>{ //... }"
}
,{
  question: "Всегда ли исполняется блок finally?",
  answer: "Код в блоке finally будет выполнен всегда, независимо от того, выброшено исключение или нет.Например в следующих ситуациях он может быть не выполнен:Существуют потоки-демоны - потоки предоставляющие некие сервисы, работая в фоновом режиме во время выполнения программы, но при этом не являются ее неотъемлеммой частью.Таким образом когда все потоки не демоны завершаются, программа завершает свою работу. В потоках демонах блок finally не выполняеться, они прерываются внезапно.System.exit(0)если в блоке finally произошло исключение и нет обработчика, то оставшийся код в блоке finally может не выполнятся."
}
,{
  question: "Может ли метод main() выбросить исключение во вне и если да, то где будет происходить обработка данного исключения?",
  answer: "Может и оно будет передано в виртуальную машину Java (JVM)."
}
,{
  question: "Предположим, есть метод, который может выбросить IOException и FileNotFoundException в какой последовательности должны идти блоки catch? Сколько блоков catch будет выполнено?",
  answer: "Общее правило: обрабатывать исключения нужно от «младшего» к старшему. Т.е. нельзя поставить в первый блок catch(Exception ex) {}, иначе все дальнейшие блоки catch() уже ничего не смогут обработать, т.к. любое исключение будет соответствовать обработчику catch(Exception ex).<br>Таким образом, исходя из факта, что FileNotFoundException extends IOException сначала нужно обработать FileNotFoundException, а затем уже IOException:<br>void method() {<br>try { //... }<br>catch (FileNotFoundException ex) { //... }<br>catch (IOException ex) { //... }<br>}"
}
,{
  question: "Какие существуют способы обработки исключений?",
  answer: "В Java есть пять ключевых слов для работы с исключениями:<br>try - данное ключевое слово используется для отметки начала блока кода, который потенциально может привести к ошибке.<br>catch - ключевое слово для отметки начала блока кода, предназначенного для перехвата и обработки исключений.<br>finally - ключевое слово для отметки начала блока кода, которой является дополнительным. Этот блок помещается после последнего блока 'catch'. Управление обычно передаётся в блок 'finally' в любом случае.<br>throw - служит для генерации исключений.<br>throws - ключевое слово, которое прописывается в сигнатуре метода, и обозначающее что метод потенциально может выбросить исключение с указанным типом."
}
,{
  question: "В чем особенность RuntimeException?",
  answer: "public class RuntimeException extends Exception - базовый класс для ошибок во время выполнения. Относится к необрабатываемым исключениям (uncatched\unchecked). Как сказано в описании класса - это суперкласс, исключения которого могут быть выброшены во время нормальной работы JVM."
}
,{
  question: "Есть ли дополнительные условия к методу, который потенциально может выбросить исключение?",
  answer: "Если это проверяемое исключение, то оно должно быть задекларировано в сигнатуре метода.public void someMethod() throws Exception {<br>}"
}
,{
  question: "Если оператор return содержится и в блоке catch и в finally, какой из них 'главнее'?",
  answer: "Вернется из блока finally.public static void main(String[] args) {<br>String what = method();<br>System.out.println(what);<br>}<br>public static String method() {<br>try {<br>return 'SomeString';<br>} catch(Exception ex) {<br>return 'Catch message';<br>} finally {<br>return 'Finally message';<br>}<br>}<br>//Вывод<br>Finally message"
}
,{
  question: "Какие есть правила для проверки исключений при наследовании?",
  answer: "Переопределяемый или реализуемый метод в наследнике / реализации не может выбрасывать контролируемые исключения, которые выше по иерархии чем исключения в методе суперкласса / интерфейса."
}
,{
  question: "Полезные советы по обработке исключений в Java",
  answer: "Не используйте для перехвата исключений класс Exception. В иерархии исключений есть множество классов на все случаи жизни вашей программы, которые не только эффективно обработают конкретную ошибку, но и предоставят полезную для пользователя и отладки информацию.Бросайте исключение как можно раньше. Это является хорошей практикой программирования на Java.<br>Ловите исключения только тогда, когда сможете эффективно для пользователя и отладки их обработать.Освобождайте ресурсы. Перехватывая исключение всегда закрывайте открытые ресурсы. Еще проще и эффективнее это делать с Java 7. Используйте try с ресурсами для лаконичного и красивого кода.Логируйте исключения. Логируйте сообщения, которые предоставляет исключение. В большинстве случаев это даст вам четкое понимание причин и поможет в отладке. Не оставляйте пустым блок catch, иначе он будет просто поглощать исключение без каких-либо значимых деталей для отладки.Один catch для нескольких исключений. Используйте преимущества Java 7 для удобства и красоты вашего кода.Используйте свои исключения. Это позволит вам лучше чувствовать свою программу и эффективнее с ней работать.Соглашения об именовании. Когда вы создать свои классы исключений, следите за тем, что из самого названия класса будет ясно, что это исключение.Используйте исключения с умом. Бросить исключение — достаточно дорогостоящая в Java операция. Возможно, в некоторых случаях будем уместно не бросать исключений, а вернуть, например, логическую переменную, которая обозначала успешное или не успешное выполнение метода.Документируйте исключения. Желательно писать javadoc @throws для ваших исключений. Это будет особенно полезно в тех случаях, когда ваша программа предоставляет интерфейс для работы с другими приложениями."
}
,
    ];

    const questionText = document.getElementById('question-text');
    const answerText = document.getElementById('answer-text');
    const modal = document.getElementById('modal');
    const modalAnswer = document.getElementById('modal-answer');

    function toggleAnswer() {
        const answer = questions[currentQuestionIndex].answer;
        if (answer.length > MAX_ANSWER_LENGTH) {
            showModal(answer);
        } else {
            if (answerText.classList.contains('hidden')) {
                answerText.innerHTML = answer;
                answerText.classList.remove('hidden');
                questionText.classList.add('hidden');
            } else {
                answerText.classList.add('hidden');
                questionText.classList.remove('hidden');
            }
        }
    }

    function showModal(answer) {
        modalAnswer.innerHTML = answer;
        modal.classList.remove('hidden');
    }

    function showQuestion(index) {
        questionText.textContent = questions[index].question;
        answerText.innerHTML = ""; // Скрываем ответ при смене вопроса
        questionText.classList.remove('hidden');
        answerText.classList.add('hidden');
    }

    function nextQuestion() {
        if (currentQuestionIndex < questions.length - 1) {
            currentQuestionIndex++;
            showQuestion(currentQuestionIndex);
        }
    }

    function prevQuestion() {
        if (currentQuestionIndex > 0) {
            currentQuestionIndex--;
            showQuestion(currentQuestionIndex);
        }
    }

    function closeModal() {
        modal.classList.add('hidden');
    }

    showQuestion(currentQuestionIndex);
</script>

</body>
</html>
