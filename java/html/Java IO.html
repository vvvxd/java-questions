<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Вопросы по собеседованию</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .question-block {
            cursor: pointer;
            transition: background-color 0.3s ease;
            word-break: break-word;
        }
        .question-block:hover {
            background-color: #f3f4f6;
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen">

<!-- Контейнер с вопросом -->
<div id="question-container" class="bg-white shadow-lg rounded-lg p-6 w-[800px] h-[750px] flex items-center justify-center text-center relative">
    <div id="question-block" class="question-block p-4 border-b w-full h-full flex items-center justify-center text-center relative" onclick="toggleAnswer()">
        <strong class="text-lg block" id="question-text"></strong>
        <div id="answer-text" class="text-gray-700 hidden" onclick="toggleAnswer()"></div>
    </div>
</div>

<!-- Навигация -->
<div class="absolute bottom-10 flex justify-center gap-4">
    <button onclick="prevQuestion()" class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600">Назад</button>
    <button onclick="location.href='main.html'" class="bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600">На главную</button>
    <button onclick="nextQuestion()" class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600">Вперед</button>
</div>

<!-- Модальное окно -->
<div id="modal" class="fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 hidden">
    <div class="bg-white p-6 rounded-lg shadow-lg w-[900px] h-[800px] overflow-y-auto">
        <h2 class="text-lg font-semibold mb-4">Ответ</h2>
        <p id="modal-answer" class="text-gray-700"></p>
        <button onclick="closeModal()" class="mt-4 bg-red-500 text-white px-4 py-2 rounded hover:bg-red-600 w-full">Закрыть</button>
    </div>
</div>

<script>
    let currentQuestionIndex = 0;
    const MAX_ANSWER_LENGTH = 2000; // Максимальная длина ответа для отображения без модального окна

    const questions = [
        {
  question: "В чём заключается разница между IO и NIO?",
  answer: "- Java IO (input-output) является потокоориентированным, а Java NIO (new/non-blocking io) - буфер-ориентированным. Потокоориентированный ввод/вывод подразумевает чтение/запись из потока/в поток одного или нескольких байт в единицу времени поочередно. Данная информация нигде не кэшируются. Таким образом, невозможно произвольно двигаться по потоку данных вперед или назад. В Java NIO данные сначала считываются в буфер, что дает больше гибкости при обработке данных.<br>- Потоки ввода/вывода в Java IO являются блокирующими. Это значит, что когда в потоке выполнения вызывается read() или write() метод любого класса из пакета java.io.*, происходит блокировка до тех пор, пока данные не будут считаны или записаны. Поток выполнения в данный момент не может делать ничего другого. Неблокирующий режим Java NIO позволяет запрашивать считанные данные из канала (channel) и получать только то, что доступно на данный момент, или вообще ничего, если доступных данных пока нет. Вместо того, чтобы оставаться заблокированным пока данные не станут доступными для считывания, поток выполнения может заняться чем-то другим. Тоже самое справедливо и для неблокирующего вывода. Поток выполнения может запросить запись в канал некоторых данных, но не дожидаться при этом пока они не будут полностью записаны.<br>- В Java NIO имеются селекторы, которые позволяют одному потоку выполнения мониторить несколько каналов ввода. Т.е. существует возможность зарегистрировать несколько каналов с селектором, а потом использовать один поток выполнения для обслуживания каналов, имеющих доступные для обработки данные, или для выбора каналов, готовых для записи.<br>"
}
,{
  question: "Какие особенности NIO вы знаете?",
  answer: "- Каналы и селекторы: NIO поддерживает различные типы каналов. Канал является абстракцией объектов более низкого уровня файловой системы (например, отображенные в памяти файлы и блокировки файлов), что позволяет передавать данные с более высокой скоростью. Каналы не блокируются и поэтому Java предоставляет еще такие инструменты, как селектор, который позволяет выбрать готовый канал для передачи данных, и сокет, который является инструментом для блокировки.<br>- Буферы: имеет буферизация для всех классов-обёрток примитивов (кроме Boolean). Появился абстрактный класс Buffer, который предоставляет такие операции, как clear, flip, mark и т.д. Его подклассы предоставляют методы для получения и установки данных.<br>- Кодировки: появились кодеры и декодеры для отображения байт и символов Unicode.<br>"
}
,{
  question: "Что такое «каналы»?",
  answer: "Каналы (channels) - это логические (не физические) порталы, абстракции объектов более низкого уровня файловой системы (например, отображенные в памяти файлы и блокировки файлов), через которые осуществляется ввод/вывод данных, а буферы являются источниками или приёмниками этих переданных данных. При организации вывода, данные, которые необходимо отправить, помещаются в буфер, который затем передается в канал. При вводе, данные из канала помещаются в заранее предоставленный буфер.<br>Каналы напоминают трубопроводы, по которым эффективно транспортируются данные между буферами байтов и сущностями по ту сторону каналов. Каналы - это шлюзы, которые позволяют получить доступ к сервисам ввода/вывода операционной системы с минимальными накладными расходами, а буферы - внутренние конечные точки этих шлюзов, используемые для передачи и приема данных.<br>"
}
,{
  question: "Какие существуют виды потоков ввода/вывода?",
  answer: "Разделяют два вида потоков ввода/вывода:<br>байтовые - java.io.InputStream, java.io.OutputStream;<br>символьные - java.io.Reader, java.io.Writer.<br>"
}
,{
  question: "В каких пакетах расположены классы потоков ввода/вывода?",
  answer: "java.io, java.nio. Для работы с потоками компрессированных данных используются классы из пакета java.util.zip"
}
,{
  question: "Какие подклассы класса InputStream вы знаете, для чего они предназначены?",
  answer: "InputStream - абстрактный класс, описывающий поток ввода;<br>BufferedInputStream - буферизованный входной поток;<br>ByteArrayInputStream позволяет использовать буфер в памяти (массив байтов) в качестве источника данных для входного потока;<br>DataInputStream - входной поток для байтовых данных, включающий методы для чтения стандартных типов данных Java;<br>FileInputStream - входной поток для чтения информации из файла;<br>FilterInputStream - абстрактный класс, предоставляющий интерфейс для классов-надстроек, которые добавляют к существующим потокам полезные свойства;<br>ObjectInputStream - входной поток для объектов;<br>StringBufferInputStream превращает строку (String) во входной поток данных InputStream;<br>PipedInputStream реализует понятие входного канала;<br>PushbackInputStream - разновидность буферизации, обеспечивающая чтение байта с последующим его возвратом в поток, позволяет «заглянуть» во входной поток и увидеть, что оттуда поступит в следующий момент, не извлекая информации.<br>SequenceInputStream используется для слияния двух или более потоков InputStream в единый.<br>"
}
,{
  question: "Для чего используется PushbackInputStream?",
  answer: "Разновидность буферизации, обеспечивающая чтение байта с последующим его возвратом в поток. Класс PushbackInputStream представляет механизм «заглянуть» во входной поток и увидеть, что оттуда поступит в следующий момент, не извлекая информации.<br>У класса есть дополнительный метод unread().<br>"
}
,{
  question: "Для чего используется SequenceInputStream?",
  answer: "Класс SequenceInputStream позволяет сливать вместе несколько экземпляров класса InputStream. Конструктор принимает в качестве аргумента либо пару объектов класса InputStream, либо интерфейс Enumeration.<br>Во время работы класс выполняет запросы на чтение из первого объекта класса InputStream и до конца, а затем переключается на второй. При использовании интерфейса работа продолжится по всем объектам класса InputStream. По достижении конца, связанный с ним поток закрывается. Закрытие потока, созданного объектом класса SequenceInputStream, приводит к закрытию всех открытых потоков.<br>"
}
,{
  question: "Какой класс позволяет читать данные из входного байтового потока в формате примитивных типов данных?",
  answer: "Класс DataInputStream представляет поток ввода и предназначен для записи данных примитивных типов, таких, как int, double и т.д. Для каждого примитивного типа определен свой метод для считывания:boolean readBoolean(): считывает из потока булевое однобайтовое значение<br>byte readByte(): считывает из потока 1 байт<br>char readChar(): считывает из потока значение char<br>double readDouble(): считывает из потока 8-байтовое значение double<br>float readFloat(): считывает из потока 4-байтовое значение float<br>int readInt(): считывает из потока целочисленное значение int<br>long readLong(): считывает из потока значение long<br>short readShort(): считывает значение short<br>String readUTF(): считывает из потока строку в кодировке UTF-8<br>"
}
,{
  question: "Какие подклассы класса OutputStream вы знаете, для чего они предназначены?",
  answer: "OutputStream - это абстрактный класс, определяющий потоковый байтовый вывод;<br>BufferedOutputStream - буферизированный выходной поток;<br>ByteArrayOutputStream - все данные, посылаемые в этот поток, размещаются в предварительно созданном буфере;<br>DataOutputStream - выходной поток байт, включающий методы для записи стандартных типов данных Java;<br>FileOutputStream - запись данных в файл на физическом носителе;<br>FilterOutputStream - абстрактный класс, предоставляющий интерфейс для классов-надстроек, которые добавляют к существующим потокам полезные свойства;<br>PrintStream - выходной поток, включающий методы print() и println();<br>ObjectOutputStream - выходной поток для записи объектов;<br>PipedOutputStream реализует понятие выходного канала.<br>"
}
,{
  question: "Какие подклассы класса Reader вы знаете, для чего они предназначены?",
  answer: "Reader - абстрактный класс, описывающий символьный ввод;<br>BufferedReader - буферизованный входной символьный поток;<br>CharArrayReader - входной поток, который читает из символьного массива;<br>FileReader - входной поток, читающий файл;<br>FilterReader - абстрактный класс, предоставляющий интерфейс для классов-надстроек;<br>InputStreamReader- входной поток, транслирующий байты в символы;<br>LineNumberReader - входной поток, подсчитывающий строки;<br>PipedReader - входной канал;<br>PushbackReader - входной поток, позволяющий возвращать символы обратно в поток;<br>StringReader - входной поток, читающий из строки.<br>"
}
,{
  question: "Какие подклассы класса Writer вы знаете, для чего они предназначены?",
  answer: "Writer - абстрактный класс, описывающий символьный вывод;<br>BufferedWriter - буферизованный выходной символьный поток;<br>CharArrayWriter - выходной поток, который пишет в символьный массив;<br>FileWriter - выходной поток, пишущий в файл;<br>FilterWriter - абстрактный класс, предоставляющий интерфейс для классов-надстроек;<br>OutputStreamWriter - выходной поток, транслирующий байты в символы;<br>PipedWriter - выходной канал;<br>PrintWriter - выходной поток символов, включающий методы print() и println();<br>StringWriter - выходной поток, пишущий в строку;<br>"
}
,{
  question: "В чем отличие класса PrintWriter от PrintStream?",
  answer: "Прежде всего, в классе PrintWriter применен усовершенствованный способ работы с символами Unicode и другой механизм буферизации вывода: в классе PrintStream буфер вывода сбрасывался всякий раз, когда вызывался метод print() или println(), а при использовании класса PrintWriter существует возможность отказаться от автоматического сброса буферов, выполняя его явным образом при помощи метода flush().<br>Кроме того, методы класса PrintWriter никогда не создают исключений. Для проверки ошибок необходимо явно вызвать метод checkError().<br>"
}
,{
  question: "Чем отличаются и что общего у InputStream, OutputStream, Reader, Writer?",
  answer: "InputStream и его наследники - совокупность для получения байтовых данных из различных источников;<br>OutputStream и его наследники - набор классов, определяющих потоковый байтовый вывод;<br>Reader и его наследники определяют потоковый ввод символов Unicode;<br>Writer и его наследники определяют потоковый вывод символов Unicode.<br>"
}
,{
  question: "Какие классы позволяют преобразовать байтовые потоки в символьные и обратно?",
  answer: "OutputStreamWriter — «мост» между классом OutputStream и классом Writer. Символы, записанные в поток, преобразовываются в байты.<br>InputStreamReader — аналог для чтения. При помощи методов класса Reader читаются байты из потока InputStream и далее преобразуются в символы<br>"
}
,{
  question: "Какие классы позволяют ускорить чтение/запись за счет использования буфера?",
  answer: "BufferedInputStream(InputStream in)/BufferedInputStream(InputStream in, int size),<br>BufferedOutputStream(OutputStream out)/BufferedOutputStream(OutputStream out, int size),<br>BufferedReader(Reader r)/BufferedReader(Reader in, int sz),<br>BufferedWriter(Writer out)/BufferedWriter(Writer out, int sz)<br>"
}
,{
  question: "Какой класс предназначен для работы с элементами файловой системы?",
  answer: "File работает непосредственно с файлами и каталогами. Данный класс позволяет создавать новые элементы и получать информацию существующих: размер, права доступа, время и дату создания, путь к родительскому каталогу."
}
,{
  question: "Какие методы класса File вы знаете?",
  answer: "Наиболее используемые методы класса File:<br>boolean createNewFile(): делает попытку создать новый файл;<br>boolean delete(): делает попытку удалить каталог или файл;<br>boolean mkdir(): делает попытку создать новый каталог;<br>boolean renameTo(File dest): делает попытку переименовать файл или каталог;<br>boolean exists(): проверяет, существует ли файл или каталог;<br>String getAbsolutePath(): возвращает абсолютный путь для пути, переданного в конструктор объекта;<br>String getName(): возвращает краткое имя файла или каталога;<br>String getParent(): возвращает имя родительского каталога;<br>boolean isDirectory(): возвращает значение true, если по указанному пути располагается каталог;<br>boolean isFile(): возвращает значение true, если по указанному пути находится файл;<br>boolean isHidden(): возвращает значение true, если каталог или файл являются скрытыми;<br>long length(): возвращает размер файла в байтах;<br>long lastModified(): возвращает время последнего изменения файла или каталога;<br>String[] list(): возвращает массив файлов и подкаталогов, которые находятся в определенном каталоге;<br>File[] listFiles(): возвращает массив файлов и подкаталогов, которые находятся в определенном каталоге.<br>"
}
,{
  question: "Что вы знаете об интерфейсе FileFilter?",
  answer: "Интерфейс FileFilter применяется для проверки, попадает ли объект File под некоторое условие. Этот интерфейс содержит единственный метод boolean accept(File pathName). Этот метод необходимо переопределить и реализовать. Например:public boolean accept(final File file) { return file.isExists() && file.isDirectory(); }"
}
,{
  question: "Как выбрать все элементы определенного каталога по критерию (например, с определенным расширением)?",
  answer: "Метод File.listFiles() возвращает массив объектов File, содержащихся в каталоге. Метод может принимать в качестве параметра объект класса, реализующего FileFilter. Это позволяет включить в список только те элементы, для которых метод accept возвращает true (критерием может быть длина имени файла или его расширение)."
}
,{
  question: "Что вы знаете о RandomAccessFile?",
  answer: "Класс java.io.RandomAccessFile обеспечивает чтение и запись данных в произвольном месте файла. Он не является частью иерархии InputStream или OutputStream. Это полностью отдельный класс, имеющий свои собственные (в большинстве своем native) методы. Объяснением этого может быть то, что RandomAccessFile имеет во многом отличающееся поведение по сравнению с остальными классами ввода/вывода так как позволяет, в пределах файла, перемещаться вперед и назад.RandomAccessFile имеет такие специфические методы как:<br>- getFilePointer() для определения текущего местоположения в файле;<br>- seek() для перемещения на новую позицию в файле;<br>- length() для выяснения размера файла;<br>- setLength() для установки размера файла;<br>- skipBytes() для того, чтобы попытаться пропустить определённое число байт;<br>- getChannel() для работы с уникальным файловым каналом, ассоциированным с заданным файлом;<br>- методы для выполнения обычного и форматированного вывода из файла (read(), readInt(), readLine(), readUTF() и т.п.);<br>- методы для обычной или форматированной записи в файл с прямым доступом (write(), writeBoolean(), writeByte() и т.п.).Так же следует отметить, что конструкторы RandomAccessFile требуют второй аргумент, указывающий необходимый режим доступа к файлу - только чтение ('r'), чтение и запись ('rw') или иную их разновидность."
}
,{
  question: "Какие режимы доступа к файлу есть у RandomAccessFile?",
  answer: "'r' открывает файл только для чтения. Запуск любых методов записи данных приведет к выбросу исключения IOException.<br>'rw' открывает файл для чтения и записи. Если файл еще не создан, то осуществляется попытка создать его.<br>'rws' открывает файл для чтения и записи подобно 'rw', но требует от системы при каждом изменении содержимого файла или метаданных синхронно записывать эти изменения на физический носитель.<br>'rwd' открывает файл для чтения и записи подобно 'rws', но требует от системы синхронно записывать изменения на физический носитель только при каждом изменении содержимого файла. Если изменяются метаданные, синхронная запись не требуется.<br>"
}
,{
  question: "Какие классы поддерживают чтение и запись потоков в компрессированном формате?",
  answer: "DeflaterOutputStream - компрессия данных в формате deflate.<br>Deflater - компрессия данных в формат ZLIB<br>ZipOutputStream - потомок DeflaterOutputStream для компрессии данных в формат Zip.<br>GZIPOutputStream - потомок DeflaterOutputStream для компрессии данных в формат GZIP.<br>InflaterInputStream - декомпрессия данных в формате deflate.<br>Inflater - декомпрессия данных в формате ZLIB<br>ZipInputStream - потомок InflaterInputStream для декомпрессии данных в формате Zip.<br>GZIPInputStream - потомок InflaterInputStream для декомпрессии данных в формате GZIP.<br>"
}
,{
  question: "Существует ли возможность перенаправить потоки стандартного ввода/вывода?",
  answer: "Класс System позволяет вам перенаправлять стандартный ввод, вывод и поток вывода ошибок, используя простой вызов статического метода:<br>setIn(InputStream) - для ввода;<br>setOut(PrintStream) - для вывода;<br>setErr(PrintStream) - для вывода ошибок.<br>"
}
,{
  question: "Какой символ является разделителем при указании пути в файловой системе?",
  answer: "Для различных операционных систем символ разделителя различается. Для Windows это \, для Linux - /.<br>В Java получить разделитель для текущей операционной системы можно через обращение к статическому полю File.separator.<br>"
}
,{
  question: "Что такое «абсолютный путь» и «относительный путь»?",
  answer: "Абсолютный (полный) путь — это путь, который указывает на одно и то же место в файловой системе, вне зависимости от текущей рабочей директории или других обстоятельств. Полный путь всегда начинается с корневого каталога.<br>Относительный путь представляет собой путь по отношению к текущему рабочему каталогу пользователя или активного приложения.<br>"
}
,{
  question: "Что такое «символьная ссылка»?",
  answer: "Символьная (символическая) ссылка (также «симлинк», Symbolic link) — специальный файл в файловой системе, в котором, вместо пользовательских данных, содержится путь к файлу, который должен быть открыт при попытке обратиться к данной ссылке (файлу). Целью ссылки может быть любой объект: например, другая ссылка, файл, каталог или даже несуществующий файл (в последнем случае, при попытке открыть его, должно выдаваться сообщение об отсутствии файла).<br>Символьные ссылки используются для более удобной организации структуры файлов на компьютере, так как:<br>- позволяют для одного файла или каталога иметь несколько имён и различных атрибутов;<br>- свободны от некоторых ограничений, присущих жёстким ссылкам (последние действуют только в пределах одной файловой системы (одного раздела) и не могут ссылаться на каталоги).<br>"
}
,
    ];

    const questionText = document.getElementById('question-text');
    const answerText = document.getElementById('answer-text');
    const modal = document.getElementById('modal');
    const modalAnswer = document.getElementById('modal-answer');

    function toggleAnswer() {
        const answer = questions[currentQuestionIndex].answer;
        if (answer.length > MAX_ANSWER_LENGTH) {
            showModal(answer);
        } else {
            if (answerText.classList.contains('hidden')) {
                answerText.innerHTML = answer;
                answerText.classList.remove('hidden');
                questionText.classList.add('hidden');
            } else {
                answerText.classList.add('hidden');
                questionText.classList.remove('hidden');
            }
        }
    }

    function showModal(answer) {
        modalAnswer.innerHTML = answer;
        modal.classList.remove('hidden');
    }

    function showQuestion(index) {
        questionText.textContent = questions[index].question;
        answerText.innerHTML = ""; // Скрываем ответ при смене вопроса
        questionText.classList.remove('hidden');
        answerText.classList.add('hidden');
    }

    function nextQuestion() {
        if (currentQuestionIndex < questions.length - 1) {
            currentQuestionIndex++;
            showQuestion(currentQuestionIndex);
        }
    }

    function prevQuestion() {
        if (currentQuestionIndex > 0) {
            currentQuestionIndex--;
            showQuestion(currentQuestionIndex);
        }
    }

    function closeModal() {
        modal.classList.add('hidden');
    }

    showQuestion(currentQuestionIndex);
</script>

</body>
</html>
