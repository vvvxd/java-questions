Что такое Поток?
Поток — это поток выполнения программы. JVM позволяет приложению иметь несколько потоков выполнения одновременно (concurrently). В Hotspot JVM существует прямое соответствие между Java потоком и native потоком операционной системы. После подготовки всех компонентов Java потока таких как thread‑local хранилище, allocations буферы, объекты синхронизации, стеки и программные счётчики будет создан native поток. Native поток (операционной системы) освобождается как только Java поток завершается1. Операционная система ответственна за планировку и распределение потоков на любом доступном процессоре. Как только native поток инициализирован он вызывает метод run() в Java потоке. Когда run() метод возвращает значение, обрабатываются неперехваченные исключения, потом native поток подтверждает нужно ли завершить работу JVM (needs to be terminated) после завершения потока (напр. последний non‑daemon thread — main). Когда поток завершается все ресурсы native потока и Java потока освобождаются.
--------------------------------------------------------------------------------------------------------------------

Какие есть Cистемные потоки JVM?
Если использовать jconsole или любой отладчик, то можно увидеть несколько потоков запущенных в фоновом режиме. Эти фоновые потоки запускаются в дополнении к основному потоку, который создаётся как часть вызова
public static void main(String[]) и любого потока созданного основным потоком.

Вот данные в формате таблицы Markdown:

| Вид потока | Описание |
| - | - |
| Потоки виртуальной машины | Ожидают появления операций, которые нужны JVM для достижения безопасной точки (safe-point). Причина, по которой эти операции должны выполняться в отдельном потоке, заключается в том, что все они требуют, чтобы JVM находилась в безопасной точке, где модификации кучи не могут произойти. Тип операций, выполняемых этим потоком сборка мусора "stop-the-world", дамп стека потока, приостановка потока (thread suspension) и biased locking revocation. |
| Поток периодической задачи | Отвечает за события таймера (прерывания), которые используются для планирования выполнения периодических задач. |
| GC | Сборки мусора различного типа, которые появляются в JVM |
| Потоки компилятора | Компилируют байт-код в машинный код при выполнении программы (runtime) |
| Поток диспетчера сигналов (signal dispatcher thread) | Получает сигналы отправленные JVM процессу и обрабатывает их внутри JVM, вызывая соответствующие JVM методы. |

--------------------------------------------------------------------------------------------------------------------
Что такое Программный счётчик (ПС)
Если текущий метод является native методом, тогда ПС не определён, иначе содержит адрес текущей инструкции (или опкод). Все процессоры имеют программный счётчик, обычно ПС инкрементируется после каждой инструкции и, таким образом, хранит адрес следующей инструкции, которая должна быть выполнена. JVM использует ПС для отслеживания того, где она выполняет инструкции, ПС на самом деле будет указывать на адрес памяти в области методов.
--------------------------------------------------------------------------------------------------------------------

Что такое Стек
Каждый поток имеет свой собственный стек, в котором хранится фрейм для каждого метода, выполняющегося в этом потоке. Стек это LIFO (Last In First Out — последний пришел, первый вышел) структура данных, поэтому текущий выполняющийся метод находится на вершине стека. При каждом вызове метода создаётся новый фрейм.

Напрямую стек не модифицируют, кроме как добавления (push) и удаления (pop) объектов фрейма и поэтому объекты фрейма могут быть аллоцированы в куче (Heap) и нет необходимости в том, чтобы память под эти объекты была непрерывной (contiguous).

--------------------------------------------------------------------------------------------------------------------

Что такое Native стек
Не все JVM поддерживают native методы, однако те, которые поддерживают обычно создают native стек на каждый Java поток. Если JVM была реализована используя C‑linkage модель для Java Native Invocation (JNI) тогда native стек будет как в Си. В этом случае порядок аргументов и возвращаемое значение будет точно такие же как и в обычной программе на языке Си. Native метод обычно может (зависит от реализации JVM) вызывать Java метод в JVM. Такой вызов будет происходить на Java стеке. Поток покинет native стек и создаст новый фрейм в Java стеке.
--------------------------------------------------------------------------------------------------------------------

Что такое Ограничения стека
Стек может быть фиксированного или переменного размера. В случае когда поток запрашивает стек большего размера, чем разрешено, то произойдёт ошибка StackOverflowError. Если поток запрашивает новый фрейм, а памяти для его выделения не хватает, тогда произойдёт ошибка OutOfMemoryError.
--------------------------------------------------------------------------------------------------------------------

Что такое Фрейм
Новый фрейм создаётся и добавляется (pushed) на вершину стека при каждом вызове метода. Фрейм удаляется (popped), когда метод штатно завершается, или, если во время выполнения метода возникло необработанное исключение. Более подробная информация по обработке исключений будет дана в Таблице Исключений.

Каждый фрейм содержит:

Массив локальных переменных

Возвращаемое значение

Стек операндов

Ссылку на runtime constant pool для класса текущего метода

--------------------------------------------------------------------------------------------------------------------

Что такое Массив локальных переменных
Массив локальных переменных содержит все переменные, которые нужны при выполнении метода, включая ссылку на this, все параметры метода и другие локальные переменные. Для методов класса (статических методов) параметры метода отсчитываются от нуля, однако для метода экземпляра класса нулевой слот зарезервирован для this.

Локальные переменные могут иметь следующий тип: boolean, byte, char, long, short, int, float, double, ссылка (reference), возвращаемый адрес (returnAddress).

Все типы занимают один слот в массиве локальных переменных, исключая long и double, которые занимают два последовательных слота так как эти типы имеют размер 64 бита, вместо 32 бит.

--------------------------------------------------------------------------------------------------------------------

Что такое Стек операндов
Cтек операндов используется во время выполнения инструкций байт‑кода и работает подобно регистрам общего назначения в процессоре. Большая часть JVM байт‑кода содержит операции со стеком операндов, добавляя (push), удаляя(pop), дублируя, меняя местами (swap) или выполняя операции, которые производят или потребляют значения. Таким образом, инструкции, которые перемещают значения между массивом локальных переменных и стеком операндов очень часто встречаются в байт‑коде. Например, простая инициализация переменной будет представлена в виде двух инструкций байт‑кода, которые взаимодействуют со стеком операндов.

int i; компилируется в следующий байт-код:

0: iconst_0  // добавить 0 на вершину стека операндов
1: istore_1  // считать значение из стека операндов и сохранить как локальную переменную с номером 1.
За более детальным объяснением взаимодействия между массивом локальных переменных, стеком операндов и runtime constant pool обращайтесь к секции Структура Файла Класса ниже.
--------------------------------------------------------------------------------------------------------------------

### Что такое Constant Pool?

**Constant Pool** — это статическая таблица констант, которая создаётся компилятором Java (javac) и хранится в файле `.class` для каждого класса или интерфейса. Она содержит все константы, используемые в коде класса, такие как строковые литералы, числовые значения, ссылки на классы, методы и поля.

- **Где находится**: В `.class`-файле, сразу после заголовка (magic number, версии и т.д.).
- **Формат**: Таблица, где каждая запись имеет:
    - Тег (1 байт), определяющий тип константы.
    - Данные, зависящие от типа.
- **Типы записей**:
    - `CONSTANT_Utf8`: Строки (имена классов, методов, строковые литералы).
    - `CONSTANT_Integer`, `CONSTANT_Float`, `CONSTANT_Long`, `CONSTANT_Double`: Числовые константы.
    - `CONSTANT_Class`: Ссылка на класс.
    - `CONSTANT_String`: Строковый литерал, ссылающийся на `CONSTANT_Utf8`.
    - `CONSTANT_Fieldref`, `CONSTANT_Methodref`, `CONSTANT_InterfaceMethodref`: Ссылки на поля, методы и методы интерфейсов.
    - `CONSTANT_NameAndType`: Пары имя/дескриптор.
    - `CONSTANT_MethodHandle`, `CONSTANT_MethodType`, `CONSTANT_InvokeDynamic` (с Java 7): Для динамических языковых конструкций.
- **Назначение**: Хранит символические ссылки (symbolic references) и константы, которые JVM использует для выполнения программы.
- **Пример**: Для строки `"Hello"` в коде в Constant Pool будет `CONSTANT_String`, ссылающийся на `CONSTANT_Utf8` с содержимым `"Hello"`.

Constant Pool неизменяем и создаётся на этапе компиляции.

---

### Что такое Run-Time Constant Pool?

**Run-Time Constant Pool** — это динамическая структура в памяти JVM, создаваемая на основе Constant Pool при загрузке класса в **Method Area** (или **Metaspace** в Java 8+). Она используется во время выполнения программы и может изменяться.

- **Где находится**: В памяти JVM, в Metaspace.
- **Создание**: Формируется при загрузке класса загрузчиком классов (ClassLoader) на основе Constant Pool из `.class`-файла.
- **Особенности**:
    - **Динамическое разрешение ссылок**: Символические ссылки (например, `CONSTANT_Methodref`) преобразуются в прямые ссылки на объекты, методы или поля в памяти. Этот процесс называется **resolution**.
    - **Интернирование строк**: Строковые литералы из `CONSTANT_String` помещаются в **String Pool** (часть Run-Time Constant Pool), что позволяет экономить память.
    - **Поддержка динамических конструкций**: Содержит данные для `invokedynamic` (например, для lambda-выражений).
- **Назначение**:
    - Предоставляет JVM быстрый доступ к константам.
    - Обеспечивает динамическое связывание (dynamic linking) классов, методов и полей.
    - Хранит интернированные строки и разрешённые ссылки.
- **Пример**: Если в коде есть вызов метода `System.out.println`, Run-Time Constant Pool сначала содержит символическую ссылку на `println`, а после разрешения — прямой адрес метода в памяти.

---
--------------------------------------------------------------------------------------------------------------------

Расскажите о модели памяти Java?

Модель памяти Java (Java Memory Model, JMM) описывает поведение потоков в среде исполнения Java. Это часть семантики языка Java, набор правил, описывающий выполнение многопоточных программ и правил, по которым потоки могут взаимодействовать друг с другом посредством основной памяти.
Формально модель памяти определяет набор действий межпоточного взаимодействия (эти действия включают в себя, в частности, чтение и запись переменной, захват и освобождений монитора, чтение и запись volatile переменной, запуск нового потока), а также модель памяти определяет отношение между этими действиями -happens-before - абстракции обозначающей, что если операция X связана отношением happens-before с операцией Y, то весь код следуемый за операцией Y, выполняемый в одном потоке, видит все изменения, сделанные другим потоком, до операции X.

Существует несколько основных правил для отношения happens-before:

В рамках одного потока любая операция happens-before любой операцией, следующей за ней в исходном коде;

Освобождение монитора (unlock) happens-before захват того же монитора (lock);

Выход из synchronized блока/метода happens-before вход в synchronized блок/метод на том же мониторе;

Запись volatile поля happens-before чтение того же самого volatile поля;

Завершение метода run() экземпляра класса Thread happens-before выход из метода join() или возвращение false методом isAlive() экземпляром того же потока;

Вызов метода start() экземпляра класса Thread happens-before начало метода run() экземпляра того же потока;

Завершение конструктора happens-before начало метода finalize() этого класса;

Вызов метода interrupt() на потоке happens-before обнаружению потоком факта, что данный метод был вызван либо путем выбрасывания исключения InterruptedException, либо с помощью методов isInterrupted() или interrupted().
Связь happens-before транзитивна, т.е. если X happens-before Y, а Y happens-before Z, то X happens-before Z.
Освобождение/захват монитора и запись/чтение в volatile переменную связаны отношением happens-before, только если операции проводятся над одним и тем же экземпляром объекта.
В отношении happens-before участвуют только два потока, о поведении остальных потоков ничего сказать нельзя, пока в каждом из них не наступит отношение happens-before с другим потоком.
Можно выделить несколько основных областей, имеющих отношение к модели памяти:
Видимость (visibility). Один поток может в какой-то момент временно сохранить значение некоторых полей не в основную память, а в регистры или локальный кэш процессора, таким образом второй поток, выполняемый на другом процессоре, читая из основной памяти, может не увидеть последних изменений поля. И наоборот, если поток на протяжении какого-то времени работает с регистрами и локальными кэшами, читая данные оттуда, он может сразу не увидеть изменений, сделанных другим потоком в основную память.
К вопросу видимости имеют отношение следующие ключевые слов языка Java: synchronized, volatile, final.
С точки зрения Java все переменные (за исключением локальных переменных, объявленных внутри метода) хранятся в главной памяти, которая доступна всем потокам, кроме этого, каждый поток имеет локальную—рабочую—память, где он хранит копии переменных, с которыми он работает, и при выполнении программы поток работает только с этими копиями. Надо отметить, что это описание не требование к реализации, а всего лишь модель, которая объясняет поведение программы, так, в качестве локальной памяти не обязательно выступает кэш память, это могут быть регистры процессора или потоки могут вообще не иметь локальной памяти.
При входе в synchronized метод или блок поток обновляет содержимое локальной памяти, а при выходе из synchronized метода или блока поток записывает изменения, сделанные в локальной памяти, в главную. Такое поведение synchronized методов и блоков следует из правил для отношения «происходит раньше»: так как все операции с памятью происходят раньше освобождения монитора и освобождение монитора происходит раньше захвата монитора, то все операции с памятью, которые были сделаны потоком до выхода из synchronized блока должны быть видны любому потоку, который входит в synchronized блок для того же самого монитора. Очень важно, что это правило работает только в том случае, если потоки синхронизируются, используя один и тот же монитор!
Что касается volatile переменных, то запись таких переменных производится в основную память, минуя локальную. и чтение volatile переменной производится также из основной памяти, то есть значение переменной не может сохраняться в регистрах или локальной памяти потока и операция чтения этой переменной гарантированно вернёт последнее записанное в неё значение.
Также модель памяти определяет дополнительную семантику ключевого слова final, имеющую отношение к видимости: после того как объект был корректно создан, любой поток может видеть значения его final полей без дополнительной синхронизации. «Корректно создан» означает, что ссылка на создающийся объект не должна использоваться до тех пор, пока не завершился конструктор объекта. Наличие такой семантики для ключевого слова final позволяет создание неизменяемых (immutable) объектов, содержащих только final поля, такие объекты могут свободно передаваться между потоками без обеспечения синхронизации при передаче.
Есть одна проблема, связанная с final полями: реализация разрешает менять значения таких полей после создания объекта (это может быть сделано, например, с использованием механизма reflection). Если значение final поля—константа, чьё значение известно на момент компиляции, изменения такого поля могут не иметь эффекта, так-как обращения к этой переменной могли быть заменены компилятором на константу. Также спецификация разрешает другие оптимизации, связанные с final полями, например, операции чтения final переменной могут быть переупорядочены с операциями, которые потенциально могут изменить такую переменную. Так что рекомендуется изменять final поля объекта только внутри конструктора, в противном случае поведение не специфицировано.
Reordering (переупорядочивание). Для увеличения производительности процессор/компилятор могут переставлять местами некоторые инструкции/операции. Вернее, с точки зрения потока, наблюдающего за выполнением операций в другом потоке, операции могут быть выполнены не в том порядке, в котором они идут в исходном коде. Тот же эффект может наблюдаться, когда один поток кладет результаты первой операции в регистр или локальный кэш, а результат второй операции попадает непосредственно в основную память. Тогда второй поток, обращаясь к основной памяти может сначала увидеть результат второй операции, и только потом первой, когда все регистры или кэши синхронизируются с основной памятью. Еще одна причина reordering, может заключаться в том, что процессор может решить поменять порядок выполнения операций, если, например, сочтет что такая последовательность выполнится быстрее.
Вопрос reordering также регулируется набором правил для отношения «происходит раньше» и у этих правил есть следствие, касающееся порядка операций, используемое на практике: операции чтения и записи volatile переменных не могут быть переупорядочены с операциями чтения и записи других volatile и не-volatile переменных. Это следствие делает возможным использование volatile переменной как флага, сигнализирующем об окончании какого-либо действия. В остальном правила, касающиеся порядка выполнения операций, гарантируют упорядоченность операций для конкретного набора случаев (таких как, например, захват и освобождение монитора), во всех остальных случаях оставляя компилятору и процессору полную свободу для оптимизаций.
--------------------------------------------------------------------------------------------------------------------
Что такое «потокобезопасность»?

Потокобезопасность - свойство объекта или кода, которое гарантирует, что при исполнении или использовании несколькими потоками, код будет вести себя, как предполагается. Например потокобезопасный счётчик не пропустит ни один счёт, даже если один и тот же экземпляр этого счётчика будет использоваться несколькими потоками.

--------------------------------------------------------------------------------------------------------------------
В чём разница между «конкуренцией» и «параллелизмом»?

Конкуренция — это способ одновременного решения множества задач.
Признаки:
Наличие нескольких потоков управления (например, Thread в Java, корутина в Kotlin), если поток управления один, то конкурентного выполнения быть не может
Недетерминированный результат выполнения. Результат зависит от случайных событий, реализации и того, как была проведена синхронизация. Даже если каждый поток полностью детерминированный, итоговый результат будет недетерминированным

Параллелизм — это способ выполнения разных частей одной задачи.
Признаки:
Необязательно имеет несколько потоков управления
Может приводить к детерминированному результату, так, например, результат умножения каждого элемента массива на число, не изменится, если умножать его по частям параллельно.
--------------------------------------------------------------------------------------------------------------------
Что такое «кооперативная многозадачность»? Какой тип многозадачности использует Java? Чем обусловлен этот выбор?

Кооперативная многозадачность - это способ деления процессорного времени между потоками, при котором каждый поток обязан отдавать управление следующему добровольно.
Преимущества такого подхода - простота реализации, меньшие накладные расходы на переключение контекста.
Недостатки - если один поток завис или ведет себя некорректно, то зависает целиком вся система и другие потоки никогда не получат управление.
Java использует вытесняющую многозадачность, при которой решение о переключении между потоками процесса принимает операционная система.
В отличие от кооперативной многозадачности управление операционной системе передаётся вне зависимости от состояния работающих приложений, благодаря чему, отдельные зависшие потоки процесса, как правило, не «подвешивают» всю систему целиком. За счёт регулярного переключения между задачами также улучшается отзывчивость приложения и повышается оперативность освобождения ресурсов, которые больше не используются.
В реализации вытесняющая многозадачность отличается от кооперативной, в частности, тем, что требует обработки системного прерывания от аппаратного таймера.
--------------------------------------------------------------------------------------------------------------------
Что такое ordering, as-if-serial semantics, sequential consistency, visibility, atomicity, happens-before, mutual exclusion, safe publication?

ordering механизм, который определяет, когда один поток может увидеть out-of-order (неверный) порядок исполнения инструкций другого потока. CPU для для повышения производительности может переупорядочивать процессорные инструкции и выполнять их в произвольном порядке до тех пор пока для потока внутри не будет видно никаких отличий. Гарантия, предоставляемая этим механизмом, называется as-if-serial semantics.

sequential consistency - то же что и as-if-serial semantics, гарантия того, что в рамках одного потока побочные эффекты от всех операций будут такие, как будто все операции выполняются последовательно.
visibility определяет, когда действия в одном потоке становятся видны из другого потока.

happens-before - логическое ограничение на порядок выполнения инструкций программы. Если указывается, что запись в переменную и последующее ее чтение связаны через эту зависимость, то как бы при выполнении не переупорядочивались инструкции, в момент чтения все связанные с процессом записи результаты уже зафиксированы и видны.

atomicity — атомарность операций. Атомарная операция выглядит единой и неделимой командой процессора, которая может быть или уже выполненной или ещё невыполненной.

mutual exclusion (взаимоисключающая блокировка, семафор с одним состоянием) - механизм, гарантирующий потоку исключительный доступ к ресурсу. Используется для предотвращения одновременного доступа к общему ресурсу. В каждый момент времени таким ресурсом может владеть только один поток. Простейший пример:
synchronized(obj) { ... }.
safe publication? - показ объектов другим потокам из текущего, не нарушая ограничений visibility. Способы такой публикации в Java:
static{} инициализатор;
volatile переменные;
atomic переменные;
сохранение в разделяемой переменной, корректно защищенной с использованием synchronized(), синхронизаторов или других конструкций, создающих read/write memory barrier;
final переменные в разделяемом объекте, который был корректно проинициализирован.
--------------------------------------------------------------------------------------------------------------------
Чем отличается процесс от потока?

Процесс — экземпляр программы во время выполнения, независимый объект, которому выделены системные ресурсы (например, процессорное время и память). Каждый процесс выполняется в отдельном адресном пространстве: один процесс не может получить доступ к переменным и структурам данных другого. Если процесс хочет получить доступ к чужим ресурсам, необходимо использовать межпроцессное взаимодействие. Это могут быть конвейеры, файлы, каналы связи между компьютерами и многое другое.
Для каждого процесса ОС создает так называемое «виртуальное адресное пространство», к которому процесс имеет прямой доступ. Это пространство принадлежит процессу, содержит только его данные и находится в полном его распоряжении. Операционная система же отвечает за то, как виртуальное пространство процесса проецируется на физическую память.
Поток(thread) — определенный способ выполнения процесса, определяющий последовательность исполнения кода в процессе. Потоки всегда создаются в контексте какого-либо процесса, и вся их жизнь проходит только в его границах. Потоки могут исполнять один и тот же код и манипулировать одними и теми же данными, а также совместно использовать описатели объектов ядра, поскольку таблица описателей создается не в отдельных потоках, а в процессах. Так как потоки расходуют существенно меньше ресурсов, чем процессы, в процессе выполнения работы выгоднее создавать дополнительные потоки и избегать создания новых процессов.
--------------------------------------------------------------------------------------------------------------------
Что такое «зелёные потоки» и есть ли они в Java?

Зелёные (легковесные) потоки(green threads) - потоки эмулируемые виртуальной машиной или средой исполнения. Создание зелёного потока не подразумевает под собой создание реального потока ОС.
Виртуальная машина Java берёт на себя заботу о переключении между разными green threads, а сама машина работает как один поток ОС. Это даёт несколько преимуществ. Потоки ОС относительно дороги в большинстве POSIX-систем. Кроме того, переключение между native threads гораздо медленнее, чем между green threads.
Это всё означает, что в некоторых ситуациях green threads гораздо выгоднее, чем native threads. Система может поддерживать гораздо большее количество green threads, чем потоков OС. Например, гораздо практичнее запускать новый green thread для нового HTTP-соединения к веб-серверу, вместо создания нового native thread.
Однако есть и недостатки. Самый большой заключается в том, что вы не можете исполнять два потока одновременно. Поскольку существует только один native thread, только он и вызывается планировщиком ОС. Даже если у вас несколько процессоров и несколько green threads, только один процессор может вызывать green thread. И всё потому, что с точки зрения планировщика заданий ОС всё это выглядит одним потоком.
Начиная с версии 1.2 Java поддерживает native threads, и с тех пор они используются по умолчанию.
--------------------------------------------------------------------------------------------------------------------
Каким образом можно создать поток?

Создать потомка класса Thread и переопределить его метод run();

Создать объект класса Thread, передав ему в конструкторе экземпляр класса, реализующего интерфейс Runnable. Эти интерфейс содержит метод run(), который будет выполняться в новом потоке. Поток закончит выполнение, когда завершится его метод run().

Вызвать метод submit() у экземпляра класса реализующего интерфейс ExecutorService, передав ему в качестве параметра экземпляр класса реализующего интерфейс Runnable или Callable (содержит метод call(), в котором описывается логика выполнения).

--------------------------------------------------------------------------------------------------------------------
Чем различаются Thread и Runnable?

Thread - это класс, некоторая надстройка над физическим потоком.
Runnable - это интерфейс, представляющий абстракцию над выполняемой задачей.
Помимо того, что Runnable помогает разрешить проблему множественного наследования, несомненный плюс от его использования состоит в том, что он позволяет логически отделить логику выполнения задачи от непосредственного управления потоком.
--------------------------------------------------------------------------------------------------------------------
В чём заключается разница между методами start() и run()?

Несмотря на то, что start() вызывает метод run() внутри себя, это не то же самое, что просто вызов run(). Если run() вызывается как обычный метод, то он вызывается в том же потоке и никакой новый поток не запускается, как это происходит, в случае, когда вы вызываете метод start().

--------------------------------------------------------------------------------------------------------------------
Как принудительно запустить поток?

Никак. В Java не существует абсолютно никакого способа принудительного запуска потока. Это контролируется JVM и Java не предоставляет никакого API для управления этим процессом.

--------------------------------------------------------------------------------------------------------------------
Что такое «монитор» в Java?

Монитор, мьютекс (mutex) - это средство обеспечения контроля за доступом к ресурсу. У монитора может быть максимум один владелец в каждый текущий момент времени. Следовательно, если кто-то использует ресурс и захватил монитор для обеспечения единоличного доступа, то другой, желающий использовать тот же ресурс, должен подождать освобождения монитора, захватить его и только потом начать использовать ресурс.
Удобно представлять монитор как id захватившего его объекта. Если этот id равен 0 - ресурс свободен. Если не 0 - ресурс занят. Можно встать в очередь и ждать его освобождения.
В Java у каждого экземпляра объекта есть монитор, который контролируется непосредственно виртуальной машиной. Используется он так: любой нестатический synchronized-метод при своем вызове прежде всего пытается захватить монитор того объекта, у которого он вызван (на который он может сослаться как на this). Если это удалось - метод исполняется. Если нет - поток останавливается и ждет, пока монитор будет отпущен.
--------------------------------------------------------------------------------------------------------------------
Как работает synchronized для статического метода?

Если метод, в котором содержится критически важная «многопоточная» логика, статический, синхронизация будет осуществляться по классу.

--------------------------------------------------------------------------------------------------------------------
Дайте определение понятию «синхронизация».

Синхронизация - это процесс, который позволяет выполнять потоки параллельно.
В Java все объекты имеют одну блокировку, благодаря которой только один поток одновременно может получить доступ к критическому коду в объекте. Такая синхронизация помогает предотвратить повреждение состояния объекта. Если поток получил блокировку, ни один другой поток не может войти в синхронизированный код, пока блокировка не будет снята. Когда поток, владеющий блокировкой, выходит из синхронизированного кода, блокировка снимается. Теперь другой поток может получить блокировку объекта и выполнить синхронизированный код. Если поток пытается получить блокировку объекта, когда другой поток владеет блокировкой, поток переходит в состояние Блокировки до тех пор, пока блокировка не снимется.
--------------------------------------------------------------------------------------------------------------------
Какие существуют способы синхронизации в Java?

Системная синхронизация с использованием wait()/notify(). Поток, который ждет выполнения каких-либо условий, вызывает у этого объекта метод wait(), предварительно захватив его монитор. На этом его работа приостанавливается. Другой поток может вызвать на этом же самом объекте метод notify() (опять же, предварительно захватив монитор объекта), в результате чего, ждущий на объекте поток «просыпается» и продолжает свое выполнение. В обоих случаях монитор надо захватывать в явном виде, через synchronized-блок, потому как методы wait()/notify() не синхронизированы!

Системная синхронизация с использованием join(). Метод join(), вызванный у экземпляра класса Thread, позволяет текущему потоку остановиться до того момента, как поток, связанный с этим экземпляром, закончит работу.

Использование классов из пакета java.util.concurrent, который предоставляет набор классов для организации межпоточного взаимодействия. Примеры таких классов - Lock, Semaphore и пр.. Концепция данного подхода заключается в использовании атомарных операций и переменных.

--------------------------------------------------------------------------------------------------------------------
В каких состояниях может находиться поток?

Потоки могут находиться в одном из следующих состояний:
Новый (New). После создания экземпляра потока, он находится в состоянии Новый до тех пор, пока не вызван метод start(). В этом состоянии поток не считается живым.

Работоспособный
(Runnable). Поток переходит в состояние Работоспособный, когда вызывается метод start(). Поток может перейти в это состояние также из состояния

Работающий или из состояния Блокирован. Когда поток находится в этом состоянии, он считается живым.
Работающий (Running). Поток переходит из состояния Работоспособный в состояние Работающий, когда Планировщик потоков выбирает его как работающий в данный момент.

Живой, но не работоспособный (Alive, but not runnable). Поток может быть живым, но не работоспособным по нескольким причинам:Ожидание (Waiting). Поток переходит в состояние Ожидания, вызывая метод wait(). Вызов notify() или notifyAll() может перевести поток из состояния Ожидания в состояние Работоспособный.Сон (Sleeping). Метод sleep() переводит поток в состояние Сна на заданный промежуток времени в миллисекундах.Блокировка (Blocked). Поток может перейти в это состояние, в ожидании ресурса, такого как ввод/вывод или из-за блокировки другого объекта. В этом случае поток переходит в состояние Работоспособный, когда ресурс становится доступен.Мёртвый (Dead). Поток считается мёртвым, когда его метод run() полностью выполнен. Мёртвый поток не может перейти ни в какое другое состояние, даже если для него вызван метод start().

--------------------------------------------------------------------------------------------------------------------
Можно ли создавать новые экземпляры класса, пока выполняется static synchronized метод?

Да, можно создавать новые экземпляры класса, так как статические поля не принадлежат к экземплярам класса.

--------------------------------------------------------------------------------------------------------------------
Зачем может быть нужен private мьютекс?

Объект для синхронизации делается private, чтобы сторонний код не мог на него синхронизироваться и случайно получить взаимную блокировку.

--------------------------------------------------------------------------------------------------------------------
Как работают методы wait() и notify()/notifyAll()?

Эти методы определены у класса Object и предназначены для взаимодействия потоков между собой при межпоточной синхронизации.
wait(): освобождает монитор и переводит вызывающий поток в состояние ожидания до тех пор, пока другой поток не вызовет метод notify()/notifyAll();
notify(): продолжает работу потока, у которого ранее был вызван метод wait();
notifyAll(): возобновляет работу всех потоков, у которых ранее был вызван метод wait().
Когда вызван метод wait(), поток освобождает блокировку на объекте и переходит из состояния Работающий (Running) в состояние Ожидания (Waiting). Метод notify() подаёт сигнал одному из потоков, ожидающих на объекте, чтобы перейти в состояние Работоспособный (Runnable). При этом невозможно определить, какой из ожидающих потоков должен стать работоспособным. Метод notifyAll() заставляет все ожидающие потоки для объекта вернуться в состояние Работоспособный (Runnable). Если ни один поток не находится в ожидании на методе wait(), то при вызове notify() или notifyAll() ничего не происходит.
Поток может вызвать методы wait() или notify() для определённого объекта, только если он в данный момент имеет блокировку на этот объект. wait(), notify() и notifyAll() должны вызываться только из синхронизированного кода.
--------------------------------------------------------------------------------------------------------------------
В чем разница между notify() и notifyAll()?

Дело в том, что «висеть» на методе wait() одного монитора могут сразу несколько потоков. При вызове notify() только один из них выходит из wait() и пытается захватить монитор, а затем продолжает работу со следующего после wait() оператора. Какой из них выйдет - заранее неизвестно. А при вызове notifyAll(), все висящие на wait() потоки выходят из wait(), и все они пытаются захватить монитор. Понятно, что в любой момент времени монитор может быть захвачен только одним потоком, а остальные ждут своей очереди. Порядок очереди определяется планировщиком потоков Java.

--------------------------------------------------------------------------------------------------------------------
Почему методы wait() и notify() вызываются только в синхронизированном блоке?

Монитор надо захватывать в явном виде (через synchronized-блок), потому что методы wait() и notify() не синхронизированы.

--------------------------------------------------------------------------------------------------------------------
Чем отличается работа метода wait() с параметром и без параметра?

wait()
без параметров освобождает монитор и переводит вызывающий поток в состояние ожидания до тех пор, пока другой поток не вызовет метод notify()/notifyAll(),
с параметрами заставит поток ожидать заданное количество времени или вызова notify()/notifyAll().
--------------------------------------------------------------------------------------------------------------------
Чем отличаются методы Thread.sleep() и Thread.yield()?

Метод yield() служит причиной того, что поток переходит из состояния работающий (running) в состояние работоспособный (runnable), давая возможность другим потокам активизироваться. Но следующий выбранный для запуска поток может и не быть другим.
Метод sleep() вызывает засыпание текущего потока на заданное время, состояние изменяется с работающий (running) на ожидающий (waiting).
--------------------------------------------------------------------------------------------------------------------
Как работает метод Thread.join()?

Когда поток вызывает join() для другого потока, текущий работающий поток будет ждать, пока другой поток, к которому он присоединяется, не будет завершён:
void join()
void join(long millis)
void join(long millis, int nanos)
--------------------------------------------------------------------------------------------------------------------
Что такое deadlock?

Взаимная блокировка (deadlock) - явление, при котором все потоки находятся в режиме ожидания. Происходит, когда достигаются состояния:
взаимного исключения: по крайней мере один ресурс занят в режиме неделимости и, следовательно, только один поток может использовать ресурс в любой данный момент времени.
удержания и ожидания: поток удерживает как минимум один ресурс и запрашивает дополнительные ресурсов, которые удерживаются другими потоками.
отсутствия предочистки: операционная система не переназначивает ресурсы: если они уже заняты, они должны отдаваться удерживающим потокам сразу же.
цикличного ожидания: поток ждёт освобождения ресурса, другим потоком, который в свою очередь ждёт освобождения ресурса заблокированного первым потоком.
Простейший способ избежать взаимной блокировки - не допускать цикличного ожидания. Этого можно достичь, получая мониторы разделяемых ресурсов в определённом порядке и освобождая их в обратном порядке.
--------------------------------------------------------------------------------------------------------------------
Что такое livelock?

livelock - тип взаимной блокировки, при котором несколько потоков выполняют бесполезную работу, попадая в зацикленность при попытке получения каких-либо ресурсов. При этом их состояния постоянно изменяются в зависимости друг от друга. Фактической ошибки не возникает, но КПД системы падает до 0. Часто возникает в результате попыток предотвращения deadlock.
Реальный пример livelock, - когда два человека встречаются в узком коридоре и каждый, пытаясь быть вежливым, отходит в сторону, и так они бесконечно двигаются из стороны в сторону, абсолютно не продвигаясь в нужном им направлении.
--------------------------------------------------------------------------------------------------------------------
Как проверить, удерживает ли поток монитор определённого ресурса?

Метод Thread.holdsLock(lock) возвращает true, когда текущий поток удерживает монитор у определённого объекта.

--------------------------------------------------------------------------------------------------------------------
На каком объекте происходит синхронизация при вызове static synchronized метода?

У синхронизированного статического метода нет доступа к this, но есть доступ к объекту класса Class, он присутствует в единственном экземпляре и именно он выступает в качестве монитора для синхронизации статических методов. Таким образом, следующая конструкция:
public class SomeClass { public static synchronized void someMethod() { //code } }
эквивалентна такой:
public class SomeClass { public static void someMethod(){ synchronized(SomeClass.class){ //code } } }
--------------------------------------------------------------------------------------------------------------------
Для чего используется ключевое слово volatile, synchronized, transient, native?

volatile - этот модификатор вынуждает потоки отключить оптимизацию доступа и использовать единственный экземпляр переменной. Если переменная примитивного типа - этого будет достаточно для обеспечения потокобезопасности. Если же переменная является ссылкой на объект - синхронизировано будет исключительно значение этой ссылки. Все же данные, содержащиеся в объекте, синхронизированы не будут!
synchronized - это зарезервированное слово позволяет добиваться синхронизации в помеченных им методах или блоках кода.
Ключевые слова transient и native к многопоточности никакого отношения не имеют, первое используется для указания полей класса, которые не нужно сериализовать, а второе - сигнализирует о том, что метод реализован в платформо-зависимом коде.
--------------------------------------------------------------------------------------------------------------------
В чём различия между volatile и Atomic переменными?

volatile принуждает использовать единственный экземпляр переменной, но не гарантирует атомарность. Например, операция count++ не станет атомарной просто потому, что count объявлена volatile. C другой стороны class AtomicInteger предоставляет атомарный метод для выполнения таких комплексных операций атомарно, например getAndIncrement() - атомарная замена оператора инкремента, его можно использовать, чтобы атомарно увеличить текущее значение на один. Похожим образом сконструированы атомарные версии и для других типов данных.

--------------------------------------------------------------------------------------------------------------------
В чём заключаются различия между java.util.concurrent.Atomic*.compareAndSwap() и java.util.concurrent.Atomic*.weakCompareAndSwap()

weakCompareAndSwap() не создает memory barrier и не дает гарантии happens-before;
weakCompareAndSwap() сильно зависит от кэша/CPU, и может возвращать false без видимых причин;
weakCompareAndSwap(), более легкая, но поддерживаемая далеко не всеми архитектурами и не всегда эффективная операция.
--------------------------------------------------------------------------------------------------------------------
Что значит «приоритет потока»?

Приоритеты потоков используются планировщиком потоков для принятия решений о том, когда какому из потоков будет разрешено работать. Теоретически высокоприоритетные потоки получают больше времени процессора, чем низкоприоритетные. Практически объем времени процессора, который получает поток, часто зависит от нескольких факторов помимо его приоритета.
Чтобы установить приоритет потока, используется метод класса Thread: final void setPriority(int level). Значение level изменяется в пределах от Thread.MIN_PRIORITY = 1 до Thread.MAX_PRIORITY = 10. Приоритет по умолчанию - Thread.NORM_PRlORITY = 5.
Получить текущее значение приоритета потока можно вызвав метод: final int getPriority() у экземпляра класса Thread
--------------------------------------------------------------------------------------------------------------------
Что такое «потоки-демоны»?

Потоки-демоны работают в фоновом режиме вместе с программой, но не являются неотъемлемой частью программы. Если какой-либо процесс может выполняться на фоне работы основных потоков выполнения и его деятельность заключается в обслуживании основных потоков приложения, то такой процесс может быть запущен как поток-демон с помощью метода setDaemon(boolean value), вызванного у потока до его запуска. Метод boolean isDaemon() позволяет определить, является ли указанный поток демоном или нет. Базовое свойство потоков-демонов заключается в возможности основного потока приложения завершить выполнение потока-демона (в отличие от обычных потоков) с окончанием кода метода main(), не обращая внимания на то, что поток-демон еще работает.

--------------------------------------------------------------------------------------------------------------------
Можно ли сделать основной поток программы демоном?

Нет. Потоки-демоны позволяют описывать фоновые процессы, которые нужны только для обслуживания основных потоков выполнения и не могут существовать без них.

--------------------------------------------------------------------------------------------------------------------
Что значит «усыпить» поток?

Это значит приостановить его на определенный промежуток времени, вызвав в ходе его выполнения статический метод Thread.sleep() передав в качестве параметра необходимое количество времени в миллисекундах. До истечения этого времени поток может быть выведен из состояния ожидания вызовом interrupt() с выбрасыванием InterruptedException.

--------------------------------------------------------------------------------------------------------------------
Чем отличаются два интерфейса Runnable и Callable?

Интерфейс Runnable появился в Java 1.0, а интерфейс Callable был введен в Java 5.0 в составе библиотеки java.util.concurrent;
Классы, реализующие интерфейс Runnable для выполнения задачи должны реализовывать метод run(). Классы, реализующие интерфейс Callable - метод call();
Метод Runnable.run() не возвращает никакого значения, Callable.call() возвращает объект Future, который может содержать результат вычислений;
Метод run() не может выбрасывать проверяемые исключения, в то время как метод call() может.
--------------------------------------------------------------------------------------------------------------------
Что такое FutureTask?

FutureTask представляет собой отменяемое асинхронное вычисление в параллельном Java приложении. Этот класс предоставляет базовую реализацию Future, с методами для запуска и остановки вычисления, методами для запроса состояния вычисления и извлечения результатов. Результат может быть получен только когда вычисление завершено, метод получения будет заблокирован, если вычисление ещё не завершено. Объекты FutureTask могут быть использованы для обёртки объектов Callable и Runnable. Так как FutureTask реализует Runnable, его можно передать в Executor на выполнение.

--------------------------------------------------------------------------------------------------------------------
В чем заключаются различия между CyclicBarrier и CountDownLatch?

CountDownLatch (замок с обратным отсчетом) предоставляет возможность любому количеству потоков в блоке кода ожидать до тех пор, пока не завершится определенное количество операций, выполняющихся в других потоках, перед тем как они будут «отпущены», чтобы продолжить свою деятельность. В конструктор CountDownLatch(int count) обязательно передается количество операций, которое должно быть выполнено, чтобы замок «отпустил» заблокированные потоки.
Примером CountDownLatch из жизни может служить сбор экскурсионной группы: пока не наберется определенное количество человек, экскурсия не начнется.
CyclicBarrier реализует шаблон синхронизации «Барьер». Циклический барьер является точкой синхронизации, в которой указанное количество параллельных потоков встречается и блокируется. Как только все потоки прибыли, выполняется опционное действие (или не выполняется, если барьер был инициализирован без него), и, после того, как оно выполнено, барьер ломается и ожидающие потоки «освобождаются». В конструкторы барьера CyclicBarrier(int parties) и CyclicBarrier(int parties, Runnable barrierAction) обязательно передается количество сторон, которые должны «встретиться», и, опционально, действие, которое должно произойти, когда стороны встретились, но перед тем когда они будут «отпущены».
CyclicBarrier является альтернативой метода join(), который «собирает» потоки только после того, как они выполнились.
CyclicBarrier похож на CountDownLatch, но главное различие между ними в том, что использовать «замок» можно лишь единожды - после того, как его счётчик достигнет нуля, а «барьер» можно использовать неоднократно, даже после того, как он «сломается».
--------------------------------------------------------------------------------------------------------------------
Как остановить поток?

На данный момент в Java принят уведомительный порядок остановки потока (хотя JDK 1.0 и имеет несколько управляющих выполнением потока методов, например stop(), suspend() и resume() - в следующих версиях JDK все они были помечены как deprecated из-за потенциальных угроз взаимной блокировки).
Для корректной остановки потока можно использовать метод класса Thread - interrupt(). Этот метод выставляет некоторый внутренний флаг-статус прерывания. В дальнейшем состояние этого флага можно проверить с помощью метода isInterrupted() или Thread.interrupted() (для текущего потока). Метод interrupt() также способен вывести поток из состояния ожидания или спячки. Т.е. если у потока были вызваны методы sleep() или wait() - текущее состояние прервется и будет выброшено исключение InterruptedException. Флаг в этом случае не выставляется.
Схема действия при этом получается следующей:
Реализовать поток.
В потоке периодически проводить проверку статуса прерывания через вызов isInterrupted().
Если состояние флага изменилось или было выброшено исключение во время ожидания/спячки, следовательно поток пытаются остановить извне.
Принять решение - продолжить работу (если по каким-то причинам остановиться невозможно) или освободить заблокированные потоком ресурсы и закончить выполнение.
Возможная проблема, которая присутствует в этом подходе - блокировки на потоковом вводе-выводе. Если поток заблокирован на чтении данных - вызов interrupt() из этого состояния его не выведет. Решения тут различаются в зависимости от типа источника данных. Если чтение идет из файла - долговременная блокировка крайне маловероятна и тогда можно просто дождаться выхода из метода read(). Если же чтение каким-то образом связано с сетью - стоит использовать неблокирующий ввод-вывод из Java NIO.
Второй вариант реализации метода остановки (а также и приостановки) - сделать собственный аналог interrupt(). Т.е. объявить в классе потока флаги - на остановку и/или приостановку и выставлять их путем вызова заранее определённых методов извне. Методика действия при этом остаётся прежней - проверять установку флагов и принимать решения при их изменении. Недостатки такого подхода. Во-первых, потоки в состоянии ожидания таким способом не «оживить». Во-вторых, выставление флага одним потоком совсем не означает, что второй поток тут же его увидит. Для увеличения производительности виртуальная машина использует кеш данных потока, в результате чего обновление переменной у второго потока может произойти через неопределенный промежуток времени (хотя допустимым решением будет объявить переменную-флаг как volatile).
--------------------------------------------------------------------------------------------------------------------
Почему не рекомендуется использовать метод Thread.stop()?

При принудительной остановке (приостановке) потока, stop() прерывает поток в недетерменированном месте выполнения, в результате становится совершенно непонятно, что делать с принадлежащими ему ресурсами. Поток может открыть сетевое соединение - что в таком случае делать с данными, которые еще не вычитаны? Где гарантия, что после дальнейшего запуска потока (в случае приостановки) он сможет их дочитать? Если поток блокировал разделяемый ресурс, то как снять эту блокировку и не переведёт ли принудительное снятие к нарушению консистентности системы? То же самое можно расширить и на случай соединения с базой данных: если поток остановят посередине транзакции, то кто ее будет закрывать? Кто и как будет разблокировать ресурсы?

--------------------------------------------------------------------------------------------------------------------
Что происходит, когда в потоке выбрасывается исключение?

Если исключение не поймано - поток «умирает» (переходит в состяние мёртв (dead)).
Если установлен обработчик непойманных исключений, то он возьмёт управление на себя. Thread.UncaughtExceptionHandler - интерфейс, определённый как вложенный интерфейс для других обработчиков, вызываемых, когда поток внезапно останавливается из-за непойманного исключения. В случае, если поток собирается остановиться из-за непойманного исключения, JVM проверяет его на наличие UncaughtExceptionHandler, используя Thread.getUncaughtExceptionHandler(), и если такой обработчик найдет, то вызовет у него метод uncaughtException(), передав этот поток и исключение в виде аргументов.
--------------------------------------------------------------------------------------------------------------------
В чем разница между interrupted() и isInterrupted()?

Механизм прерывания работы потока в Java реализован с использованием внутреннего флага, известного как статус прерывания. Прерывание потока вызовом Thread.interrupt() устанавливает этот флаг. Методы Thread.interrupted() и isInterrupted() позволяют проверить, является ли поток прерванным.
Когда прерванный поток проверяет статус прерывания, вызывая статический метод Thread.interrupted(), статус прерывания сбрасывается.
Нестатический метод isInterrupted() используется одним потоком для проверки статуса прерывания у другого потока, не изменяя флаг прерывания.
--------------------------------------------------------------------------------------------------------------------
Что такое «пул потоков»?

Создание потока является затратной по времени и ресурсам операцией. Количество потоков, которое может быть запущено в рамках одного процесса также ограниченно. Чтобы избежать этих проблем и в целом управлять множеством потоков более эффективно в Java был реализован механизм пула потоков (thread pool), который создаётся во время запуска приложения и в дальнейшем потоки для обработки запросов берутся и переиспользуются уже из него. Таким образом, появляется возможность не терять потоки, сбалансировать приложение по количеству потоков и частоте их создания.

Начиная с Java 1.5 Java API предоставляет фреймворк Executor, который позволяет создавать различные типы пула потоков:

Executor - упрощенный интерфейс пула, содержит один метод для передачи задачи на выполнение;

ExecutorService - расширенный интерфейс пула, с возможностью завершения всех потоков;

AbstractExecutorService - базовый класс пула, реализующий интерфейс ExecutorService;

Executors - фабрика объектов связанных с пулом потоков, в том числе позволяет создать основные типы пулов;

ThreadPoolExecutor - пул потоков с гибкой настройкой, может служить базовым классом для нестандартных пулов;

ForkJoinPool - пул для выполнения задач типа ForkJoinTask;
... и другие.

Методы Executors для создания пулов:

newCachedThreadPool() - если есть свободный поток, то задача выполняется в нем, иначе добавляется новый поток в пул. Потоки не используемые больше минуты завершаются и удалются и кэша. Размер пула неограничен. Предназначен для выполнения множество небольших асинхронных задач;

newCachedThreadPool(ThreadFactory threadFactory) - аналогично предыдущему, но с собственной фабрикой потоков;

newFixedThreadPool(int nThreads) - создает пул на указанное число потоков. Если новые задачи добавлены, когда все потоки активны, то они будут сохранены в очереди для выполнения позже. Если один из потоков завершился из-за ошибки, на его место будет запущен другой поток. Потоки живут до тех пор, пока пул не будет закрыт явно методом shutdown().

newFixedThreadPool(int nThreads, ThreadFactory threadFactory) - аналогично предыдущему, но с собственной фабрикой потоков;

newSingleThreadScheduledExecutor() - однопотоковый пул с возможностью выполнять задачу через указанное время или выполнять периодически. Если поток был завершен из-за каких-либо ошибок, то для выполнения следующей задачи будет создан новый поток.

newSingleThreadScheduledExecutor(ThreadFactory threadFactory) - аналогично предыдущему, но с собственной фабрикой потоков;
newScheduledThreadPool(int corePoolSize) - пул для выполнения задач через указанное время или переодически;

newScheduledThreadPool(int corePoolSize, ThreadFactory threadFactory) - аналогично предыдущему, но с собственной фабрикой потоков;

unconfigurableExecutorService(ExecutorService executor) - обертка на пул, запрещающая изменять его конфигурацию;

--------------------------------------------------------------------------------------------------------------------
Что делает метод shutdown() и shutdownNow() у ExecutorService?

shutdown()
метода инициирует остановку ExecutorService. Все задачи, которые уже были отправлены на обработку, будут завершены, новые задачи приниматься не будут.

List<Runnable> shutdownNow()
Вызов метода инициирует остановку ExecutorService. Все задачи, которые уже были отправлены на обработку, получат команду Thread.interrupt. Задачи, находящиеся в очереди, возвращаются в виде списка как результат вызова метода.
Метод не ожидает завершения всех задач, которые находятся "в работе" на момент вызова метода.
--------------------------------------------------------------------------------------------------------------------
Какого размера должен быть пул потоков?

Настраивая размер пула потоков, важно избежать двух ошибок: слишком мало потоков (очередь на выполнение будет расти, потребляя много памяти) или слишком много потоков (замедление работы всей систему из-за частых переключений контекста).
Оптимальный размер пула потоков зависит от количества доступных процессоров и природы задач в рабочей очереди. На N-процессорной системе для рабочей очереди, которая будет выполнять исключительно задачи с ограничением по скорости вычислений, можно достигнуть максимального использования CPU с пулом потоков, в котором содержится N или N+1 поток. Для задач, которые могут ждать осуществления I/O (ввода - вывода) - например, задачи, считывающей HTTP-запрос из сокета - может понадобиться увеличение размера пула свыше количества доступных процессоров, потому, что не все потоки будут работать все время. Используя профилирование, можно оценить отношение времени ожидания (WT) ко времени обработки (ST) для типичного запроса. Если назвать это соотношение WT/ST, то для N-процессорной системе понадобится примерно N*(1 + WT/ST) потоков для полной загруженности процессоров.
Использование процессора - не единственный фактор, важный при настройке размера пула потоков. По мере возрастания пула потоков, можно столкнуться с ограничениями планировщика, доступной памяти, или других системных ресурсов, таких, как количество сокетов, дескрипторы открытого файла, или каналы связи базы данных.
--------------------------------------------------------------------------------------------------------------------
Что будет, если очередь пула потоков уже заполнена, но подаётся новая задача?

Если очередь пула потоков заполнилась, то поданная задача будет «отклонена». Например - метод submit() у ThreadPoolExecutor выкидывает RejectedExecutionException, после которого вызывается RejectedExecutionHandler.

--------------------------------------------------------------------------------------------------------------------
В чём заключается различие между методами submit() и execute() у пула потоков?

Оба метода являются способами подачи задачи в пул потоков, но между ними есть небольшая разница.
execute(Runnable command) определён в интерфейсе Executor и выполняет поданную задачу и ничего не возвращает.
submit() - перегруженный метод, определённый в интерфейсе ExecutorService. Способен принимать задачи типов Runnable и Callable и возвращать объект Future, который можно использовать для контроля и управления процессом выполнения, получения его результата.
--------------------------------------------------------------------------------------------------------------------
В чем заключаются различия между cтеком (stack) и кучей (heap) с точки зрения многопоточности?

Cтек - участок памяти, тесно связанный с потоками. У каждого потока есть свой стек, которые хранит локальные переменные, параметры методов и стек вызовов. Переменная, хранящаяся в стеке одного потока, не видна для другого.
Куча - общий участок памяти, который делится между всеми потоками. Объекты, неважно локальные или любого другого уровня, создаются в куче. Для улучшения производительности, поток обычно кэширует значения из кучи в свой стек, в этом случае для того, чтобы указать потоку, что переменную следует читать из кучи используется ключевое слово volatile.
--------------------------------------------------------------------------------------------------------------------
Как поделиться данными между двумя потоками?

Данными между потоками возможно делиться, используя общий объект или параллельные структуры данных, например BlockingQueue.

--------------------------------------------------------------------------------------------------------------------
Какой параметр запуска JVM используется для контроля размера стека потока?

-Xss

--------------------------------------------------------------------------------------------------------------------
Как получить дамп потока?

Среды исполнения Java на основе HotSpot генерируют только дамп в формате HPROF. В распоряжении разработчика имеется несколько интерактивных методов генерации дампов и один метод генерации дампов на основе событий.
Интерактивные методы:

Использование Ctrl+Break: если для исполняющегося приложения установлена опция командной строки -XX:+HeapDumpOnCtrlBreak, то дамп формата HPROF генерируется вместе с дампом потока при наступлении события Ctrl+Break или SIGQUIT (обычно генерируется с помощью kill -3), которое инициируется посредством консоли. Эта опция может быть недоступна в некоторых версиях. В этом случае можно попытаться использовать следующую опцию: -Xrunhprof:format=b,file=heapdump.hprof

Использование инструмента jmap: утилита jmap, поставляемая в составе каталога /bin/ комплекта JDK, позволяет запрашивать дамп HPROF из исполняющегося процесса.

Использование операционной системы: Для создания файла ядра можно воспользоваться неразрушающей командой gcore или разрушающими командами kill -6 или kill -11. Затем извлечь дамп кучи из файла ядра с помощью утилиты jmap.

Использование инструмента JConsole. Операция dumpHeap предоставляется в JConsole как MBean-компонент HotSpotDiagnostic. Эта операция запрашивает генерацию дампа в формате HPROF.

Метод на основе событий:

Событие OutOfMemoryError: Если для исполняющегося приложения установлена опция командной строки -XX:+HeapDumpOnOutOfMemoryError, то при возникновении ошибки OutOfMemoryError генерируется дамп формата HPROF. Это идеальный метод для «production» систем, поскольку он практически обязателен для диагностирования проблем памяти и не сопровождается постоянными накладными расходами с точки зрения производительности. В старых выпусках сред исполнения Java на базе HotSpot для этого события не устанавливается предельное количество дампов кучи в пересчете на одну JVM; в более новых выпусках допускается не более одного дампа кучи для этого события на каждый запуск JVM.

--------------------------------------------------------------------------------------------------------------------
Что такое ThreadLocal-переменная?

ThreadLocal - класс, позволяющий имея одну переменную, иметь различное её значение для каждого из потоков.
У каждого потока - т.е. экземпляра класса Thread - есть ассоциированная с ним таблица ThreadLocal-переменных. Ключами таблицы являются cсылки на объекты класса ThreadLocal, а значениями - ссылки на объекты, «захваченные» ThreadLocal-переменными, т.е. ThreadLocal-переменные отличаются от обычных переменных тем, что у каждого потока свой собственный, индивидуально инициализируемый экземпляр переменной. Доступ к значению можно получить через методы get() или set().
Например, если мы объявим ThreadLocal-переменную: ThreadLocal<Object> locals = new ThreadLocal<Object>();. А затем, в потоке, сделаем locals.set(myObject), то ключом таблицы будет ссылка на объект locals, а значением - ссылка на объект myObject. При этом для другого потока существует возможность «положить» внутрь locals другое значение.
Следует обратить внимание, что ThreadLocal изолирует именно ссылки на объекты, а не сами объекты. Если изолированные внутри потоков ссылки ведут на один и тот же объект, то возможны коллизии.
Так же важно отметить, что т.к. ThreadLocal-переменные изолированы в потоках, то инициализация такой переменной должна происходить в том же потоке, в котором она будет использоваться. Ошибкой является инициализация такой переменной (вызов метода set()) в главном потоке приложения, потому как в данном случае значение, переданное в методе set(), будет «захвачено» для главного потока, и при вызове метода get() в целевом потоке будет возвращен null.
--------------------------------------------------------------------------------------------------------------------
Назовите различия между synchronized и ReentrantLock?

В Java 5 появился интерфейс Lock предоставляющий возможности более эффективного и тонкого контроля блокировки ресурсов. ReentrantLock - распространённая реализация Lock, которая предоставляет Lock с таким же базовым поведением и семантикой, как у synchronized, но расширенными возможностями, такими как опрос о блокировании (lock polling), ожидание блокирования заданной длительности и прерываемое ожидание блокировки. Кроме того, он предлагает гораздо более высокую эффективность функционирования в условиях жесткой состязательности.
Что понимается под блокировкой с повторным входом (reentrant)? Просто то, что есть подсчет сбора данных, связанный с блокировкой, и если поток, который удерживает блокировку, снова ее получает, данные отражают увеличение, и тогда для реального разблокирования нужно два раза снять блокировку. Это аналогично семантике synchronized; если поток входит в синхронный блок, защищенный монитором, который уже принадлежит потоку, потоку будет разрешено дальнейшее функционирование, и блокировка не будет снята, когда поток выйдет из второго (или последующего) блока synchronized, она будет снята только когда он выйдет из первого блока synchronized, в который он вошел под защитой монитора.
Lock lock = new ReentrantLock(); lock.lock(); try { // update object state } finally { lock.unlock(); }
Реализация ReentrantLock гораздо более масштабируема в условиях состязательности, чем реализация synchronized. Это значит, что когда много потоков соперничают за право получения блокировки, общая пропускная способность обычно лучше у ReentrantLock, чем у synchronized. JVM требуется меньше времени на установление очередности потоков и больше времени на непосредственно выполнение.
У ReentrantLock (как и у других реализаций Lock) блокировка должна обязательно сниматься в finally блоке (иначе, если бы защищенный код выбросил исключение, блокировка не была бы снята). Используя синхронизацию, JVM гарантирует, что блокировка автоматически снимаются.
Резюмируя, можно сказать, что когда состязания за блокировку нет либо оно очень мало, то synchronized возможно будет быстрее. Если присутствует заметное состязание за доступ к ресурсу, то скорее всего ReentrantLock даст некое преимущество.
--------------------------------------------------------------------------------------------------------------------
Что такое ReadWriteLock?

ReadWriteLock - это интерфейс расширяющий базовый интерфейс Lock. Используется для улучшения производительности в многопоточном процессе и оперирует парой связанных блокировок (одна - для операций чтения, другая - для записи). Блокировка чтения может удерживаться одновременно несколькими читающими потоками, до тех пор, пока не появится записывающий. Блокировка записи является эксклюзивеной.
Существует реализующий интерфейс ReadWriteLock класс ReentrantReadWriteLock, который поддерживает до 65535 блокировок записи и до стольки же блокировок чтения.
ReadWriteLock rwLock = new ReentrantReadWriteLock(); Lock rLock = rwLock.readLock(); Lock wLock = rwLock.writeLock(); wLock.lock();
try { // exclusive write } finally { wLock.unlock(); } rLock.lock();
try { // shared reading } finally { rLock.unlock(); }
--------------------------------------------------------------------------------------------------------------------
Что такое «блокирующий метод»?

Блокирующий метод - метод, который блокируется, до тех пор, пока задание не выполнится, например метод accept() у ServerSocket блокируется в ожидании подключения клиента. Здесь блокирование означает, что контроль не вернётся к вызывающему методу до тех пор, пока не выполнится задание. Так же существуют асинхронные или неблокирующиеся методы, которые могут завершится до выполнения задачи.

--------------------------------------------------------------------------------------------------------------------
то такое «фреймворк Fork/Join»?

Фреймворк Fork/Join, представленный в JDK 7, - это набор классов и интерфейсов позволяющих использовать преимущества многопроцессорной архитектуры современных компьютеров. Он разработан для выполнения задач, которые можно рекурсивно разбить на маленькие подзадачи, которые можно решать параллельно.
Этап Fork: большая задача разделяется на несколько меньших подзадач, которые в свою очередь также разбиваются на меньшие. И так до тех пор, пока задача не становится тривиальной и решаемой последовательным способом.
Этап Join: далее (опционально) идёт процесс «свёртки» - решения подзадач некоторым образом объединяются пока не получится решение всей задачи.
Решение всех подзадач (в т.ч. и само разбиение на подзадачи) происходит параллельно.
Для решения некоторых задач этап Join не требуется. Например, для параллельного QuickSort — массив рекурсивно делится на всё меньшие и меньшие диапазоны, пока не вырождается в тривиальный случай из 1 элемента. Хотя в некотором смысле Join будет необходим и тут, т.к. всё равно остаётся необходимость дождаться пока не закончится выполнение всех подзадач.
Ещё одно замечательное преимущество этого фреймворка заключается в том, что он использует work-stealing алгоритм: потоки, которые завершили выполнение собственных подзадач, могут «украсть» подзадачи у других потоков, которые всё ещё заняты.
--------------------------------------------------------------------------------------------------------------------
Что такое Semaphore?

Semaphore - это новый тип синхронизатора: семафор со счётчиком, реализующий шаблон синхронизации Семафор. Доступ управляется с помощью счётчика: изначальное значение счётчика задаётся в конструкторе при создании синхронизатора, когда поток заходит в заданный блок кода, то значение счётчика уменьшается на единицу, когда поток его покидает, то увеличивается. Если значение счётчика равно нулю, то текущий поток блокируется, пока кто-нибудь не выйдет из защищаемого блока. Semaphore используется для защиты дорогих ресурсов, которые доступны в ограниченном количестве, например подключение к базе данных в пуле.

--------------------------------------------------------------------------------------------------------------------
Что такое double checked locking Singleton?

double checked locking Singleton - это один из способов создания потокобезопасного класса реализующего шаблон Одиночка. Данный метод пытается оптимизировать производительность, блокируясь только случае, когда экземпляр одиночки создаётся впервые.

class DoubleCheckedLockingSingleton { private static volatile DoubleCheckedLockingSingleton instance; static DoubleCheckedLockingSingleton getInstance() { DoubleCheckedLockingSingleton current = instance; if (current == null) { synchronized (DoubleCheckedLockingSingleton.class) { current = instance; if (current == null) { instance = current = new DoubleCheckedLockingSingleton(); } } } return current; } }

Следует заметить, что требование volatile обязательно. Проблема Double Checked Lock заключается в модели памяти Java, точнее в порядке создания объектов, когда возможна ситуация, при которой другой поток может получить и начать использовать (на основании условия, что указатель не нулевой) не полностью сконструированный объект. Хотя эта проблема была частично решена в JDK 1.5, однако рекомендация использовать volatile для Double Cheсked Lock остаётся в силе.

--------------------------------------------------------------------------------------------------------------------
Как создать потокобезопасный Singleton?

Static field
public class Singleton { public static final Singleton INSTANCE = new Singleton(); }

Enum
public enum Singleton { INSTANCE; }

Synchronized Accessor
public class Singleton { private static Singleton instance; public static synchronized Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } }

Double Checked Locking & volatile
public class Singleton { private static volatile

Singleton instance; public static Singleton getInstance() { Singleton localInstance = instance; if (localInstance == null) { synchronized (Singleton.class) { localInstance = instance; if (localInstance == null) { instance = localInstance = new Singleton(); } } } return localInstance; } }

On Demand Holder Idiom
public class Singleton { public static class SingletonHolder { public static final Singleton HOLDER_INSTANCE = new Singleton(); } public static Singleton getInstance() { return SingletonHolder.HOLDER_INSTANCE; } }
--------------------------------------------------------------------------------------------------------------------
Чем полезны неизменяемые объекты?

Неизменяемость (immutability) помогает облегчить написание многопоточного кода. Неизменяемый объект может быть использован без какой-либо синхронизации. К сожалению, в Java нет аннотации @Immutable, которая делает объект неизменяемым, для этого разработчикам нужно самим создавать класс с необходимыми характеристиками. Для этого необходимо следовать некоторым общим принципам: инициализация всех полей только в конструкторе, отсутствие методов setX() вносящих изменения в поля класса, отсутствие утечек ссылки, организация отдельного хранилища копий изменяемых объектов и т.д.

--------------------------------------------------------------------------------------------------------------------
Что такое busy spin?

busy spin - это техника, которую программисты используют, чтобы заставить поток ожидать при определённом условии. В отличие от традиционных методов wait(), sleep() или yield(), которые подразумевают уступку процессорного времени, этот метод вместо уступки выполняет пустой цикл. Это необходимо, для того, чтобы сохранить кэш процессора, т.к. в многоядерных системах, существует вероятность, что приостановленный поток продолжит своё выполнение уже на другом ядре, а это повлечет за собой перестройку состояния процессорного кэша, которая является достаточно затратной процедурой.

--------------------------------------------------------------------------------------------------------------------
Перечислите принципы, которым вы следуете в многопоточном программировании?

При написании многопоточных программ следует придерживаться определённых правил, которые помогают обеспечить достойную производительность приложения в сочетании с удобной отладкой и простотой дальнейшей поддержки кода.

Всегда давайте значимые имена своим потокам. Процесс отладки, нахождения ошибок или отслеживание исключения в многопоточном коде - довольно сложная задача. OrderProcessor, QuoteProcessor или TradeProcessor намного информативнее, чем Thread1, Thread2 и Thread3. Имя должно отражать задачу, выполняемую данным потоком.

Избегайте блокировок или старайтесь уменьшить масштабы синхронизации. Блокировка затратна, а переключение контекста ещё более ресурсоёмко. Пытайтесь избегать синхронизации и блокировки насколько это возможно, и организуйте критическую секцию в минимально необходимом объёме. Поэтому синхронизированный блок всегда предпочительней синхронизированного метода, дополнительно наделяя возможностью абсолютного контроля над масштабом блокировки.

Обрабатывайте прерывание потока с особой тщательностью. Нет ничего хуже оставшегося заблокированным ресурса или системы в неконстистентном, по причине неподтверждённой транзакции, состоянии.

Помните об обработке исключений. Выброшенные InterruptedException должны быть адекватно обработаны, а не просто подавлены. Так же не стоит пренебрегать Thread.UncaughtExceptionHandler. При использовании пула потоков необходимо помнить, что он зачастую просто «проглатывает» исключения. Так, если вы отправили на выполнение Runnable нужно обязательно поместить код выполнения задачи внутрь блока try-catch. Если в очередь пула помещается Callable, необходимо удостоверится, что результат выполнения всегда изымается помощью блокирующего get(), чтобы в случае возникновения существовала возможнотсь заново выбросить произошедшее исключение.

Между синхронизаторами и wait() и notify() следует выбирать синхронизаторы. Во-первых, синхронизаторы, типа CountDownLatch, Semaphore, CyclicBarrier или Exchanger упрощают написание кода. Очень сложно реализовывать комплексный управляющий поток, используя wait() и notify(). Во-вторых, эти классы написаны и поддерживаются настоящими мастерами своего дела и есть шанс, что в последующих версиях JDK они будут оптимизированы изнутри или заменены более производительной внешней реализацией.

Почти всегда использование Concurrent сollection выгоднее использования Synchronized сollection, т.к. первые более современны (используют все доступные на момент их написания новшества языка) и масштабируемы, чем их синхронизированые аналоги.

--------------------------------------------------------------------------------------------------------------------
Какое из следующих утверждений о потоках неверно?

1) Если метод start() вызывается дважды для одного и того же объекта Thread, во время выполнения генерируется исключение.

2) Порядок, в котором запускались потоки, может не совпадать с порядком их фактического выполнения.

3) Если метод run() вызывается напрямую для объекта Thread, во время выполнения генерируется исключение.

4) Если метод sleep() вызывается для потока, во время выполнения синхронизированного кода, блокировка не снимается.

Правильный ответ: 3. Если метод run() вызывается напрямую для объекта Thread, во время выполнения исключение не генерируется. Однако, код, написанный в методе run() будет выполняться текущим, а не новым потоком. Таким образом, правильный способ запустить поток - это вызов метода start(), который приводит к выполнению метода run() новым потоком.
Вызов метода start() дважды для одного и того же объекта Thread приведёт к генерированию исключения IllegalThreadStateException во время выполнения, следовательно, утверждение 1 верно. Утверждение 2 верно, так как порядок, в котором выполняются потоки, определяется Планировщиком потоков, независимо от того, какой поток запущен первым. Утверждение 4 верно, так как поток не освободит блокировки, которые он держит, когда он переходит в состояние Ожидания.
--------------------------------------------------------------------------------------------------------------------
Даны 3 потока Т1, Т2 и Т3? Как реализовать выполнение в последовательности Т1, Т2, Т3?

Такой последовательности выполнения можно достичь многими способами, например просто воспользоваться методом join(), чтобы запустить поток в момент, когда другой уже закончит своё выполнение. Для реализации заданной последовательности, нужно запустить последний поток первым, и затем вызывать метод join() в обратном порядке, то есть Т3 вызывает Т2.join, а Т2 вызывает Т1.join, таким образом Т1 закончит выполнение первым, а Т3 последним.

--------------------------------------------------------------------------------------------------------------------
Напишите минимальный неблокирующий стек (всего два метода — push() и pop()).

class NonBlockingStack<T> {
private final AtomicReference<Element> head = new AtomicReference<>(null);
Stack<T> push(final T value) {
final Element current = new Element();
current.value = value;
Element recent;
do {
recent = head.get();
current.previous = recent;
} while (!head.compareAndSet(recent, current));
return this;
}
T pop() {
Element result;
Element previous;
do {
result = head.get();
if (result == null) {
return null;
}
previous = result.previous;
} while (!head.compareAndSet(result, previous));
return result.value;
}
private class Element {
private T value;
private Element previous;
}
}
--------------------------------------------------------------------------------------------------------------------
Напишите минимальный неблокирующий стек (всего два метода — push() и pop()) с использованием Semaphore.

class SemaphoreStack<T> {
private final Semaphore semaphore = new Semaphore(1);
private Node<T> head = null;
SemaphoreStack<T> push(T value) {
semaphore.acquireUninterruptibly();
try {
head = new Node<>(value, head);
} finally {
semaphore.release();
}
return this;
}
T pop() {
semaphore.acquireUninterruptibly();
try {
Node<T> current = head;
if (current != null) {
head = head.next;
return current.value;
}
return null;
} finally {
semaphore.release();
}
}
private static class Node<E> {
private final E value;
private final Node<E> next;
private Node(E value, Node<E> next) {
this.value = value;
this.next = next;
}
}
}
--------------------------------------------------------------------------------------------------------------------
Напишите минимальный неблокирующий ArrayList (всего четыре метода — add(), get(), remove(), size()).

class NonBlockingArrayList<T> {
private volatile Object[] content = new Object[0];
NonBlockingArrayList<T> add(T item) {
return add(content.length, item);
}
NonBlockingArrayList<T> add(int index, T item) {
if (index < 0) {
throw new IllegalArgumentException();
}
boolean needsModification = index > content.length - 1;
if (!needsModification) {
if (item == null) {
needsModification = content[index] != null;
} else {
needsModification = item.equals(content[index]);
}
}
if (needsModification) {
final Object[] renewed = Arrays.copyOf(content, Math.max(content.length, index + 1));
renewed[index] = item;
content = renewed;
}
return this;
}
NonBlockingArrayList<T> remove(int index) {
if (index < 0 || index >= content.length) {
throw new IllegalArgumentException();
}
int size = content.length - 1;
final Object[] renewed = new Object[size];
System.arraycopy(content, 0, renewed, 0, index);
if (index + 1 < size) {
System.arraycopy(content, index + 1, renewed, index, size - index);
}
content = renewed;
return this;
}
T get(int index) {
return (T) content[index];
}
int size() {
return content.length;
}
}
--------------------------------------------------------------------------------------------------------------------
Напишите потокобезопасную реализацию класса с неблокирующим методом BigInteger next(), который возвращает элементы последовательности: [1, 2, 4, 8, 16, ...].

class PowerOfTwo {
private AtomicReference<BigInteger> current = new AtomicReference<>(null);

BigInteger next() {
BigInteger recent, next;
do {
recent = current.get();
next = (recent == null) ? BigInteger.valueOf(1) : recent.shiftLeft(1);
} while (!current.compareAndSet(recent, next));
return next;
}
}
--------------------------------------------------------------------------------------------------------------------
Напишите простейший многопоточный ограниченный буфер с использованием synchronized.

class QueueSynchronized<T> {
private volatile int size = 0;
private final Object[] content;
private final int capacity;
private int out;
private int in;
private final Object isEmpty = new Object();
private final Object isFull = new Object();
QueueSynchronized(final int capacity) {
this.capacity = capacity;
content = new Object[this.capacity];
out = 0;
in = 0;
size = 0;
}
private int cycleInc(int index) {
return (++index == capacity)
? 0
: index;
}
@SuppressWarnings("unchecked")
T get() throws InterruptedException {
if (size == 0) {
synchronized (isEmpty) {
while (size < 1) {
isEmpty.wait();
}
}
}
try {
synchronized (this) {
final Object value = content[out];
content[out] = null;
if (size > 1) {
out = cycleInc(out);
}
size--;
return (T) value;
}
} finally {
synchronized (isFull) {
isFull.notify();
}
}
}
QueueSynchronized<T> put(T value) throws InterruptedException {
if (size == capacity) {
synchronized (isFull) {
while (size == capacity) {
isFull.wait();
}
}
}
synchronized (this) {
if (size == 0) {
content[in] = value;
} else {
in = cycleInc(in);
content[in] = value;
}
size++;
}
synchronized (isEmpty) {
isEmpty.notify();
}
return this;
}
}
--------------------------------------------------------------------------------------------------------------------
Напишите простейший многопоточный ограниченный буфер с использованием ReentrantLock.

class QueueReentrantLock<T> {
private volatile int size = 0;
private final Object[] content;
private final int capacity;
private int out;
private int in;
private final ReentrantLock lock = new ReentrantLock();
private final Condition isEmpty = lock.newCondition();
private final Condition isFull = lock.newCondition();
QueueReentrantLock(int capacity) {
try {
lock.lock();
this.capacity = capacity;
content = new Object[capacity];
out = 0;
in = 0;
} finally {
lock.unlock();
}
}
private int cycleInc(int index) {
return (++index == capacity)
? 0
: index;
}
@SuppressWarnings("unchecked")
T get() throws InterruptedException {
try {
lock.lockInterruptibly();
if (size == 0) {
while (size < 1) {
isEmpty.await();
}
}
final Object value = content[out];
content[out] = null;
if (size > 1) {
out = cycleInc(out);
}
size--;
isFull.signal();
return (T) value;
} finally {
lock.unlock();
}
}
QueueReentrantLock<T> put(T value) throws InterruptedException {
try {
lock.lockInterruptibly();
if (size == capacity) {
while (size == capacity) {
isFull.await();
}
}
if (size == 0) {
content[in] = value;
} else {
in = cycleInc(in);
content[in] = value;
}
size++;
isEmpty.signal();
} finally {
lock.unlock();
}
return this;
}
}
--------------------------------------------------------------------------------------------------------------------
Что такое race condition?

Состояние гонки (race condition) - ошибка проектирования многопоточной системы или приложения, при которой эта работа напрямую зависит от того, в каком порядке выполняются потоки. Состояние гонки возникает, когда поток, который должен исполнится в начале, проиграл гонку и первым исполняется другой поток: поведение кода изменяется, из-за чего возникают недетерменированные ошибки.

--------------------------------------------------------------------------------------------------------------------
Существует ли способ решения проблемы race condition?

Существует ли способ решения проблемы race condition?

--------------------------------------------------------------------------------------------------------------------
Что мы понимаем под операцией CAS?

CAS означает сравнение и замена и означает, что процессор предоставляет отдельную инструкцию, которая обновляет значение регистра, только если предоставленное значение равно текущему значению. Операции CAS можно использовать, чтобы избежать синхронизации, поскольку поток может попытаться обновить значение, предоставив его текущее значение и новое значение для операции CAS. Если другой поток тем временем обновил значение, значение потока не равно текущему значению, и операция обновления завершается неудачно. Затем поток читает новое значение и пытается снова. Таким образом, необходимая синхронизация сменяется оптимистическим ожиданием вращения.

--------------------------------------------------------------------------------------------------------------------
Какие классы Java используют операцию CAS?

Классы SDK в пакете java.util.concurrent.atomic
похожи AtomicIntege rили AtomicBoolean используют внутреннюю операцию CAS для реализации одновременного увеличения.

public class CounterAtomic {
private AtomicLong counter = new AtomicLong();
public void increment() {
counter.incrementAndGet();
}
public long get() {
return counter.get();
}
}
--------------------------------------------------------------------------------------------------------------------
С какими распространенными проблемами вы столкнулись в многопоточной среде?

Deadlock — два потока A и B, удерживайте lock_A и lock_B соответственно. Они оба хотят получить доступ к ресурсу R. Для безопасного доступа к R требуются и lock_A, и lock_B. Но поток A нуждается в lock_B, а поток B — в lock_A. Но оба они не готовы отказаться от замков, которые они держат. Следовательно, нет прогресса. Это тупик!

Условия гонки — Рассмотрим классический пример производителя-потребителя. Что если вы забудете заблокировать перед добавлением или удалением элемента из очереди? Представьте, что два потока A и B пытаются добавить элемент без блокировки. Поток A обращается к задней части очереди. Затем планировщик дает возможность запустить поток B, который успешно добавляет элемент и обновляет хвостовой указатель. Теперь указатель хвоста, прочитанный потоком A, устарел, но он думает, что это хвост, и добавляет элемент. Таким образом, пункт, добавленный B, потерян! Структура данных повреждена! Хуже того, это может также привести к утечке памяти во время очистки.

Гонка данных — представьте переменную флага, которую следует установить. Предположим, что вы установили замки, чтобы избежать условий гонки. Теперь разные потоки хотят устанавливать разные значения. Поскольку планировщик может планировать выполнение потока любым способом, вы не знаете, каково значение флага в конце.

Голодание — это проблема, вызванная
планировщиком потоков. Некоторые потоки не имеют возможности запустить и завершить или не могут получить требуемые блокировки, потому что другим потокам предоставляется более высокий приоритет. Они «жаждут» циклов ЦП или других ресурсов.
Инверсия приоритетов. Представьте себе два потока A и B. A имеет более высокий приоритет, чем B, и, следовательно, получает больше циклов ЦП, чем B. Но при доступе к общему ресурсу B удерживает блокировку, которая также требуется для A, и возвращает. Теперь A не может ничего сделать без блокировки, и много циклов ЦП тратится впустую, потому что B не получает достаточно циклов, но имеет блокировку.
--------------------------------------------------------------------------------------------------------------------
Разница между зеленым потоком и собственным потоком в Java?

Зеленые потоки относятся к модели, в которой сама виртуальная машина Java создает, управляет и переключает контекст всех потоков Java в рамках одного процесса операционной системы. Библиотека потоков операционной системы не используется.

Под собственными потоками понимается объект, в котором виртуальная машина Java создает потоки Java и управляет ими с помощью библиотеки потоков операционной системы — с именем libthread в UnixWare — и каждый поток Java отображается в один поток библиотеки потоков.

--------------------------------------------------------------------------------------------------------------------
Можно ли улучшить производительность приложения, используя многопоточность? Назовите несколько примеров.

Если у нас имеется более одного доступного ядра ЦП, производительность приложения можно повысить с помощью многопоточности, если возможно распараллелить вычисления на доступных ядрах ЦП. Примером может служить приложение, которое должно масштабировать все изображения, хранящиеся в структуре локального каталога. Вместо того, чтобы перебирать все изображения одно за другим, реализация производителя / потребителя может использовать один поток для сканирования структуры каталогов и группу рабочих потоков, которые выполняют фактическую операцию масштабирования. Другим примером может быть приложение, которое отображает некоторую веб-страницу. Вместо загрузки одной HTML-страницы за другой поток производителя может проанализировать первую HTML-страницу и выдать найденные ссылки в очередь. Рабочие потоки отслеживают очередь и загружают веб-страницы, найденные анализатором. Пока рабочие потоки ждут полной загрузки страницы, другие потоки могут использовать ЦП для анализа уже загруженных страниц и выдачи новых запросов.

--------------------------------------------------------------------------------------------------------------------
Приведите пример, почему улучшения производительности для однопоточных приложений могут привести к снижению производительности многопоточных приложений.

Ярким примером такой оптимизации является реализация List , в которой количество элементов хранится в виде отдельной переменной. Это повышает производительность для однопоточных приложений, поскольку операция size() не должна повторяться по всем элементам, но может возвращать текущее количество элементов напрямую. В многопоточном приложении дополнительный счетчик должен защищаться блокировкой, поскольку несколько параллельных потоков могут вставлять элементы в список. Эта дополнительная блокировка может стоить производительности, когда в списке больше обновлений, чем вызовов операции size() .

--------------------------------------------------------------------------------------------------------------------
Что такое ключевое слово volatile в Java и чем оно отличается от синхронизированного метода в Java?

Использование volatile заставляет поток читать и записывать переменные непосредственно из оперативной памяти. Поэтому, когда многие потоки используют одну и ту же переменную переменную, все они видят последнюю версию, которая присутствует в оперативной памяти, а не возможную старую копию в кэше. Когда поток входит в синхронизированный блок, он должен получить контроль над переменной монитора. Все остальные потоки ожидают выхода первого потока из синхронизированного блока. Чтобы все потоки могли видеть одинаковые изменения, все переменные, используемые в синхронизированном блоке, считываются и записываются непосредственно из памяти RAM, а не из копии кэша.

--------------------------------------------------------------------------------------------------------------------
Может ли конструктор быть синхронизирован?

Нет, конструктор не может быть синхронизирован. Причина, по которой это приводит к синтаксической ошибке, заключается в том, что только конструирующий поток должен иметь доступ к создаваемому объекту.

--------------------------------------------------------------------------------------------------------------------
Если два потока одновременно вызывают синхронизированный метод для разных экземпляров объекта, может ли один из этих потоков блокировать?

Оба метода блокируют один и тот же монитор. Следовательно, вы не можете одновременно выполнять их на одном и том же объекте из разных потоков (один из двух методов будет блокироваться, пока другой не будет завершен).

--------------------------------------------------------------------------------------------------------------------
Future vs CompletableFuture - концепция и отличия

Future - интерфейс, который представляет пока еще недовычисленный результат. Когда породившая его асинхронная операция заканчивается, он заполняется значением. Метод get блокирует выполнение до получения результата, isDone проверяет его наличие. К примеру результат выполнения задач в ExecutorService, ForkJoinTask, реализует интерфейс Future.

CompletableFuture появился в Java 8. Это класс-реализация старого интерфейса Future, а значит всё сказанное выше справедливо и для него. Вдобавок к этому, CompletableFuture реализует работу с отложенными результатами посредством коллбэков. Метод thenApply регистрирует код обработки значения, который будет автоматически вызван позже, когда это значение появится.
CompletableFutures были введены в Java 8 (2014). На самом деле они представляют собой эволюцию обычных Futures, вдохновленных Google Listenable Futures , частью библиотеки Guava . Это фьючерсы, которые также позволяют вам связывать задачи в цепочку. Вы можете использовать их, чтобы сказать некоторому рабочему потоку «иди и выполни задачу X, а когда закончишь, иди делай другую вещь, используя результат X». Используя CompletableFutures, вы можете что-то сделать с результатом операции, фактически не блокируя поток для ожидания результата.
--------------------------------------------------------------------------------------------------------------------
Объект синхронизации Semaphore

Синхронизатор Semaphore реализует шаблон синхронизации Семафор. Чаще всего, семафоры необходимы, когда нужно ограничить доступ к некоторому общему ресурсу. В конструктор этого класса (Semaphore(int permits) или Semaphore(int permits, boolean fair)) обязательно передается количество потоков, которому семафор будет разрешать одновременно использовать заданный ресурс.
Доступ управляется с помощью счётчика: изначально значение счётчика равно int permits, когда поток заходит в заданный блок кода, то значение счётчика уменьшается на единицу, когда поток его покидает, то увеличивается. Если значение счётчика равно нулю, то текущий поток блокируется, пока кто-нибудь не выйдет из блока (в качестве примера из жизни с permits = 1, можно привести очередь в кабинет в поликлинике: когда пациент покидает кабинет, мигает лампа, и заходит следующий пациент).
--------------------------------------------------------------------------------------------------------------------
Объект синхронизации CountDownLatch

CountDownLatch (замок с обратным отсчетом) предоставляет возможность любому количеству потоков в блоке кода ожидать до тех пор, пока не завершится определенное количество операций, выполняющихся в других потоках, перед тем как они будут «отпущены», чтобы продолжить свою деятельность. В конструктор CountDownLatch (CountDownLatch(int count)) обязательно передается количество операций, которое должно быть выполнено, чтобы замок «отпустил» заблокированные потоки.Блокировка потоков снимается с помощью счётчика: любой действующий поток, при выполнении определенной операции уменьшает значение счётчика. Когда счётчик достигает 0, все ожидающие потоки разблокируются и продолжают выполняться (примером CountDownLatch из жизни может служить сбор экскурсионной группы: пока не наберется определенное количество человек, экскурсия не начнется).

--------------------------------------------------------------------------------------------------------------------
Объект синхронизации CyclicBarrier

CyclicBarrier реализует шаблон синхронизации Барьер. Циклический барьер является точкой синхронизации, в которой указанное количество параллельных потоков встречается и блокируется. Как только все потоки прибыли, выполняется опционное действие (или не выполняется, если барьер был инициализирован без него), и, после того, как оно выполнено, барьер ломается и ожидающие потоки «освобождаются». В конструктор барьера (CyclicBarrier(int parties) и CyclicBarrier(int parties, Runnable barrierAction)) обязательно передается количество сторон, которые должны «встретиться», и, опционально, действие, которое должно произойти, когда стороны встретились, но перед тем когда они будут «отпущены».Барьер похож на CountDownLatch, но главное различие между ними в том, что вы не можете заново использовать «замок» после того, как его счётчик достигнет нуля, а барьер вы можете использовать снова, даже после того, как он сломается. CyclicBarrier является альтернативой метода join(), который «собирает» потоки только после того, как они выполнились.

--------------------------------------------------------------------------------------------------------------------
Объект синхронизации Exchanger

Exchanger (обменник) может понадобиться, для того, чтобы обменяться данными между двумя потоками в определенной точки работы обоих потоков. Обменник — обобщенный класс, он параметризируется типом объекта для передачи.Обменник является точкой синхронизации пары потоков: поток, вызывающий у обменника метод exchange() блокируется и ждет другой поток. Когда другой поток вызовет тот же метод, произойдет обмен объектами: каждая из них получит аргумент другой в методе exchange(). Стоит отметить, что обменник поддерживает передачу null значения. Это дает возможность использовать его для передачи объекта в одну сторону, или, просто как точку синхронизации двух потоков.

--------------------------------------------------------------------------------------------------------------------
Объект синхронизации Phaser

Phaser (фазер), как и CyclicBarrier, является реализацией шаблона синхронизации Барьер, но, в отличии от CyclicBarrier, предоставляет больше гибкости. Этот класс позволяет синхронизировать потоки, представляющие отдельную фазу или стадию выполнения общего действия. Как и CyclicBarrier, Phaser является точкой синхронизации, в которой встречаются потоки-участники. Когда все стороны прибыли, Phaser переходит к следующей фазе и снова ожидает ее завершения.Если сравнить Phaser и CyclicBarrier, то можно выделить следующие важные особенности Phaser:
Каждая фаза (цикл синхронизации) имеет номер;

Количество сторон-участников жестко не задано и может меняться: поток может регистрироваться в качестве участника и отменять свое участие;

Участник не обязан ожидать, пока все остальные участники соберутся на барьере. Чтобы продолжить свою работу достаточно сообщить о своем прибытии;

Случайные свидетели могут следить за активностью в барьере;

Поток может и не быть стороной-участником барьера, чтобы ожидать его преодоления;

У фазера нет опционального действия.

--------------------------------------------------------------------------------------------------------------------
Что такое Lock?

Lock — Базовый интерфейс из lock framework, предоставляющий более гибкий подход по ограничению доступа к ресурсам/блокам нежели при использовании synchronized. Так, при использовании нескольких локов, порядок их освобождения может быть произвольный. Плюс имеется возможность пойти по альтернативному сценарию, если лок уже кем то захвачен.

--------------------------------------------------------------------------------------------------------------------
Что такое ReentrantLock?

ReentrantLock — Лок на вхождение. Только один поток может зайти в защищенный блок. Класс поддерживает «честную» (fair) и «нечестную» (non-fair) разблокировку потоков. При «честной» разблокировке соблюдается порядок освобождения потоков, вызывающих lock(). При «нечестной» разблокировке порядок освобождения потоков не гарантируется, но, как бонус, такая разблокировка работает быстрее. По умолчанию, используется «нечестная» разблокировка.

--------------------------------------------------------------------------------------------------------------------
Как использовать ReadWriteLock?

Стандартный интерфейс ReadWriteLock предоставляет потокобезопасный разделенный доступ на чтение и на запись. Для этих целей в нём объявлены два метода: readLock() и writeLock(). Они возвращают объекты под интерфейсом Lock.
Оба типа блокировок одного экземпляра ReadWriteLock связаны. Пока какой-то поток не заберет блокировку на запись, сколько угодно потоков могут читать не мешая друг другу. Блокировкой readLock закрывается часть кода с семантикой «только чтения» некоторого условного «ресурса». В критической секции кода writeLock осуществляется модификация ресурса.
Свойства этих локов защищают программу от ситуаций конкурентной записи ресурса и чтения во время записи. Подобно copy-on-write коллекциям, этот подход становится выгодным, когда ресурс читают сильно чаще чем модифицируют.Интерфейс реализуется классом ReentrantReadWriteLock, который во многом похож на обычный ReentrantLock.
--------------------------------------------------------------------------------------------------------------------
Когда используется StampedLock?

StampedLock - примитив синхронизации, добавленный в Java с версии 8. Общий принцип его работы точно такой же, как у ReadWriteLock: захват неэксклюзивной блокировки (на чтение), и эксклюзивной (на запись). Но есть у этих классов ряд различий в деталях.Во-первых, если блокировка ReadWriteLock возвращает объекты типа Lock, то StampedLock возвращает числа типа long, которые и называется «штампами». Штамп служит идентификатором лока, он передается параметром в методы по работе с ранее захваченной блокировкой чтения или записи. Специальный штамп 0 означает неудавшийся захват.
StampedLock в отличие от ReentrantReadWriteLock - не реентрант. Это накладывает бóльшую ответственность на программиста: можно устроить дедлок на одном потоке.В StampedLock расширена функциональность. Новые методы с префиксом try* не висят в ожидании. Методы tryOptimistic* реализуют оптимистичную блокировку. Методы tryConvert* дают возможность изменять «уровень» заблокированности: можно попытаться превратить readLock во writeLock, и наоборот.
Не смотря на похожесть, StampedLock не наследуется от ReadWriteLock. Но для совместимости в нём предусмотрены методы-адаптеры asReadWriteLock, asReadLock и asWriteLock.
Итого, блокировка на штампах решает те же задачи, что ReadWriteLock, но дает больше возможностей и лучшую производительность.
--------------------------------------------------------------------------------------------------------------------
Зачем выбирать ReentrantLock вместо synchronized?

Объект класса ReentrantLock решает те же задачи, что и блок synchronized. Поток висит на вызове метода lock() в ожидании своей очереди занять этот объект. Владеть локом, как и находиться внутри блока synchronized может только один поток одновременно. unlock(), подобно выходу из блока синхронизации, освобождает объект-монитор для других потоков.В отличие от блока синхронизации, ReentrantLock дает расширенный интерфейс для получения информации о состоянии блокировки. Методы лока позволяют еще до блокировки узнать, занят ли он сейчас, сколько потоков ждут его в очереди, сколько раз подряд текущий поток завладел им.Шире и возможные режимы блокировки. Кроме обычного ожидающего lock(), вариант tryLock() с параметром ожидает своей очереди только заданное время, а без параметра - вообще не ждет, а только захватывает свободный лок.Еще одно отличие - свойство fair. Лок с этим свойством обеспечивает «справедливость» очереди: пришедший раньше поток захватывает объект раньше. Блок synchronized не дает никаких гарантий порядка.

--------------------------------------------------------------------------------------------------------------------
Что такое Executor?

Executor - интерфейс, который может выполнять подтвержденные задачи. Интерфейс предоставляет возможность избежать вникания в механику выполнения задачи и деталей использования выполняемого потока. Executor обычно используется для явного создания нитей. Например так:

//Вместо
Thread(new(RunnableTask())).start():
//Лучше использовать
Executor executor = anExecutor;
executor.execute(new RunnableTask1());
executor.execute(new RunnableTask2());
--------------------------------------------------------------------------------------------------------------------
Что такое ExecutorService?

ExecutorService исполняет асинхронный код в одном или нескольких потоках. Создание инстанса ExecutorService'а делается либо вручную через конкретные имплементации (ScheduledThreadPoolExecutor или ThreadPoolExecutor), но проще будет использовать фабрики класса Executors. Например, если надо создать пул с 2мя потоками, то делается это так:
1
ExecutorService service = Executors.newFixedThreadPool(2);
Если требуется использовать кэширующий пул потоков, который создает потоки по мере необходимости, но переиспользует неактивные потоки (и подчищает потоки, которые были неактивные некоторое время), то это задается следующим образом:

ExecutorService service = Executors.newCachedThreadPool();

Если требуется запустить асинхронный код несколько раз, то это будет выполняться так:

ExecutorService service = Executors.newCachedThreadPool();
for(int i = 0; i < 10; i++) {
service.submit(new Runnable() {
public void run() {
// snip... piece of code
}
});
}
Метод submit также возвращает объект Future, который содержит информацию о статусе исполнения переданного Runnable или Callable (который может возвращать значение). Из него можно узнать выполнился ли переданный код успешно, или он еще выполняется. Вызов метода get на объекте Future возвратит значение, который возвращает Callable (или null, если используется Runnable). Метод имеет 2 checked-исключения: InterruptedException, который бросается, когда выполнение прервано через метод interrupt(), или ExecutionException если код в Runnable или Callable бросил RuntimeException, что решает проблему поддержки исключений между потоками.
--------------------------------------------------------------------------------------------------------------------
Что такое ThreadPoolExecutor и зачем он нужен?

ThreadPoolExecutor - реализация ExecutorService. Он выполняет переданную задачу (Callable или Runnable), используя одну из внутренних доступных нитей из пула. Пул потоков содержит в себе ThreadPoolExecutor, который может содержать изменяющееся число нитей. Число нитей в пуле задается с помощью corePoolSize и maximumPoolSize.

--------------------------------------------------------------------------------------------------------------------
Зачем нужен ScheduledExecutorService?

Иногда требуется выполнение кода асихронно и периодически или требуется выполнить код через некоторое время, тогда на помощь приходит ScheduledExecutorService. Он позволяет поставить код выполняться в одном или нескольких потоках и сконфигурировать интервал или время, на которое выполненение будет отложено. Интервалом может быть время между двумя последовательными запусками или время между окончанием одного выполнения и началом другого. Методы ScheduledExecutorService возвращают ScheduledFuture, который также содержит значение отсрочки для выполнения ScheduledFuture.
Если требуется отложить выполнение на 5 секунд, потребуется следующий код:

ScheduledExecutorService service = Executors.newSingleThreadScheduledExecutor();
service.schedule(new Runnable() { ... }, 5, TimeUnit.SECONDS);
Если требуется назначить выполнение каждую секунду:

ScheduledExecutorService service = Executors.newSingleThreadScheduledExecutor();
service.scheduleAtFixedRate(new Runnable() { ... }, 0, 1, TimeUnit.SECONDS);
И, наконец, если требуется назначить выполнение кода с промежутком 1 секунда между выполнениями:
Java

ScheduledExecutorService service = Executors.newSingleThreadScheduledExecutor();
service.scheduleWithFixedDelay(new Runnable() { ... }, 0, 1, TimeUnit.SECONDS);
--------------------------------------------------------------------------------------------------------------------
Что такое ForkJoinPool?

ForkJoinPool - специальный вид ExecutorService (пулла потоков), который появился в Java с версии 7. Предназначен для выполнения рекурсивных задач.Задача для сервиса представляется экземпляром класса ForkJoinTask. В основном используются подклассы RecursiveTask и RecursiveAction, для задач с результатом и без соответственно. Аналогично интерфейсам Callable и Runnable обычного ExecutorService.Тело рекурсивной операции задается в реализации метода compute() задачи ForkJoinTask. Здесь же создаются новые подзадачи, и запускаются параллельно методом fork(). Чтобы дождаться завершения выполнения задачи, на каждой форкнутой подзадаче вызывается блокирующий метод join(), результат выполнения при необходимости агрегируется.С точки зрения использования метод ForkJoinTask.join() похож на аналогичный метод класса Thread. Но в случае fork-join поток может на самом деле не заснуть, а переключиться на выполнение другой задачи. Такая стратегия называется work stealing, и позволяет эффективнее использовать ограниченное количество потоков. Это похоже на переиспользование потоков корутинах Kotlin (green threads).

--------------------------------------------------------------------------------------------------------------------
Какими коллекциями пользоваться в многопоточной среде?

Первый вариант - превратить в синхронизированную обычную коллекцию, вызвав соответствующий ее типу метод Collections.synchronized*(). Самый общий и самый примитивный способ, создает обертку с синхронизацией всех операций с помощью synchronized.

Если работа с коллекцией состоит в основном из чтения, лучшая в плане производительности альтернатива - CopyOnWriteArrayList, и содержащий его в реализации CopyOnWriteArraySet. 
Потокобезопасность достигается копированием внутреннего массива при любой модификации, оригинальный массив остается immutable. 
Program order достигается модификатором volatile на внутреннем массиве.

Третий вариант - использование Concurrent-коллекций:
• Неблокирующие хэш-таблицы ConcurrentSkipListMap, ConcurrentHashMap и ConcurrentSkipListSet (хэш-таблица в основе реализации)
• Неблокирующие очереди ConcurrentLinkedQueue и ConcurrentLinkedDeque
• Большой набор различных блокирующих очередей ArrayBlockingQueue, LinkedBlockingQueue
--------------------------------------------------------------------------------------------------------------------
Как внутри работает CopyOnWriteArrayList?

### **Основной принцип работы**
`CopyOnWriteArrayList` основан на концепции "копирование при записи" (copy-on-write). Это означает, что:
- Внутренние данные хранятся в массиве (`Object[]`).
- При любой модификации (добавление, удаление, обновление) создаётся **новая копия массива**, в которую вносятся изменения, а исходный массив остаётся неизменным.
- Операции чтения (например, `get`, итерация) выполняются на текущем массиве без блокировок, так как он не изменяется во время чтения.

Этот подход обеспечивает:
- **Потокобезопасность**: Все операции чтения и записи безопасны без необходимости явной синхронизации со стороны пользователя.
- **Консистентность данных**: Итераторы работают со "снимком" данных на момент их создания, не видя последующих изменений.
- **Высокую производительность чтения**: Чтение не требует блокировок, что делает его быстрым в многопоточной среде.

Однако за это приходится платить:
- Высокая стоимость операций записи из-за копирования массива.
- Большое потребление памяти при частых модификациях, особенно для больших списков.


### **Внутренняя структура**
`CopyOnWriteArrayList` использует следующие ключевые элементы:

- **Массив `Object[] array`**: Основное хранилище данных. Все элементы списка хранятся в этом массиве.
- **ReentrantLock `lock`**: Используется для синхронизации операций записи, чтобы предотвратить одновременное изменение массива несколькими потоками.
- **Volatile поле для массива**: Ссылка на массив помечена как `volatile`, чтобы гарантировать видимость изменений для всех потоков после завершения записи.

Пример упрощённой внутренней структуры (на основе исходного кода JDK):

```java
public class CopyOnWriteArrayList<E> implements List<E>, RandomAccess, Cloneable, Serializable {
    // Блокировка для операций записи
    final transient ReentrantLock lock = new ReentrantLock();
    // Массив для хранения элементов, помечен как volatile
    private transient volatile Object[] array;
    
    // Конструктор
    public CopyOnWriteArrayList() {
        setArray(new Object[0]);
    }
    
    // Установка нового массива
    final void setArray(Object[] a) {
        array = a;
    }
}
```

- **Volatile**: Гарантирует, что все потоки видят актуальную ссылку на массив после завершения модификации.
- **ReentrantLock**: Используется только для операций записи, чтобы обеспечить эксклюзивный доступ к процессу копирования массива.

---

### **Операции и их реализация**
Рассмотрим, как реализованы основные операции в `CopyOnWriteArrayList`, и как они обеспечивают потокобезопасность.

#### **Операции чтения**
Операции чтения, такие как `get(int index)`, `size()`, или итерация, выполняются **без блокировок**:
- **get(int index)**:
    - Получает текущий массив через `getArray()` (чтение volatile переменной).
    - Возвращает элемент по индексу: `return (E) array[index];`.
    - Поскольку массив неизменяем до следующей операции записи, чтение безопасно для всех потоков.

    - **Сложность**: Очень быстрые (O(1) для `get`), так как не требуют синхронизации.
  
- **Итерация**:
    - Итератор создаётся на основе "снимка" текущего массива (копия ссылки на массив на момент создания итератора).
    - Итератор работает с этим снимком и не видит последующих изменений в списке.
    - Это называется **snapshot-итерация** (не "fail-fast", как в `ArrayList`, а "fail-safe").
    - Итератор не поддерживает операции модификации (например, `remove()` вызовет `UnsupportedOperationException`).


#### **Операции записи**
Операции записи, такие как `add(E element)`, `remove(int index)`, `set(int index, E element)`, используют **блокировку** через `ReentrantLock`:
- **add(E element)**:
    1. Захватывается блокировка (`lock.lock()`).
    2. Получается текущий массив (`Object[] oldArray = getArray()`).
    3. Создаётся новый массив размером `oldArray.length + 1`.
    4. Копируются все элементы из старого массива в новый.
    5. Новый элемент добавляется в конец нового массива.
    6. Ссылка на массив обновляется (`setArray(newArray)`).
    7. Блокировка снимается (`lock.unlock()`).

- **remove(int index)**:
    - Аналогично: захватывается блокировка, создаётся новый массив без удаляемого элемента, обновляется ссылка на массив.
- **set(int index, E element)**:
    - Создаётся копия массива, заменяется элемент по индексу, обновляется ссылка.
    
- **Сложность**: Медленные (O(n) для большинства операций из-за копирования массива).

#### **Ключевые моменты операций записи**:
- **Копирование массива**: Каждая операция записи создаёт новый массив, что делает её дорогостоящей по времени и памяти.
- **Атомарность**: Блокировка (`ReentrantLock`) гарантирует, что только один поток может выполнять модификацию в момент времени.
- **Видимость**: Использование `volatile` для массива обеспечивает, что все потоки видят обновлённый массив после завершения записи.

--------------------------------------------------------------------------------------------------------------------
Как внутри работает CopyOnWriteArraySet?

### **Основной принцип работы**
`CopyOnWriteArraySet` — это обёртка над `CopyOnWriteArrayList`, которая обеспечивает функциональность множества (Set), то есть гарантирует уникальность элементов. Основные характеристики:
- Внутренне хранит элементы в `CopyOnWriteArrayList`.
- Потокобезопасность достигается за счёт создания новой копии внутреннего массива при каждой операции модификации (добавление, удаление).
- Операции чтения выполняются без блокировок, так как работают с неизменяемым "снимком" данных.
- Подходит для сценариев с редкими модификациями и частым чтением.


### **2. Внутренняя структура**
`CopyOnWriteArraySet` не хранит данные напрямую, а делегирует это `CopyOnWriteArrayList`. Ключевые компоненты:
- **Поле `CopyOnWriteArrayList<E> al`**: Единственное поле класса, которое хранит все элементы множества.
- **ReentrantLock** (унаследован от `CopyOnWriteArrayList`): Используется для синхронизации операций записи.
- **Volatile массив** (унаследован от `CopyOnWriteArrayList`): Внутренний массив `Object[]` в `CopyOnWriteArrayList`, помеченный как `volatile` для гарантии видимости изменений.

Упрощённая структура класса (на основе исходного кода JDK):
```java
public class CopyOnWriteArraySet<E> extends AbstractSet<E> implements Serializable {
    private final CopyOnWriteArrayList<E> al;

    public CopyOnWriteArraySet() {
        al = new CopyOnWriteArrayList<E>();
    }
}
```

### **Как работает `CopyOnWriteArraySet`**
Поскольку `CopyOnWriteArraySet` полностью основан на `CopyOnWriteArrayList`, его поведение во многом повторяет поведение списка, но с дополнительной логикой для обеспечения уникальности элементов.

#### **Операции чтения**
- Операции чтения (например, `contains`, `size`, итерация) делегируются напрямую `CopyOnWriteArrayList`:
    - **contains(Object o)**: Проверяет наличие элемента в списке через `al.contains(o)`, что выполняется без блокировок, так как массив неизменяем.
    - **size()**: Возвращает размер списка через `al.size()`.
    - **Итерация**: Итератор создаётся через `al.iterator()`, который возвращает `COWIterator` — итератор, работающий со "снимком" массива на момент создания. Это обеспечивает **fail-safe** итерацию, не видящую последующих изменений.
- Чтение сложность (O(n) для `contains` из-за линейного поиска), так как не требует синхронизации.

#### **Операции записи**
- Операции записи (например, `add`, `remove`) также делегируются `CopyOnWriteArrayList`, но с проверкой уникальности элементов:
    - **add(E e)**:
        1. Захватывается `ReentrantLock` (внутри `CopyOnWriteArrayList`).
        2. Проверяется, содержится ли элемент в списке (`al.contains(e)`).
        3. Если элемент уже есть, операция завершается без изменений (`return false`).
        4. Если элемента нет, вызывается `al.add(e)`, что:
            - Создаёт копию внутреннего массива.
            - Добавляет новый элемент в конец нового массива.
            - Обновляет ссылку на массив (`setArray(newArray)`).
        5. Блокировка снимается.
        - **Запись сложность**: Медленная (O(n) из-за копирования массива и проверки уникальности). Операции добавления и удаления особенно дороги для больших множеств.
    
    - **remove(Object o)**:
        1. Захватывается блокировка.
        2. Создаётся новый массив без указанного элемента (через `al.remove(o)`).
        3. Обновляется ссылка на массив.
        4. Блокировка снимается.

- **Атомарность**: Все операции записи атомарны благодаря `ReentrantLock` в `CopyOnWriteArrayList`.
- **Копирование массива**: Как и в `CopyOnWriteArrayList`, каждая модификация создаёт новый массив, что делает запись дорогостоящей (O(n)).

#### **Уникальность элементов**
- `CopyOnWriteArraySet` гарантирует, что каждый элемент уникален, используя метод `addIfAbsent` из `CopyOnWriteArrayList`.
- Проверка уникальности выполняется линейным поиском (`contains`), что имеет сложность O(n), так как `CopyOnWriteArrayList` не использует хеш-таблицу.

--------------------------------------------------------------------------------------------------------------------
Как ConcurrentHashMap работал до java 8?

До Java 8 `ConcurrentHashMap` использовал совершенно другую архитектуру, основанную на сегментировании (segment-based), которая обеспечивала потокобезопасность с помощью тонкой блокировки.


1. **Сегментированная структура**:
    - Хэш-таблица делилась на фиксированное количество сегментов (по умолчанию 16)
    - Каждый сегмент был независимой хэш-таблицей (похожей на `HashMap`)
    - Сегменты создавались при инициализации и не изменялись

2. **Механизм блокировок**:
    - Каждый сегмент защищался собственной `ReentrantLock`
    - Операции блокировали только нужный сегмент (lock striping)
    - Чтение без блокировок (volatile reads)

3. **Детали реализации**:
   ```java
   final Segment<K,V>[] segments; // Массив сегментов

   static final class Segment<K,V> extends ReentrantLock {
       volatile HashEntry<K,V>[] table; // Хэш-бакеты сегмента
       transient int count; // Количество элементов
   }

   static final class HashEntry<K,V> {
       final K key;
       volatile V value;
       final int hash;
       final HashEntry<K,V> next;
   }
   ```

4. **Характеристики производительности**:
    - Параллелизм = количеству сегментов (по умолчанию 16 потоков)
    - Блокировка на уровне сегмента (меньше contention, чем у `Hashtable`)
    - Нулевая блокировка для операций чтения
    - При достижении размера threshold в сегменте - ресайзинг только этого сегмента

5. **Недостатки**:
    - Фиксированный уровень параллелизма (не масштабировался динамически)
    - Блокировки даже для некоторых read-операций (например, size())
    - Менее эффективное использование памяти из-за фиксированной сегментации

Эта реализация была заменена в Java 8 на более современную, использующую синхронизацию на уровне отдельных бакетов с помощью `synchronized` и CAS-операций, что обеспечило лучшую масштабируемость.

--------------------------------------------------------------------------------------------------------------------
Как внутри работает ConcurrentHashMap?

`ConcurrentHashMap` оптимизирован для конкурентного доступа, обеспечивая:
- **Высокую производительность чтения**: Операции чтения (например, `get`) обычно выполняются без блокировок, благодаря использованию `volatile` полей и атомарных операций.
- **Конкурентные записи**: Операции записи (например, `put`, `remove`) используют блокировки, но только на уровне отдельных сегментов (или бакетов), а не всей структуры.
- **Отсутствие полной блокировки**: В отличие от `Hashtable` или `Collections.synchronizedMap`, которые блокируют всю карту, `ConcurrentHashMap` применяет сегментированную блокировку (lock striping) или неблокирующие алгоритмы (в Java 8+).
- **Потокобезопасность без `null`**: Не допускает `null` в ключах или значениях, чтобы избежать неоднозначностей при конкурентном доступе.

Ключевой принцип: **разделение данных на сегменты (бакеты)** и использование минимально необходимых блокировок для обеспечения конкурентности.

### **Внутренняя структура**
`ConcurrentHashMap` хранит данные в массиве бакетов (таблице), где каждый бакет может содержать связный список или красно-чёрное дерево (в случае высокой коллизии). Основные компоненты:

- **Массив `Node[] table`**: Основное хранилище, где каждый элемент (бакет) — это либо `Node` (для связного списка), либо `TreeBin` (для красно-чёрного дерева).
- **Volatile поля**: Поля, такие как `table` и `next` в узлах, помечены как `volatile` для обеспечения видимости изменений между потоками.
- **CAS-операции** (Compare-And-Swap): Используются для атомарных обновлений, например, при инициализации таблицы или изменении размера.
- **CounterCells**: Специальная структура для подсчёта количества элементов (`size`) в многопоточной среде.

Упрощённая структура (на основе исходного кода JDK):
```java
public class ConcurrentHashMap<K,V> extends AbstractMap<K,V> implements ConcurrentMap<K,V>, Serializable {
    // Основной массив бакетов
    private transient volatile Node<K,V>[] table;
    // Временный массив для ресайзинга
    private transient volatile Node<K,V>[] nextTable;
    // Счётчик элементов (для size())
    private transient volatile long baseCount;
    // Массив для конкурентного подсчёта
    private transient volatile CounterCell[] counterCells;
    // Состояние ресайзинга и инициализации
    private transient volatile int sizeCtl;
}

static class Node<K,V> implements Map.Entry<K,V> {
    final int hash;
    final K key;
    volatile V val; // Значение помечено как volatile
    volatile Node<K,V> next; // Ссылка на следующий узел
}
```

### **Операции и их реализация**

#### **Инициализация таблицы**
- Таблица (`table`) изначально не создаётся (null), чтобы минимизировать память при создании объекта.
- При первой операции `put` или аналогичной таблица инициализируется (обычно с размером 16 бакетов).
- Инициализация выполняется атомарно с использованием CAS (через `sizeCtl`), чтобы только один поток выполнил инициализацию.

#### **Операции чтения (`get`)**
- **get(K key)**:
    1. Вычисляется хэш ключа (`hash = spread(key.hashCode())`).
    2. Определяется индекс бакета (`index = (table.length - 1) & hash`).
    3. Если бакет пуст, возвращается `null`.
    4. Если бакет содержит `Node` (связный список), выполняется линейный поиск по ключу.
    5. Если бакет содержит `TreeBin` (красно-чёрное дерево), поиск выполняется по дереву (O(log n)).
- **Особенности**:
    - Не использует блокировки, так как поля `val` и `next` в `Node` помечены как `volatile`, что гарантирует видимость изменений.
    - Высокая производительность (O(1) в среднем, O(log n) для деревьев).
    - Неблокирующее чтение позволяет множеству потоков одновременно читать данные.

#### **Операции записи (`put`, `remove`)**
- **put(K key, V value)**:
    1. Вычисляется хэш ключа.
    2. Если таблица не инициализирована, выполняется инициализация.
    3. Определяется индекс бакета.
    4. Если бакет пуст, новый узел добавляется атомарно через CAS (без блокировки).
    5. Если бакет занят, используется `synchronized` на первом узле бакета:
        - Для связного списка: проверяется наличие ключа, обновляется значение или добавляется новый узел.
        - Для красно-чёрного дерева: добавление выполняется с балансировкой.
    6. Если бакет становится слишком длинным (по умолчанию 8 узлов), связный список преобразуется в красно-чёрное дерево.
    7. Обновляется счётчик элементов (`addCount`).
- **remove(K key)**:
    - Аналогично `put`, но удаляет узел из бакета (либо из списка, либо из дерева).
- **Особенности**:
    - Блокировка применяется только к конкретному бакету, а не ко всей таблице.
    - CAS используется для оптимизации вставки в пустые бакеты.
    - Если происходит ресайзинг, поток записи помогает завершить его (см. ниже).
    - **Сложноть**: O(1) в среднем для `put`/`remove`, но может быть O(log n) для деревьев. Блокировки ограничены бакетом.

#### **Ресайзинг (увеличение таблицы)**
- Когда таблица заполняется (по умолчанию load factor = 0.75), выполняется расширение:
    1. Создаётся новый массив `nextTable` удвоенного размера.
    2. Потоки, выполняющие операции записи, участвуют в переносе данных (cooperative resizing).
    3. Перенос выполняется по сегментам: каждый поток обрабатывает подмножество бакетов.
    4. Бакеты переносятся с сохранением порядка (для связных списков) или ребалансировкой (для деревьев).
    5. После завершения переноса ссылка `table` обновляется на `nextTable`.
- **Особенности**:
    - Ресайзинг не блокирует чтение: операции `get` работают с текущей таблицей.
    - Потоки записи помогают в ресайзинге, что распределяет нагрузку.

#### **Подсчёт элементов (`size`)**
- Используется структура `CounterCells` для конкурентного подсчёта.
- Каждый поток обновляет свой счётчик в `CounterCells` через CAS, чтобы избежать блокировок.
- Итоговый размер вычисляется суммированием `baseCount` и значений в `CounterCells`.

--------------------------------------------------------------------------------------------------------------------
Как внутри работает ConcurrentSkipListMap?

### **1. Основной принцип работы**
`ConcurrentSkipListMap` использует **skip list** — вероятностную структуру данных, которая обеспечивает эффективный поиск, вставку и удаление (в среднем O(log n)) за счёт многоуровневой организации узлов. Основные характеристики:
- **Потокобезопасность**: Операции чтения и записи выполняются без полной блокировки, используя атомарные операции (Compare-And-Swap, CAS) и `volatile` поля.
- **Упорядоченность**: Ключи хранятся в отсортированном порядке (по естественному порядку или с использованием компаратора).
- **Конкурентность**: Поддерживает высокую степень параллелизма благодаря отсутствию глобальных блокировок и использованию неблокирующих алгоритмов.
- **Отсутствие `null`**: Не допускает `null` в ключах или значениях для устранения неоднозначностей при конкурентном доступе.

Ключевой принцип: **skip list** сочетает простоту связного списка с эффективностью поиска, близкой к бинарному дереву, а потокобезопасность достигается через атомарные обновления и логические удаления.

### **2. Внутренняя структура**
`ConcurrentSkipListMap` основана на структуре skip list, которая представляет собой многоуровневый связный список, где каждый уровень ускоряет поиск за счёт "пропуска" части узлов. Основные компоненты:

- **Узлы (`Node`)**: Хранят пары ключ-значение и ссылки на следующий узел на том же уровне.
- **Индексные узлы (`Index`)**: Формируют дополнительные уровни skip list, указывая на узлы нижних уровней и ускоряя поиск.
- **Голова (`HeadIndex`)**: Указатель на верхний уровень skip list, с которого начинается обход.
- **Volatile поля**: Используются для обеспечения видимости изменений между потоками.
- **CAS-операции**: Применяются для атомарного обновления ссылок и значений.

Упрощённая структура (на основе исходного кода JDK):
```java
public class ConcurrentSkipListMap<K,V> extends AbstractMap<K,V>
    implements ConcurrentNavigableMap<K,V>, Cloneable, Serializable {
    // Голова skip list (указатель на верхний уровень)
    private transient volatile HeadIndex<K,V> head;
    
    // Компаратор для сортировки ключей
    final Comparator<? super K> comparator;

    // Базовый узел, хранящий ключ и значение
    static final class Node<K,V> {
        final K key;
        volatile Object value; // Значение или маркер удаления
        volatile Node<K,V> next; // Ссылка на следующий узел
    }

    // Индексный узел для уровней skip list
    static final class Index<K,V> {
        final Node<K,V> node; // Связь с базовым узлом
        final Index<K,V> down; // Ссылка на нижний уровень
        volatile Index<K,V> right; // Ссылка на следующий индекс на том же уровне
    }

    // Голова skip list
    static final class HeadIndex<K,V> extends Index<K,V> {
        final int level; // Уровень в skip list
    }
}
```

- **Skip List**: Каждый узел может быть связан с несколькими уровнями. Верхние уровни содержат меньше узлов, что ускоряет поиск.
- **Вероятностная структура**: Новые узлы получают случайный уровень (обычно с геометрическим распределением, где вероятность добавления на следующий уровень = 1/2).
- **Маркер удаления**: Вместо физического удаления узлов используется логическое удаление (значение узла помечается как `null` или специальный маркер).

### **Как работает Skip List**
Skip list — это многоуровневый связный список, где:
- **Нижний уровень (уровень 0)**: Содержит все узлы в порядке сортировки, как обычный связный список.
- **Высшие уровни**: Содержат подмножество узлов, что позволяет "перепрыгивать" через узлы при поиске, приближая сложность к O(log n).
- **Вероятностное распределение**: Каждый узел случайным образом получает высоту (количество уровней), что обеспечивает балансировку без сложных операций, как в деревьях.

Пример структуры skip list:
```
Level 3:  Head ----> [10] ----------------> [50]
Level 2:  Head ----> [10] ----> [30] ----> [50]
Level 1:  Head ----> [10] -> [20] -> [30] -> [50]
Level 0:  Head -> [5] -> [10] -> [15] -> [20] -> [30] -> [40] -> [50]
```

- Поиск начинается с верхнего уровня, переходя на нижний, если следующий узел на текущем уровне слишком далеко.


### **Операции и их реализация**

#### **Инициализация**
- При создании `ConcurrentSkipListMap` инициализируется пустой skip list с головой (`HeadIndex`), указывающей на минимальный уровень (0).
- Если задан компаратор, он используется для сортировки ключей; иначе используется естественный порядок (`Comparable`).

#### **Операции чтения (`get`, `containsKey`)**
- **get(K key)**:
  1. Начинается с верхнего уровня (`head`).
  2. Выполняется поиск, двигаясь вправо и вниз, пока не найдётся узел с искомым ключом или его ближайший предшественник.
  3. Если узел найден и не помечен как удалённый (значение не является маркером), возвращается значение.
  4. Если узел не найден или помечен как удалённый, возвращается `null`.
- **Особенности**:
  - Полностью неблокирующая операция, так как использует `volatile` поля (`next`, `right`, `value`) для видимости.
  - Сложность в среднем O(log n), так как skip list позволяет пропускать узлы.
  - Не требует синхронизации, что обеспечивает высокую производительность при чтении.

#### **Операции записи (`put`, `remove`)**
- **put(K key, V value)**:
  1. Выполняется поиск позиции для вставки (аналогично `get`), определяя предшественника и уровень нового узла (случайный, с вероятностью 1/2 для каждого уровня).
  2. Создаётся новый узел (`Node`) с ключом и значением.
  3. Используется CAS для атомарного обновления ссылки `next` у предшественника, чтобы вставить новый узел.
  4. Если узел уже существует, значение обновляется через CAS.
  5. Для каждого уровня создаются индексные узлы (`Index`), которые также вставляются с помощью CAS.
  6. Если CAS не удаётся (другой поток изменил структуру), операция повторяется.
- **remove(K key)**:
  1. Выполняется поиск узла с заданным ключом.
  2. Узел логически помечается как удалённый (значение устанавливается в специальный маркер через CAS).
  3. Ссылки на узел постепенно удаляются с помощью CAS на каждом уровне.
  4. Физическое удаление узлов не выполняется сразу — сборщик мусора очищает их позже.
- **Особенности**:
  - Используются неблокирующие CAS-операции (через `Unsafe` или `VarHandle` в JDK) для обновления ссылок.
  - Логическое удаление минимизирует влияние на другие потоки.
  - Сложность в среднем O(log n) для вставки и удаления.
  - Конфликты CAS (если другой поток изменил структуру) приводят к повторным попыткам, что делает алгоритм lock-free.
--------------------------------------------------------------------------------------------------------------------
Как внутри работает ConcurrentLinkedDeque?

`ConcurrentLinkedDeque` представляет собой двусвязный список, где элементы можно добавлять или удалять с обоих концов (head и tail). Основные характеристики:
- **Потокобезопасность**: Все операции (добавление, удаление, чтение) выполняются без блокировок, используя CAS для атомарного обновления ссылок.
- **Двусторонняя очередь**: Поддерживает операции с начала (`head`) и конца (`tail`) очереди, такие как `addFirst`, `addLast`, `pollFirst`, `pollLast`.
- **Неограниченный размер**: Очередь не имеет фиксированного размера, растёт по мере добавления элементов.
- **Отсутствие `null`**: Не допускает `null` элементы для устранения неоднозначностей при конкурентном доступе.
- **Lock-free алгоритм**: Использует CAS для координации изменений, что минимизирует конкуренцию между потоками.

Ключевой принцип: **неблокирующий двусвязный список**, где атомарные операции обеспечивают корректность изменений даже при одновременном доступе множества потоков.

### **Внутренняя структура**
`ConcurrentLinkedDeque` основана на двусвязном списке, где каждый узел содержит элемент и ссылки на предыдущий и следующий узлы. Основные компоненты:

- **Узлы (`Node`)**: Хранят элемент и ссылки на соседние узлы (`prev` и `next`).
- **Head и Tail**: Указатели на первый и последний узлы списка, обновляемые атомарно.
- **Volatile поля**: Ссылки в узлах (`item`, `prev`, `next`) помечены как `volatile` для обеспечения видимости изменений.
- **CAS-операции**: Используются для атомарного обновления ссылок и элементов.

Упрощённая структура (на основе исходного кода JDK):
```java
public class ConcurrentLinkedDeque<E> extends AbstractCollection<E> implements Deque<E>, Serializable {
    // Указатели на начало и конец списка
    private transient volatile Node<E> head;
    private transient volatile Node<E> tail;

    // Узел двусвязного списка
    private static final class Node<E> {
        volatile E item; // Элемент (или null для удалённых узлов)
        volatile Node<E> prev; // Ссылка на предыдущий узел
        volatile Node<E> next; // Ссылка на следующий узел
    }
}
```

- **Head и Tail**: Указывают на первый и последний активные узлы, но могут временно быть несогласованными из-за конкурентных операций.
- **Node**: Каждый узел хранит элемент и ссылки, причём `item` может быть `null` для обозначения логически удалённого узла.
- **CAS**: Используется через `Unsafe` или `VarHandle` для атомарного обновления полей `prev`, `next` и `item`.


### **Операции и их реализация**
Рассмотрим ключевые операции и как они обеспечивают потокобезопасность.

#### **Инициализация**
- При создании `ConcurrentLinkedDeque` создаётся пустой список, где `head` и `tail` указывают на фиктивный узел (sentinel node) или `null`.
- Первый добавленный элемент инициализирует структуру, создавая первый реальный узел.

#### **Операции добавления (`addFirst`, `addLast`, `offerFirst`, `offerLast`)**
- **addLast(E e)**:
  1. Создаётся новый узел с элементом `e` (`new Node<>(e)`).
  2. Находится текущий `tail` узел.
  3. Проверяется, можно ли добавить новый узел как следующий за `tail`:
    - CAS используется для атомарного обновления `tail.next` на новый узел.
    - Если CAS успешен, обновляется `tail.prev` предыдущего узла и `tail` указатель.
  4. Если CAS не удаётся (другой поток изменил `tail` или `next`), операция повторяется.
- **addFirst(E e)**:
  - Аналогично, но добавление происходит в начало списка, обновляя `head` и `prev`/`next` ссылки.
- **Особенности**:
  - CAS обеспечивает атомарность вставки.
  - Повторные попытки при конфликтах делают операцию lock-free.
  - Сложность в среднем O(1), так как добавление происходит в начало или конец, но конфликты CAS могут увеличить время.

#### **Операции удаления (`pollFirst`, `pollLast`, `removeFirst`, `removeLast`)**
- **pollFirst()**:
  1. Находится текущий `head` узел.
  2. Если `head.item` не `null`, элемент извлекается, а узел логически удаляется:
    - CAS устанавливает `head.item` в `null`.
    - CAS обновляет `head` на следующий узел (`head.next`) и корректирует `prev`/`next` ссылки.
  3. Если `head.item` уже `null` или список пуст, возвращается `null`.
  4. Если CAS не удаётся, операция повторяется.
- **pollLast()**:
  - Аналогично, но работает с `tail`, удаляя последний элемент.
- **Особенности**:
  - Логическое удаление (установка `item` в `null`) минимизирует изменения структуры.
  - Сложность O(1) в среднем, но конфликты CAS могут вызывать повторные попытки.

#### **Операции чтения (`peekFirst`, `peekLast`)**
- **peekFirst()**:
  1. Находится текущий `head` узел.
  2. Возвращается `head.item`, если он не `null`, иначе ищется следующий непустой узел.
- **Особенности**:
  - Полностью неблокирующая операция, так как использует `volatile` поля.
  - Сложность O(1) в среднем, но может быть O(n) в худшем случае, если много удалённых узлов.

#### **Итерация**
- Итераторы (`iterator`, `descendingIterator`) являются **weakly consistent**:
  - Работают со снимком списка на момент создания, обходя узлы через `next` или `prev`.
  - Пропускают узлы с `item == null` (логически удалённые).
  - Не вызывают `ConcurrentModificationException`, но могут не отражать все изменения.
- Итерация неблокирующая, так как использует `volatile` ссылки.

--------------------------------------------------------------------------------------------------------------------
Как внутри работает ArrayBlockingQueue?

### **Основной принцип работы**
`ArrayBlockingQueue` — это ограниченная очередь (bounded queue), которая:
- Хранит элементы в массиве фиксированного размера, заданного при создании.
- Поддерживает FIFO (First-In-First-Out) порядок.
- Использует **одну блокировку** (`ReentrantLock`) для синхронизации всех операций (чтения и записи).
- Применяет **условия** (`Condition`) для блокировки потоков, когда очередь полна (для `put`) или пуста (для `poll`).
- Обеспечивает потокобезопасность, но с меньшей конкурентностью по сравнению с lock-free структурами, такими как `ConcurrentLinkedDeque`.

Ключевой принцип: **блокирующая очередь с фиксированным размером**, где операции добавления и извлечения синхронизируются через одну блокировку, а потоки могут ожидать выполнения условий (например, появления свободного места или элементов).

### **Внутренняя структура**
`ArrayBlockingQueue` использует циклический массив (circular buffer) для хранения элементов, что позволяет эффективно переиспользовать пространство. Основные компоненты:

- **Массив `Object[] items`**: Фиксированного размера, хранит элементы очереди.
- **Индексы**:
  - `takeIndex`: Индекс, указывающий на следующий элемент для извлечения (голова очереди).
  - `putIndex`: Индекс, указывающий на место для добавления следующего элемента (хвост очереди).
- **Счётчик `count`**: Количество элементов в очереди.
- **ReentrantLock `lock`**: Единая блокировка для всех операций.
- **Condition `notEmpty`, `notFull`**: Условия для координации потоков (сигнализируют, когда очередь становится непустой или незаполненной).
- **Volatile поля**: Поля, такие как `count`, могут быть помечены как `volatile` для видимости изменений, хотя основная синхронизация идёт через `lock`.

Упрощённая структура (на основе исходного кода JDK):
```java
public class ArrayBlockingQueue<E> extends AbstractQueue<E> implements BlockingQueue<E>, Serializable {
    // Массив для хранения элементов
    final Object[] items;
    // Индекс для извлечения (голова)
    int takeIndex;
    // Индекс для добавления (хвост)
    int putIndex;
    // Количество элементов
    int count;
    // Единая блокировка
    final ReentrantLock lock;
    // Условие для ожидания непустой очереди
    private final Condition notEmpty;
    // Условие для ожидания свободного места
    private final Condition notFull;
}
```

### **Как работает циклический массив**
`ArrayBlockingQueue` использует циклический массив, где:
- Элементы добавляются в `putIndex`, который увеличивается и оборачивается (modulo размер массива), если достигает конца.
- Элементы извлекаются из `takeIndex`, который также оборачивается.
- Это позволяет эффективно использовать фиксированный массив без необходимости сдвига элементов.

Пример:
```
items: [A, B, C, null, null]
takeIndex: 0 (указывает на A)
putIndex: 3 (указывает на следующее свободное место)
count: 3
capacity: 5
```

После добавления `D`:
```
items: [A, B, C, D, null]
takeIndex: 0
putIndex: 4
count: 4
```

После извлечения `A` и добавления `E`:
```
items: [E, B, C, D, null]
takeIndex: 1
putIndex: 0 (обернулся)
count: 4
```


### **Операции и их реализация**
Рассмотрим ключевые операции и их потокобезопасность.

#### **Инициализация**
- При создании задаётся фиксированная ёмкость (`capacity`), и создаётся массив `items` этого размера.
- Инициализируются `lock`, `notEmpty` и `notFull` для синхронизации.
- `takeIndex` и `putIndex` начинаются с 0, `count` равен 0.

#### **Операции добавления (`put`, `offer`, `add`)**
- **put(E e)** (блокирующая):
  1. Захватывается `lock`.
  2. Если очередь полна (`count == items.length`), поток блокируется через `notFull.await()`, ожидая освобождения места.
  3. Элемент добавляется в `items[putIndex]`, `putIndex` увеличивается (с обёртыванием: `putIndex = (putIndex + 1) % capacity`).
  4. Увеличивается `count`.
  5. Сигнализируется `notEmpty.signal()`, чтобы разбудить потоки, ожидающие извлечения.
  6. Блокировка снимается.
  
- **offer(E e)**: Неблокирующая версия, возвращает `false`, если очередь полна.

#### **Операции извлечения (`take`, `poll`)**
- **take()** (блокирующая):
  1. Захватывается `lock`.
  2. Если очередь пуста (`count == 0`), поток блокируется через `notEmpty.await()`, ожидая появления элементов.
  3. Извлекается элемент из `items[takeIndex]`, `takeIndex` увеличивается (с обёртыванием).
  4. Уменьшается `count`, элемент в массиве обнуляется (`items[takeIndex] = null`).
  5. Сигнализируется `notFull.signal()`, чтобы разбудить потоки, ожидающие добавления.
  6. Блокировка снимается.
- **poll()**: Неблокирующая версия, возвращает `null`, если очередь пуста.

#### **Операции чтения (`peek`)**
- **peek()**:
  1. Захватывается `lock`.
  2. Возвращается `items[takeIndex]`, если очередь не пуста, иначе `null`.
  3. Блокировка снимается.
- Сложность O(1), но требует блокировки.

#### **Итерация**
- Итератор создаётся через снимок массива (`Itrs` внутренний класс).
- Итераторы **weakly consistent**, могут не отражать изменения, сделанные после их создания.
- Итерация требует блокировки для доступа к `items`, что снижает конкурентность.

--------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------
