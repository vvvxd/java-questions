Что такое Stream?

Интерфейс java.util.Stream представляет собой последовательность элементов, над которой можно производить различные операции.
Операции над стримами бывают или промежуточными (intermediate) или конечными (terminal). Конечные операции возвращают результат определенного типа, а промежуточные операции возвращают тот же стрим. Таким образом вы можете строить цепочки из несколько операций над одним и тем же стримом.
У стрима может быть сколько угодно вызовов промежуточных операций и последним вызов конечной операции. При этом все промежуточные операции выполняются лениво и пока не будет вызвана конечная операция никаких действий на самом деле не происходит (похоже на создание объекта Thread или Runnable, без вызова start()).
Стримы создаются на основе каких-либо источников, например классов из java.util.Collection.
Ассоциативные массивы (maps), например, HashMap, не поддерживаются.
Операции над стримами могут выполняться как последовательно, так и параллельно.
Потоки не могут быть использованы повторно. Как только была вызвана какая-нибудь конечная операция, поток закрывается.
Кроме универсальных объектных существуют особые виды стримов для работы с примитивными типами данных int, long и double: IntStream, LongStream и DoubleStream. Эти примитивные стримы работают так же, как и обычные объектные, но со следующими отличиями:
- используют специализированные лямбда-выражения, например, IntFunction или IntPredicate вместо Function и Predicate;
- поддерживают дополнительные конечные операции sum(), average(), mapToObj().
--------------------------------------------------------------------------------------------------------------------
Какие существуют способы создания стрима?

Из коллекции:
Stream<String> fromCollection = Arrays.asList("x", "y", "z").stream();
Из набора значений:
Stream<String> fromValues = Stream.of("x", "y", "z");
Из массива:
Stream<String> fromArray = Arrays.stream(new String[]{"x", "y", "z"});
Из файла (каждая строка в файле будет отдельным элементом в стриме):
Stream<String> fromFile = Files.lines(Paths.get("input.txt"));
Из строки:
IntStream fromString = "0123456789".chars();
С помощью Stream.builder():
Stream<String> fromBuilder = Stream.builder().add("z").add("y").add("z").build();
С помощью Stream.iterate() (бесконечный):
Stream<Integer> fromIterate = Stream.iterate(1, n -> n + 1);
С помощью Stream.generate() (бесконечный):
Stream<String> fromGenerate = Stream.generate(() -> "0");
--------------------------------------------------------------------------------------------------------------------
В чем разница между Collection и Stream?

Коллекции позволяют работать с элементами по-отдельности, тогда как стримы так делать не позволяют, но вместо этого предоставляют возможность выполнять функции над данными как над одним целым.
Также стоит отметить важность самой концепции сущностей: Collection - это прежде всего воплощение Структуры Данных. Например, Set не просто хранит в себе элементы, он реализует идею множества с уникальными элементами, тогда как Stream, это прежде всего абстракция необходимая для реализации конвейера вычислений, собственно, поэтому, результатом работы конвейера являются те или иные Структуры Данных или же результаты проверок/поиска и т.п.
--------------------------------------------------------------------------------------------------------------------
Для чего нужен метод collect() в стримах?

Метод collect() является конечной операцией, которая используется для представление результата в виде коллекции или какой-либо другой структуры данных.
collect() принимает на вход Collector<Тип_источника, Тип_аккумулятора, Тип_результата>, который содержит четыре этапа: supplier - инициализация аккумулятора, accumulator - обработка каждого элемента, combiner - соединение двух аккумуляторов при параллельном выполнении, [finisher] - необязательный метод последней обработки аккумулятора. В Java 8 в классе Collectors реализовано несколько распространённых коллекторов:
toList(), toCollection(), toSet() - представляют стрим в виде списка, коллекции или множества;
toConcurrentMap(), toMap() - позволяют преобразовать стрим в Map;
averagingInt(), averagingDouble(), averagingLong() - возвращают среднее значение;
summingInt(), summingDouble(), summingLong() - возвращает сумму;
summarizingInt(), summarizingDouble(), summarizingLong() - возвращают SummaryStatistics с разными агрегатными значениями;
partitioningBy() - разделяет коллекцию на две части по соответствию условию и возвращает их как Map<Boolean, List>;
groupingBy() - разделяет коллекцию на несколько частей и возвращает Map<N, List<T>>;
mapping() - дополнительные преобразования значений для сложных Collector-ов.
Так же существует возможность создания собственного коллектора через Collector.of():

Collector<String, List<String>, List<String>> toList = Collector.of( ArrayList::new, List::add, (l1, l2) -> { l1.addAll(l2); return l1; } );

--------------------------------------------------------------------------------------------------------------------
Расскажите о параллельной обработке в Java 8.

Стримы могут быть последовательными и параллельными. Операции над последовательными стримами выполняются в одном потоке процессора, над параллельными — используя несколько потоков процессора. Параллельные стримы используют общий ForkJoinPool доступный через статический ForkJoinPool.commonPool() метод. При этом, если окружение не является многоядерным, то поток будет выполняться как последовательный. Фактически применение параллельных стримов сводится к тому, что данные в стримах будут разделены на части, каждая часть обрабатывается на отдельном ядре процессора, и в конце эти части соединяются, и над ними выполняются конечные операции.
Для создания параллельного потока из коллекции можно также использовать метод parallelStream() интерфейса Collection.
Чтобы сделать обычный последовательный стрим параллельным, надо вызвать у объекта Stream метод parallel(). Метод isParallel() позволяет узнать является ли стрим параллельным.
С помощью, методов parallel() и sequential() можно определять какие операции могут быть параллельными, а какие только последовательными. Так же из любого последовательного стрима можно сделать параллельный и наоборот:

collection .
stream()
.peek(...) // операция последовательна
.parallel()
.map(...) // операция может выполняться параллельно, .sequential()
.reduce(...) // операция снова
последовательна

Как правило, элементы передаются в стрим в том же порядке, в котором они определены в источнике данных. При работе с параллельными стримами система сохраняет порядок следования элементов. Исключение составляет метод forEach(), который может выводить элементы в произвольном порядке. И чтобы сохранить порядок следования, необходимо применять метод forEachOrdered().

Критерии, которые могут повлиять на производительность в параллельных стримах:
- Размер данных - чем больше данных, тем сложнее сначала разделять данные, а потом их соединять.
- Количество ядер процессора. Теоретически, чем больше ядер в компьютере, тем быстрее программа будет работать. Если на машине одно ядро, нет смысла применять параллельные потоки.
- Чем проще структура данных, с которой работает поток, тем быстрее будут происходить операции. Например, данные из ArrayList легко использовать, так как структура данной коллекции предполагает последовательность несвязанных данных. А вот коллекция типа LinkedList - не лучший вариант, так как в последовательном списке все элементы связаны с предыдущими/последующими. И такие данные трудно распараллелить.
- Над данными примитивных типов операции будут производиться быстрее, чем над объектами классов.
- Крайне не рекомендуется использовать параллельные стримы для скольких-нибудь долгих операций (например, сетевых соединений), так как все параллельные стримы работают c одним ForkJoinPool, то такие долгие операции могут остановить работу всех параллельных стримов в JVM из-за отсутствия доступных потоков в пуле, т.е. параллельные стримы стоит использовать лишь для коротких операций, где счет идет на миллисекунды, но не для тех где счет может идти на секунды и минуты;
- Сохранение порядка в параллельных стримах увеличивает издержки при выполнении и если порядок не важен, то имеется возможность отключить его сохранение и тем самым увеличить производительность, использовав промежуточную
  операцию unordered():

collection.parallelStream()
.sorted()
.unordered() .collect(Collectors.toList());
--------------------------------------------------------------------------------------------------------------------
Какие конечные методы работы со стримами вы знаете?

findFirst() возвращает первый элемент;
findAny() возвращает любой подходящий элемент;
collect() представление результатов в виде коллекций и других структур данных;
count() возвращает количество элементов;
anyMatch() возвращает true, если условие выполняется хотя бы для одного элемента;
noneMatch() возвращает true, если условие не выполняется ни для одного элемента;
allMatch() возвращает true, если условие выполняется для всех элементов;
min() возвращает минимальный элемент, используя в качестве условия Comparator;
max() возвращает максимальный элемент, используя в качестве условия Comparator;
forEach() применяет функцию к каждому объекту (порядок при параллельном выполнении не гарантируется);
forEachOrdered() применяет функцию к каждому объекту с сохранением порядка элементов;
toArray() возвращает массив значений;
reduce()позволяет выполнять агрегатные функции и возвращать один результат.
Для числовых стримов дополнительно доступны:
sum() возвращает сумму всех чисел;
average() возвращает среднее арифметическое всех чисел.
--------------------------------------------------------------------------------------------------------------------
Какие промежуточные методы работы со стримами вы знаете?

filter() отфильтровывает записи, возвращая только записи, соответствующие условию;
skip() позволяет пропустить определённое количество элементов в начале;
distinct() возвращает стрим без дубликатов (для метода equals());
map() преобразует каждый элемент;
peek() возвращает тот же стрим, применяя к каждому элементу функцию;
limit() позволяет ограничить выборку определенным количеством первых элементов;
sorted() позволяет сортировать значения либо в натуральном порядке, либо задавая Comparator;
mapToInt(), mapToDouble(), mapToLong() - аналоги map() возвращающие стрим числовых примитивов;
flatMap(), flatMapToInt(), flatMapToDouble(), flatMapToLong() - похожи на map(), но могут создавать из одного элемента несколько.
Для числовых стримов дополнительно доступен метод mapToObj(), который преобразует числовой стрим обратно в объектный.
--------------------------------------------------------------------------------------------------------------------
Как вывести на экран 10 случайных чисел, используя forEach()

(new Random()) .ints() .limit(10) .forEach(System.out::println

--------------------------------------------------------------------------------------------------------------------
Как можно вывести на экран уникальные квадраты чисел используя метод map()?

Stream .of(1, 2, 3, 2, 1) .map(s -> s * s) .distinct() .forEach(System.out::println);

--------------------------------------------------------------------------------------------------------------------
Как вывести на экран количество пустых строк с помощью метода filter()?

System.out.println( Stream .of("Hello", "", ", ", "world", "!") .filter(String::isEmpty) .count());

--------------------------------------------------------------------------------------------------------------------
Как вывести на экран 10 случайных чисел в порядке возрастания?

(new Random()) .ints() .limit(10) .sorted() .forEach(System.out::println);

--------------------------------------------------------------------------------------------------------------------
Как найти максимальное число в наборе?

Stream .of(5, 3, 4, 55, 2) .mapToInt(a -> a) .max() .getAsInt(); //55

--------------------------------------------------------------------------------------------------------------------
Как найти минимальное число в наборе

Stream .of(5, 3, 4, 55, 2) .mapToInt(a -> a) .min() .getAsInt(); //2

--------------------------------------------------------------------------------------------------------------------
Как получить сумму всех чисел в наборе?

Stream .of(5, 3, 4, 55, 2) .mapToInt() .sum(); //69

--------------------------------------------------------------------------------------------------------------------
Как получить среднее значение всех чисел?

Stream .of(5, 3, 4, 55, 2) .mapToInt(a -> a) .average() .getAsDouble(); //13.8

--------------------------------------------------------------------------------------------------------------------
Какие дополнительные методы для работы с ассоциативными массивами (maps) появились в Java 8?

- putIfAbsent() добавляет пару «ключ-значение», только если ключ отсутствовал:
  map.putIfAbsent("a", "Aa");
- forEach() принимает функцию, которая производит операцию над каждым элементом:
  map.forEach((k, v) -> System.out.println(v));
- compute() создаёт или обновляет текущее значение на полученное в результате вычисления (возможно использовать ключ и текущее значение):
  map.compute("a", (k, v) -> String.valueOf(k).concat(v)); //["a", "aAa"]
- computeIfPresent() если ключ существует, обновляет текущее значение на полученное в результате вычисления (возможно использовать ключ и текущее значение):
  map.computeIfPresent("a", (k, v) -> k.concat(v));
- computeIfAbsent() если ключ отсутствует, создаёт его со значением, которое вычисляется (возможно использовать ключ):
  map.computeIfAbsent("a", k -> "A".concat(k)); //["a","Aa"]
- getOrDefault() в случае отсутствия ключа, возвращает переданное значение по-умолчанию:
  map.getOrDefault("a", "not found");
- merge() принимает ключ, значение и функцию, которая объединяет передаваемое и текущее значения. Если под заданным ключем значение отсутствует, то записывает туда передаваемое значение.
  map.merge("a", "z", (value, newValue) -> value.concat(newValue)); //["a","Aaz"]
--------------------------------------------------------------------------------------------------------------------
empty()

Стрим, как и коллекция, может быть пустым, а значит всем последующем операторам нечего будет обрабатывать.
Stream.empty()
.forEach(System.out::println);
// Вывода нет
--------------------------------------------------------------------------------------------------------------------
of(T value)
of(T... values)

Стрим для одного или нескольких перечисленных элементов. Очень часто вижу, что используют такую конструкцию:

Arrays.asList(1, 2, 3).stream()
.forEach(System.out::println);

однако она излишня. Вот так проще:

Stream.of(1, 2, 3)
.forEach(System.out::println);
--------------------------------------------------------------------------------------------------------------------
ofNullable(T t)

Появился в Java 9. Возвращает пустой стрим, если в качестве аргумента передан null, в противном случае, возвращает стрим из одного элемента.

String str = Math.random() > 0.5 ? "I'm feeling lucky" : null;
Stream.ofNullable(str)
.forEach(System.out::println);
--------------------------------------------------------------------------------------------------------------------
generate(Supplier s)

Возвращает стрим с бесконечной последовательностью элементов, генерируемых функцией Supplier s.

Stream.generate(() -> 6)
.limit(6)
.forEach(System.out::println);
--------------------------------------------------------------------------------------------------------------------
iterate(T seed, UnaryOperator f)

Возвращает бесконечный стрим с элементами, которые образуются в результате последовательного применения функции f к итерируемому значению. Первым элементом будет seed, затем f(seed), затем f(f(seed)) и так далее.

Stream.iterate(2, x -> x + 6)
.limit(6)
.forEach(System.out::println);
// 2, 8, 14, 20, 26, 32
--------------------------------------------------------------------------------------------------------------------
iterate(T seed, Predicate hasNext, UnaryOperator f)

Появился в Java 9. Всё то же самое, только добавляется ещё один аргумент hasNext: если он возвращает false, то стрим завершается. Это очень похоже на цикл for:

for (i = seed; hasNext(i); i = f(i)) {
}

Таким образом, с помощью iterate теперь можно создать конечный стрим.

Stream.iterate(2, x -> x < 25, x -> x + 6)
.forEach(System.out::println);
// 2, 8, 14, 20
--------------------------------------------------------------------------------------------------------------------
concat(Stream a, Stream b)

Объединяет два стрима так, что вначале идут элементы стрима A, а по его окончанию последуют элементы стрима B.

Stream.concat(
Stream.of(1, 2, 3),
Stream.of(4, 5, 6))
.forEach(System.out::println);
// 1, 2, 3, 4, 5, 6
--------------------------------------------------------------------------------------------------------------------
builder()

Создаёт мутабельный объект для добавления элементов в стрим без использования какого-либо контейнера для этого.

Stream.Builder<Integer> streamBuider = Stream.<Integer>builder()
.add(0)
.add(1);
for (int i = 2; i <= 8; i += 2) {
streamBuider.accept(i);
}

streamBuider
.add(9)
.add(10)
.build()
.forEach(System.out::println);
// 0, 1, 2, 4, 6, 8, 9, 10
--------------------------------------------------------------------------------------------------------------------
IntStream.range(int startInclusive, int endExclusive)LongStream.range(long startInclusive, long endExclusive)

Создаёт стрим из числового промежутка [start..end), то есть от start (включительно) по end.

IntStream.range(0, 10)
.forEach(System.out::println);
// 0, 1, 2, 3, 4, 5, 6, 7, 8, 9

LongStream.range(-10L, -5L)
.forEach(System.out::println);
// -10, -9, -8, -7, -6
--------------------------------------------------------------------------------------------------------------------
IntStream.rangeClosed(int startInclusive, int endInclusive)LongStream.rangeClosed(long startInclusive, long endInclusive)

Создаёт стрим из числового промежутка [start..end], то есть от start (включительно) по end (включительно).

IntStream.rangeClosed(0, 5)
.forEach(System.out::println);
// 0, 1, 2, 3, 4, 5
LongStream.range(-8L, -5L)
.forEach(System.out::println);
// -8, -7, -6, -5
--------------------------------------------------------------------------------------------------------------------
Промежуточный оператор filter(Predicate predicate)

Фильтрует стрим, принимая только те элементы, которые удовлетворяют заданному условию.

Stream.of(1, 2, 3)
.filter(x -> x == 10)
.forEach(System.out::print);
// Вывода нет, так как после фильтрации стрим станет пустым
Stream.of(120, 410, 85, 32, 314, 12)
.filter(x -> x > 100)
.forEach(System.out::println);
// 120, 410, 314
--------------------------------------------------------------------------------------------------------------------
Промежуточный оператор map(Function mapper)

Применяет функцию к каждому элементу и затем возвращает стрим, в котором элементами будут результаты функции. map можно применять для изменения типа элементов.

Stream.mapToDouble(ToDoubleFunction mapper)
Stream.mapToInt(ToIntFunction mapper)
Stream.mapToLong(ToLongFunction mapper)
IntStream.mapToObj(IntFunction mapper)
IntStream.mapToLong(IntToLongFunction mapper)
IntStream.mapToDouble(IntToDoubleFunction mapper)

Специальные операторы для преобразования объектного стрима в примитивный, примитивного в объектный, либо примитивного стрима одного типа в примитивный стрим другого.

Stream.of("3", "4", "5")
.map(Integer::parseInt)
.map(x -> x + 10)
.forEach(System.out::println);
// 13, 14, 15

Stream.of(120, 410, 85, 32, 314, 12)
.map(x -> x + 11)
.forEach(System.out::println);
// 131, 421, 96, 43, 325, 23
--------------------------------------------------------------------------------------------------------------------
Промежуточный оператор flatMap(Function<T, Stream<R>> mapper)

Один из самых интересных операторов. Работает как map, но с одним отличием — можно преобразовать один элемент в ноль, один или множество других.

flatMapToDouble(Function mapper)
flatMapToInt(Function mapper)
flatMapToLong(Function mapper)

Как и в случае с map, служат для преобразования в примитивный стрим.Для того, чтобы один элемент преобразовать в ноль элементов, нужно вернуть null, либо пустой стрим. Чтобы преобразовать в один элемент, нужно вернуть стрим из одного элемента, например, через Stream.of(x). Для возвращения нескольких элементов, можно любыми способами создать стрим с этими элементами.

Stream.of(2, 3, 0, 1, 3)
.flatMap(x -> IntStream.range(0, x))
.forEach(System.out::println);
// 0, 1, 0, 1, 2, 0, 0, 1, 2
--------------------------------------------------------------------------------------------------------------------
Промежуточный оператор mapMulti(BiConsumer<T, Consumer<R>> mapper)

Появился в Java 16. Этот оператор похож на flatMap, но использует императивный подход при работе. Теперь вместе с элементом стрима приходит ещё и Consumer, в который можно передать одно или несколько значений, либо не передавать вовсе.

Stream.of(1, 2, 3, 4, 5, 6)
.mapMulti((x, consumer) -> {
if (x % 2 == 0) {
consumer.accept(-x);
consumer.accept(x);
}
})
.forEach(System.out::println);
// -2, 2, -4, 4, -6, 6


mapMultiToDouble(BiConsumer<T, DoubleConsumer> mapper)
mapMultiToInt(BiConsumer<T, IntConsumer> mapper)
mapMultiToLong(BiConsumer<T, LongConsumer> mapper)
--------------------------------------------------------------------------------------------------------------------
Промежуточный оператор limit(long maxSize)

Ограничивает стрим maxSize элементами.

Stream.of(120, 410, 85, 32, 314, 12)
.limit(4)
.forEach(System.out::println);
--------------------------------------------------------------------------------------------------------------------
Промежуточный оператор skip(long n)

Пропускает n элементов стрима.

Stream.of(5, 10)
.skip(40)
.forEach(System.out::println);
// Вывода нет
Stream.of(120, 410, 85, 32, 314, 12)
.skip(2)
.forEach(System.out::println);
// 85, 32, 314, 12
--------------------------------------------------------------------------------------------------------------------
Промежуточный оператор
sorted()
sorted(Comparator comparator)

Сортирует элементы стрима. Причём работает этот оператор очень хитро: если стрим уже помечен как отсортированный, то сортировка проводиться не будет, иначе соберёт все элементы, отсортирует их и вернёт новый стрим, помеченный как отсортированный.

IntStream.range(0, 100000000)
.sorted()
.limit(3)
.forEach(System.out::println);
// 0, 1, 2

IntStream.concat(
IntStream.range(0, 100000000),
IntStream.of(-1, -2))
.sorted()
.limit(3)
.forEach(System.out::println);
// Exception in thread "main" java.lang.OutOfMemoryError: Java heap space

Stream.of(120, 410, 85, 32, 314, 12)
.sorted()
.forEach(System.out::println);
// 12, 32, 85, 120, 314, 410
--------------------------------------------------------------------------------------------------------------------
Промежуточный оператор distinct()

Убирает повторяющиеся элементы и возвращаем стрим с уникальными элементами. Как и в случае с sorted, смотрит, состоит ли уже стрим из уникальных элементов и если это не так, отбирает уникальные и помечает стрим как содержащий уникальные элементы.

Stream.of(2, 1, 8, 1, 3, 2)
.distinct()
.forEach(System.out::println);
// 2, 1, 8, 3
--------------------------------------------------------------------------------------------------------------------
Промежуточный оператор peek(Consumer action)

Выполняет действие над каждым элементом стрима и при этом возвращает стрим с элементами исходного стрима. Служит для того, чтобы передать элемент куда-нибудь, не разрывая при этом цепочку операторов (вы же помните, что forEach — терминальный оператор и после него стрим завершается?), либо для отладки.

Stream.of(0, 3, 0, 0, 5)
.peek(x -> System.out.format("before distinct: %d%n", x))
.distinct()
.peek(x -> System.out.format("after distinct: %d%n", x))
.map(x -> x * x)
.forEach(x -> System.out.format("after map: %d%n", x));
--------------------------------------------------------------------------------------------------------------------
Промежуточный оператор takeWhile(Predicate predicate)

Появился в Java 9. Возвращает элементы до тех пор, пока они удовлетворяют условию, то есть функция-предикат возвращает true. Это как limit, только не с числом, а с условием.

Stream.of(1, 2, 3, 4, 2, 5)
.takeWhile(x -> x < 3)
.forEach(System.out::println);
// 1, 2
--------------------------------------------------------------------------------------------------------------------
Промежуточный оператор dropWhile(Predicate predicate)

Появился в Java 9. Пропускает элементы до тех пор, пока они удовлетворяют условию, затем возвращает оставшуюся часть стрима. Если предикат вернул для первого элемента false, то ни единого элемента не будет пропущено. Оператор подобен skip, только работает по условию.

Stream.of(1, 2, 3, 4, 2, 5)
.dropWhile(x -> x >= 3)
.forEach(System.out::println);
// 1, 2, 3, 4, 2, 5

Stream.of(1, 2, 3, 4, 2, 5)
.dropWhile(x -> x < 3)
.forEach(System.out::println);
// 3, 4, 2, 5
--------------------------------------------------------------------------------------------------------------------
Промежуточный оператор boxed()

Преобразует примитивный стрим в объектный.

DoubleStream.of(0.1, Math.PI)
.boxed()
.map(Object::getClass)
.forEach(System.out::println);
--------------------------------------------------------------------------------------------------------------------
Терминальный оператор void forEach(Consumer action)

Выполняет указанное действие для каждого элемента стрима.

Stream.of(120, 410, 85, 32, 314, 12)
.forEach(x -> System.out.format("%s, ", x));
--------------------------------------------------------------------------------------------------------------------
Терминальный оператор void forEachOrdered(Consumer action)

Выполняет указанное действие для каждого элемента стрима, но перед этим добивается правильного порядка вхождения элементов. Используется для параллельных стримов, когда нужно получить правильную последовательность элементов.

IntStream.range(0, 100000)
.parallel()
.filter(x -> x % 10000 == 0)
.map(x -> x / 10000)
.forEach(System.out::println);
// 5, 6, 7, 3, 4, 8, 0, 9, 1, 2

IntStream.range(0, 100000)
.parallel()
.filter(x -> x % 10000 == 0)
.map(x -> x / 10000)
.forEachOrdered(System.out::println);
// 0, 1, 2, 3, 4, 5, 6, 7, 8, 9
--------------------------------------------------------------------------------------------------------------------
Терминальный оператор long count()

Возвращает количество элементов стрима.

long count = IntStream.range(0, 10)
.flatMap(x -> IntStream.range(0, x))
.count();
System.out.println(count);
// 45

System.out.println(
IntStream.rangeClosed(-3, )
.count()
);
// 10

System.out.println(
Stream.of(0, 2, 9, 13, 5, 11)
.(x -> x 2)
.filter(x -> x % 2 == 1)
.count()
);
// 0
--------------------------------------------------------------------------------------------------------------------
Терминальный оператор R collect(Collector collector)

Один из самых мощных операторов Stream API. С его помощью можно собрать все элементы в список, множество или другую коллекцию, сгруппировать элементы по какому-нибудь критерию, объединить всё в строку и т.д.. В классе java.util.stream.Collectors очень много методов на все случаи жизни, мы рассмотрим их позже. При желании можно написать свой коллектор, реализовав интерфейс Collector.

List<Integer> list = Stream.of(1, 2, 3)
.collect(Collectors.toList());
// list: [1, 2, 3]

String s = Stream.of(1, 2, 3)
.map(String::valueOf)
.collect(Collectors.joining("-", "<", ">"));
// s: "<1-2-3>"
--------------------------------------------------------------------------------------------------------------------
Терминальный оператор R collect(Supplier supplier, BiConsumer accumulator, BiConsumer combiner)

То же, что и collect(collector), только параметры разбиты для удобства. Если нужно быстро сделать какую-то операцию, нет нужды реализовывать интерфейс Collector, достаточно передать три лямбда-выражения.supplier должен поставлять новые объекты (контейнеры), например new ArrayList(), accumulator добавляет элемент в контейнер, combiner необходим для параллельных стримов и объединяет части стрима воедино.

List<String> list = Stream.of("a", "b", "c", "d")
.collect(ArrayList::new, ArrayList::add, ArrayList::addAll);
// list: ["a", "b", "c", "d"]
--------------------------------------------------------------------------------------------------------------------
Терминальный оператор Object[] toArray()

Возвращает нетипизированный массив с элементами стрима.A[] toArray(IntFunction<A[]> generator)Аналогично, только возвращает типизированный массив.

String[] elements = Stream.of("a", "b", "c", "d")
.toArray(String[]::new);
// elements: ["a", "b", "c", "d"]
--------------------------------------------------------------------------------------------------------------------
Терминальный оператор List<T> toList()

Возвращает список, подобно collect(Collectors.toList()). Отличие в том, что теперь возвращаемый список гарантированно нельзя будет модифицировать. Любое добавление или удаление элементов в полученный список будет сопровождаться исключением UnsupportedOperationException.

List<String> elements = Stream.of("a", "b", "c", "d")
.map(String::toUpperCase)
.toList();
// elements: ["A", "B", "C", "D"]
--------------------------------------------------------------------------------------------------------------------
Терминальный оператор
T reduce(T identity, BinaryOperator accumulator)
U reduce(U identity, BiFunction accumulator, BinaryOperator combiner)

Позволяет преобразовать все элементы стрима в один объект. Например, посчитать сумму всех элементов, либо найти минимальный элемент.Сперва берётся объект identity и первый элемент стрима, применяется функция accumulator и identity становится её результатом. Затем всё продолжается для остальных элементов.
int sum = Stream.of(1, 2, 3, 4, 5)
.reduce(10, (acc, x) -> acc + x);
// sum: 25
--------------------------------------------------------------------------------------------------------------------
Терминальный оператор
Optional reduce(BinaryOperator accumulator)

Этот метод отличается тем, что у него нет начального объекта identity. В качестве него служит первый элемент стрима. Поскольку стрим может быть пустой и тогда identity объект не присвоится, то результатом функции служит Optional, позволяющий обработать и эту ситуацию, вернув Optional.empty().

Optional<Integer> result = Stream.<Integer>empty()
.reduce((acc, x) -> acc + x);
System.out.println(result.isPresent());
// false

Optional<Integer> sum = Stream.of(1, 2, 3, 4, 5)
.reduce((acc, x) -> acc + x);
System.out.println(sum.get());
// 15
--------------------------------------------------------------------------------------------------------------------
Терминальный оператор
Optional min(Comparator comparator)
Optional max(Comparator comparator)

Поиск минимального/максимального элемента, основываясь на переданном компараторе.
int min = Stream.of(20, 11, 45, 78, 13)
.min(Integer::compare).get();
// min: 11
int max = Stream.of(20, 11, 45, 78, 13)
.max(Integer::compare).get();
// max: 78
--------------------------------------------------------------------------------------------------------------------
Терминальный оператор Optional findAny()

Возвращает первый попавшийся элемент стрима. В параллельных стримах это может быть действительно любой элемент, который лежал в разбитой части последовательности.

--------------------------------------------------------------------------------------------------------------------
Терминальный оператор Optional findFirst()

Гарантированно возвращает первый элемент стрима, даже если стрим параллельный.Если нужен любой элемент, то для параллельных стримов быстрее будет работать findAny().

int anySeq = IntStream.range(4, 65536)
.findAny()
.getAsInt();
// anySeq: 4

int firstSeq = IntStream.range(4, 65536)
.findFirst()
.getAsInt();
// firstSeq: 4

int anyParallel = IntStream.range(4, 65536)
.parallel()
.findAny()
.getAsInt();
// anyParallel: 32770

int firstParallel = IntStream.range(4, 65536)
.parallel()
.findFirst()
.getAsInt();
// firstParallel: 4
--------------------------------------------------------------------------------------------------------------------
Терминальный оператор boolean allMatch(Predicate predicate)

Возвращает true, если все элементы стрима удовлетворяют условию predicate. Если встречается какой-либо элемент, для которого результат вызова функции-предиката будет false, то оператор перестаёт просматривать элементы и возвращает false.

boolean result = Stream.of(1, 2, 3, 4, 5)
.allMatch(x -> x <= 7);
// result: true
--------------------------------------------------------------------------------------------------------------------
Терминальный оператор boolean anyMatch(Predicate predicate)

Возвращает true, если хотя бы один элемент стрима удовлетворяет условию predicate. Если такой элемент встретился, нет смысла продолжать перебор элементов, поэтому сразу возвращается результат.

boolean result = Stream.of(1, 2, 3, 4, 5)
.anyMatch(x -> x == 3);
// result: true
--------------------------------------------------------------------------------------------------------------------
Терминальный оператор boolean noneMatch(Predicate predicate)

Возвращает true, если, пройдя все элементы стрима, ни один не удовлетворил условию predicate. Если встречается какой-либо элемент, для которого результат вызова функции-предиката будет true, то оператор перестаёт перебирать элементы и возвращает false.
boolean result = Stream.of(1, 2, 3, 4, 5)
.noneMatch(x -> x == 9);
// result: true
--------------------------------------------------------------------------------------------------------------------
Терминальный оператор OptionalDouble average()

Только для примитивных стримов. Возвращает среднее арифметическое всех элементов. Либо Optional.empty, если стрим пуст.
double result = IntStream.range(2, 16)
.average()
.getAsDouble();
// result: 8.5
--------------------------------------------------------------------------------------------------------------------
Терминальный оператор sum()

Возвращает сумму элементов примитивного стрима. Для IntStream результат будет типа int, для LongStream — long, для DoubleStream — double.

long result = LongStream.range(2, 16)
.sum();
// result: 119
--------------------------------------------------------------------------------------------------------------------
Терминальный оператор IntSummaryStatistics summaryStatistics()

Полезный метод примитивных стримов. Позволяет собрать статистику о числовой последовательности стрима, а именно: количество элементов, их сумму, среднее арифметическое, минимальный и максимальный элемент.

LongSummaryStatistics stats = LongStream.range(2, 16)
.summaryStatistics();
System.out.format(" count: %d%n", stats.getCount());
System.out.format(" sum: %d%n", stats.getSum());
System.out.format("average: %.1f%n", stats.getAverage());
System.out.format(" min: %d%n", stats.getMin());
System.out.format(" max: %d%n", stats.getMax());
// count: 14
// sum: 119
// average: 8,5
// min: 2
// max: 15
--------------------------------------------------------------------------------------------------------------------
Collector

Интерфейс java.util.stream.Collector служит для сбора элементов стрима в некоторый мутабельный контейнер. Он состоит из таких методов:
- Supplier\<A> supplier() — функция, которая создаёт экземпляры контейнеров.
- BiConsumer<A,T> accumulator() — функция, которая кладёт новый элемент в контейнер.
- BinaryOperator\<A> combiner() — функция, которая объединяет два контейнера в один. В параллельных стримах каждая часть может собираться в отдельный экземпляр контейнера и в итоге необходимо их объединять в один результирующий.
- Function<A,R> finisher() — функция, которая преобразовывает весь контейнер в конечный результат. Например, можно обернуть List в Collections.unmodifiableList.
- Set<Characteristics> characteristics() — возвращает характеристики коллектора, чтобы внутренняя реализация знала, с чем имеет дело. Например, можно указать, что коллектор поддерживает многопоточность.
  Характеристики: - CONCURRENT — коллектор поддерживает многопоточность, а значит отдельные части стрима могут быть успешно положены в контейнер из другого потока. - UNORDERED — коллектор не зависит от порядка поступаемых элементов. - IDENTITY_FINISH — функция finish() имеет стандартную реализацию (Function.identity()), а значит её можно не вызывать.
--------------------------------------------------------------------------------------------------------------------