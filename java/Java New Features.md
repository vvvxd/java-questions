

</details>

## Java 11

### 1. Что такое новый HTTP Client API в Java 11 и как он работает под капотом?

<details> <summary>Ответ</summary>

**Описание**: Java 11 стандартизировала новый `HttpClient` API (пакет `java.net.http`), который был представлен как инкубационный в Java 9 и доработан в Java 10. Этот API заменяет устаревший `HttpURLConnection`, предоставляя современный способ работы с HTTP/1.1, HTTP/2 и WebSocket.

**Основные возможности**:
- Поддержка синхронных и асинхронных HTTP-запросов.
- Поддержка HTTP/2 с мультиплексированием запросов в одном соединении.
- Интеграция с WebSocket для двунаправленного общения.
- Настраиваемые обработчики ответа (`BodyHandler`) и подписчики (`BodySubscriber`).

**Пример**:
```java
HttpClient client = HttpClient.newBuilder()
    .version(HttpClient.Version.HTTP_2)
    .build();
HttpRequest request = HttpRequest.newBuilder()
    .uri(URI.create("https://example.com"))
    .GET()
    .build();
HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
System.out.println(response.body());
```

**Внутреннее устройство**:
- `HttpClient` использует асинхронную модель, основанную на `CompletableFuture` для неблокирующих операций.
- Реализован на основе NIO (`AsynchronousSocketChannel`) для эффективной работы с сетью.
- Поддерживает пул соединений, который повторно использует TCP-соединения для HTTP/1.1 и HTTP/2.
- Для HTTP/2 используется протокол ALPN (Application-Layer Protocol Negotiation), чтобы договориться о версии протокола с сервером.
- Внутренний движок обрабатывает фреймы HTTP/2 (например, HEADERS, DATA), обеспечивая мультиплексирование запросов.
- `BodyHandler` и `BodySubscriber` позволяют настраивать обработку тела ответа, минимизируя копирование данных.

**Оптимизации**:
- Пул соединений уменьшает накладные расходы на установку соединений.
- Асинхронные запросы используют `ForkJoinPool.commonPool()` для выполнения задач.
- Поддержка прямых буферов (`ByteBuffer`) для эффективной передачи данных.

**Особенности**:
- Поддержка потоковой обработки больших ответов через `BodySubscriber`.
- Гибкая настройка таймаутов, редиректов и прокси.


</details>

---

### 2. Какие новые методы String появились в Java 11 и как они реализованы?

<details> <summary>Ответ</summary>

**Описание**: Java 11 добавила несколько новых методов в класс `String`, упрощающих работу с текстовыми данными: `isBlank()`, `lines()`, `strip()`, `stripLeading()`, `stripTrailing()`, и `repeat()`.

**Список методов**:
- `isBlank()`: проверяет, является ли строка пустой или содержит только пробельные символы.
- `lines()`: возвращает `Stream<String>`, представляющий строки, разделенные символами новой строки.
- `strip()`, `stripLeading()`, `stripTrailing()`: удаляют пробельные символы (включая Unicode) с начала, конца или полностью.
- `repeat(int n)`: повторяет строку заданное количество раз.


</details>

---

### 3. Как работает Epsilon GC в Java 11 и для чего он нужен?

<details> <summary>Ответ</summary>

**Описание**: Epsilon GC — это экспериментальный сборщик мусора, введенный в Java 11 (JEP 318), который вообще не выполняет сборку мусора. Он предназначен для тестирования, отладки и приложений с коротким временем жизни.

**Основные особенности**:
- Выделяет память, но не освобождает её, пока не будет достигнут лимит кучи.
- При переполнении кучи JVM завершает работу с ошибкой `OutOfMemoryError`.
- Полезен для анализа производительности без влияния сборки мусора.

**Пример запуска**:
```bash
java -XX:+UseEpsilonGC -Xmx512m MyApp
```

**Внутреннее устройство**:
- Epsilon GC реализует минималистичный интерфейс сборщика мусора, игнорируя операции освобождения памяти.
- Использует простую стратегию выделения памяти (bump-the-pointer) в куче.
- Не выполняет никаких операций по маркировке или очистке объектов, что минимизирует накладные расходы.
- Поддерживает диагностические инструменты JVM (например, JMX, JFR) для анализа использования памяти.

**Применение**:
- Тестирование приложений для оценки потребления памяти.
- Использование в высокопроизводительных приложениях с коротким жизненным циклом, где сборка мусора не требуется.
- Отладка проблем, связанных с влиянием сборки мусора на производительность.

**Ограничения**:
- Не подходит для долгоживущих приложений из-за отсутствия очистки памяти.
- Требует осторожного управления памятью разработчиком.


</details>

---

### 4. Что такое JEP 254 (Compact Strings) и как оно оптимизирует работу со строками?

<details> <summary>Ответ</summary>

**Описание**: JEP 254, реализованное в Java 9 и доработанное в Java 11, изменило внутреннее представление строк в JVM, перейдя с `char[]` (2 байта на символ) на `byte[]` с выбором кодировки (LATIN1 или UTF16) в зависимости от содержимого строки.

**Как это работает**:
- Если строка содержит только символы Latin-1 (коды 0–255), она хранится в `byte[]` с кодировкой LATIN1, занимая 1 байт на символ.
- Если строка содержит символы вне Latin-1, используется UTF16 (`byte[]` с 2 байтами на символ).
- Поле `coder` в классе `String` указывает используемую кодировку (0 для LATIN1, 1 для UTF16).

**Пример**:
```java
String latin1 = "Hello"; // Хранится в LATIN1 (5 байт)
String unicode = "Привет"; // Хранится в UTF16 (12 байт)
```

**Внутреннее устройство**:
- JVM определяет кодировку при создании строки, анализируя её содержимое.
- Методы `String` (например, `length`, `charAt`) адаптированы для работы с `byte[]` и `coder`.
- Intrinsic-функции JVM оптимизируют операции со строками (например, конкатенацию, сравнение).
- Сериализация и десериализация строк также учитывают кодировку.

**Преимущества**:
- Уменьшение потребления памяти (до 50% для строк, содержащих только Latin-1 символы).
- Ускорение операций со строками благодаря меньшему объему данных.

**Оптимизации**:
- JIT-компилятор инлайн-вызовы методов `String` для обеих кодировок.
- Пул строк (`StringTable`) оптимизирован для хранения `byte[]`.


</details>

---

### 5. Как работает улучшенный `var` для лямбда-выражений в Java 11?

<details> <summary>Ответ</summary>

**Описание**: Java 11 расширила использование ключевого слова `var` (введенного в Java 10) для параметров лямбда-выражений, что позволяет упростить синтаксис, особенно при использовании аннотаций.

**Пример**:
```java
Function<String, String> func = (@NonNull var s) -> s.toUpperCase();
```

**Внутреннее устройство**:
- `var` в лямбда-выражениях — это синтаксический сахар, где компилятор выводит тип параметра на основе функционального интерфейса.
- Аннотации (например, `@NonNull`) применяются к параметру, сохраняя типобезопасность.
- Компилятор генерирует байт-код, аналогичный явному указанию типа, поэтому производительность не изменяется.

**Ограничения**:
- `var` можно использовать только если все параметры лямбда-выражения аннотированы или все используют `var`.
- Тип выводится только на основе целевого функционального интерфейса.

**Преимущества**:
- Упрощает написание лямбда-выражений с аннотациями.
- Сохраняет читаемость кода.


</details>

---

### 7. Как работает ZGC (Z Garbage Collector) в Java 11?

<details> <summary>Ответ</summary>

**Описание**: ZGC — это экспериментальный низколатентный сборщик мусора, введенный в Java 11 (JEP 333), предназначенный для приложений, требующих минимальных пауз (менее 10 мс).

**Основные особенности**:
- Параллельная и конкурентная сборка мусора.
- Поддержка больших куч (до терабайт).
- Минимальные паузы, независимые от размера кучи.

**Внутреннее устройство**:
- ZGC использует **colored pointers** (цветные указатели) и **load barriers** для отслеживания объектов.
- Вместо традиционной маркировки объектов ZGC кодирует метаданные в указателях (64-битные архитектуры).
- Сборка мусора выполняется конкурентно с приложением, перемещая объекты (compaction) без длительных пауз.
- Поддерживает **multi-mapping**: несколько виртуальных адресов для одного физического объекта, что упрощает перемещение объектов.

**Пример запуска**:
```bash
java -XX:+UseZGC -Xmx16g MyApp
```

**Ограничения**:
- Экспериментальный в Java 11, стабилизирован позже (Java 15).
- Требует 64-битной архитектуры.
- Высокое потребление памяти из-за multi-mapping.

**Преимущества**:
- Идеально для приложений реального времени (например, финансовые системы).
- Масштабируемость на больших кучах.


</details>

---

### 8. Как работает поддержка TLS 1.3 в Java 11?

<details> <summary>Ответ</summary>

**Описание**: Java 11 добавила поддержку протокола TLS 1.3 (JEP 332), который обеспечивает улучшенную безопасность и производительность по сравнению с TLS 1.2.

**Основные особенности**:
- Более быстрое установление соединения (1-RTT вместо 2-RTT).
- Улучшенные алгоритмы шифрования.
- Удаление устаревших криптографических алгоритмов.

**Внутреннее устройство**:
- Реализация TLS 1.3 встроена в `SunJSSE` (Java Secure Socket Extension).
- Использует нативные криптографические библиотеки через JNI для ускорения операций (например, AES-GCM).
- Поддерживает новые алгоритмы, такие как ChaCha20-Poly1305.
- JVM автоматически выбирает TLS 1.3, если сервер поддерживает его, с возможностью отката на TLS 1.2.

**Пример**:
```java
SSLSocket socket = (SSLSocket) SSLSocketFactory.getDefault().createSocket("example.com", 443);
socket.setEnabledProtocols(new String[]{"TLSv1.3"});
```

**Оптимизации**:
- Уменьшение количества рукопожатий (handshake) повышает производительность.
- JIT-компилятор оптимизирует криптографические операции.


</details>

---

### 10. Как работает `jlink` и `jdeps` для создания кастомных JRE в Java 11?

<details> <summary>Ответ</summary>

**Описание**: `jlink` (JEP 282) позволяет создавать минималистичные JRE, включающие только необходимые модули. `jdeps` анализирует зависимости приложения.

**Пример**:
```bash
jdeps --module-path mods --print-module-deps MyApp.jar
jlink --module-path mods --add-modules java.base,my.app --output custom-jre
```

**Внутреннее устройство**:
- `jdeps` сканирует байт-код классов, определяя зависимости от модулей JDK и сторонних библиотек.
- `jlink` использует `ModuleLayer` для сборки JRE, включая только указанные модули.
- Созданный JRE содержит минимальный набор классов, библиотек и нативных компонентов.

**Преимущества**:
- Уменьшение размера JRE (например, до 30–50 МБ).
- Улучшение безопасности за счет исключения ненужных модулей.


</details>

---

### 11. Как работает Flight Recorder (JFR) в Java 11?

<details> <summary>Ответ</summary>

**Описание**: Java Flight Recorder (JEP 328) стал open-source в Java 11 и предоставляет инструмент для профилирования и мониторинга приложений с минимальными накладными расходами.

**Основные возможности**:
- Сбор данных о производительности (GC, CPU, I/O, блокировки).
- Поддержка пользовательских событий.
- Интеграция с инструментами, такими как Mission Control.

**Пример**:
```bash
java -XX:StartFlightRecording=duration=60s,filename=recording.jfr MyApp
```

**Внутреннее устройство**:
- JFR встроен в JVM и использует буферы в памяти для записи событий.
- События записываются конкурентно, минимизируя влияние на производительность.
- Поддерживает асинхронную запись в файл или потоковую передачу данных.

**Оптимизации**:
- Низкие накладные расходы (<1% в большинстве случаев).
- JIT-компилятор оптимизирует точки вставки событий.


---

</details>

## Java 17

### 12. Что такое запечатанные классы и интерфейсы (`sealed`) в Java 17 и как они реализованы?

<details> <summary>Ответ</summary>

**Описание**: Запечатанные классы и интерфейсы (`sealed`), стандартизированные в Java 17 (JEP 409) после preview в Java 15–16, позволяют ограничивать, какие классы могут наследоваться от данного класса или реализовывать интерфейс, усиливая контроль над иерархией наследования.

**Пример**:
```java
sealed interface Shape permits Circle, Rectangle, Triangle {}
final class Circle implements Shape {}
final class Rectangle implements Shape {}
non-sealed class Triangle implements Shape {} // Позволяет дальнейшее наследование
```

**Внутреннее устройство**:
- Директива `permits` указывает разрешенные подклассы или реализации, которые должны быть `final`, `sealed` или `non-sealed`.
- Компилятор проверяет, что все подклассы указаны в `permits` и находятся в том же модуле или пакете.
- В байт-коде запечатанные классы содержат метаданные в `PermittedSubclasses` атрибуте, который JVM использует для проверки ограничений наследования.
- JVM обеспечивает соблюдение правил запечатывания во время загрузки классов через `ClassLoader`.

**Особенности**:
- Упрощает анализ иерархии, особенно в сочетании с `switch` выражениями и pattern matching.
- Усиливает инкапсуляцию, предотвра Unused

System: предотвращая нежелательное наследование.
- Полезно для библиотек и фреймворков, где нужно ограничить расширяемость.

**Пример использования в `switch`**:
```java
String describe(Shape shape) {
    return switch (shape) {
        case Circle c -> "Circle with radius " + c.radius();
        case Rectangle r -> "Rectangle with dimensions " + r.width() + "x" + r.height();
        case Triangle t -> "Triangle";
    };
}
```

**Оптимизации**:
- JVM может оптимизировать `switch` на запечатанных типах, используя таблицы переходов (`tableswitch`), так как иерархия фиксирована.
- Компилятор проверяет полноту (`exhaustiveness`) в `switch`, что исключает необходимость в `default`.


</details>

---

### 13. Как работает улучшенный `switch` с pattern matching в Java 17?

<details> <summary>Ответ</summary>

**Описание**: Улучшенный `switch` (JEP 406, стандартизирован в Java 17 после preview в Java 12–14) поддерживает выражения и pattern matching для `instanceof`, упрощая обработку сложных иерархий типов.

**Пример**:
```java
Object obj = "Hello";
String result = switch (obj) {
    case String s -> "String: " + s;
    case Integer i -> "Integer: " + i;
    case null -> "Null value";
    default -> "Unknown";
};
```

**Внутреннее устройство**:
- `switch` выражения компилируются в байт-код, аналогичный условным операторам, но с оптимизациями для компактности.
- Pattern matching использует инструкцию `instanceof` с автоматическим приведением типа, что устраняет необходимость явного кастинга.
- Для `switch` на запечатанных классах компилятор проверяет полноту, гарантируя, что все возможные подтипы учтены.
- Поддержка `null` в `switch` реализована через специальную проверку в байт-коде, что делает обработку null-safe.

**Особенности**:
- Поддержка `yield` для возврата значений из блочного `switch`:
  ```java
  int value = switch (obj) {
      case String s -> { yield s.length(); }
      default -> 0;
  };
  ```
- Полнота проверки для `sealed` типов исключает ошибки времени выполнения.
- Поддержка `null` как отдельного случая.

**Оптимизации**:
- JVM использует `tableswitch` или `lookupswitch` для оптимизации переходов в `switch`.
- JIT-компилятор инлайн-вызовы для pattern matching, минимизируя накладные расходы.


</details>

---

### 14. Что такое записи (`record`) и как они работают в Java 17?

<details> <summary>Ответ</summary>

**Описание**: Записи (`record`), стандартизированные в Java 16 (JEP 395) и унаследованные в Java 17, предоставляют компактный синтаксис для создания неизменяемых классов данных, автоматически генерируя конструктор, геттеры, `equals`, `hashCode` и `toString`.

**Пример**:
```java
record Person(String name, int age) {
    public Person { // Компактный конструктор
        if (age < 0) throw new IllegalArgumentException("Age cannot be negative");
    }
}
Person person = new Person("Alice", 30);
System.out.println(person.name()); // Alice
```

**Внутреннее устройство**:
- `record` компилируется в `final` класс, унаследованный от `java.lang.Record`.
- Компилятор автоматически генерирует:
   - Приватные `final` поля для каждого компонента.
   - Публичные геттеры (именованные по компонентам, без префикса `get`).
   - Конструктор, проверяющий входные данные.
   - Реализации `equals`, `hashCode` и `toString`, учитывающие все компоненты.
- Компоненты доступны через методы, а не напрямую как поля.
- Поддерживает компактные конструкторы для валидации и дополнительные методы.

**Оптимизации**:
- JIT-компилятор инлайн-вызовы геттеров и методов `equals`/`hashCode`.
- Поля хранятся в компактной форме, минимизируя потребление памяти.
- Сериализация записей оптимизирована для сохранения неизменяемости.

**Особенности**:
- Неизменяемость по умолчанию (поля `final`).
- Поддержка аннотаций на компонентах и дополнительных методов.
- Совместимость с `sealed` классами для создания иерархий данных.


</details>

---

### 15. Как работает новый API генерации случайных чисел (`RandomGenerator`) в Java 17?

<details> <summary>Ответ</summary>

**Описание**: Java 17 представила интерфейс `RandomGenerator` (JEP 356), унифицирующий API для генерации случайных чисел и добавляющий новые алгоритмы, такие как Xoshiro и LXM.

**Основные возможности**:
- Единый интерфейс для всех генераторов случайных чисел (`Random`, `SecureRandom`, `SplittableRandom`).
- Новые алгоритмы: Xoshiro256++, Xoshiro512++, LXM.
- Поддержка потоков (`Stream`) для генерации случайных чисел.

**Пример**:
```java
RandomGenerator rng = RandomGenerator.of("Xoshiro256PlusPlus");
int randomInt = rng.nextInt(100);
DoubleStream doubles = rng.doubles(10); // Поток из 10 случайных чисел
doubles.forEach(System.out::println);
```

**Внутреннее устройство**:
- `RandomGenerator` — это интерфейс с реализациями для различных алгоритмов.
- Xoshiro256++ и Xoshiro512++ — высокопроизводительные алгоритмы с хорошей статистической случайностью.
- LXM — гибридный алгоритм, комбинирующий LCG (Linear Congruential Generator) и Xorshift.
- Реализации используют нативные intrinsic-функции JVM для оптимизации вычислений.
- Поддержка потоков реализована через `Spliterator`, что интегрируется с Stream API.


</details>

---

### 16. Как работает восстановленный AOT (Ahead-of-Time) Compilation и GraalVM в Java 17?

<details> <summary>Ответ</summary>

**Описание**: Java 17 восстановила поддержку Ahead-of-Time Compilation (JEP 410, экспериментальная) и улучшила интеграцию с GraalVM, позволяя компилировать Java-приложения в нативные исполняемые файлы.

**Основные возможности**:
- AOT-компиляция преобразует байт-код в нативный код до запуска, уменьшая время старта.
- GraalVM используется как компилятор для AOT, заменяя устаревший `jaotc` из Java 9–11.
- Поддержка создания нативных образов с помощью `native-image` (вне JDK).

**Пример**:
```bash
native-image --no-fallback -cp MyApp.jar MyApp
```

**Внутреннее устройство**:
- GraalVM использует анализ точек входа (points-to analysis) для определения используемых классов и методов.
- AOT-компиляция исключает ненужные части JDK, создавая компактный исполняемый файл.
- JVM поддерживает AOT-скомпилированные библиотеки через загрузчик `.so`/`.dll` файлов.
- GraalVM оптимизирует код, используя агрессивное инлайнинг и удаление неиспользуемого кода (dead code elimination).

**Преимущества**:
- Уменьшение времени запуска (до 10–100 раз быстрее для небольших приложений).
- Снижение потребления памяти (до 5 раз по сравнению с JIT).
- Идеально для серверлесс-приложений и контейнеров.

**Ограничения**:
- Ограниченная поддержка рефлексии и динамической загрузки классов.
- Экспериментальный статус в Java 17.


</details>

---

### 17. Что такое улучшения в `java.nio.file` в Java 17?

<details> <summary>Ответ</summary>

**Описание**: Java 17 добавила новые методы в `java.nio.file.Files` для упрощения работы с файлами, такие как `readString` и `writeString`.

**Пример**:
```java
Path path = Path.of("file.txt");
Files.writeString(path, "Hello, World!");
String content = Files.readString(path);
System.out.println(content); // Hello, World!
```

**Внутреннее устройство**:
- `Files.readString` использует `FileChannel` и `ByteBuffer` для чтения файла в память, затем декодирует байты с помощью указанной кодировки (по умолчанию UTF-8).
- `Files.writeString` кодирует строку в байты и записывает их через `FileChannel`.
- Методы оптимизированы для работы с небольшими файлами, минимизируя копирование данных.
- Используют нативные вызовы через JNI для операций с файлами.

**Оптимизации**:
- Прямое использование буферов NIO снижает накладные расходы.
- JIT-компилятор инлайн-вызовы методов `Files`.

**Преимущества**:
- Упрощает чтение и запись текстовых файлов, заменяя многострочные конструкции с `BufferedReader`/`BufferedWriter`.
- Поддержка кодировок через `Charset`.



</details>

## Java 21

### 22. Что такое виртуальные потоки (Virtual Threads) в Java 21 и как они реализованы?

<details> <summary>Ответ</summary>

Виртуальные потоки — это легковесные потоки (lightweight threads), управляемые самой JVM, а не операционной системой (ОС). В отличие от традиционных потоков Java (которые мы теперь называем **платформенными потоками** или platform threads), виртуальные потоки не привязаны 1:1 к потокам ОС на протяжении всего своего жизненного цикла.

Основная идея в том, чтобы позволить приложениям создавать огромное количество (миллионы) виртуальных потоков, которые могут выполнять блокирующие операции ввода-вывода (I/O) без значительного расходования системных ресурсов.

**Зачем они нужны? (Проблема, которую они решают)**

1.  **Ограничения платформенных потоков:**
  *   **Дорогие:** Платформенные потоки являются обертками над потоками ОС. Создание и управление потоками ОС — ресурсоемкая операция (память на стек, контекстные переключения на уровне ядра).
  *   **Ограниченное количество:** Из-за их "тяжеловесности" вы не можете создать миллионы платформенных потоков. Обычно их количество ограничивается несколькими тысячами.
  *   **Блокировка ввода-вывода:** Когда платформенный поток выполняет блокирующую операцию (например, чтение из сокета, запрос к БД), он блокирует поток ОС, на котором он работает. Этот поток ОС простаивает, потребляя ресурсы, пока операция не завершится.

2.  **Сложность асинхронного программирования:**
  *   Чтобы обойти проблему блокировки, разработчики прибегали к асинхронным/реактивным моделям (Callbacks, Futures, CompletableFuture, RxJava, Project Reactor).
  *   Такой код часто сложнее писать, читать, отлаживать и профилировать (например, "callback hell", сложные цепочки вызовов, неинформативные стектрейсы).

**Виртуальные потоки предлагают лучшее из двух миров:**
*   **Простота синхронного кода:** Вы пишете код в привычном императивном, блокирующем стиле.
*   **Масштабируемость асинхронного кода:** Приложение может обслуживать огромное количество одновременных операций.


Магия виртуальных потоков заключается в том, как JVM управляет их выполнением на платформенных потоках.

1.  **Carrier Threads (Несущие потоки):**
  *   Виртуальные потоки выполняются на платформенных потоках. Эти платформенные потоки называются **несущими потоками (carrier threads)**.
  *   Обычно используется небольшой пул несущих потоков (по умолчанию это `ForkJoinPool`, количество потоков в котором часто равно количеству ядер процессора).
  *   Один несущий поток может поочередно выполнять код множества разных виртуальных потоков.

2.  **Mounting (Монтирование) и Unmounting (Демонтирование):**
  *   Когда виртуальный поток готов к выполнению, он **монтируется** на несущий поток. Код виртуального потока начинает исполняться.
  *   **Ключевой момент:** Если виртуальный поток выполняет блокирующую операцию ввода-вывода (которая была адаптирована для работы с Project Loom, например, операции с сокетами, `Thread.sleep()`, `LockSupport.park()` и некоторые другие JDK-операции синхронизации), происходит следующее:
    *   Виртуальный поток **демонтируется** с несущего потока.
    *   Несущий поток **освобождается** и может быть использован для монтирования и выполнения другого виртуального потока.
    *   Состояние демонтированного виртуального потока (его стек) сохраняется в куче (heap) Java. Он не потребляет поток ОС.
  *   Когда блокирующая операция завершается (например, пришли данные из сети), виртуальный поток становится готов к продолжению выполнения. JVM планирует его для повторного монтирования на доступный несущий поток.

3.  **Continuations (Продолжения) / Stack Slicing:**
  *   Внутренне это достигается с помощью механизма, называемого **продолжениями (continuations)** или **stack slicing (нарезка стека)**.
  *   Стек виртуального потока не хранится целиком в виде одного большого блока памяти, как у платформенных потоков. Вместо этого он может быть разбит на небольшие части (сегменты или "чанки"), которые хранятся как обычные Java-объекты в куче.
  *   Это позволяет легко "приостанавливать" виртуальный поток (сохраняя его нарезанный стек в куче) и "возобновлять" его позже.

4.  **Планировщик (Scheduler):**
  *   JVM имеет внутренний планировщик (по умолчанию используется `ForkJoinPool`), который решает, какой виртуальный поток будет выполняться на каком несущем потоке.
  *   Этот планировщик оптимизирован для работы с большим количеством короткоживущих или часто блокирующихся задач.

| Характеристика        | Платформенные потоки (Platform Threads)                                  | Виртуальные потоки (Virtual Threads)                                   |
| :-------------------- | :----------------------------------------------------------------------- | :--------------------------------------------------------------------- |
| **Основа**            | Обертка над потоком ОС (1:1 mapping)                                     | Управляются JVM, легковесные, не привязаны к потоку ОС постоянно (M:N) |
| **Ресурсоемкость**    | Высокая (стек ОС ~1MB+, ресурсы ядра)                                    | Низкая (небольшие объекты в куче для стека, стек растет по мере надобности) |
| **Количество**        | Ограничено (тысячи)                                                      | Очень большое (миллионы)                                               |
| **Время создания**    | Относительно долго                                                       | Очень быстро                                                           |
| **Блокировка I/O**    | Блокирует поток ОС (и несущий платформенный поток)                       | Демонтируется с несущего потока, несущий поток освобождается           |
| **Пулинг**            | Часто необходим из-за высокой стоимости создания                        | Обычно не нужен (создавайте новый виртуальный поток для каждой задачи) |
| **`ThreadLocal`**     | Работают как обычно                                                      | Работают, но могут быть проблемы с производительностью или памятью при ОЧЕНЬ большом количестве виртуальных потоков, если `ThreadLocal` хранит много данных или часто используется. Стоит использовать с осторожностью. |
| **Синхронизация**     | `synchronized` блокирует платформенный поток                           | `synchronized` при блокировке "прибивает" (pins) виртуальный поток к несущему потоку, не давая несущему потоку освободиться. Это может снизить преимущества виртуальных потоков. Рекомендуется использовать `java.util.concurrent.locks.ReentrantLock` и другие примитивы `java.util.concurrent`. |
| **Стек вызовов**      | Традиционный стек                                                        | "Нарезанный" стек, хранимый в куче                                     |
| **Прерывание**        | Стандартное (`interrupt()`)                                              | Стандартное (`interrupt()`)                                              |
| **Использование**     | Длительные задачи, задачи, интенсивно использующие CPU, ограниченное кол-во | Короткие задачи, задачи, часто блокирующиеся на I/O, массовая параллельность |



</details>

---

### 23. Как работает улучшенный pattern matching для `switch` в Java 21?

<details> <summary>Ответ</summary>

**Описание**: Pattern matching для `switch` (JEP 441, стандартизирован в Java 21 после preview в Java 17–20) расширяет возможности `switch`, добавляя поддержку проверки типов, `null` и сложных шаблонов, таких как `record` и массивы.

**Пример**:
```java
Object obj = new Point(1, 2);
String result = switch (obj) {
    case null -> "Null";
    case Point(int x, int y) when x > 0 -> "Positive point: " + x + "," + y;
    case Point(int x, int y) -> "Point: " + x + "," + y;
    case String s -> "String: " + s;
    default -> "Unknown";
};
record Point(int x, int y) {}
```

**Внутреннее устройство**:
- Компилятор преобразует `switch` с pattern matching в байт-код, использующий `instanceof` и условные переходы.
- Для `record` шаблонов компилятор автоматически декомпозирует компоненты, вызывая геттеры (например, `x()` и `y()` для `Point`).
- Поддержка `when` (guard clauses) реализуется через условные операторы в байт-коде.
- Проверка полноты (`exhaustiveness`) для `sealed` типов гарантирует, что все подтипы учтены, исключая необходимость `default` в некоторых случаях.
- Поддержка `null` реализована через отдельную проверку в байт-коде перед выполнением `switch`.

**Особенности**:
- Поддержка вложенных шаблонов (например, `case Point(Point p1, Point p2)`).
- Условия `when` позволяют добавлять дополнительные проверки в шаблонах.
- Полнота проверки для `sealed` классов и перечислений.

**Оптимизации**:
- JVM использует `tableswitch` или `lookupswitch` для оптимизации переходов в `switch`.
- JIT-компилятор инлайн-вызовы геттеров и проверок `instanceof`, минимизируя накладные расходы.
- Проверка полноты выполняется на этапе компиляции, что исключает ошибки времени выполнения.

**Преимущества**:
- Упрощает обработку сложных иерархий типов.
- Уменьшает шаблонный код, заменяя цепочки `instanceof` и приведения типов.


</details>

---

### 24. Что такое `Sequenced Collections` в Java 21 и как они реализованы?

<details> <summary>Ответ</summary>

**Описание**: `Sequenced Collections` (JEP 431) вводят новый интерфейс `SequencedCollection` и связанные интерфейсы (`SequencedSet`, `SequencedMap`), добавляя методы для упорядоченного доступа к элементам коллекций.

**Основные возможности**:
- Методы: `getFirst()`, `getLast()`, `addFirst()`, `addLast()`, `removeFirst()`, `removeLast()`, `reversed()`.
- Применимо к коллекциям с определенным порядком (например, `List`, `LinkedHashSet`, `LinkedHashMap`).

**Пример**:
```java
SequencedCollection<String> list = new ArrayList<>();
list.addLast("A");
list.addLast("B");
System.out.println(list.getFirst()); // A
System.out.println(list.reversed()); // [B, A]
```

**Внутреннее устройство**:
- `SequencedCollection` — это новый интерфейс, унаследованный `Collection`, добавляющий методы для работы с первым и последним элементами.
- Реализации (`ArrayList`, `LinkedList`, `LinkedHashSet`, `LinkedHashMap`) обновлены для поддержки новых методов.
- Метод `reversed()` возвращает представление (`view`) коллекции в обратном порядке, не создавая копию данных.
- Для `SequencedMap` добавлены методы `firstEntry()`, `lastEntry()`, `putFirst()`, `putLast()`.


</details>

---

### 25. Как работает `String Templates` в Java 21 и что происходит под капотом?

<details> <summary>Ответ</summary>

**Описание**: `String Templates` (JEP 430, preview в Java 21) — это механизм для упрощения создания строк с динамическими значениями, заменяющий конкатенацию и `String.format`.

**Пример**:
```java
String name = "Alice";
String template = STR."Hello, \{name}!"; // Hello, Alice!
```

**Внутреннее устройство**:
- `STR` — это встроенный процессор шаблонов, предоставляемый JVM.
- Шаблон компилируется в байт-код, где выражения (`\{...}`) вычисляются отдельно, а затем передаются в процессор шаблонов.
- `StringTemplate` — это объект, содержащий статические части шаблона и вычисленные значения.
- Процессор шаблонов (например, `STR`) комбинирует части в итоговую строку.
- Поддерживает пользовательские процессоры для кастомной обработки (например, для SQL-запросов или JSON).

**Пример пользовательского процессора**:
```java
StringTemplate.Processor<String, RuntimeException> MY_PROC = (st) -> 
    st.interpolate().toUpperCase();
String result = MY_PROC."Hello, \{name}!"; // HELLO, ALICE!
```

**Оптимизации**:
- JIT-компилятор оптимизирует вызовы процессоров шаблонов, инлайнинг статических частей.
- Использование `StringBuilder` для сборки строк минимизирует накладные расходы.
- Выражения в шаблонах вычисляются лениво, только если используются.

**Преимущества**:
- Более читаемый и безопасный синтаксис по сравнению с `String.format`.
- Защита от инъекций (например, в SQL) при использовании специализированных процессоров.

**Ограничения**:
- Экспериментальный статус в Java 21 (стабилизирован позже).


</details>

---

### 26. Как работает улучшенный `Foreign Function & Memory API` в Java 21?

<details> <summary>Ответ</summary>

**Описание**: `Foreign Function & Memory API` (JEP 442, третья версия preview в Java 21) позволяет вызывать нативные функции и управлять памятью вне кучи JVM, продолжая развитие API из Java 17.

**Пример**:
```java
try (var arena = Arena.ofConfined()) {
    var segment = arena.allocate(100);
    var printf = Linker.nativeLinker().downcallHandle(
        Linker.nativeLinker().defaultLookup().find("printf").orElseThrow(),
        FunctionDescriptor.ofVoid(ValueLayout.ADDRESS)
    );
    printf.invoke(segment);
}
```

**Внутреннее устройство**:
- **Arena**: управляет жизненным циклом нативной памяти, заменяя `MemorySession` из предыдущих версий.
- **MemorySegment**: представляет участок памяти вне кучи, поддерживая безопасное выделение и доступ.
- **Linker**: использует `MethodHandle` для вызова нативных функций через `invokedynamic`.
- Поддерживает структурированную память (например, для C-структур) через `MemoryLayout`.

**Оптимизации**:
- Прямой доступ к нативной памяти минимизирует копирование данных.
- JIT-компилятор оптимизирует вызовы нативных функций через `invokedynamic`.
- `Arena` автоматически освобождает память при закрытии, предотвращая утечки.

**Преимущества**:
- Упрощает интеграцию с нативным кодом (например, C/C++ библиотеками).
- Безопаснее и производительнее, чем JNI.

**Ограничения**:
- Экспериментальный статус в Java 21 (стабилизирован в Java 22).


</details>

---

### 27. Как работает `Key Encapsulation Mechanism API` в Java 21?

<details> <summary>Ответ</summary>

**Описание**: `Key Encapsulation Mechanism (KEM) API` (JEP 452) вводит поддержку криптографических алгоритмов KEM, таких как Kyber, для постквантовой криптографии.

**Пример**:
```java
KeyPairGenerator kpg = KeyPairGenerator.getInstance("Kyber");
KeyPair kp = kpg.generateKeyPair();
Cipher cipher = Cipher.getInstance("Kyber");
cipher.init(Cipher.WRAP_MODE, kp.getPublic());
byte[] wrappedKey = cipher.wrap(kp.getPrivate());
```

**Внутреннее устройство**:
- Реализован в пакете `javax.crypto`, интегрирован с `SunJCE` провайдером.
- Использует нативные криптографические библиотеки через JNI для реализации KEM (например, Kyber).
- Поддерживает гибридные схемы шифрования, комбинирующие KEM с традиционными алгоритмами.




</details>

---

### 29. Как работает `Unnamed Classes and Instance Main Methods` в Java 21?

<details> <summary>Ответ</summary>

**Описание**: `Unnamed Classes and Instance Main Methods` (JEP 445, preview в Java 21) упрощают создание простых программ, позволяя определять `main` методы без явного объявления класса.

**Пример**:
```java
void main() {
    System.out.println("Hello, World!");
}
```

**Внутреннее устройство**:
- Компилятор автоматически создает неназванный класс, содержащий метод `main`.
- Поддерживает как статические, так и экземплярные `main` методы.
- JVM загружает неназванный класс через стандартный `ClassLoader`.

**Оптимизации**:
- Минимальные накладные расходы, так как неназванный класс компилируется как обычный класс.
- JIT-компилятор оптимизирует вызов `main`.

**Преимущества**:
- Упрощает написание простых программ для обучения.
- Снижает барьер входа для новичков.


</details>

---

### 30. Как работает `Structured Concurrency` в Java 21?

<details> <summary>Ответ</summary>

**Описание**: `Structured Concurrency` (JEP 453, preview в Java 21) предоставляет API для структурированной работы с задачами в виртуальных потоках, упрощая управление параллельными операциями.

**Пример**:
```java
try (var scope = StructuredTaskScope.ShutdownOnFailure()) {
    var future1 = scope.fork(() -> fetchData("url1"));
    var future2 = scope.fork(() -> fetchData("url2"));
    scope.join();
    System.out.println(future1.get() + ", " + future2.get());
}
```

**Внутреннее устройство**:
- `StructuredTaskScope` управляет группой виртуальных потоков, обеспечивая их завершение в определенном порядке.
- Поддерживает политики завершения (например, `ShutdownOnFailure`, `ShutdownOnSuccess`).
- Использует виртуальные потоки для выполнения задач, минимизируя накладные расходы.

**Оптимизации**:
- Интеграция с `ForkJoinPool` для эффективного распределения задач.
- JIT-компилятор оптимизирует вызовы `fork` и `join`.

**Преимущества**:
- Упрощает управление параллельными задачами.
- Предотвращает утечки ресурсов благодаря структурированному завершению.
