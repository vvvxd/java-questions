### Java 11
1. [Что такое новый HTTP Client API в Java 11 и как он работает под капотом?](#1-что-такое-новый-http-client-api-в-java-11-и-как-он-работает-под-капотом)
2. [Какие новые методы String появились в Java 11 и как они реализованы?](#2-какие-новые-методы-string-появились-в-java-11-и-как-они-реализованы)
3. [Как работает Epsilon GC в Java 11 и для чего он нужен?](#3-как-работает-epsilon-gc-в-java-11-и-для-чего-он-нужен)
4. [Что такое JEP 254 (Compact Strings) и как оно оптимизирует работу со строками?](#4-что-такое-jep-254-compact-strings-и-как-оно-оптимизирует-работу-со-строками)
5. [Как работает улучшенный `var` для лямбда-выражений в Java 11?](#5-как-работает-улучшенный-var-для-лямбда-выражений-в-java-11)
6. [Что такое улучшения в `Optional` в Java 11?](#6-что-такое-улучшения-в-optional-в-java-11)
7. [Как работает ZGC (Z Garbage Collector) в Java 11?](#7-как-работает-zgc-z-garbage-collector-в-java-11)
8. [Как работает поддержка TLS 1.3 в Java 11?](#8-как-работает-поддержка-tls-13-в-java-11)
9. [Что такое удаление устаревших API в Java 11?](#9-что-такое-удаление-устаревших-api-в-java-11)
10. [Как работает `jlink` и `jdeps` для создания кастомных JRE в Java 11?](#10-как-работает-jlink-и-jdeps-для-создания-кастомных-jre-в-java-11)
11. [Как работает Flight Recorder (JFR) в Java 11?](#11-как-работает-flight-recorder-jfr-в-java-11)

### Java 17
12. [Что такое запечатанные классы и интерфейсы (`sealed`) в Java 17 и как они реализованы?](#12-что-такое-запечатанные-классы-и-интерфейсы-sealed-в-java-17-и-как-они-реализованы)
13. [Как работает улучшенный `switch` с pattern matching в Java 17?](#13-как-работает-улучшенный-switch-с-pattern-matching-в-java-17)
14. [Что такое записи (`record`) и как они работают в Java 17?](#14-что-такое-записи-record-и-как-они-работают-в-java-17)
15. [Как работает новый API генерации случайных чисел (`RandomGenerator`) в Java 17?](#15-как-работает-новый-api-генерации-случайных-чисел-randomgenerator-в-java-17)
16. [Как работает восстановленный AOT (Ahead-of-Time) Compilation и GraalVM в Java 17?](#16-как-работает-восстановленный-aot-ahead-of-time-compilation-и-graalvm-в-java-17)
17. [Что такое улучшения в `java.nio.file` в Java 17?](#17-что-такое-улучшения-в-javaniofile-в-java-17)
18. [Как работает новый API `Mac` для macOS в Java 17?](#18-как-работает-новый-api-mac-для-macos-в-java-17)
19. [Как работает удаление устаревших API и инструментов в Java 17?](#19-как-работает-удаление-устаревших-api-и-инструментов-в-java-17)
20. [Какие улучшения в производительности JVM появились в Java 17?](#20-какие-улучшения-в-производительности-jvm-появились-в-java-17)
21. [Как работает поддержка `Foreign Function & Memory API` в Java 17?](#21-как-работает-поддержка-foreign-function--memory-api-в-java-17)

### Java 21
22. [Что такое виртуальные потоки (Virtual Threads) в Java 21 и как они реализованы?](#22-что-такое-виртуальные-потоки-virtual-threads-в-java-21-и-как-они-реализованы)
23. [Как работает улучшенный pattern matching для `switch` в Java 21?](#23-как-работает-улучшенный-pattern-matching-для-switch-в-java-21)
24. [Что такое `Sequenced Collections` в Java 21 и как они реализованы?](#24-что-такое-sequenced-collections-в-java-21-и-как-они-реализованы)
25. [Как работает `String Templates` в Java 21 и что происходит под капотом?](#25-как-работает-string-templates-в-java-21-и-что-происходит-под-капотом)
26. [Как работает улучшенный `Foreign Function & Memory API` в Java 21?](#26-как-работает-улучшенный-foreign-function--memory-api-в-java-21)
27. [Как работает `Key Encapsulation Mechanism API` в Java 21?](#27-как-работает-key-encapsulation-mechanism-api-в-java-21)
28. [Какие улучшения в производительности JVM появились в Java 21?](#28-какие-улучшения-в-производительности-jvm-появились-в-java-21)
29. [Как работает `Unnamed Classes and Instance Main Methods` в Java 21?](#29-как-работает-unnamed-classes-and-instance-main-methods-в-java-21)
30. [Как работает `Structured Concurrency` в Java 21?](#30-как-работает-structured-concurrency-в-java-21)

---

## Java 11

### 1. Что такое новый HTTP Client API в Java 11 и как он работает под капотом?

**Описание**: Java 11 стандартизировала новый `HttpClient` API (пакет `java.net.http`), который был представлен как инкубационный в Java 9 и доработан в Java 10. Этот API заменяет устаревший `HttpURLConnection`, предоставляя современный способ работы с HTTP/1.1, HTTP/2 и WebSocket.

**Основные возможности**:
- Поддержка синхронных и асинхронных HTTP-запросов.
- Поддержка HTTP/2 с мультиплексированием запросов в одном соединении.
- Интеграция с WebSocket для двунаправленного общения.
- Настраиваемые обработчики ответа (`BodyHandler`) и подписчики (`BodySubscriber`).

**Пример**:
```java
HttpClient client = HttpClient.newBuilder()
    .version(HttpClient.Version.HTTP_2)
    .build();
HttpRequest request = HttpRequest.newBuilder()
    .uri(URI.create("https://example.com"))
    .GET()
    .build();
HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
System.out.println(response.body());
```

**Внутреннее устройство**:
- `HttpClient` использует асинхронную модель, основанную на `CompletableFuture` для неблокирующих операций.
- Реализован на основе NIO (`AsynchronousSocketChannel`) для эффективной работы с сетью.
- Поддерживает пул соединений, который повторно использует TCP-соединения для HTTP/1.1 и HTTP/2.
- Для HTTP/2 используется протокол ALPN (Application-Layer Protocol Negotiation), чтобы договориться о версии протокола с сервером.
- Внутренний движок обрабатывает фреймы HTTP/2 (например, HEADERS, DATA), обеспечивая мультиплексирование запросов.
- `BodyHandler` и `BodySubscriber` позволяют настраивать обработку тела ответа, минимизируя копирование данных.

**Оптимизации**:
- Пул соединений уменьшает накладные расходы на установку соединений.
- Асинхронные запросы используют `ForkJoinPool.commonPool()` для выполнения задач.
- Поддержка прямых буферов (`ByteBuffer`) для эффективной передачи данных.

**Особенности**:
- Поддержка потоковой обработки больших ответов через `BodySubscriber`.
- Гибкая настройка таймаутов, редиректов и прокси.

[Вернуться к оглавлению](#оглавление)

---

### 2. Какие новые методы String появились в Java 11 и как они реализованы?

**Описание**: Java 11 добавила несколько новых методов в класс `String`, упрощающих работу с текстовыми данными: `isBlank()`, `lines()`, `strip()`, `stripLeading()`, `stripTrailing()`, и `repeat()`.

**Список методов**:
- `isBlank()`: проверяет, является ли строка пустой или содержит только пробельные символы.
- `lines()`: возвращает `Stream<String>`, представляющий строки, разделенные символами новой строки.
- `strip()`, `stripLeading()`, `stripTrailing()`: удаляют пробельные символы (включая Unicode) с начала, конца или полностью.
- `repeat(int n)`: повторяет строку заданное количество раз.

**Пример**:
```java
String text = "  Hello\nWorld  ";
System.out.println(text.isBlank()); // false
text.lines().forEach(System.out::println); // Hello, World
System.out.println(text.strip()); // "Hello\nWorld"
System.out.println("Hi".repeat(3)); // "HiHiHi"
```

**Внутреннее устройство**:
- **isBlank()**: использует метод `Character.isWhitespace(int)` для проверки Unicode-пробелов, что делает его более универсальным, чем `trim()`. Реализация проверяет каждый кодовый пункт строки.
- **lines()**: создает `Stream<String>` с помощью `Splitter.SplittingIterator`, который разделяет строку на подстроки по символам новой строки (`\n`, `\r`, `\r\n`).
- **strip()**: использует `Character.isWhitespace(int)` для удаления Unicode-пробелов, в отличие от `trim()`, который работает только с ASCII-пробелами (код < 0x20).
- **repeat()**: оптимизирован для минимизации копирования памяти, используя внутренний массив `byte[]` (в Java 11 строки хранятся в `byte[]` с кодировкой LATIN1 или UTF16, см. JEP 254).
- Все методы реализованы нативно в JVM (через intrinsic-функции), что обеспечивает высокую производительность.

**Оптимизации**:
- JIT-компилятор может инлайн-вызовы этих методов, уменьшая накладные расходы.
- Использование `byte[]` вместо `char[]` (JEP 254) снижает потребление памяти для строк в кодировке LATIN1.

[Вернуться к оглавлению](#оглавление)

---

### 3. Как работает Epsilon GC в Java 11 и для чего он нужен?

**Описание**: Epsilon GC — это экспериментальный сборщик мусора, введенный в Java 11 (JEP 318), который вообще не выполняет сборку мусора. Он предназначен для тестирования, отладки и приложений с коротким временем жизни.

**Основные особенности**:
- Выделяет память, но не освобождает её, пока не будет достигнут лимит кучи.
- При переполнении кучи JVM завершает работу с ошибкой `OutOfMemoryError`.
- Полезен для анализа производительности без влияния сборки мусора.

**Пример запуска**:
```bash
java -XX:+UseEpsilonGC -Xmx512m MyApp
```

**Внутреннее устройство**:
- Epsilon GC реализует минималистичный интерфейс сборщика мусора, игнорируя операции освобождения памяти.
- Использует простую стратегию выделения памяти (bump-the-pointer) в куче.
- Не выполняет никаких операций по маркировке или очистке объектов, что минимизирует накладные расходы.
- Поддерживает диагностические инструменты JVM (например, JMX, JFR) для анализа использования памяти.

**Применение**:
- Тестирование приложений для оценки потребления памяти.
- Использование в высокопроизводительных приложениях с коротким жизненным циклом, где сборка мусора не требуется.
- Отладка проблем, связанных с влиянием сборки мусора на производительность.

**Ограничения**:
- Не подходит для долгоживущих приложений из-за отсутствия очистки памяти.
- Требует осторожного управления памятью разработчиком.

[Вернуться к оглавлению](#оглавление)

---

### 4. Что такое JEP 254 (Compact Strings) и как оно оптимизирует работу со строками?

**Описание**: JEP 254, реализованное в Java 9 и доработанное в Java 11, изменило внутреннее представление строк в JVM, перейдя с `char[]` (2 байта на символ) на `byte[]` с выбором кодировки (LATIN1 или UTF16) в зависимости от содержимого строки.

**Как это работает**:
- Если строка содержит только символы Latin-1 (коды 0–255), она хранится в `byte[]` с кодировкой LATIN1, занимая 1 байт на символ.
- Если строка содержит символы вне Latin-1, используется UTF16 (`byte[]` с 2 байтами на символ).
- Поле `coder` в классе `String` указывает используемую кодировку (0 для LATIN1, 1 для UTF16).

**Пример**:
```java
String latin1 = "Hello"; // Хранится в LATIN1 (5 байт)
String unicode = "Привет"; // Хранится в UTF16 (12 байт)
```

**Внутреннее устройство**:
- JVM определяет кодировку при создании строки, анализируя её содержимое.
- Методы `String` (например, `length`, `charAt`) адаптированы для работы с `byte[]` и `coder`.
- Intrinsic-функции JVM оптимизируют операции со строками (например, конкатенацию, сравнение).
- Сериализация и десериализация строк также учитывают кодировку.

**Преимущества**:
- Уменьшение потребления памяти (до 50% для строк, содержащих только Latin-1 символы).
- Ускорение операций со строками благодаря меньшему объему данных.

**Оптимизации**:
- JIT-компилятор инлайн-вызовы методов `String` для обеих кодировок.
- Пул строк (`StringTable`) оптимизирован для хранения `byte[]`.

[Вернуться к оглавлению](#оглавление)

---

### 5. Как работает улучшенный `var` для лямбда-выражений в Java 11?

**Описание**: Java 11 расширила использование ключевого слова `var` (введенного в Java 10) для параметров лямбда-выражений, что позволяет упростить синтаксис, особенно при использовании аннотаций.

**Пример**:
```java
Function<String, String> func = (@NonNull var s) -> s.toUpperCase();
```

**Внутреннее устройство**:
- `var` в лямбда-выражениях — это синтаксический сахар, где компилятор выводит тип параметра на основе функционального интерфейса.
- Аннотации (например, `@NonNull`) применяются к параметру, сохраняя типобезопасность.
- Компилятор генерирует байт-код, аналогичный явному указанию типа, поэтому производительность не изменяется.

**Ограничения**:
- `var` можно использовать только если все параметры лямбда-выражения аннотированы или все используют `var`.
- Тип выводится только на основе целевого функционального интерфейса.

**Преимущества**:
- Упрощает написание лямбда-выражений с аннотациями.
- Сохраняет читаемость кода.

[Вернуться к оглавлению](#оглавление)

---

### 6. Что такое улучшения в `Optional` в Java 11?

**Описание**: Java 11 добавила метод `isEmpty()` в класс `Optional`, дополняющий `isPresent()` для большей ясности кода.

**Пример**:
```java
Optional<String> opt = Optional.ofNullable(null);
if (opt.isEmpty()) {
    System.out.println("Optional is empty");
}
```

**Внутреннее устройство**:
- `isEmpty()` возвращает `true`, если `Optional` не содержит значения (т.е. `value == null`).
- Реализация тривиальна и инлайн-оптимизируется JIT-компилятором:
  ```java
  public boolean isEmpty() {
      return value == null;
  }
  ```
- Не добавляет новых накладных расходов по сравнению с `isPresent()`.

**Преимущества**:
- Улучшает читаемость кода, заменяя `!isPresent()`.
- Соответствует семантике других API (например, `Collection.isEmpty()`).

[Вернуться к оглавлению](#оглавление)

---

### 7. Как работает ZGC (Z Garbage Collector) в Java 11?

**Описание**: ZGC — это экспериментальный низколатентный сборщик мусора, введенный в Java 11 (JEP 333), предназначенный для приложений, требующих минимальных пауз (менее 10 мс).

**Основные особенности**:
- Параллельная и конкурентная сборка мусора.
- Поддержка больших куч (до терабайт).
- Минимальные паузы, независимые от размера кучи.

**Внутреннее устройство**:
- ZGC использует **colored pointers** (цветные указатели) и **load barriers** для отслеживания объектов.
- Вместо традиционной маркировки объектов ZGC кодирует метаданные в указателях (64-битные архитектуры).
- Сборка мусора выполняется конкурентно с приложением, перемещая объекты (compaction) без длительных пауз.
- Поддерживает **multi-mapping**: несколько виртуальных адресов для одного физического объекта, что упрощает перемещение объектов.

**Пример запуска**:
```bash
java -XX:+UseZGC -Xmx16g MyApp
```

**Ограничения**:
- Экспериментальный в Java 11, стабилизирован позже (Java 15).
- Требует 64-битной архитектуры.
- Высокое потребление памяти из-за multi-mapping.

**Преимущества**:
- Идеально для приложений реального времени (например, финансовые системы).
- Масштабируемость на больших кучах.

[Вернуться к оглавлению](#оглавление)

---

### 8. Как работает поддержка TLS 1.3 в Java 11?

**Описание**: Java 11 добавила поддержку протокола TLS 1.3 (JEP 332), который обеспечивает улучшенную безопасность и производительность по сравнению с TLS 1.2.

**Основные особенности**:
- Более быстрое установление соединения (1-RTT вместо 2-RTT).
- Улучшенные алгоритмы шифрования.
- Удаление устаревших криптографических алгоритмов.

**Внутреннее устройство**:
- Реализация TLS 1.3 встроена в `SunJSSE` (Java Secure Socket Extension).
- Использует нативные криптографические библиотеки через JNI для ускорения операций (например, AES-GCM).
- Поддерживает новые алгоритмы, такие как ChaCha20-Poly1305.
- JVM автоматически выбирает TLS 1.3, если сервер поддерживает его, с возможностью отката на TLS 1.2.

**Пример**:
```java
SSLSocket socket = (SSLSocket) SSLSocketFactory.getDefault().createSocket("example.com", 443);
socket.setEnabledProtocols(new String[]{"TLSv1.3"});
```

**Оптимизации**:
- Уменьшение количества рукопожатий (handshake) повышает производительность.
- JIT-компилятор оптимизирует криптографические операции.

[Вернуться к оглавлению](#оглавление)

---

### 9. Что такое удаление устаревших API в Java 11?

**Описание**: Java 11 удалила ряд устаревших API и модулей, помеченных как deprecated в Java 9 (JEP 320), включая Java EE модули и CORBA.

**Удаленные модули**:
- `java.xml.ws`, `java.xml.bind`, `java.activation` (Java EE).
- `java.corba` (CORBA).
- `java.transaction`.

**Внутреннее устройство**:
- Удаление модулей сократило размер JDK, что упростило создание минималистичных JRE с помощью `jlink`.
- Удаленные API были перенесены в отдельные библиотеки (например, JAXB доступен как зависимость Maven).

**Воздействие**:
- Требуется миграция приложений, использующих Java EE или CORBA.
- Улучшает модульность и уменьшает долг технического обслуживания.

[Вернуться к оглавлению](#оглавление)

---

### 10. Как работает `jlink` и `jdeps` для создания кастомных JRE в Java 11?

**Описание**: `jlink` (JEP 282) позволяет создавать минималистичные JRE, включающие только необходимые модули. `jdeps` анализирует зависимости приложения.

**Пример**:
```bash
jdeps --module-path mods --print-module-deps MyApp.jar
jlink --module-path mods --add-modules java.base,my.app --output custom-jre
```

**Внутреннее устройство**:
- `jdeps` сканирует байт-код классов, определяя зависимости от модулей JDK и сторонних библиотек.
- `jlink` использует `ModuleLayer` для сборки JRE, включая только указанные модули.
- Созданный JRE содержит минимальный набор классов, библиотек и нативных компонентов.

**Преимущества**:
- Уменьшение размера JRE (например, до 30–50 МБ).
- Улучшение безопасности за счет исключения ненужных модулей.

[Вернуться к оглавлению](#оглавление)

---

### 11. Как работает Flight Recorder (JFR) в Java 11?

**Описание**: Java Flight Recorder (JEP 328) стал open-source в Java 11 и предоставляет инструмент для профилирования и мониторинга приложений с минимальными накладными расходами.

**Основные возможности**:
- Сбор данных о производительности (GC, CPU, I/O, блокировки).
- Поддержка пользовательских событий.
- Интеграция с инструментами, такими как Mission Control.

**Пример**:
```bash
java -XX:StartFlightRecording=duration=60s,filename=recording.jfr MyApp
```

**Внутреннее устройство**:
- JFR встроен в JVM и использует буферы в памяти для записи событий.
- События записываются конкурентно, минимизируя влияние на производительность.
- Поддерживает асинхронную запись в файл или потоковую передачу данных.

**Оптимизации**:
- Низкие накладные расходы (<1% в большинстве случаев).
- JIT-компилятор оптимизирует точки вставки событий.

[Вернуться к оглавлению](#оглавление)

---

## Java 17

### 12. Что такое запечатанные классы и интерфейсы (`sealed`) в Java 17 и как они реализованы?

**Описание**: Запечатанные классы и интерфейсы (`sealed`), стандартизированные в Java 17 (JEP 409) после preview в Java 15–16, позволяют ограничивать, какие классы могут наследоваться от данного класса или реализовывать интерфейс, усиливая контроль над иерархией наследования.

**Пример**:
```java
sealed interface Shape permits Circle, Rectangle, Triangle {}
final class Circle implements Shape {}
final class Rectangle implements Shape {}
non-sealed class Triangle implements Shape {} // Позволяет дальнейшее наследование
```

**Внутреннее устройство**:
- Директива `permits` указывает разрешенные подклассы или реализации, которые должны быть `final`, `sealed` или `non-sealed`.
- Компилятор проверяет, что все подклассы указаны в `permits` и находятся в том же модуле или пакете.
- В байт-коде запечатанные классы содержат метаданные в `PermittedSubclasses` атрибуте, который JVM использует для проверки ограничений наследования.
- JVM обеспечивает соблюдение правил запечатывания во время загрузки классов через `ClassLoader`.

**Особенности**:
- Упрощает анализ иерархии, особенно в сочетании с `switch` выражениями и pattern matching.
- Усиливает инкапсуляцию, предотвра Unused

System: предотвращая нежелательное наследование.
- Полезно для библиотек и фреймворков, где нужно ограничить расширяемость.

**Пример использования в `switch`**:
```java
String describe(Shape shape) {
    return switch (shape) {
        case Circle c -> "Circle with radius " + c.radius();
        case Rectangle r -> "Rectangle with dimensions " + r.width() + "x" + r.height();
        case Triangle t -> "Triangle";
    };
}
```

**Оптимизации**:
- JVM может оптимизировать `switch` на запечатанных типах, используя таблицы переходов (`tableswitch`), так как иерархия фиксирована.
- Компилятор проверяет полноту (`exhaustiveness`) в `switch`, что исключает необходимость в `default`.

[Вернуться к оглавлению](#оглавление)

---

### 13. Как работает улучшенный `switch` с pattern matching в Java 17?

**Описание**: Улучшенный `switch` (JEP 406, стандартизирован в Java 17 после preview в Java 12–14) поддерживает выражения и pattern matching для `instanceof`, упрощая обработку сложных иерархий типов.

**Пример**:
```java
Object obj = "Hello";
String result = switch (obj) {
    case String s -> "String: " + s;
    case Integer i -> "Integer: " + i;
    case null -> "Null value";
    default -> "Unknown";
};
```

**Внутреннее устройство**:
- `switch` выражения компилируются в байт-код, аналогичный условным операторам, но с оптимизациями для компактности.
- Pattern matching использует инструкцию `instanceof` с автоматическим приведением типа, что устраняет необходимость явного кастинга.
- Для `switch` на запечатанных классах компилятор проверяет полноту, гарантируя, что все возможные подтипы учтены.
- Поддержка `null` в `switch` реализована через специальную проверку в байт-коде, что делает обработку null-safe.

**Особенности**:
- Поддержка `yield` для возврата значений из блочного `switch`:
  ```java
  int value = switch (obj) {
      case String s -> { yield s.length(); }
      default -> 0;
  };
  ```
- Полнота проверки для `sealed` типов исключает ошибки времени выполнения.
- Поддержка `null` как отдельного случая.

**Оптимизации**:
- JVM использует `tableswitch` или `lookupswitch` для оптимизации переходов в `switch`.
- JIT-компилятор инлайн-вызовы для pattern matching, минимизируя накладные расходы.

[Вернуться к оглавлению](#оглавление)

---

### 14. Что такое записи (`record`) и как они работают в Java 17?

**Описание**: Записи (`record`), стандартизированные в Java 16 (JEP 395) и унаследованные в Java 17, предоставляют компактный синтаксис для создания неизменяемых классов данных, автоматически генерируя конструктор, геттеры, `equals`, `hashCode` и `toString`.

**Пример**:
```java
record Person(String name, int age) {
    public Person { // Компактный конструктор
        if (age < 0) throw new IllegalArgumentException("Age cannot be negative");
    }
}
Person person = new Person("Alice", 30);
System.out.println(person.name()); // Alice
```

**Внутреннее устройство**:
- `record` компилируется в `final` класс, унаследованный от `java.lang.Record`.
- Компилятор автоматически генерирует:
   - Приватные `final` поля для каждого компонента.
   - Публичные геттеры (именованные по компонентам, без префикса `get`).
   - Конструктор, проверяющий входные данные.
   - Реализации `equals`, `hashCode` и `toString`, учитывающие все компоненты.
- Компоненты доступны через методы, а не напрямую как поля.
- Поддерживает компактные конструкторы для валидации и дополнительные методы.

**Оптимизации**:
- JIT-компилятор инлайн-вызовы геттеров и методов `equals`/`hashCode`.
- Поля хранятся в компактной форме, минимизируя потребление памяти.
- Сериализация записей оптимизирована для сохранения неизменяемости.

**Особенности**:
- Неизменяемость по умолчанию (поля `final`).
- Поддержка аннотаций на компонентах и дополнительных методов.
- Совместимость с `sealed` классами для создания иерархий данных.

[Вернуться к оглавлению](#оглавление)

---

### 15. Как работает новый API генерации случайных чисел (`RandomGenerator`) в Java 17?

**Описание**: Java 17 представила интерфейс `RandomGenerator` (JEP 356), унифицирующий API для генерации случайных чисел и добавляющий новые алгоритмы, такие как Xoshiro и LXM.

**Основные возможности**:
- Единый интерфейс для всех генераторов случайных чисел (`Random`, `SecureRandom`, `SplittableRandom`).
- Новые алгоритмы: Xoshiro256++, Xoshiro512++, LXM.
- Поддержка потоков (`Stream`) для генерации случайных чисел.

**Пример**:
```java
RandomGenerator rng = RandomGenerator.of("Xoshiro256PlusPlus");
int randomInt = rng.nextInt(100);
DoubleStream doubles = rng.doubles(10); // Поток из 10 случайных чисел
doubles.forEach(System.out::println);
```

**Внутреннее устройство**:
- `RandomGenerator` — это интерфейс с реализациями для различных алгоритмов.
- Xoshiro256++ и Xoshiro512++ — высокопроизводительные алгоритмы с хорошей статистической случайностью.
- LXM — гибридный алгоритм, комбинирующий LCG (Linear Congruential Generator) и Xorshift.
- Реализации используют нативные intrinsic-функции JVM для оптимизации вычислений.
- Поддержка потоков реализована через `Spliterator`, что интегрируется с Stream API.

**Оптимизации**:
- Новые алгоритмы быстрее, чем старый `Random` (например, Xoshiro256++ генерирует числа в 2–3 раза быстрее).
- JIT-компилятор оптимизирует вызовы `nextInt`, `nextLong` и других методов.
- Потоки случайных чисел используют ленивую генерацию для минимизации вычислений.

**Преимущества**:
- Упрощает выбор подходящего генератора (например, `SecureRandom` для криптографии, Xoshiro для общего использования).
- Улучшает производительность и качество случайных чисел.

[Вернуться к оглавлению](#оглавление)

---

### 16. Как работает восстановленный AOT (Ahead-of-Time) Compilation и GraalVM в Java 17?

**Описание**: Java 17 восстановила поддержку Ahead-of-Time Compilation (JEP 410, экспериментальная) и улучшила интеграцию с GraalVM, позволяя компилировать Java-приложения в нативные исполняемые файлы.

**Основные возможности**:
- AOT-компиляция преобразует байт-код в нативный код до запуска, уменьшая время старта.
- GraalVM используется как компилятор для AOT, заменяя устаревший `jaotc` из Java 9–11.
- Поддержка создания нативных образов с помощью `native-image` (вне JDK).

**Пример**:
```bash
native-image --no-fallback -cp MyApp.jar MyApp
```

**Внутреннее устройство**:
- GraalVM использует анализ точек входа (points-to analysis) для определения используемых классов и методов.
- AOT-компиляция исключает ненужные части JDK, создавая компактный исполняемый файл.
- JVM поддерживает AOT-скомпилированные библиотеки через загрузчик `.so`/`.dll` файлов.
- GraalVM оптимизирует код, используя агрессивное инлайнинг и удаление неиспользуемого кода (dead code elimination).

**Преимущества**:
- Уменьшение времени запуска (до 10–100 раз быстрее для небольших приложений).
- Снижение потребления памяти (до 5 раз по сравнению с JIT).
- Идеально для серверлесс-приложений и контейнеров.

**Ограничения**:
- Ограниченная поддержка рефлексии и динамической загрузки классов.
- Экспериментальный статус в Java 17.

[Вернуться к оглавлению](#оглавление)

---

### 17. Что такое улучшения в `java.nio.file` в Java 17?

**Описание**: Java 17 добавила новые методы в `java.nio.file.Files` для упрощения работы с файлами, такие как `readString` и `writeString`.

**Пример**:
```java
Path path = Path.of("file.txt");
Files.writeString(path, "Hello, World!");
String content = Files.readString(path);
System.out.println(content); // Hello, World!
```

**Внутреннее устройство**:
- `Files.readString` использует `FileChannel` и `ByteBuffer` для чтения файла в память, затем декодирует байты с помощью указанной кодировки (по умолчанию UTF-8).
- `Files.writeString` кодирует строку в байты и записывает их через `FileChannel`.
- Методы оптимизированы для работы с небольшими файлами, минимизируя копирование данных.
- Используют нативные вызовы через JNI для операций с файлами.

**Оптимизации**:
- Прямое использование буферов NIO снижает накладные расходы.
- JIT-компилятор инлайн-вызовы методов `Files`.

**Преимущества**:
- Упрощает чтение и запись текстовых файлов, заменяя многострочные конструкции с `BufferedReader`/`BufferedWriter`.
- Поддержка кодировок через `Charset`.

[Вернуться к оглавлению](#оглавление)

---

### 18. Как работает новый API `Mac` для macOS в Java 17?

**Описание**: Java 17 добавила поддержку рендеринга для macOS через Metal API (JEP 382), заменяя устаревший OpenGL.

**Основные особенности**:
- Улучшенная производительность графики на macOS.
- Поддержка Retina-дисплеев и плавного рендеринга.
- Интеграция с AWT и JavaFX.

**Внутреннее устройство**:
- JVM использует нативный Metal API через JNI для рендеринга графики.
- Реализация интегрирована в `sun.java2d` пакет, заменяя OpenGL pipeline.
- Поддерживает аппаратное ускорение для 2D-графики (AWT) и 3D (JavaFX).

**Преимущества**:
- Улучшение производительности и качества рендеринга на macOS.
- Совместимость с современными версиями macOS.

[Вернуться к оглавлению](#оглавление)

---

### 19. Как работает удаление устаревших API и инструментов в Java 17?

**Описание**: Java 17 удалила ряд устаревших API и инструментов (JEP 403, JEP 407), включая Applet API и SecurityManager.

**Удаленные компоненты**:
- **Applet API** (`java.applet`): устарело из-за отсутствия поддержки в браузерах.
- **SecurityManager**: заменен более современными механизмами безопасности (например, модульной системой).
- Устаревшие методы в `Runtime` и других классах.

**Внутреннее устройство**:
- Удаление API сократило размер JDK, упростив его обслуживание.
- JVM больше не загружает классы `Applet` и `SecurityManager`, что уменьшает накладные расходы.
- Модульная система (JPMS) обеспечивает альтернативу `SecurityManager` через ограничение доступа.

**Воздействие**:
- Требуется миграция приложений, использующих Applet или SecurityManager.
- Улучшает безопасность и производительность современных приложений.

[Вернуться к оглавлению](#оглавление)

---

### 20. Какие улучшения в производительности JVM появились в Java 17?

**Описание**: Java 17 включает оптимизации для сборщиков мусора, JIT-компиляции и других компонентов JVM.

**Основные улучшения**:
- **ZGC и Shenandoah**: улучшены для еще меньших пауз и лучшей масштабируемости.
- **G1GC**: оптимизирована работа с большими кучами и регионы памяти.
- **JIT-компиляция**: улучшения в C2 компиляторе для инлайнинга и оптимизации циклов.
- **String Deduplication**: оптимизация памяти для строк в пуле строк.

**Внутреннее устройство**:
- ZGC использует colored pointers и load barriers для конкурентной сборки мусора.
- Shenandoah оптимизирует перемещение объектов (compaction) с минимальными паузами.
- G1GC улучшил алгоритмы эвакуации регионов, уменьшая фрагментацию.
- JIT-компилятор (C2) использует профилирование для более агрессивного инлайнинга.

**Преимущества**:
- Уменьшение пауз GC (особенно в ZGC и Shenandoah).
- Ускорение выполнения кода благодаря оптимизациям JIT.

[Вернуться к оглавлению](#оглавление)

---

### 21. Как работает поддержка `Foreign Function & Memory API` в Java 17?

**Описание**: Foreign Function & Memory API (JEP 412, preview в Java 17) позволяет безопасно вызывать нативные функции и управлять памятью вне кучи JVM, заменяя JNI.

**Пример**:
```java
try (var linker = CLinker.getInstance()) {
    MethodHandle printf = linker.downcallHandle(
        linker.lookup("printf").get(),
        MethodType.methodType(void.class, MemoryAddress.class),
        FunctionDescriptor.ofVoid(CLinker.C_POINTER)
    );
    printf.invoke(CLinker.toCString("Hello, Foreign API!").address());
}
```

**Внутреннее устройство**:
- **MemorySegment**: управляет памятью вне кучи (нативной или выделенной JVM).
- **CLinker**: предоставляет доступ к нативным функциям через `MethodHandle`.
- Использует `invokedynamic` для оптимизации вызовов нативных функций.
- Поддерживает безопасное выделение и освобождение памяти через `MemorySession`.

**Преимущества**:
- Упрощает интеграцию с нативным кодом.
- Безопасное управление памятью без утечек.
- Высокая производительность благодаря `MethodHandle`.

**Ограничения**:
- Экспериментальный статус в Java 17 (стабилизирован в Java 22).

[Вернуться к оглавлению](#оглавление)

---

## Java 21

### 22. Что такое виртуальные потоки (Virtual Threads) в Java 21 и как они реализованы?

Виртуальные потоки — это легковесные потоки (lightweight threads), управляемые самой JVM, а не операционной системой (ОС). В отличие от традиционных потоков Java (которые мы теперь называем **платформенными потоками** или platform threads), виртуальные потоки не привязаны 1:1 к потокам ОС на протяжении всего своего жизненного цикла.

Основная идея в том, чтобы позволить приложениям создавать огромное количество (миллионы) виртуальных потоков, которые могут выполнять блокирующие операции ввода-вывода (I/O) без значительного расходования системных ресурсов.

**Зачем они нужны? (Проблема, которую они решают)**

1.  **Ограничения платформенных потоков:**
  *   **Дорогие:** Платформенные потоки являются обертками над потоками ОС. Создание и управление потоками ОС — ресурсоемкая операция (память на стек, контекстные переключения на уровне ядра).
  *   **Ограниченное количество:** Из-за их "тяжеловесности" вы не можете создать миллионы платформенных потоков. Обычно их количество ограничивается несколькими тысячами.
  *   **Блокировка ввода-вывода:** Когда платформенный поток выполняет блокирующую операцию (например, чтение из сокета, запрос к БД), он блокирует поток ОС, на котором он работает. Этот поток ОС простаивает, потребляя ресурсы, пока операция не завершится.

2.  **Сложность асинхронного программирования:**
  *   Чтобы обойти проблему блокировки, разработчики прибегали к асинхронным/реактивным моделям (Callbacks, Futures, CompletableFuture, RxJava, Project Reactor).
  *   Такой код часто сложнее писать, читать, отлаживать и профилировать (например, "callback hell", сложные цепочки вызовов, неинформативные стектрейсы).

**Виртуальные потоки предлагают лучшее из двух миров:**
*   **Простота синхронного кода:** Вы пишете код в привычном императивном, блокирующем стиле.
*   **Масштабируемость асинхронного кода:** Приложение может обслуживать огромное количество одновременных операций.


Магия виртуальных потоков заключается в том, как JVM управляет их выполнением на платформенных потоках.

1.  **Carrier Threads (Несущие потоки):**
  *   Виртуальные потоки выполняются на платформенных потоках. Эти платформенные потоки называются **несущими потоками (carrier threads)**.
  *   Обычно используется небольшой пул несущих потоков (по умолчанию это `ForkJoinPool`, количество потоков в котором часто равно количеству ядер процессора).
  *   Один несущий поток может поочередно выполнять код множества разных виртуальных потоков.

2.  **Mounting (Монтирование) и Unmounting (Демонтирование):**
  *   Когда виртуальный поток готов к выполнению, он **монтируется** на несущий поток. Код виртуального потока начинает исполняться.
  *   **Ключевой момент:** Если виртуальный поток выполняет блокирующую операцию ввода-вывода (которая была адаптирована для работы с Project Loom, например, операции с сокетами, `Thread.sleep()`, `LockSupport.park()` и некоторые другие JDK-операции синхронизации), происходит следующее:
    *   Виртуальный поток **демонтируется** с несущего потока.
    *   Несущий поток **освобождается** и может быть использован для монтирования и выполнения другого виртуального потока.
    *   Состояние демонтированного виртуального потока (его стек) сохраняется в куче (heap) Java. Он не потребляет поток ОС.
  *   Когда блокирующая операция завершается (например, пришли данные из сети), виртуальный поток становится готов к продолжению выполнения. JVM планирует его для повторного монтирования на доступный несущий поток.

3.  **Continuations (Продолжения) / Stack Slicing:**
  *   Внутренне это достигается с помощью механизма, называемого **продолжениями (continuations)** или **stack slicing (нарезка стека)**.
  *   Стек виртуального потока не хранится целиком в виде одного большого блока памяти, как у платформенных потоков. Вместо этого он может быть разбит на небольшие части (сегменты или "чанки"), которые хранятся как обычные Java-объекты в куче.
  *   Это позволяет легко "приостанавливать" виртуальный поток (сохраняя его нарезанный стек в куче) и "возобновлять" его позже.

4.  **Планировщик (Scheduler):**
  *   JVM имеет внутренний планировщик (по умолчанию используется `ForkJoinPool`), который решает, какой виртуальный поток будет выполняться на каком несущем потоке.
  *   Этот планировщик оптимизирован для работы с большим количеством короткоживущих или часто блокирующихся задач.

| Характеристика        | Платформенные потоки (Platform Threads)                                  | Виртуальные потоки (Virtual Threads)                                   |
| :-------------------- | :----------------------------------------------------------------------- | :--------------------------------------------------------------------- |
| **Основа**            | Обертка над потоком ОС (1:1 mapping)                                     | Управляются JVM, легковесные, не привязаны к потоку ОС постоянно (M:N) |
| **Ресурсоемкость**    | Высокая (стек ОС ~1MB+, ресурсы ядра)                                    | Низкая (небольшие объекты в куче для стека, стек растет по мере надобности) |
| **Количество**        | Ограничено (тысячи)                                                      | Очень большое (миллионы)                                               |
| **Время создания**    | Относительно долго                                                       | Очень быстро                                                           |
| **Блокировка I/O**    | Блокирует поток ОС (и несущий платформенный поток)                       | Демонтируется с несущего потока, несущий поток освобождается           |
| **Пулинг**            | Часто необходим из-за высокой стоимости создания                        | Обычно не нужен (создавайте новый виртуальный поток для каждой задачи) |
| **`ThreadLocal`**     | Работают как обычно                                                      | Работают, но могут быть проблемы с производительностью или памятью при ОЧЕНЬ большом количестве виртуальных потоков, если `ThreadLocal` хранит много данных или часто используется. Стоит использовать с осторожностью. |
| **Синхронизация**     | `synchronized` блокирует платформенный поток                           | `synchronized` при блокировке "прибивает" (pins) виртуальный поток к несущему потоку, не давая несущему потоку освободиться. Это может снизить преимущества виртуальных потоков. Рекомендуется использовать `java.util.concurrent.locks.ReentrantLock` и другие примитивы `java.util.concurrent`. |
| **Стек вызовов**      | Традиционный стек                                                        | "Нарезанный" стек, хранимый в куче                                     |
| **Прерывание**        | Стандартное (`interrupt()`)                                              | Стандартное (`interrupt()`)                                              |
| **Использование**     | Длительные задачи, задачи, интенсивно использующие CPU, ограниченное кол-во | Короткие задачи, задачи, часто блокирующиеся на I/O, массовая параллельность |


[Вернуться к оглавлению](#оглавление)

---

### 23. Как работает улучшенный pattern matching для `switch` в Java 21?

**Описание**: Pattern matching для `switch` (JEP 441, стандартизирован в Java 21 после preview в Java 17–20) расширяет возможности `switch`, добавляя поддержку проверки типов, `null` и сложных шаблонов, таких как `record` и массивы.

**Пример**:
```java
Object obj = new Point(1, 2);
String result = switch (obj) {
    case null -> "Null";
    case Point(int x, int y) when x > 0 -> "Positive point: " + x + "," + y;
    case Point(int x, int y) -> "Point: " + x + "," + y;
    case String s -> "String: " + s;
    default -> "Unknown";
};
record Point(int x, int y) {}
```

**Внутреннее устройство**:
- Компилятор преобразует `switch` с pattern matching в байт-код, использующий `instanceof` и условные переходы.
- Для `record` шаблонов компилятор автоматически декомпозирует компоненты, вызывая геттеры (например, `x()` и `y()` для `Point`).
- Поддержка `when` (guard clauses) реализуется через условные операторы в байт-коде.
- Проверка полноты (`exhaustiveness`) для `sealed` типов гарантирует, что все подтипы учтены, исключая необходимость `default` в некоторых случаях.
- Поддержка `null` реализована через отдельную проверку в байт-коде перед выполнением `switch`.

**Особенности**:
- Поддержка вложенных шаблонов (например, `case Point(Point p1, Point p2)`).
- Условия `when` позволяют добавлять дополнительные проверки в шаблонах.
- Полнота проверки для `sealed` классов и перечислений.

**Оптимизации**:
- JVM использует `tableswitch` или `lookupswitch` для оптимизации переходов в `switch`.
- JIT-компилятор инлайн-вызовы геттеров и проверок `instanceof`, минимизируя накладные расходы.
- Проверка полноты выполняется на этапе компиляции, что исключает ошибки времени выполнения.

**Преимущества**:
- Упрощает обработку сложных иерархий типов.
- Уменьшает шаблонный код, заменяя цепочки `instanceof` и приведения типов.

[Вернуться к оглавлению](#оглавление)

---

### 24. Что такое `Sequenced Collections` в Java 21 и как они реализованы?

**Описание**: `Sequenced Collections` (JEP 431) вводят новый интерфейс `SequencedCollection` и связанные интерфейсы (`SequencedSet`, `SequencedMap`), добавляя методы для упорядоченного доступа к элементам коллекций.

**Основные возможности**:
- Методы: `getFirst()`, `getLast()`, `addFirst()`, `addLast()`, `removeFirst()`, `removeLast()`, `reversed()`.
- Применимо к коллекциям с определенным порядком (например, `List`, `LinkedHashSet`, `LinkedHashMap`).

**Пример**:
```java
SequencedCollection<String> list = new ArrayList<>();
list.addLast("A");
list.addLast("B");
System.out.println(list.getFirst()); // A
System.out.println(list.reversed()); // [B, A]
```

**Внутреннее устройство**:
- `SequencedCollection` — это новый интерфейс, унаследованный `Collection`, добавляющий методы для работы с первым и последним элементами.
- Реализации (`ArrayList`, `LinkedList`, `LinkedHashSet`, `LinkedHashMap`) обновлены для поддержки новых методов.
- Метод `reversed()` возвращает представление (`view`) коллекции в обратном порядке, не создавая копию данных.
- Для `SequencedMap` добавлены методы `firstEntry()`, `lastEntry()`, `putFirst()`, `putLast()`.

**Оптимизации**:
- Метод `reversed()` реализован как легковесное представление, минимизирующее потребление памяти.
- JIT-компилятор инлайн-вызовы новых методов для стандартных коллекций.
- Реализации используют существующие структуры данных (например, двусвязный список в `LinkedList`), что минимизирует изменения.

**Преимущества**:
- Унифицированный API для работы с упорядоченными коллекциями.
- Упрощает операции с началом и концом коллекций.

[Вернуться к оглавлению](#оглавление)

---

### 25. Как работает `String Templates` в Java 21 и что происходит под капотом?

**Описание**: `String Templates` (JEP 430, preview в Java 21) — это механизм для упрощения создания строк с динамическими значениями, заменяющий конкатенацию и `String.format`.

**Пример**:
```java
String name = "Alice";
String template = STR."Hello, \{name}!"; // Hello, Alice!
```

**Внутреннее устройство**:
- `STR` — это встроенный процессор шаблонов, предоставляемый JVM.
- Шаблон компилируется в байт-код, где выражения (`\{...}`) вычисляются отдельно, а затем передаются в процессор шаблонов.
- `StringTemplate` — это объект, содержащий статические части шаблона и вычисленные значения.
- Процессор шаблонов (например, `STR`) комбинирует части в итоговую строку.
- Поддерживает пользовательские процессоры для кастомной обработки (например, для SQL-запросов или JSON).

**Пример пользовательского процессора**:
```java
StringTemplate.Processor<String, RuntimeException> MY_PROC = (st) -> 
    st.interpolate().toUpperCase();
String result = MY_PROC."Hello, \{name}!"; // HELLO, ALICE!
```

**Оптимизации**:
- JIT-компилятор оптимизирует вызовы процессоров шаблонов, инлайнинг статических частей.
- Использование `StringBuilder` для сборки строк минимизирует накладные расходы.
- Выражения в шаблонах вычисляются лениво, только если используются.

**Преимущества**:
- Более читаемый и безопасный синтаксис по сравнению с `String.format`.
- Защита от инъекций (например, в SQL) при использовании специализированных процессоров.

**Ограничения**:
- Экспериментальный статус в Java 21 (стабилизирован позже).

[Вернуться к оглавлению](#оглавление)

---

### 26. Как работает улучшенный `Foreign Function & Memory API` в Java 21?

**Описание**: `Foreign Function & Memory API` (JEP 442, третья версия preview в Java 21) позволяет вызывать нативные функции и управлять памятью вне кучи JVM, продолжая развитие API из Java 17.

**Пример**:
```java
try (var arena = Arena.ofConfined()) {
    var segment = arena.allocate(100);
    var printf = Linker.nativeLinker().downcallHandle(
        Linker.nativeLinker().defaultLookup().find("printf").orElseThrow(),
        FunctionDescriptor.ofVoid(ValueLayout.ADDRESS)
    );
    printf.invoke(segment);
}
```

**Внутреннее устройство**:
- **Arena**: управляет жизненным циклом нативной памяти, заменяя `MemorySession` из предыдущих версий.
- **MemorySegment**: представляет участок памяти вне кучи, поддерживая безопасное выделение и доступ.
- **Linker**: использует `MethodHandle` для вызова нативных функций через `invokedynamic`.
- Поддерживает структурированную память (например, для C-структур) через `MemoryLayout`.

**Оптимизации**:
- Прямой доступ к нативной памяти минимизирует копирование данных.
- JIT-компилятор оптимизирует вызовы нативных функций через `invokedynamic`.
- `Arena` автоматически освобождает память при закрытии, предотвращая утечки.

**Преимущества**:
- Упрощает интеграцию с нативным кодом (например, C/C++ библиотеками).
- Безопаснее и производительнее, чем JNI.

**Ограничения**:
- Экспериментальный статус в Java 21 (стабилизирован в Java 22).

[Вернуться к оглавлению](#оглавление)

---

### 27. Как работает `Key Encapsulation Mechanism API` в Java 21?

**Описание**: `Key Encapsulation Mechanism (KEM) API` (JEP 452) вводит поддержку криптографических алгоритмов KEM, таких как Kyber, для постквантовой криптографии.

**Пример**:
```java
KeyPairGenerator kpg = KeyPairGenerator.getInstance("Kyber");
KeyPair kp = kpg.generateKeyPair();
Cipher cipher = Cipher.getInstance("Kyber");
cipher.init(Cipher.WRAP_MODE, kp.getPublic());
byte[] wrappedKey = cipher.wrap(kp.getPrivate());
```

**Внутреннее устройство**:
- Реализован в пакете `javax.crypto`, интегрирован с `SunJCE` провайдером.
- Использует нативные криптографические библиотеки через JNI для реализации KEM (например, Kyber).
- Поддерживает гибридные схемы шифрования, комбинирующие KEM с традиционными алгоритмами.

**Оптимизации**:
- Нативные вызовы оптимизированы для минимальной задержки.
- JIT-компилятор инлайн-вызовы криптографических операций.

**Преимущества**:
- Подготовка к постквантовой криптографии.
- Совместимость с существующими API шифрования.

[Вернуться к оглавлению](#оглавление)

---

### 28. Какие улучшения в производительности JVM появились в Java 21?

**Описание**: Java 21 включает оптимизации для сборщиков мусора, JIT-компиляции и других компонентов JVM.

**Основные улучшения**:
- **ZGC**: поддержка generational mode (JEP 439), разделяющая объекты на молодое и старое поколение для уменьшения пауз.
- **Shenandoah**: улучшена производительность для больших куч.
- **G1GC**: оптимизирована работа с регионами памяти, уменьшая фрагментацию.
- **JIT-компиляция**: улучшения в C2 компиляторе для инлайнинга и оптимизации виртуальных потоков.

**Внутреннее устройство**:
- ZGC generational mode использует отдельные области памяти для молодых и старых объектов, минимизируя затраты на маркировку и перемещение.
- Shenandoah оптимизирует конкурентное перемещение объектов (compaction).
- G1GC улучшил алгоритмы эвакуации регионов, уменьшая накладные расходы.
- JIT-компилятор (C2) использует профилирование для оптимизации горячих участков кода, особенно для виртуальных потоков.

**Преимущества**:
- Уменьшение пауз GC (ZGC и Shenandoah достигают пауз <1 мс).
- Ускорение выполнения кода благодаря улучшенному инлайнингу.

[Вернуться к оглавлению](#оглавление)

---

### 29. Как работает `Unnamed Classes and Instance Main Methods` в Java 21?

**Описание**: `Unnamed Classes and Instance Main Methods` (JEP 445, preview в Java 21) упрощают создание простых программ, позволяя определять `main` методы без явного объявления класса.

**Пример**:
```java
void main() {
    System.out.println("Hello, World!");
}
```

**Внутреннее устройство**:
- Компилятор автоматически создает неназванный класс, содержащий метод `main`.
- Поддерживает как статические, так и экземплярные `main` методы.
- JVM загружает неназванный класс через стандартный `ClassLoader`.

**Оптимизации**:
- Минимальные накладные расходы, так как неназванный класс компилируется как обычный класс.
- JIT-компилятор оптимизирует вызов `main`.

**Преимущества**:
- Упрощает написание простых программ для обучения.
- Снижает барьер входа для новичков.

[Вернуться к оглавлению](#оглавление)

---

### 30. Как работает `Structured Concurrency` в Java 21?

**Описание**: `Structured Concurrency` (JEP 453, preview в Java 21) предоставляет API для структурированной работы с задачами в виртуальных потоках, упрощая управление параллельными операциями.

**Пример**:
```java
try (var scope = StructuredTaskScope.ShutdownOnFailure()) {
    var future1 = scope.fork(() -> fetchData("url1"));
    var future2 = scope.fork(() -> fetchData("url2"));
    scope.join();
    System.out.println(future1.get() + ", " + future2.get());
}
```

**Внутреннее устройство**:
- `StructuredTaskScope` управляет группой виртуальных потоков, обеспечивая их завершение в определенном порядке.
- Поддерживает политики завершения (например, `ShutdownOnFailure`, `ShutdownOnSuccess`).
- Использует виртуальные потоки для выполнения задач, минимизируя накладные расходы.

**Оптимизации**:
- Интеграция с `ForkJoinPool` для эффективного распределения задач.
- JIT-компилятор оптимизирует вызовы `fork` и `join`.

**Преимущества**:
- Упрощает управление параллельными задачами.
- Предотвращает утечки ресурсов благодаря структурированному завершению.

[Вернуться к оглавлению](#оглавление)

---

Если у вас есть дополнительные вопросы или вы хотите углубиться в конкретный аспект (например, виртуальные потоки или pattern matching), дайте знать!