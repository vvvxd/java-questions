Какие "строковые" классы вы знаете?

public final class String implements java.io.Serializable, Comparable<String>, CharSequence

public final class StringBuffer extends AbstractStringBuilder implements java.io.Serializable, CharSequence

public final class StringBuilder extends AbstractStringBuilder implements java.io.Serializable, CharSequence

--------------------------------------------------------------------------------------------------------------------
Какие основные свойства "строковых" классов (их особенности)?

Все строковые классы - final (следовательно от них нельзя унаследоваться).

String.Строка — объект, что представляет последовательность символов. Для создания и манипулирования строками Java платформа предоставляет общедоступный финальный (не может иметь подклассов) класс java.lang.String. Данный класс является неизменяемым (immutable) — созданный объект класса String не может быть изменен.

StringBuffer Строки являются неизменными, поэтому частая их модификация приводит к созданию новых объектов, что в свою очередь расходует драгоценную память. Для решения этой проблемы был создан класс java.lang.StringBuffer, который позволяет более эффективно работать над модификацией строки. Класс является mutable, то есть изменяемым — используйте его, если Вы хотите изменять содержимое строки. StringBuffer может быть использован в многопоточных средах, так как все необходимые методы являются синхронизированными.

StringBuilder StringBuilder — класс, что представляет изменяемую последовательность символов. Класс был введен в Java 5 и имеет полностью идентичный API с StringBuffer. Единственное отличие — StringBuilder не синхронизирован. Это означает, что его использование в многопоточных средах нежелательно. Следовательно, если вы работаете с многопоточностью, Вам идеально подходитStringBuffer, иначе используйте StringBuilder, который работает намного быстрее в большинстве реализаций.

--------------------------------------------------------------------------------------------------------------------
Можно ли наследовать строковый тип, почему?

Классы объявлены final, поэтому наследоваться не получится.

--------------------------------------------------------------------------------------------------------------------
Дайте определение понятию конкатенация строк.

Конкатенация — операция объединения строк, что возвращает новую строку, что является результатом объединения второй строки с окончанием первой. Операции конкатенации могут быть выполнены так:

StringBuffer stringBuffer = new StringBuffer();
StringBuilder stringBuilder = new StringBuilder();
String str = "ABC";
str += "DEF";
String str2 = "one".concat("two").concat("three");
stringBuffer.append("DDD").append("EEE");
stringBuilder.append("FFF").append("GGG");
System.out.println(str + " " +str2 + " " + stringBuffer.toString() + " " + stringBuilder.toString());//ABCDEF onetwothree DDDEEE FFFGGG

--------------------------------------------------------------------------------------------------------------------
Как преобразовать строку в число?

У каждой обертки для примитивов есть свой метод valueOf(String s), который возвращает преобразованное численное значение из строки. При этом форматы строки и принимаемого типа должны совпадать. Например:

String x = "523.5";
Double xd = Double.valueOf(x);
/*
Integer xy = Integer.valueOf(x); //java.lang.NumberFormatException: For input string: "523.5"
*/
System.out.println(xd); //523.5

--------------------------------------------------------------------------------------------------------------------
Как сравнить значение двух строк?

Оператор == работает с ссылками объекта String. Если две переменные String указывают на один и тот же объект в памяти, сравнение вернет результат true. В противном случае результат будет false, несмотря на то что текст может содержать в точности такие же символы. Оператор == не сравнивает сами данные типа char. Для сравнения посимвольно необходимо использовать метод equals();

--------------------------------------------------------------------------------------------------------------------
Как перевернуть строку?

String s = "ABCDEFG";
StringBuilder stringBuilder = new StringBuilder(s);
stringBuilder.reverse();
System.out.println(stringBuilder.toString()); //GFEDCBA
Можно и алгоритмом переставляя каждый char, но это на ваше усмотрение:).

--------------------------------------------------------------------------------------------------------------------
Как работает сравнение двух строк?

Строка в Java - это отдельный объект, который может не совпадать с другим объектом, хотя на экране результат выводимой строки может выглядеть одинаково. Просто Java в случае с логическим оператором == (а также !=) сравнивает ссылки на объекты.
Метод equals сравнивает посимвольно на эквивалентность.

--------------------------------------------------------------------------------------------------------------------
Как обрезать пробелы в конце строки?

String s = "a ";
System.out.println(s.trim() + "b");//ab
System.out.println(s + "b");//a b

--------------------------------------------------------------------------------------------------------------------
Как заменить символ в строке?

Можно использовать метод replace(CharSequence target, CharSequence replacement), который меняет символы в строке. Можно преобразовать в массив символов и заменить символ там. Можно использовать StringBuilder и метод setCharAt(int index, char ch)

--------------------------------------------------------------------------------------------------------------------
Как получить часть строки?

Метод substring(int beginIndex, int lastIndex) - возвращает часть строки по указанным индексам.

--------------------------------------------------------------------------------------------------------------------
Дайте определение понятию "пул строк".

Пул строк - это набор строк, который хранится в памяти Java heap. Мы знаем, что String это специальный класс в Java, и мы можем создавать объекты этого класса, используя оператор new точно так же, как и создавать объекты, предоставляя значение строки в двойных кавычках.Диаграмма ниже объясняет, как пул строк размещается в памяти Java heap и что происходит, когда мы используем различные способы создания строк.

Пул строк возможен исключительно благодаря неизменяемости строк в Java и реализации идеи интернирования строк. Пул строк также является примером паттерна Приспособленец (Flyweight).Пул строк помогает экономить большой объем памяти, но с другой стороны создание строки занимает больше времени.Когда мы используем двойные кавычки для создания строки, сначала ищется строка в пуле с таким же значением, если находится, то просто возвращается ссылка, иначе создается новая строка в пуле, а затем возвращается ссылка.Тем не менее, когда мы используем оператор new, мы принуждаем класс String создать новый объект строки, а затем мы можем использовать метод intern() для того, чтобы поместить строку в пул, или получить из пула ссылку на другой объект String с таким же значением.
Ниже приведен пример, показывающий работу пула строк.

String s1 = "Cat";
String s2 = "Cat";
String s3 = new String("Cat");
System.out.println("s1 == s2 :"+(s1==s2)); //s1 == s2 :true
System.out.println("s1 == s3 :"+(s1==s3)); //s1 == s3 :false

--------------------------------------------------------------------------------------------------------------------
Какой метод позволяет выделить подстроку в строке?

В дополнении к "как получить часть строки" можно использовать метод string.indexOf(char c), который вернет индекс первого вхождения символа. Таким образом потом можно использовать этот номер для выделения подстроки с помощью substring();

--------------------------------------------------------------------------------------------------------------------
Как разбить строку на подстроки по заданному разделителю?

ы можем использовать метод split(String regex) для разделения строки на массив символов, используя в качестве разделителя регулярное выражение. Метод split(String regex, int numOfStrings) является перегруженным методом для разделения строки на заданное количество строк. Мы можем использовать обратную черту для использования специальных символов регулярных выражений в качестве обычных символов.

String line = "I am a java developer";
String[] words = line.split(" ");
String[] twoWords = line.split(" ", 2);
System.out.println("String split with delimiter: "+Arrays.toString(words));//String split with delimiter: [I, am, a, java, developer]
System.out.println("String split into two: "+Arrays.toString(twoWords));//String split into two: [I, am a java developer]
//split string delimited with special characters
String wordsWithNumbers = "I|am|a|java|developer";
String[] numbers = wordsWithNumbers.split("\\|");
System.out.println("String split with special character: "+ Arrays.toString(numbers));

--------------------------------------------------------------------------------------------------------------------
Какой метод вызывается для преобразования переменной в строку?

public static String valueOf(Object obj) {
return (obj == null) ? "null" : obj.toString();
}

--------------------------------------------------------------------------------------------------------------------
Как узнать значение конкретного символа строки, зная его порядковый номер в строке?

str.charAt(int i) вернет символ по индексу.

--------------------------------------------------------------------------------------------------------------------
Как найти необходимый символ в строке?

str.indexOf(char ch) или lastIndexOf(char c) - вернет индекс первого и последнего вхождения символа.

String fs = "12345678904";
int a = fs.indexOf("456"); //3
int b = fs.lastIndexOf("4"); //10

--------------------------------------------------------------------------------------------------------------------
Можно ли синхронизировать доступ к строке?

String сам по себе потокобезопасный класс. Если мы работаем с изменяемыми строками, то нужно использовать StringBuffer.

--------------------------------------------------------------------------------------------------------------------
Что делает метод intern()?

Когда метод intern() вызван, если пул строк уже содержит строку, эквивалентную к нашему объекту, что подтверждается методом equals(Object), тогда возвращается ссылка на строку из пула. В противном случае объект строки добавляется в пул и ссылка на этот объект возвращается.Этот метод всегда возвращает строку, которая имеет то же значение, что и текущая строка, но гарантирует что это будет строка из пула уникальных строк.

--------------------------------------------------------------------------------------------------------------------
Чем отличаются и что общего у классов String, StringBuffer и StringBuilder?

Класс String является immutable - Вы не можете модифицировать объект String, но можете заменить его созданием нового экземпляра. Создание нового экземпляра обходится дороговато:

//Inefficient version using immutable String String output = "Some text"; int count = 100; for(int i =0; i<count; i++) { output += i; } return output;

Кусок кода, в примере выше создаст 99 новых объектов String, 98 из которых будут тут же откинуты. Создание новых объектов неэффективно.StringBuffer/StringBuilderКласс StringBuffer является mutable - использовать StringBuffer или StringBuilder следует тогда, когда вы хотите модифицировать содержимое. StringBuilder был добавлен в пятой джаве и он во всем идентичен классу StringBuffer, за исключением того, что он не синхронизирован, что делает его значительно шустрее. Но цена скорости - небезопасное поведение в мультипоточной среде.

//More efficient version using mutable StringBuffer // set an initial size of 110 StringBuffer output = new StringBuffer(110); output.append("Some text"); for(int i =0; i<count; i++) { output.append(i); } return output.toString();

Вышеуказанный код создает только два новых объекта, StringBuffer и строковую константу, которая возвращается. StringBuffer расширяется по мере надобности, что, в свою очередь дороговато, так что лучше инициализировать StringBuffer корректным значением размера.Другой важный момент заключается в том, что создание дополнительных строк не ограничено математическим оператором "+", но существует некоторое количество методов, таких как concat(), trim(), substring(), replace() в классах String, которые генерируют новые объекты.

--------------------------------------------------------------------------------------------------------------------
Как правильно сравнить значения строк двух различных объектов типа String и StringBuffer?

Привести их к одному типу и сравнить.

--------------------------------------------------------------------------------------------------------------------
Почему строка неизменная и финализированная в Java?

Есть несколько преимуществ в неизменности строк:

Строковый пул возможен только потому, что строка неизменна в Java, таким образом виртуальная машина сохраняет много места в памяти(heap space), поскольку разные строковые переменные указывают на одну переменную в пуле. Если бы строка не была неизмененяемой, тогда бы интернирование строк не было бы возможным, потому что если какая-либо переменная изменит значение, это отразится также и на остальных переменных, ссылающихся на эту строку.

Если строка будет изменяемой, тогда это станет серьезной угрозой безопасности приложения. Например, имя пользователя базы данных и пароль передаются строкой для получения соединения с базой данных и в программировании сокетов реквизиты хоста и порта передаются строкой. Так как строка неизменяемая, её значение не может быть изменено, в противном случае любой хакер может изменить значение ссылки и вызвать проблемы в безопасности приложения.

Так как строка неизменная, она безопасна для многопоточности и один экземпляр строки может быть совместно использован различными потоками. Это позволяет избежать синхронизации для потокобезопасности, строки полностью потокобезопасны.

Строки используются в Java classloader и неизменность обеспечивает правильность загрузки класса при помощи Classloader. К примеру, задумайтесь об экземпляре класса, когда вы пытаетесь загрузить java.sql.Connection класс, но значение ссылки изменено на myhacked.Connection класс, который может осуществить нежелательные вещи с вашей базой данных.

Поскольку строка неизменная, её hashcode кэшируется в момент создания и нет необходимости рассчитывать его снова. Это делает строку отличным кандидатом для ключа в Map и его обработка будет быстрее, чем других ключей HashMap. Это причина, почему строка наиболее часто используемый объект в качестве ключа HashMap.

--------------------------------------------------------------------------------------------------------------------
Почему массив символов предпочтительнее строки для хранения пароля?

Строка неизменяемая в Java и хранится в пуле строк. С тех пор, как она была создана, она остается в пуле, пока не будет удалена сборщиком мусора, поэтому, когда мы думаем, что закончили работу с паролем, он остается доступным в памяти некоторое время, и нет способа избежать этого. Это риск безопасности, поскольку кто-либо, имеющий доступ к дампу памяти сможет найти пароль в виде чистого текста.Если мы используем массив символов для хранения пароля, мы можем очистить его после того, как закончим с ним работать. Таким образом, мы можем контролировать, как долго он находится в памяти, что позволяет избежать риска безопасности, свойственного строке.

--------------------------------------------------------------------------------------------------------------------
Почему строка является популярным ключом в HashMap в Java?

Поскольку строки неизменны, их хэшкод кэшируется в момент создания, и не требует повторного пересчета. Это делает строки отличным кандидатом для ключа в Map и они обрабатываются быстрее, чем другие объекты-ключи HashMap. Вот почему строки преимущественно используются в качестве ключей HashMap

--------------------------------------------------------------------------------------------------------------------
Напишите метод удаления данного символа из строки.

Мы можем использовать метод replaceAll для замены всех вхождений в строку другой строкой. Обратите внимание на то, что метод получает в качестве аргумента строку, поэтому мы используем класс Character для создания строки из символа, и используем её для замены всех символов на пустую строку.

public static String removeChar(String str, char ch) {
if (str == null)
return null;
return str.replaceAll(Character.toString(ch), "");
}

--------------------------------------------------------------------------------------------------------------------
Какие есть особенности класса String?

- Это неизменяемый (immutable) и финализированный тип данных;
- Все объекты класса String JVM хранит в пуле строк;
- Объект класса String можно получить, используя двойные кавычки;
- Можно использовать оператор + для конкатенации строк;
- Начиная с Java 7 строки можно использовать в конструкции switch.

--------------------------------------------------------------------------------------------------------------------
Какие GOF-шаблоны применяются в строковом пуле?

В строковом пуле явно прослеживается GOF шаблон — легковес (flyweight), иначе его называют поселенец. Если же вы увидели тут ещё какой-то шаблон — делитесь в комментарии. Ну а мы поговорим о шаблоне легковесе. Легковес — структурный шаблон проектирования, при котором объект, представляющий себя как уникальный экземпляр в разных местах программы, по факту не является таковым. Легковес экономит память, разделяя общее состояние объектов между собой, вместо хранения одинаковых данных в каждом объекте.

--------------------------------------------------------------------------------------------------------------------