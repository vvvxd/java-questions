## Оглавление

1. [Что такое класс `String` и каковы его ключевые характеристики?](#1-что-такое-класс-string-и-каковы-его-ключевые-характеристики)
2. [Как работает неизменяемость строк в Java?](#2-как-работает-неизменяемость-строк-в-java)
3. [Как работает пул строк (String Pool) и интернирование в Java?](#3-как-работает-пул-строк-string-pool-и-интернирование-в-java)
4. [Как работает Compact Strings (JEP 254) в Java 11+ и как это влияет на строки?](#4-как-работает-compact-strings-jep-254-в-java-11-и-как-это-влияет-на-строки)
5. [Какие методы класса `String` наиболее часто используются и как они реализованы?](#5-какие-методы-класса-string-наиболее-часто-используются-и-как-они-реализованы)
6. [Как работает конкатенация строк в Java и как её оптимизировать?](#6-как-работает-конкатенация-строк-в-java-и-как-её-оптимизировать)
7. [Как работает сериализация строк в Java?](#7-как-работает-сериализация-строк-в-java)
8. [Как работает `String Templates` в Java 21+ и как они связаны с `String`?](#8-как-работает-string-templates-в-java-21-и-как-они-связаны-с-string)
9. [Как строки взаимодействуют с другими API (например, Stream API, NIO)?](#9-как-строки-взаимодействуют-с-другими-api-например-stream-api-nio)
10. [Какие проблемы и ограничения связаны с классом `String`?](#10-какие-проблемы-и-ограничения-связаны-с-классом-string)
11. [Можно ли наследовать строковый тип, почему?](#11-можно-ли-наследовать-строковый-тип-почему)
12. [Чем отличаются и что общего у классов `String`, `StringBuffer` и `StringBuilder`?](#12-чем-отличаются-и-что-общего-у-классов-string-stringbuffer-и-stringbuilder)
13. [Почему строка неизменная и финализированная в Java?](#13-почему-строка-неизменная-и-финализированная-в-java)
14. [Почему массив символов предпочтительнее строки для хранения пароля?](#14-почему-массив-символов-предпочтительнее-строки-для-хранения-пароля)
15. [Почему строка является популярным ключом в `HashMap` в Java?](#15-почему-строка-является-популярным-ключом-в-hashmap-в-java)
16. [Какие шаблоны GoF применяются в строковом пуле?](#16-какие-шаблоны-gof-применяются-в-строковом-пуле)

---

## 1. Что такое класс `String` и каковы его ключевые характеристики?

**Описание**: Класс `String` представляет неизменяемую последовательность символов Unicode. Он находится в пакете `java.lang` и широко используется для обработки текстовых данных.

**Ключевые характеристики**:
- **Неизменяемость**: После создания объект `String` нельзя изменить. Модификации создают новый объект.
- **Потокобезопасность**: Неизменяемость обеспечивает безопасность в многопоточных приложениях без синхронизации.
- **Пул строк**: JVM хранит уникальные строки в `String Pool` для оптимизации памяти.
- **Поддержка Unicode**: Поддерживает символы Unicode, включая суррогатные пары.

**Пример**:
```java
String str = "Hello";
str = str + " World"; // Создается новый объект
System.out.println(str); // Hello World
```

**Внутреннее устройство**:
- С Java 9 (JEP 254) строки хранятся в `byte[]` вместо `char[]` с кодировкой LATIN1 или UTF16.
- Поле `coder`: `0` для LATIN1, `1` для UTF16.
- Поле `value` (`byte[]`) содержит данные строки.

[Вернуться к оглавлению](#оглавление)

---

## 2. Как работает неизменяемость строк в Java?

**Описание**: Неизменяемость означает, что содержимое `String` не может быть изменено после создания, что влияет на производительность и безопасность.

**Почему строки неизменяемы**:
- **Безопасность**: Предотвращает случайные изменения критических данных (например, ключей `HashMap`).
- **Потокобезопасность**: Безопасны для многопоточного доступа.
- **Оптимизация памяти**: Позволяет использовать пул строк.

**Внутреннее устройство**:
- Поле `value` (`byte[]`) помечено как `final`.
- Методы, такие как `substring` или `replace`, создают новый объект `String`.
- JVM использует intrinsic-функции для оптимизации методов (`length`, `charAt`).

**Пример**:
```java
String str = "Hello";
str.substring(1); // Создает "ello"
System.out.println(str); // Hello (оригинал не изменился)
```

**Оптимизации**:
- JIT-компилятор инлайн-вызовы методов `String`.
- Пул строк минимизирует дублирование.

[Вернуться к оглавлению](#оглавление)

---

## 3. Как работает пул строк (String Pool) и интернирование в Java?

**Описание**: Пул строк — область памяти в куче, где JVM хранит уникальные строковые литералы для экономии памяти.

**Как это работает**:
- Литералы (например, `"Hello"`) автоматически интернируются в пул при загрузке класса.
- Метод `String.intern()` добавляет строку в пул, возвращая каноническую версию.
- Одинаковые строки используют одну ссылку из пула.

**Пример**:
```java
String s1 = "Hello"; // В пуле
String s2 = new String("Hello"); // Новый объект
String s3 = s2.intern(); // Ссылка из пула
System.out.println(s1 == s3); // true
System.out.println(s1 == s2); // false
```

**Внутреннее устройство**:
- Пул строк находится в куче (с Java 7).
- Реализован как хэш-таблица (`StringTable`).
- Настраивается через `-XX:StringTableSize`.

**Оптимизации**:
- Дедупликация строк (JEP 192) объединяет одинаковые строки.
- JIT-компилятор оптимизирует доступ к пулу.

**Особенности**:
- Чрезмерное использование `intern()` может перегрузить `StringTable`.

[Вернуться к оглавлению](#оглавление)

---

## 4. Как работает Compact Strings (JEP 254) в Java 11+ и как это влияет на строки?

**Описание**: С Java 9 (стандартизировано в Java 11) строки используют `byte[]` с кодировкой LATIN1 или UTF16 (JEP 254).

**Как это работает**:
- Символы Latin-1 (0–255) хранятся в LATIN1 (1 байт/символ).
- Символы вне Latin-1 (например, кириллица) — в UTF16 (2 байта/символ).
- Поле `coder`: `0` (LATIN1), `1` (UTF16).

**Пример**:
```java
String latin1 = "Hello"; // LATIN1, 5 байт
String unicode = "Привет"; // UTF16, 12 байт
```

**Внутреннее устройство**:
- Поле `value` (`byte[]`) хранит данные.
- Методы (`charAt`, `length`) адаптированы для `byte[]`:
    - LATIN1: `charAt` преобразует байт в `char`.
    - UTF16: читает два байта.
- Intrinsic-функции оптимизируют операции.

**Оптимизации**:
- До 50% экономии памяти для Latin-1 строк.
- JIT-компилятор инлайн-вызовы методов.
- Пул строк использует LATIN1, если возможно.

**Преимущества**:
- Меньше памяти для ASCII/Latin-1.
- Быстрее операции за счет меньшего объема данных.

[Вернуться к оглавлению](#оглавление)

---

## 5. Какие методы класса `String` наиболее часто используются и как они реализованы?

**Описание**: Класс `String` предоставляет множество методов для работы со строками.

**Основные методы**:
- `length()`: Количество символов.
- `charAt(int index)`: Символ по индексу.
- `substring(int begin, int end)`: Подстрока.
- `concat(String str)`: Объединение.
- `equals(Object obj)`: Сравнение.
- `toLowerCase()`, `toUpperCase()`: Изменение регистра.
- `trim()`, `strip()` (Java 11+): Удаление пробелов.
- `isBlank()` (Java 11+): Проверка на пустоту/пробелы.
- `lines()` (Java 11+): `Stream<String>` строк.
- `repeat(int count)` (Java 11+): Повторение.
- `replace()`, `replaceAll()`: Замена.

**Пример**:
```java
String str = "  Hello World  ";
System.out.println(str.strip()); // "Hello World"
System.out.println(str.repeat(2)); // "  Hello World    Hello World  "
str.lines().forEach(System.out::println);
```

**Внутреннее устройство**:
- `length()`: Учитывает кодировку (`value.length` для LATIN1, `value.length / 2` для UTF16).
- `charAt()`: LATIN1 — байт в `char`, UTF16 — два байта.
- `substring()`: Создает новый `String` с копированием данных.
- `equals()`: Сравнивает `byte[]` с учетом кодировки.
- `strip()`: Использует `Character.isWhitespace(int)`.
- `lines()`: Использует `Splitter.SplittingIterator`.

**Оптимизации**:
- Intrinsic-функции для `equals`, `length`, `charAt`.
- JIT-компилятор инлайн-вызовы.

[Вернуться к оглавлению](#оглавление)

---

## 6. Как работает конкатенация строк в Java и как её оптимизировать?

**Описание**: Конкатенация объединяет строки с помощью `+` или `concat()`.

**Пример**:
```java
String s1 = "Hello";
String s2 = "World";
String result = s1 + " " + s2; // Hello World
```

**Внутреннее устройство**:
- `+` компилируется в `StringBuilder`:
  ```java
  String result = new StringBuilder().append(s1).append(" ").append(s2).toString();
  ```
- `StringBuilder` использует `byte[]`, расширяя его при необходимости.
- `toString()` создает новый `String`.

**Оптимизации**:
- Используйте `StringBuilder` в циклах:
  ```java
  StringBuilder sb = new StringBuilder();
  for (int i = 0; i < 100; i++) {
      sb.append(i);
  }
  String result = sb.toString();
  ```
- В Java 21+ используйте `String Templates` (preview):
  ```java
  String result = STR."\{s1} \{s2}";
  ```
- JIT-компилятор оптимизирует простые конкатенации.

**Проблемы**:
- `+` в циклах создает много объектов.
- Решение: `StringBuilder` или `StringBuffer` (потокобезопасный).

[Вернуться к оглавлению](#оглавление)

---

## 7. Как работает сериализация строк в Java?

**Описание**: `String` поддерживает сериализацию через интерфейс `Serializable`.

**Как это работает**:
- Сериализация записывает `byte[]` в UTF-8.
- Десериализация восстанавливает `String`.

**Пример**:
```java
try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("string.ser"))) {
    oos.writeObject("Hello");
}
try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream("string.ser"))) {
    String str = (String) ois.readObject();
    System.out.println(str); // Hello
}
```

**Внутреннее устройство**:
- `writeObject` записывает `byte[]` и `coder`.
- Десериализация восстанавливает `byte[]` и `coder`.
- Пул строк может интернировать строки при вызове `intern()`.

**Оптимизации**:
- Compact Strings уменьшают размер данных.
- Intrinsic-функции ускоряют сериализацию.

[Вернуться к оглавлению](#оглавление)

---

## 8. Как работает `String Templates` в Java 21+ и как они связаны с `String`?

**Описание**: `String Templates` (JEP 430, preview в Java 21) упрощают создание строк с динамическими вставками.

**Пример**:
```java
String name = "Alice";
String template = STR."Hello, \{name}!"; // Hello, Alice!
```

**Внутреннее устройство**:
- `STR` — встроенный процессор шаблонов.
- Шаблон компилируется в `StringTemplate` (статические части + выражения).
- `STR` объединяет части через `StringBuilder`.
- Поддерживает пользовательские процессоры.

**Оптимизации**:
- `StringBuilder` минимизирует промежуточные объекты.
- JIT-компилятор инлайн-вызовы.
- Ленивое вычисление выражений.

**Преимущества**:
- Читаемый синтаксис.
- Защита от инъекций.

[Вернуться к оглавлению](#оглавление)

---

## 9. Как строки взаимодействуют с другими API (например, Stream API, NIO)?

**Описание**: `String` интегрирован с Stream API и `java.nio.file`.

**Примеры**:
- **Stream API**:
  ```java
  String text = "a\nb\nc";
  text.lines().forEach(System.out::println); // a, b, c
  ```
- **NIO** (Java 17+):
  ```java
  Path path = Path.of("file.txt");
  Files.writeString(path, "Hello, NIO!");
  String content = Files.readString(path);
  ```

**Внутреннее устройство**:
- `lines()`: `Splitter.SplittingIterator` создает `Stream<String>`.
- `Files.readString`/`writeString`: Используют `FileChannel`, `ByteBuffer` и `Charset`.
- Intrinsic-функции оптимизируют преобразования.

**Оптимизации**:
- Ленивая обработка в `lines()`.
- Прямое использование буферов в NIO.

[Вернуться к оглавлению](#оглавление)

---

## 10. Какие проблемы и ограничения связаны с классом `String`?

**Описание**: Ограничения `String`:
- **Неизменяемость**: Затраты на создание новых объектов.
- **Пул строк**: Перегрузка `StringTable` при чрезмерного `intern()`.
- **Unicode**: `length()` считает кодовые единицы, не символы.
- **Память**: UTF16 для Unicode-строк больше.

**Решения**:
- `StringBuilder` для конкатенации.
- Ограничьте `intern()`.
- Используйте `codePoints()` для Unicode.

[Вернуться к оглавлению](#оглавление)

---

## 11. Можно ли наследовать строковой класс?

**Почему нельзя?**

**Описание**: Класс `String` нельзя унаследить, так как он объявлен как `final`.

**Причины**:
- **Гарантия неизменяемости**: Наследование могло бы нарушить контракт `String` (например, добавить изменяемое состояние).
- **Безопасность**: Подклассы могли бы переопределить методы (`hashCode()`, `equals()`), ломая поведение в структурах, таких как `HashMap`.
- **Предсказуемость**: Финализация обеспечивает стабильное поведение.

**Пример проблемы**:
```java
// Гипотетический подкласс
class EvilString extends String { // Ошибка компиляции
    @Override
    public int hashCode() { return 42; } // Ломает HashMap
}
```

[Вернуться к оглавлению](#оглавление)

---

## 12. Чем отличаются и что общего у классов `String`, `StringBuffer` и `StringBuilder`?

**Общие черты**:
- Работают с последовательностями символов.
- Реализуют `CharSequence`.
- Поддерживают базовые операции (длина, извлечение символов).

**Различия**:

| Характеристика       | String                  | StringBuffer            | StringBuilder           |
|----------------------|-------------------------|-------------------------|-------------------------|
| **Изменяемость**     | Неизменяемый           | Изменяемый             | Изменяемый             |
| **Потокобезопасность** | Да (неизменяемость)  | Да (синхронизация)     | Нет                    |
| **Производительность** | Медленный (модификации) | Средний                | Быстрый                |
| **Память**           | Много объектов         | Эффективен             | Эффективен             |
| **Использование**    | Константы              | Многопоточность        | Однопоточность         |

**Примеры**:
- **String**:
  ```java
  String str = "Hello";
  str = str + " World"; // Новый объект
  ```
- **StringBuffer**:
```java
  StringBuffer sb = new StringBuffer("Hello");
  sb.append(" World"); // Модификация
  ```
- **StringBuilder**:
```java
  StringBuilder sb = new StringBuilder("Hello");
  sb.append(" World"); // Быстрая
модификация
  ```

**Рекомендации**:
- `String`: Для констант.
- `StringBuffer`: Для многопоточности.
- `StringBuilder`: Для производительности в однопоточных приложениях.

[Вернуться к оглавлению](#оглавление)

---

## 13. Почему строка `String` неизменная и финализированная в Java?

**Причины неизменяемости**:
1. **Безопасность**:
   - Защищает пароли, URL, параметры от модификаций.
   - Предотвращает атаки через изменение констант.
2. **Кэширование hashCode**:
   - Хэш кэшируется в поле `hash`, не пересчитывается.
   ```java
   private int hash;
   public int hashCode() {
       int h = hash;
       if (h == 0 && value.length > 0) {
           hash = h.hashCode();
       }
       return h;
   }
   ```
3. **Пул строк**:
    - Экономит память, позволяет сравнение через `==`.
4. **Потокобезопасность**:
    - Безопасна без синхронизации.
5. **Оптимизация**:
    - Предсказуемое поведение для JVM.

**Причины финализации**:
- Запрещает наследование, нарушающее контракт.
- Гарантирует неизменяемость.
- Сохраняет поведение в `HashMap`.

**Пример**:
```java
String s1 = "Java";
String s2 = "Java"; // Один объект в пуле
```

[Вероятно к оглавлению](#оглавление)

---

## 14. Почему массив символов предпочтительнее `String` для хранения паролей?

**Причины**:
1. **Изменяемость**:
    - `char[]` можно очистить (`Arrays.fill(passwordChars, '\0')`).
    - `String` неизменяема, остается в памяти.
2. **Риск утечки**:
    - `String` в пуле строк доступна для дампа.
    - `char[]` очищается сразу.
3. **Логирование**:
    - `String` легко логируется:
      ```java
      logger.info("Password: " + password); // Утечка
      ```
    - `char[]` безопаснее:
      ```java
      logger.info("Password: " + Arrays.toString(password));
      ```
4. **Рефлексия**:
    - `String` уязвима для доступа через отражение.
    - `char[]` можно очистить.

**Пример**:
```java
char[] password = {'s', 'e', 'c', 'r', 'e', 't'};
Arrays.fill(password, '\0'); // Очистка
```

[Вернуться к оглавлению](#оглавление)

---

## 15. Почему строка является популярным ключом в `HashMap` в Java?

**Причины**:
1. **Неизменяемость**:
    - Гарантирует стабильный `hashCode()`.
    - Предотвращает ошибки доступа.
2. **Эффективный hashCode()**:
    - Кэшируется.
    - Хорошо распределяет значения.
    - Соблюдает контракт: `s1.equals(s2)` → `s1.hashCode() == s2.hashCode()`.
3. **Пул строк**:
    - Экономит память для повторяющихся ключей.
4. **Универсальность**:
    - Строки естественны для текстовых ключей (ID, имена).

**Пример**:
```java
Map<String, Integer> map = new HashMap<>();
map.put("key", 1);
map.get("key"); // Надежно
```

[Вернуться к оглавлению](#оглавление)

---

## 16. Какие шаблоны GoF применяются в строковом пуле?

**Шаблоны**:
1. **Flyweight (Приспособленец)**:
    - **Идея**: Совместное использование объектов.
    - **Применение**: Пул хранит уникальные строки, возвращая ссылки.
    - **Пример**:
      ```java
      String s1 = "hello";
      String s2 = "hello"; // s1 == s2
      ```
    - **Почему**: Экономит память.
2. **Singleton (Одиночка)**:
    - **Идея**: Единственный экземпляр.
    - **Применение**: Один `String Pool` в JVM, доступ через `intern()`.
    - **Пример**:
      ```java
      String s1 = "abc";
      String s2 = "abc"; // s1 == s2
      ```
    - **Почему**: Глобальное хранилище.
3. **Factory Method (Фабричный метод)**:
    - **Идея**: Создание объектов через интерфейс
    - **Применение**: `intern()` решает, вернуть или создать строку.
    - **Пример**:
      ```java
      String s1 = new String("world").intern();
      String s2 = "world"; // s1 == s2
      ```
    - **Почему**: Управляет созданием.

[Вернуться к оглавлению](#оглавление)

---
