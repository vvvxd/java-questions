## Оглавление

1. [Что такое лямбда-выражения в Java и для чего они нужны?](#1-что-такое-лямбда-выражения-в-java-и-для-чего-они-нужны)
2. [Каков синтаксис лямбда-выражений и какие варианты он поддерживает?](#2-как-работает-invokedynamic-на-уровне-байт-кода-jvm)
3. [Как лямбда-выражения связаны с функциональными интерфейсами?](#3-как-лямбда-выражения-связаны-с-функциональными-интерфейсами)
4. [Как лямбда-выражения компилируются в байт-код?](#4-как-лямбда-выражения-компилируются-в-байт-код)
5. [Что такое инструкция `invokedynamic` и зачем она была введена в Java?](#5-что-такое-инструкция-invokedynamic-и-зачем-она-была-введена-в-java)
6. [Как работает `invokedynamic` на уровне байт-кода JVM?](#6-как-работает-invokedynamic-на-уровне-байт-кода-jvm)
7. [Что такое bootstrap method и как он связан с `invokedynamic`?](#7-что-такое-bootstrap-method-и-как-он-связан-с-invokedynamic)
8. [Как `invokedynamic` используется для реализации лямбда-выражений в Java 8?](#8-как-invokedynamic-используется-для-реализации-лямбда-выражений-в-java-8)
9. [Как `invokedynamic` взаимодействует с Method Handles?](#9-как-invokedynamic-взаимодействует-с-method-handles)
10. [Как JVM оптимизирует вызовы `invokedynamic`?](#10-как-jvm-оптимизирует-вызовы-invokedynamic)
11. [Какие существуют типы `CallSite` и как они влияют на поведение `invokedynamic`?](#11-какие-существуют-типы-callsite-и-как-они-влияют-на-поведение-invokedynamic)
12. [Как `invokedynamic` используется в реализации Records в Java?](#12-как-invokedynamic-используется-в-реализации-records-в-java)
13. [Как `invokedynamic` используется для улучшения конкатенации строк в Java 9?](#13-как-invokedynamic-используется-для-улучшения-конкатенации-строк-в-java-9)
14. [Как работает захват переменных (замыкания) в лямбда-выражениях?](#14-как-работает-захват-переменных-замыкания-в-лямбда-выражениях)
15. [Как лямбда-выражения используются с Stream API?](#15-как-лямбда-выражения-используются-с-stream-api)
16. [Какие ограничения и проблемы связаны с лямбда-выражениями?](#16-какие-ограничения-и-проблемы-связаны-с-лямбда-выражениями)
17. [Что такое функциональный интерфейс в Java?](#17-что-такое-функциональный-интерфейс-в-java)
18. [Как функциональные интерфейсы связаны с лямбда-выражениями?](#18-как-функциональные-интерфейсы-связаны-с-лямбда-выражениями)
19. [Какие стандартные функциональные интерфейсы предоставляет Java?](#19-какие-стандартные-функциональные-интерфейсы-предоставляет-java)
20. [Как создавать собственные функциональные интерфейсы?](#20-как-создавать-собственные-функциональные-интерфейсы)
21. [Какова внутренняя архитектура Stream API?](#21-как-работает-внутренняя-архитектура-stream-api)
22. [Как работает ленивое выполнение (laziness) в Stream API?](#22-как-работает-ленивое-выполнение-laziness-в-stream-api)
23. [Как данные проходят через конвейер операций?](#23-как-данные-проходят-через-конвейер-операций)
24. [Как работает параллельная обработка в Stream API?](#24-как-работает-параллельная-обработка-в-stream-api)
25. [Нюансы использования параллельной обработки в Java 8](#25-нюансы-использования-параллельной-обработки-в-java-8)
26. [Как JVM оптимизирует выполнение Stream API?](#26-как-jvm-оптимизирует-выполнение-stream-api)
27. [Как Stream API обрабатывает примитивные типы?](#27-как-stream-api-обрабатывает-примитивные-типы)
28. [Как Collectors работают изнутри?](#28-как-collectors-работают-изнутри)
29. [Какие ограничения и подводные камни есть у Stream API?](#29-какие-ограничения-и-подводные-камни-есть-у-stream-api)
30. [Как отладить внутреннюю работу Stream API?](#30-как-отладить-внутреннюю-работу-stream-api)
31. [Что такое Stream API и зачем оно нужно?](#31-что-такое-stream-api-и-зачем-оно-нужно)
32. [Какие основные операции предоставляет Stream API?](#32-какие-основные-операции-предоставляет-stream-api)
33. [Как Stream API взаимодействует с функциональными интерфейсами?](#33-как-stream-api-взаимодействует-с-функциональными-интерфейсами)
34. [Как Collectors используются в Stream API?](#34-как-collectors-используются-в-stream-api)
35. [Для чего в стримах применяются методы `forEach()` и `forEachOrdered()`?](#35-для-чего-в-стримах-применяются-методы-foreach-и-foreachordered)
36. [Как Stream API развивается в новых версиях Java?](#36-как-stream-api-развивается-в-новых-версиях-java)

---

## 1. Что такое лямбда-выражения в Java и для чего они нужны?

[К оглавлению](#оглавление)

**Описание**: Лямбда-выражения — это синтаксический способ представления экземпляра функционального интерфейса, то есть интерфейса с одним абстрактным методом (SAM — Single Abstract Method). Они позволяют передавать поведение (функцию) как аргумент метода или хранить его в переменной.

**Пример**:
```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
names.forEach(name -> System.out.println(name));
```

**Назначение**:
- Упрощение написания кода, заменяя анонимные классы.
- Поддержка функционального программирования (например, в Stream API).
- Улучшение читаемости и сокращение шаблонного кода.

**Ключевые особенности**:
- Лямбда-выражения не создают полноценные анонимные классы, что снижает накладные расходы.
- Они могут захватывать переменные из окружающей области видимости (замыкания), но только если эти переменные `final` или effectively final.

---

## 2. Каков синтаксис лямбда-выражений и какие варианты он поддерживает?

[К оглавлению](#оглавление)

**Описание**: Синтаксис лямбда-выражений состоит из трех частей: параметры, стрелка (`->`), и тело.

**Синтаксис**:
```java
(параметры) -> выражение
// или
(параметры) -> { блок кода; }
```

**Примеры вариантов**:
- Без параметров:
  ```java
  () -> System.out.println("Hello");
  ```
- Один параметр (скобки необязательны):
  ```java
  x -> x * 2
  ```
- Несколько параметров:
  ```java
  (x, y) -> x + y
  ```
- С блоком кода:
  ```java
  (x, y) -> {
      System.out.println("Processing: " + x);
      return x + y;
  }
  ```
- С аннотациями (Java 11+ с `var`):
  ```java
  (@NonNull var x) -> x.toUpperCase()
  ```

**Особенности**:
- Если тело состоит из одного выражения, фигурные скобки и `return` можно опустить.
- Типы параметров могут быть выведены компилятором (type inference).
- В Java 11+ ключевое слово `var` позволяет использовать аннотации в параметрах лямбда-выражений.

---

## 3. Как лямбда-выражения связаны с функциональными интерфейсами?

[К оглавлению](#оглавление)

**Описание**: Лямбда-выражения представляют реализацию единственного абстрактного метода функционального интерфейса.

**Функциональный интерфейс**:
- Это интерфейс с ровно одним абстрактным методом (SAM).
- Может быть помечен аннотацией `@FunctionalInterface` для проверки компилятором.

**Пример**:
```java
@FunctionalInterface
interface MyFunction {
    int apply(int x);
}
MyFunction func = x -> x * 2;
System.out.println(func.apply(5)); // 10
```

**Стандартные функциональные интерфейсы** (пакет `java.util.function`):
- `Function<T, R>`: принимает `T`, возвращает `R` (метод `apply`).
- `Predicate<T>`: принимает `T`, возвращает `boolean` (метод `test`).
- `Consumer<T>`: принимает `T`, ничего не возвращает (метод `accept`).
- `Supplier<T>`: не принимает параметров, возвращает `T` (метод `get`).

**Внутреннее устройство**:
- Лямбда-выражение привязывается к функциональному интерфейсу через механизм вывода типов (type inference) компилятором.
- Компилятор проверяет соответствие сигнатуры лямбда-выражения методу интерфейса.

---

## 4. Как лямбда-выражения компилируются в байт-код?

[К оглавлению](#оглавление)

**Описание**: Лямбда-выражения используют механизм `invokedynamic`, введенный в Java 7, для эффективной компиляции и выполнения.

**Внутреннее устройство**:
- **Компиляция**:
  - Компилятор преобразует лямбда-выражение в приватный статический метод в том же классе, где оно определено.
  - Например, лямбда `x -> x * 2` компилируется в метод вида:
    ```java
    private static int lambda$0(int x) {
        return x * 2;
    }
    ```
- **Связывание**:
  - JVM использует инструкцию `invokedynamic` для динамического связывания лямбда-выражения с функциональным интерфейсом.
  - При первом вызове `invokedynamic` вызывает `LambdaMetafactory`, которая создает реализацию интерфейса, ссылающуюся на статический метод.
- **Создание экземпляра**:
  - Результатом является объект функционального интерфейса, который делегирует вызовы статическому методу.
  - В отличие от анонимных классов, не создается отдельный `.class` файл, что снижает накладные расходы.

**Пример байт-кода** (упрощенно):
```java
// Лямбда: x -> x * 2
invokedynamic #0, 0 // InvokeDynamic #0:makeLambda:()Ljava/util/function/Function;
```

**Оптимизации**:
- `LambdaMetafactory` создает легковесные реализации, минимизируя создание объектов.
- JIT-компилятор может инлайн-вызовы лямбда-выражений, оптимизируя их до уровня обычных методов.
- Захват переменных (замыкания) оптимизирован для минимизации копирования данных.

---

## 5. Что такое инструкция `invokedynamic` и зачем она была введена в Java?

[К оглавлению](#оглавление)

`invokedynamic` — это инструкция байт-кода, добавленная в JVM в Java 7, чтобы поддерживать динамическое связывание методов. В отличие от традиционных инструкций (`invokevirtual`, `invokestatic`, `invokeinterface`, `invokespecial`), которые фиксируют метод на этапе компиляции, `invokedynamic` позволяет определить логику вызова метода во время выполнения. Это делает её идеальной для реализации динамических языков (например, JRuby, Groovy) и таких функций, как лямбда-выражения в Java 8.

**Цели введения**:
- **Поддержка динамических языков**: Динамические языки, такие как Python или JavaScript, часто не имеют строгого определения метода на этапе компиляции. `invokedynamic` позволяет JVM гибко обрабатывать такие случаи.
- **Оптимизация производительности**: Динамическое связывание позволяет JVM оптимизировать вызовы методов, например, через инлайн-кэширование.
- **Расширяемость**: `invokedynamic` предоставляет разработчикам возможность настраивать поведение вызовов методов, что используется, например, в лямбда-выражениях и метод-хэндлах (Method Handles).

---

## 6. Как работает `invokedynamic` на уровне байт-кода JVM?

[К оглавлению](#оглавление)

**Ответ**:  
Инструкция `invokedynamic` в байт-коде указывает JVM выполнить вызов, но не ссылается на конкретный метод напрямую. Вместо этого она ссылается на **bootstrap method** (BSM), который вызывается JVM в первый раз для определения, какой метод или логика должны быть выполнены. После этого JVM может кэшировать результат, чтобы последующие вызовы были быстрее.

**Основные компоненты**:
- **Call Site**: Объект, представляющий точку вызова `invokedynamic`. Он хранит информацию о том, как выполнять вызов.
- **Bootstrap Method**: Метод, написанный на Java (или нативном коде), который вызывается JVM для инициализации вызова. Он возвращает объект `CallSite`, определяющий поведение вызова.
- **Dynamic Linkage**: JVM откладывает связывание до момента выполнения, а не фиксирует его на этапе компиляции.

**Байт-код `invokedynamic` содержит**:
- Индекс в пуле констант, указывающий на `CONSTANT_InvokeDynamic_info`, где хранятся:
  - Ссылка на bootstrap method.
  - Имя метода и его дескриптор (сигнатура).

---

## 7. Что такое bootstrap method и как он связан с `invokedynamic`?

[К оглавлению](#оглавление)

**Bootstrap Method** (BSM) — это метод, который JVM вызывает в момент первого выполнения инструкции `invokedynamic`. Он отвечает за создание объекта `CallSite`, который определяет, как будет выполнен вызов. BSM обычно находится в классе, написанном на Java, и аннотирован как `static`.

**Формат BSM**:
```java
public static CallSite bootstrapMethod(
    MethodHandles.Lookup caller,  // Контекст вызывающего класса
    String name,                 // Имя динамического метода
    MethodType type,             // Тип метода (сигнатура)
    Object... args              // Дополнительные аргументы
) throws Throwable;
```

- **MethodHandles.Lookup**: Предоставляет доступ к методам и полям вызывающего класса.
- **name**: Имя вызываемого метода (может быть произвольным, так как не обязательно соответствует реальному методу).
- **type**: Сигнатура метода (возвращаемый тип и типы аргументов).
- **args**: Статические аргументы, переданные из пула констант (например, дополнительные метаданные).

**BSM возвращает один из трёх типов `CallSite`**:
- **ConstantCallSite**: Фиксированный вызов, который не меняется после инициализации.
- **MutableCallSite**: Может изменять целевой метод во время выполнения.
- **VolatileCallSite**: Подобен `MutableCallSite`, но с поддержкой потокобезопасных изменений.

---

## 8. Как `invokedynamic` используется для реализации лямбда-выражений в Java 8?

[К оглавлению](#оглавление)

Лямбда-выражения в Java 8 компилируются не в отдельные классы с фиксированными методами, а в вызовы `invokedynamic`. Это позволяет JVM эффективно реализовать лямбды, минимизируя создание новых классов и улучшая производительность.

**Процесс**:
1. Компилятор `javac` преобразует лямбда-выражение в инструкцию `invokedynamic`.
2. `invokedynamic` ссылается на bootstrap method из класса `LambdaMetafactory`.
3. `LambdaMetafactory` создаёт `CallSite`, который указывает на реализацию лямбды. Реализация может быть:
  - Существующий метод в классе.
  - Динамически сгенерированный класс, реализующий функциональный интерфейс.
4. JVM кэширует результат, чтобы последующие вызовы лямбды были быстрыми.

**Пример**:
```java
Function<String, Integer> lambda = s -> s.length();
```
- Компилятор создаёт `invokedynamic` с ссылкой на `LambdaMetafactory.metafactory`.
- `LambdaMetafactory` возвращает `CallSite`, который ссылается на сгенерированный класс, реализующий `Function<String, Integer>`.

---

## 9. Как `invokedynamic` взаимодействует с Method Handles?

[К оглавлению](#оглавление)

`MethodHandle` — это механизм, введённый в Java 7 (в пакете `java.lang.invoke`), который представляет собой типобезопасную ссылку на метод, конструктор или поле. `invokedynamic` тесно связан с `MethodHandle`, так как bootstrap method обычно возвращает `CallSite`, содержащий `MethodHandle` для выполнения целевого метода.

**Ключевые аспекты**:
- **MethodHandle** указывает на конкретный метод или логику, которую нужно выполнить.
- **CallSite** оборачивает `MethodHandle`, добавляя возможность кэширования или динамического изменения.
- `MethodHandle` позволяет выполнять сложные операции, такие как:
  - Вызов методов с адаптацией аргументов (например, преобразование типов).
  - Комбинирование методов (например, фильтрация аргументов).
  - Динамическое изменение целевого метода.

**Пример**:
```java
MethodHandle mh = MethodHandles.lookup().findVirtual(String.class, "length", MethodType.methodType(int.class));
```
`invokedynamic` может использовать этот `MethodHandle` через `CallSite` для вызова метода `String.length()`.

---

## 10. Как JVM оптимизирует вызовы `invokedynamic`?

[К оглавлению](#оглавление)

JVM использует несколько техник для оптимизации `invokedynamic`:
- **Инлайн-кэширование**: После первого вызова bootstrap method возвращает `CallSite`, который кэшируется. Последующие вызовы `invokedynamic` используют этот кэш, избегая повторного вызова BSM.
- **JIT-компиляция**: JIT-компилятор может инлайнить вызовы, основанные на `CallSite`, если они стабильны (например, `ConstantCallSite`).
- **Оптимизация лямбд**: Для лямбда-выражений JVM может создавать лёгкие реализации, минимизируя создание классов.
- **Polymorphic Inline Cache (PIC)**: Для динамических языков JVM может кэшировать несколько `MethodHandle` для одного `CallSite`, чтобы обрабатывать разные типы объектов.

Эти оптимизации делают `invokedynamic` производительным даже в сравнении с традиционными вызовами.

---

## 11. Какие существуют типы `CallSite` и как они влияют на поведение `invokedynamic`?

[К оглавлению](#оглавление)

`CallSite` определяет, как будет выполняться вызов `invokedynamic`. Существует три основных типа:
1. **ConstantCallSite**:
  - Фиксирует `MethodHandle` после инициализации.
  - Используется для неизменяемых вызовов, например, лямбда-выражений.
  - Производительность максимальна, так как вызов не меняется.
2. **MutableCallSite**:
  - Позволяет менять `MethodHandle` во время выполнения через метод `setTarget`.
  - Используется для сценариев, где целевой метод может измениться (например, в динамических языках).
3. **VolatileCallSite**:
  - Подобен `MutableCallSite`, но с потокобезопасными операциями изменения `MethodHandle`.
  - Используется в многопоточных приложениях, где целевой метод может меняться.

Выбор типа `CallSite` зависит от задачи: для лямбд обычно используется `ConstantCallSite`, а для динамических языков — `MutableCallSite`.

---

## 12. Как `invokedynamic` используется в реализации Records в Java?

[К оглавлению](#оглавление)

Records — это компактный способ определения неизменяемых классов данных в Java, автоматически предоставляющих методы, такие как `toString()`, `equals()`, `hashCode()`, а также геттеры для компонентов. `invokedynamic` применяется для оптимизации генерации и выполнения этих методов, особенно для `toString()`, `equals()`, и `hashCode()`.

**Подробности**:
- **Генерация методов**: Компилятор `javac` не создаёт фиксированный байт-код для методов `toString()`, `equals()`, и `hashCode()` в Records. Вместо этого он использует `invokedynamic` для вызова специального **bootstrap method** (BSM) из класса `java.lang.runtime.ObjectMethods`. Этот BSM динамически генерирует реализацию этих методов во время выполнения.
- **Bootstrap Method**: Метод `ObjectMethods.bootstrap` создаёт `CallSite`, который указывает на реализацию метода, специфичную для структуры Record. Например, для `toString()` он генерирует строку, включающую имена и значения всех компонентов Record.
- **Преимущества**:
  - **Гибкость**: JVM может оптимизировать реализацию методов в зависимости от структуры Record.
  - **Меньше байт-кода**: Вместо генерации громоздкого байт-кода для каждого Record, компилятор использует компактные вызовы `invokedynamic`.
  - **Производительность**: JIT-компилятор может инлайнить вызовы, что делает выполнение методов Record очень эффективным.

**Пример**:
```java
record Person(String name, int age) {}
```
- Для метода `toString()` компилятор генерирует `invokedynamic`, который ссылается на `ObjectMethods.bootstrap`.
- BSM возвращает `CallSite`, который создаёт строку вида `Person[name=..., age=...]`, используя reflection-подобный доступ к компонентам Record.

**Байт-код** (упрощённый):
```java
invokedynamic #X, 0 // ObjectMethods.bootstrap для toString
```

---

## 13. Как `invokedynamic` используется для улучшения конкатенации строк в Java 9?

[К оглавлению](#оглавление)

В Java 9 (JEP 280) механизм конкатенации строк был переработан, чтобы использовать `invokedynamic` вместо генерации байт-кода, основанного на `StringBuilder`. Это позволило улучшить производительность и гибкость конкатенации строк.

**Подробности**:
- **До Java 9**: Конкатенация строк (например, `s1 + s2`) компилировалась в вызовы методов `StringBuilder.append()`. Это создавало громоздкий байт-код, особенно для сложных выражений, и не позволяло JVM гибко оптимизировать процесс.
- **После Java 9**: Компилятор `javac` преобразует операции конкатенации строк в вызовы `invokedynamic`, которые ссылаются на bootstrap method из класса `java.lang.invoke.StringConcatFactory`.
- **Bootstrap Method**: Метод `StringConcatFactory.makeConcat` или `StringConcatFactory.makeConcatWithConstants` создаёт `CallSite`, который определяет, как объединить строки. Реализация зависит от контекста:
  - Для простых конкатенаций может использоваться `StringBuilder`.
  - Для конкатенаций с константами или шаблонами создаётся специализированная реализация, минимизирующая накладные расходы.
- **Преимущества**:
  - **Оптимизация**: JVM может выбрать оптимальную стратегию конкатенации во время выполнения (например, использовать `StringBuilder` или прямое копирование памяти).
  - **Меньше байт-кода**: `invokedynamic` делает байт-код компактнее, так как логика конкатенации выносится в BSM.
  - **Гибкость**: Будущие улучшения конкатенации могут быть реализованы в `StringConcatFactory` без изменения байт-кода.

**Пример**:
```java
String result = "Hello, " + name + "!";
```
- Компилятор генерирует:
```java
invokedynamic #X, 0 // StringConcatFactory.makeConcatWithConstants
```
- BSM `makeConcatWithConstants` создаёт `CallSite`, который формирует строку, используя шаблон `"Hello, \u0001!"` (где `\u0001` — это плейсхолдер для переменной `name`).

**Варианты реализации**:
- `StringConcatFactory` может использовать разные стратегии:
  - **StringBuilderStrategy**: Для сложных конкатенаций, где много переменных.
  - **MethodHandleStrategy**: Для оптимизированных вызовов с использованием `MethodHandle`.
  - **DirectStrategy**: Для прямой конкатенации без `StringBuilder` в простых случаях (возможность добавлена в JVM).

---

## 14. Как работает захват переменных (замыкания) в лямбда-выражениях?

[К оглавлению](#оглавление)

**Описание**: Лямбда-выражения могут захватывать переменные из окружающей области видимости, но только если они `final` или effectively final (не изменяются после инициализации).

**Пример**:
```java
int multiplier = 2;
Function<Integer, Integer> func = x -> x * multiplier;
System.out.println(func.apply(5)); // 10
```

**Внутреннее устройство**:
- Захваченные переменные копируются в статический метод, созданный для лямбда-выражения.
- Если переменная — примитив, она передается по значению.
- Если переменная — объект, передается ссылка на объект (но сам объект может быть изменяемым).
- Компилятор проверяет, что захваченные переменные являются effectively final, чтобы избежать проблем с синхронизацией в многопоточной среде.

**Ограничения**:
- Попытка изменить захваченную переменную вызовет ошибку компиляции:
  ```java
  int multiplier = 2;
  Function<Integer, Integer> func = x -> x * multiplier++; // Ошибка: variable must be final or effectively final
  ```

**Оптимизации**:
- JVM минимизирует копирование захваченных переменных, используя прямой доступ к памяти.
- JIT-компилятор может инлайн-вызовы, устраняя накладные расходы на захват.

---

## 15. Как лямбда-выражения используются с Stream API?

[К оглавлению](#оглавление)

**Описание**: Лямбда-выражения являются основой для работы с Stream API, позволяя задавать поведение для операций, таких как `map`, `filter`, `forEach`.

**Пример**:
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
numbers.stream()
       .filter(n -> n % 2 == 0) // Predicate
       .map(n -> n * n) // Function
       .forEach(System.out::println); // Consumer
```

**Внутреннее устройство**:
- Stream API использует функциональные интерфейсы (`Predicate`, `Function`, `Consumer`) для определения операций.
- Лямбда-выражения преобразуются в реализации этих интерфейсов через `invokedynamic`.
- Пайплайн операций (`ReferencePipeline`) строится как цепочка лямбда-выражений, выполняемых лениво (lazy evaluation).
- Терминальная операция (например, `forEach`) запускает выполнение пайплайна, вызывая лямбда-выражения для каждого элемента.

**Оптимизации**:
- JVM может объединять операции (`filter` + `map`) в один проход для минимизации итераций.
- Параллельные потоки используют `ForkJoinPool` для распределения задач, где лямбда-выражения выполняются в разных потоках.

---

## 16. Какие ограничения и проблемы связаны с лямбда-выражениями?

[К оглавлению](#оглавление)

**Описание**: Несмотря на мощь, лямбда-выражения имеют ограничения:
- **Ограниченный доступ к переменным**: Только `final` или effectively final переменные могут быть захвачены.
- **Сложность отладки**: Лямбда-выражения не имеют явного имени, что затрудняет анализ стека вызовов.
- **Производительность**: Хотя лямбды оптимизированы, захват переменных может создавать небольшие накладные расходы.
- **Читаемость**: Сложные лямбда-выражения (с большими блоками кода) могут ухудшать читаемость.

**Решения**:
- Используйте метод-ссылки для простых операций.
- Избегайте сложных блоков в лямбда-выражениях, вынося логику в отдельные методы.
- Для отладки используйте инструменты, такие как Java Flight Recorder (JFR).

---

## 17. Что такое функциональный интерфейс в Java?

[К оглавлению](#оглавление)

Функциональный интерфейс — это интерфейс в Java, который содержит **ровно один абстрактный метод** (SAM — Single Abstract Method). Он может также включать любое количество `default` или `static` методов, но только один абстрактный метод определяет его функциональную природу. Функциональные интерфейсы используются для представления лямбда-выражений и метод-референсов, которые могут быть переданы как аргументы или присвоены переменным.

**Пример**:
```java
@FunctionalInterface
interface MyFunction {
    int apply(String s); // Единственный абстрактный метод
    default void doNothing() {} // Дополнительный default-метод
}
```
Аннотация `@FunctionalInterface` необязательна, но помогает компилятору проверить, что интерфейс соответствует требованиям (только один абстрактный метод).

---

## 18. Как функциональные интерфейсы связаны с лямбда-выражениями?

[К оглавлению](#оглавление)

Лямбда-выражения в Java 8 — это синтаксический сахар для реализации функциональных интерфейсов. Когда вы пишете лямбда-выражение, компилятор `javac` преобразует его в реализацию функционального интерфейса, используя инструкцию `invokedynamic`.

**Процесс**:
1. Лямбда-выражение, например, `s -> s.length()`, компилируется в вызов `invokedynamic`.
2. `invokedynamic` ссылается на bootstrap method в `LambdaMetafactory`, который создаёт `CallSite`.
3. `CallSite` указывает на динамически сгенерированный класс, реализующий функциональный интерфейс (например, `Function<String, Integer>`).
4. Этот класс содержит реализацию абстрактного метода, соответствующую телу лямбда-выражения.

**Пример**:
```java
Function<String, Integer> length = s -> s.length();
```
- Компилятор преобразует лямбду в `invokedynamic`, который вызывает `LambdaMetafactory.metafactory`.
- `LambdaMetafactory` генерирует класс, реализующий `Function`, с методом `apply`, возвращающим длину строки.

**Байт-код** (упрощённый):
```java
invokedynamic #X,  ECONO, 0 // java/lang/invoke/LambdaMetafactory.metafactory
```

---

## 19. Какие стандартные функциональные интерфейсы предоставляет Java?

[К оглавлению](#оглавление)

Java 8 ввела пакет `java.util.function`, содержащий множество встроенных функциональных интерфейсов для типичных сценариев. Основные из них:

- **Function<T, R>**: Представляет функцию, принимающую аргумент типа `T` и возвращающую результат типа `R`.
  ```java
  Function<String, Integer> length = s -> s.length();
  ```
- **Predicate<T>**: Проверяет условие для аргумента типа `T`, возвращает `boolean`.
  ```java
  Predicate<String> isEmpty = s -> s.isEmpty();
  ```
- **Consumer<T>**: Принимает в качестве входного аргумента объект типа `T`, совершает некоторые действия, но при этом ничего не возвращает.
  ```java
  Consumer<String> print = s -> System.out.println(s);
  ```
- **Supplier<T>**: Не принимает никаких аргументов, но возвращает некоторый объект типа `T`.
  ```java
  Supplier<Double> random = () -> Math.random();
  ```
- **UnaryOperator<T>** и **BinaryOperator<T>**: Специализированные версии `Function` для операций с одним или двумя аргументами того же типа.
  ```java
  UnaryOperator<Integer> square = x -> x * x;
  ```

Другие интерфейсы включают `BiPredicate`, `BiConsumer`, `IntFunction`, `DoublePredicate` и т.д., оптимизированные для примитивных типов, чтобы избежать автоупаковки.

---

## 20. Как создавать собственные функциональные интерфейсы?

[К оглавлению](#оглавление)

Вы можете определить собственный функциональный интерфейс, просто создав интерфейс с одним абстрактным методом. Использование аннотации `@FunctionalInterface` рекомендуется для проверки.

**Пример**:
```java
@FunctionalInterface
interface Calculator {
    double calculate(double a, double b);
}

Calculator add = (a, b) -> a + b;
Calculator multiply = (a, b) -> a * b;
```

**Ограничения**:
- Интерфейс должен содержать ровно один абстрактный метод.
- Методы из `Object` (`toString`, `equals`, `hashCode`) не считаются абстрактными, поэтому интерфейс вроде `interface X { String toString(); }` всё ещё считается функциональным.

---

## 21. Какова внутренняя архитектура Stream API?

[К оглавлению](#оглавление)

Stream API построен вокруг концепции **конвейера обработки** (pipeline), который состоит из трёх основных компонентов:
- **Источник данных** (Source): Стримы получают данные из коллекций (`Collection.stream()`), массивов (`Arrays.stream()`), генераторов (`Stream.generate()`), файлов (`Files.lines()`) или других источников.
- **Промежуточные операции** (Intermediate Operations): Операции, такие как `filter`, `map`, `sorted`, которые формируют цепочку преобразований. Они ленивые (lazy) и не выполняются до вызова терминальной операции.
- **Терминальная операция** (Terminal Operation): Операция, такая как `collect`, `forEach`, `reduce`, которая завершает обработку и инициирует выполнение всего конвейера.

**Внутренняя структура**:
- Стримы реализованы через классы в пакете `java.util.stream`, такие как `ReferencePipeline`, `IntPipeline`, `LongPipeline`, `DoublePipeline` (для примитивных типов).
- Каждый стрим представлен объектом, реализующим интерфейс `Stream` (или его специализированные версии, например, `IntStream`).
- Внутренне стрим хранит цепочку операций как **граф операций** (operation graph), где каждая операция представлена как узел (`Stage`), связанный с предыдущим.

**Ключевые классы**:
- `AbstractPipeline`: Базовый класс для всех стримов, управляющий цепочкой операций.
- `ReferencePipeline`: Для объектов (`Stream<T>`).
- `Sink`: Интерфейс для передачи данных между стадиями конвейера.

---

## 22. Как работает ленивое выполнение (laziness) в Stream API?

[К оглавлению](#оглавление)

Ленивое выполнение — ключевая особенность Stream API, которая означает, что промежуточные операции (`filter`, `map`, и т.д.) не выполняются, пока не вызвана терминальная операция (`collect`, `forEach`, и т.д.).

**Механизм**:
- Промежуточные операции создают новый объект стрима, добавляя операцию в цепочку (граф операций), но не обрабатывают данные.
- Каждая операция представлена как `Stage` в классе `PipelineHelper`, который хранит информацию о её типе и лямбда-выражении (если есть).
- Терминальная операция вызывает метод `evaluate()` в `AbstractPipeline`, который инициирует обработку данных.

**Процесс выполнения**:
1. Когда вызывается терминальная операция, стрим проходит через метод `wrapSink`, который создаёт цепочку `Sink`-объектов для каждой операции.
2. `Sink` определяет, как данные передаются между стадиями (например, через `accept` для обработки элемента).
3. Данные из источника проходят через всю цепочку `Sink`-ов, выполняя операции последовательно (или параллельно для `parallelStream`).

**Пример**:
```java
List<String> result = Stream.of("a", "bb", "ccc")
                           .filter(s -> s.length() > 1)
                           .map(String::toUpperCase)
                           .collect(Collectors.toList());
```
- `filter` и `map` создают новые стадии, но ничего не делают до вызова `collect`.
- `collect` запускает обработку, проходя через все элементы и применяя `filter` и `map` к каждому.

---

## 23. Как данные проходят через конвейер операций?

[К оглавлению](#оглавление)

Данные в Stream API обрабатываются через **цепочку `Sink`-ов**, где каждый `Sink` представляет операцию (например, `filter`, `map`). Эта цепочка формируется во время выполнения терминальной операции.

**Процесс**:
1. **Создание цепочки**:
  - Метод `wrapSink` в `AbstractPipeline` создаёт `Sink` для каждой операции в обратном порядке (от терминальной к источнику).
  - Например, для `stream.filter(...).map(...).collect(...)` создаётся цепочка: `Sink(collect) -> Sink(map) -> Sink(filter) -> Source`.
2. **Обработка данных**:
  - Источник данных вызывает метод `begin` у первого `Sink`, затем передаёт элементы через `accept`.
  - Каждый `Sink` обрабатывает элемент и передаёт его следующему `Sink` (или отбрасывает, если это `filter`).
3. **Завершение**:
  - Терминальная операция (например, `collect`) собирает результаты через `Collector` или выполняет побочный эффект (`forEach`).

**Пример кода**:
```java
Stream.of("a", "bb", "ccc")
      .filter(s -> s.length() > 1)
      .map(String::toUpperCase)
      .forEach(System.out::println);
```
- **Внутренне**:
  - Создаётся цепочка `Sink`-ов: `forEach -> map -> filter -> source`.
  - Источник (`Stream.of`) передаёт элементы в `filter`, который проверяет длину.
  - Прошедшие элементы передаются в `map`, который преобразует их в верхний регистр.
  - Результаты передаются в `forEach`, который выводит их.

**Роль `invokedynamic`**:
- Лямбды для `filter` и `map` реализованы через `invokedynamic`, что позволяет JVM оптимизировать их вызовы (например, инлайнить `String::toUpperCase`).

---

## 24. Как работает параллельная обработка в Stream API?

[К оглавлению](#оглавление)

**Ответ**:  
Параллельные стримы (`parallelStream` или `stream.parallel()`) используют **Fork/Join Framework** для распределения работы между потоками.

**Механизм**:
1. **Разделение данных**:
  - Источник данных делится на части с помощью интерфейса `Spliterator` (Splittable Iterator).
  - `Spliterator` определяет, как разбить данные (например, для `ArrayList` это деление массива на подмассивы).
2. **Fork/Join Pool**:
  - Параллельные стримы используют `ForkJoinPool.commonPool()` (по умолчанию) для выполнения задач.
  - Каждая часть данных обрабатывается в отдельной задаче (`ForkJoinTask`).
3. **Обработка**:
  - Каждая задача выполняет конвейер операций (например, `filter -> map`) над своей частью данных.
  - Лямбда-выражения, реализованные через `invokedynamic`, применяются в каждом потоке.
4. **Объединение**:
  - Результаты от разных потоков объединяются через терминальную операцию (например, `Collector` для `collect`).

**Пример**:
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
int sum = numbers.parallelStream()
                .mapToInt(i -> i)
                .sum();
```
- `Spliterator` делит список на части (например, [1, 2] и [3, 4, 5]).
- Каждый поток выполняет `mapToInt` и частичную сумму.
- Результаты объединяются в итоговую сумму.

**Оптимизации**:
- **Spliterator Characteristics**: `Spliterator` сообщает JVM о свойствах данных (например, `ORDERED`, `SIZED`), что помогает оптимизировать разделение.
- **Инлайнинг лямбд**: `invokedynamic` позволяет JIT-компилятору встраивать лямбда-выражения в задачи Fork/Join.
- **Работа с примитивами**: Для примитивных типов (`IntStream`, `LongStream`) используются специализированные стримы, минимизирующие автоупаковку.

**Ограничения**:
- Параллелизм эффективен только для больших наборов данных, где выгода от многопоточности превышает накладные расходы.
- Лямбды и коллекторы должны быть потокобезопасными (например, `toConcurrentMap` вместо `toMap`).

---

## 25. Нюансы использования параллельной обработки в Java 8

[К оглавлению](#оглавление)

Стримы могут быть последовательными и параллельными. Операции над последовательными стримами выполняются в одном потоке процессора, над параллельными — используя несколько потоков процессора. Параллельные стримы используют общий `ForkJoinPool`, доступный через статический метод `ForkJoinPool.commonPool()`. При этом, если окружение не является многоядерным, то поток будет выполняться как последовательный. Фактически применение параллельных стримов сводится к тому, что данные в стримах будут разделены на части, каждая часть обрабатывается на отдельном ядре процессора, и в конце эти части соединяются, и над ними выполняются конечные операции.

Для создания параллельного потока из коллекции можно также использовать метод `parallelStream()` интерфейса `Collection`. Чтобы сделать обычный последовательный стрим параллельным, надо вызвать у объекта `Stream` метод `parallel()`. Метод `isParallel()` позволяет узнать, является ли стрим параллельным. С помощью методов `parallel()` и `sequential()` можно определять, какие операции могут быть параллельными, а какие только последовательными. Так же из любого последовательного стрима можно сделать параллельный и наоборот:

```java
collection.stream()
          .peek(...) // операция последовательна
          .parallel()
          .map(...) // операция может выполняться параллельно
          .sequential()
          .reduce(...) // операция снова последовательна
```

Как правило, элементы передаются в стрим в том же порядке, в котором они определены в источнике данных. При работе с параллельными стримами система сохраняет порядок следования элементов. Исключение составляет метод `forEach()`, который может выводить элементы в произвольном порядке. Чтобы сохранить порядок следования, необходимо применять метод `forEachOrdered()`.

**Критерии, которые могут повлиять на производительность в параллельных стримах**:
- **Размер данных**: Чем больше данных, тем сложнее сначала разделять данные, а потом их соединять.
- **Количество ядер процессора**: Теоретически, чем больше ядер в компьютере, тем быстрее программа будет работать. Если на машине одно ядро, нет смысла применять параллельные потоки.
- **Структура данных**: Чем проще структура данных, с которой работает поток, тем быстрее будут происходить операции. Например, данные из `ArrayList` легко использовать, так как структура данной коллекции предполагает последовательность несвязанных данных. А вот коллекция типа `LinkedList` — не лучший вариант, так как в последовательном списке все элементы связаны с предыдущими/последующими. И такие данные трудно распараллелить.
- **Примитивные типы**: Над данными примитивных типов операции будут производиться быстрее, чем над объектами классов.
- **Долгие операции**: Крайне не рекомендуется использовать параллельные стримы для сколь-нибудь долгих операций (например, сетевых соединений), так как все параллельные стримы работают c одним `ForkJoinPool`, то такие долгие операции могут остановить работу всех параллельных стримов в JVM из-за отсутствия доступных потоков в пуле. Параллельные стримы стоит использовать лишь для коротких операций, где счет идет на миллисекунды, но не для тех, где счет может идти на секунды и минуты.
- **Сохранение порядка**: Сохранение порядка в параллельных стримах увеличивает издержки при выполнении. Если порядок не важен, то имеется возможность отключить его сохранение и тем самым увеличить производительность, использовав промежуточную операцию `unordered()`:

```java
collection.parallelStream()
          .sorted()
          .unordered()
          .collect(Collectors.toList());
```

---

## 26. Как JVM оптимизирует выполнение Stream API?

[К оглавлению](#оглавление)

JVM применяет несколько оптимизаций для Stream API, многие из которых связаны с `invokedynamic` и JIT-компиляцией:

1. **Инлайнинг лямбд**:
  - Лямбда-выражения, реализованные через `invokedynamic`, инлайнятся JIT-компилятором, что устраняет накладные расходы на вызов методов.
  - Например, `s -> s.length()` может быть встроено напрямую как вызов `String.length()`.

2. **Кэширование CallSite**:
  - `invokedynamic` создаёт `CallSite` один раз, который кэшируется для последующих вызовов, минимизируя затраты на создание лямбд.

3. **Оптимизация конвейера**:
  - JVM может объединять операции (например, `filter` и `map`) в одну итерацию по данным, избегая создания промежуточных стримов.
  - Например, `stream.filter(...).map(...)` обрабатывается за один проход по данным.

4. **Параллельные оптимизации**:
  - `Fork/Join Framework` оптимизирует разделение задач, используя work-stealing для балансировки нагрузки.
  - Для примитивных стримов (`IntStream`) избегается автоупаковка, что снижает затраты памяти.

5. **Элиминация копий**:
  - В некоторых случаях JVM может устранять создание промежуточных коллекций, особенно при использовании `collect` с оптимизированными коллекторами.

**Пример**:
```java
stream.filter(s -> s.length() > 2)
      .map(String::toUpperCase)
      .collect(Collectors.toList());
```
- JVM объединяет `filter` и `map` в один цикл.
- Лямбды инлайнятся через `invokedynamic`, минимизируя вызовы.
- Результат собирается в `ArrayList` без промежуточных копий.

---

## 27. Как Stream API обрабатывает примитивные типы?

[К оглавлению](#оглавление)

Для минимизации автоупаковки (`Integer` вместо `int`) Stream API предоставляет специализированные стримы: `IntStream`, `LongStream`, `DoubleStream`.

**Механизм**:
- Эти стримы используют примитивные типы напрямую, избегая создания объектов.
- Операции, такие как `mapToInt`, `sum`, `average`, оптимизированы для примитивов.
- Внутренне используются классы, такие как `IntPipeline`, которые реализуют те же принципы, что и `ReferencePipeline`, но без упаковки.

**Пример**:
```java
IntStream.range(1, 100)
         .filter(i -> i % 2 == 0)
         .sum();
```
- `IntStream` работает с `int` напрямую, избегая создания объектов `Integer`.
- Лямбда для `filter` реализована через `invokedynamic`, но операция `sum` использует нативные примитивные вычисления.

---

## 28. Как Collectors работают изнутри?

[К оглавлению](#оглавление)

`Collectors` — это утилитный класс, предоставляющий реализации интерфейса `Collector`, который определяет, как собирать элементы стрима в результат.

**Структура Collector**:
- `Supplier<A>`: Создаёт контейнер для накопления (например, `ArrayList::new`).
- `BiConsumer<A, T>`: Добавляет элемент в контейнер (например, `List::add`).
- `BinaryOperator<A>`: Объединяет два контейнера (для параллельных стримов).
- `Function<A, R>`: Преобразует контейнер в финальный результат.
- `Characteristics`: Указывает свойства коллектора (например, `CONCURRENT`, `UNORDERED`).

**Пример (`toList`)**:
- `Supplier`: `ArrayList::new`.
- `BiConsumer`: `(list, item) -> list.add(item)`.
- `BinaryOperator`: `(list1, list2) -> { list1.addAll(list2); return list1; }`.
- `Function`: `list -> list`.

**Внутренний процесс**:
- Терминальная операция `collect` вызывает `Collector.accumulator()` для каждого элемента.
- Для параллельных стримов результаты от разных потоков объединяются через `combiner`.

**Роль `invokedynamic`**:
- Лямбда-выражения в коллекторах (например, `Collectors.groupingBy(s -> s.length())`) используют `invokedynamic` для создания `Function` или других интерфейсов.

---

## 29. Какие ограничения и подводные камни есть у Stream API?

[К оглавлению](#оглавление)

**Ограничения**:
- **Производительность**:
  - Накладные расходы на создание конвейера и `invokedynamic` делают стримы менее эффективными для малых коллекций.
  - Параллельные стримы могут быть медленнее для небольших данных из-за затрат на `Fork/Join`.
- **Отладка**:
  - Ленивость и `invokedynamic` затрудняют отладку, так как лямбды скрыты в сгенерированных классах.
  - Используйте `peek` для промежуточного логирования.
- **Потокобезопасность**:
  - Лямбды и коллекторы в параллельных стримах должны быть stateless и thread-safe.
- **Память**:
  - Промежуточные операции, такие как `sorted`, могут требовать дополнительной памяти.
- **Однократное использование**: Стрим нельзя переиспользовать после терминальной операции.

---

## 30. Как отладить внутреннюю работу Stream API?

[К оглавлению](#оглавление)

- **Логирование**:
  ```java
  stream.peek(s -> System.out.println("Processing: " + s))
  ```
- **Байт-код**:
  ```bash
  javap -c -v MyClass.class
  ```
  Показывает вызовы `invokedynamic` для лямбд.
- **JVM-опции**:
  - `-XX:+TraceInvokeDynamic`: Трассировка создания `CallSite`.
  - `-XX:+PrintCompilation`: Анализ JIT-оптимизаций.
- **Профилирование**: Используйте VisualVM или IntelliJ Profiler для анализа производительности стримов.
- **Spliterator**: Можно реализовать кастомный `Spliterator` для отладки разделения данных.

---

## 31. Что такое Stream API и зачем оно нужно?

[К оглавлению](#оглавление)

**Ответ**:  
Stream API — это API в пакете `java.util.stream`, предназначенное для обработки последовательностей данных (например, коллекций, массивов или других источников) в функциональном style. Оно позволяет выполнять операции над данными декларативно, минимизируя использование циклов и промежуточных переменных.

**Цели**:
- **Упрощение кода**: Декларативный подход делает код короче и выразительнее по сравнению с традиционными циклами.
- **Параллелизм**: Stream API поддерживает параллельную обработку данных с минимальными усилиями.
- **Гибкость**: Поддерживает широкий набор операций, таких как фильтрация, маппинг, сортировка и агрегация.
- **Интеграция с функциональным программированием**: Использует лямбда-выражения и функциональные интерфейсы (`Function`, `Predicate`, `Consumer` и др.).

**Пример**:
```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
List<String> filtered = names.stream()
                            .filter(s -> s.startsWith("A"))
                            .collect(Collectors.toList()); // [Alice]
```

---

## 32. Какие основные операции предоставляет Stream API?

[К оглавлению](#оглавление)

Stream API делит операции на **промежуточные** и **терминальные**.

**Промежуточные операции** (возвращают новый стрим):
- `filter(Predicate<T>)`: Фильтрует элементы по условию.
  ```java
  stream.filter(s -> s.length() > 2)
  ```
- `map(Function<T, R>)`: Преобразует элементы в новый тип.
  ```java
  stream.map(String::toUpperCase)
  ```
- `flatMap(Function<T, Stream<R>>)`: Преобразует элемент в стрим и объединяет результаты.
  ```java
  stream.flatMap(s -> Stream.of(s.split("")))
  ```
- `sorted(Comparator<T>)`: Сортирует элементы.
  ```java
  stream.sorted()
  ```
- `distinct()`: Удаляет дубликаты.
- `limit(long n)`: Ограничивает количество элементов.
- `skip(long n)`: Пропускает первые n элементов.

**Терминальные операции** (завершают стрим):
- `collect(Collector)`: Собирает элементы в коллекцию или другой результат.
  ```java
  stream.collect(Collectors.toList())
  ```
- `forEach(Consumer<T>)`: Выполняет действие для каждого элемента.
  ```java
  stream.forEach(System.out::println)
  ```
- `reduce(BinaryOperator<T>)`: Агрегирует элементы (например, сумма, минимум).
  ```java
  stream.reduce(0, Integer::sum)
  ```
- `count()`: Подсчитывает количество элементов.
- `anyMatch(Predicate<T>)`, `allMatch(Predicate<T>)`, `noneMatch(Predicate<T>)`: Проверяют элементы на соответствие условию.
- `findFirst()`, `findAny()`: Возвращают первый или любой элемент.

---

## 33. Как Stream API взаимодействует с функциональными интерфейсами?

[К оглавлению](#оглавление)

Stream API использует функциональные интерфейсы из пакета `java.util.function` для определения операций. Основные интерфейсы:
- `Function<T, R>`: Для `map`, `flatMap`.
- `Predicate<T>`: Для `filter`, `anyMatch`, `allMatch`, `noneMatch`.
- `Consumer<T>`: Для `forEach`.
- `BinaryOperator<T>`: Для `reduce`.
- `Supplier<T>`: Для генерации стримов (`Stream.generate`).

**Пример**:
```java
Predicate<String> isLong = s -> s.length() > 3;
stream.filter(isLong);
```
Лямбда-выражения или метод-референсы, переданные в эти методы, преобразуются в `invokedynamic`, что обеспечивает их эффективную реализацию.

---

## 34. Как Collectors используются в Stream API?

[К оглавлению](#оглавление)

`Collectors` — это утилитный класс (`java.util.stream.Collectors`), предоставляющий готовые коллекторы для терминальной операции `collect`. Они позволяют собирать элементы стрима в коллекции, строки, числа или другие структуры.

**Популярные коллекторы**:
- `toList()`, `toSet()`: Собирают элементы в `List` или `Set`.
  ```java
  List<String> list = stream.collect(Collectors.toList());
  ```
- `toMap(Function, Function)`: Создаёт `Map` с ключами и значениями.
  ```java
  Map<String, Integer> map = stream.collect(Collectors.toMap(s -> s, String::length));
  ```
- `joining()`: Объединяет строки с разделителем.
  ```java
  String result = stream.collect(Collectors.joining(", "));
  ```
- `groupingBy(Function)`: Группирует элементы по ключу.
  ```java
  Map<Integer, List<String>> byLength = stream.collect(Collectors.groupingBy(String::length));
  ```
- `partitioningBy(Predicate)`: Разделяет элементы на две группы (true/false).
  ```java
  Map<Boolean, List<String>> partitioned = stream.collect(Collectors.partitioningBy(s -> s.length() > 2));
  ```

**Собственные коллекторы**: Можно создать кастомный коллектор с помощью `Collector.of`.

---

## 35. Для чего в стримах применяются методы `forEach()` и `forEachOrdered()`?

[К оглавлению](#оглавление)

Оба метода являются терминальными операциями и служат для выполнения действия над каждым элементом стрима, но имеют важные различия:

### `forEach()`
- **Назначение**: Выполняет действие для каждого элемента стрима.
- **Порядок выполнения**: Не гарантирует порядок обработки элементов (особенно в параллельных стримах).
- **Использование**:
  ```java
  Stream.of("a", "b", "c").forEach(System.out::print);
  // Может вывести: a b c (но в параллельном стриме порядок может быть другим)
  ```
- **Когда использовать**:
  - Когда порядок обработки не важен.
  - Для побочных эффектов (запись в лог, изменение внешних переменных).
  - В параллельных стримах, где производительность важнее порядка.

### `forEachOrdered()`
- **Назначение**: Выполняет действие для каждого элемента с сохранением порядка исходного стрима.
- **Порядок выполнения**: Гарантирует обработку в порядке встречи элементов в источнике.
- **Использование**:
  ```java
  Stream.of("a", "b", "c").parallel().forEachOrdered(System.out::print);
  // Всегда выведет: a b c, даже в параллельном стриме
  ```
- **Когда использовать**:
  - Когда критически важен порядок обработки.
  - Для операций, где последовательность имеет значение (например, запись в упорядоченную коллекцию).
  - В параллельных стримах, когда нужно сохранить порядок исходных данных.

---

## 36. Как Stream API развивается в новых версиях Java?

[К оглавлению](#оглавление)

Stream API продолжает улучшаться:
- **Java 9**: Добавлен `takeWhile` и `dropWhile` для условного взятия или пропуска элементов.
  ```java
  Stream.of(1, 2, 3, 4).takeWhile(i -> i < 3).collect(Collectors.toList()); // [1, 2]
  ```
- **Java 10**: `Collectors.toUnmodifiableList/Set/Map` для создания неизменяемых коллекций.
- **Java 16**: `mapMulti` для более гибкого преобразования элементов в стримы.
  ```java
  stream.mapMulti((s, consumer) -> s.chars().forEach(c -> consumer.accept((char) c)));
  ```
- **Будущее**: В рамках Project Valhalla стримы могут быть оптимизированы для работы с value types и примитивами, уменьшая автоупаковку.