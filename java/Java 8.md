Что такое «лямбда»? Какова структура и особенности использования лямбда-выражения?

Лямбда представляет собой набор инструкций, которые можно выделить в отдельную переменную и затем многократно вызвать в различных местах программы.
Основу лямбда-выражения составляет лямбда-оператор, который представляет стрелку ->. Этот оператор разделяет лямбда-выражение на две части: левая часть содержит список параметров выражения, а правая, собственно, представляет тело лямбда-выражения, где выполняются все действия.
Лямбда-выражение не выполняется само по себе, а образует реализацию метода, определенного в функциональном интерфейсе. При этом важно, что функциональный интерфейс должен содержать только один единственный метод без реализации.

interface Operationable { int calculate(int x, int y); }
public static void main(String[] args) {
Operationable operation = (x, y) -> x + y; int result = operation.calculate(10, 20); System.out.println(result); //30 }

По факту лямбда-выражения являются в некотором роде сокращенной формой внутренних анонимных классов, которые ранее применялись в Java.
Отложенное выполнение (deferred execution) лямбда-выражения- определяется один раз в одном месте программы, вызываются при необходимости, любое количество раз и в произвольном месте программы.
Параметры лямбда-выражения должны соответствовать по типу параметрам метода функционального интерфейса:
operation = (int x, int y) -> x + y; //При написании самого лямбда-выражения тип параметров разрешается не указывать: (x, y) -> x + y; //Если метод не принимает никаких параметров, то пишутся пустые скобки, например, () -> 30 + 20; //Если метод принимает только один параметр, то скобки можно опустить: n -> n * n;
Конечные лямбда-выражения не обязаны возвращать какое-либо значение.

interface Printable { void print(String s); }
public static void main(String[] args) {
Printable printer = s -> System.out.println(s); printer.print("Hello, world"); }

Блочные лямбда-выражения обрамляются фигурными скобками. В блочных лямбда-выражениях можно использовать внутренние вложенные блоки, циклы, конструкции if, switch, создавать переменные и т.д. Если блочное лямбда-выражение должно возвращать значение, то явным образом применяется оператор return:

Operationable operation = (int x, int y) -> { if (y == 0) { return 0; } else { return x / y; } };

Передача лямбда-выражения в качестве параметра метода:

interface Condition { boolean isAppropriate(int n); }
private static int sum(int[] numbers, Condition condition) { int result = 0; for (int i : numbers) {
if (condition.isAppropriate(i))
{ result += i; } } return result; }
public static void main(String[] args) { System.out.println(sum(new int[] {0, 1, 0, 3, 0, 5, 0, 7, 0, 9}, (n) -> n != 0)); }
--------------------------------------------------------------------------------------------------------------------
К каким переменным есть доступ у лямбда-выражений?

Доступ к переменным внешней области действия из лямбда-выражения очень схож к доступу из анонимных объектов. Можно ссылаться на:
- неизменяемые (effectively final - не обязательно помеченные как final) локальные переменные;
- поля класса;
- статические переменные.
  К методам по умолчанию реализуемого функционального интерфейса обращаться внутри лямбда-выражения запрещено.
--------------------------------------------------------------------------------------------------------------------
Как отсортировать список строк с помощью лямбда-выражения?

public static List<String> sort(List<String> list){ Collections.sort(list, (a, b) -> a.compareTo(b));
return list;
}
--------------------------------------------------------------------------------------------------------------------
Что такое «ссылка на метод»?

Если существующий в классе метод уже делает все, что необходимо, то можно воспользоваться механизмом method reference (ссылка на метод) для непосредственной передачи этого метода. Такая ссылка передается в виде:
имя_класса::имя_статического_метода для статического метода;
объект_класса::имя_метода для метода экземпляра;
название_класса::new для конструктора.
Результат будет в точности таким же, как в случае определения лямбда-выражения, которое вызывает этот метод.

private interface Measurable { public int length(String string); }
public static void main(String[] args) {
Measurable a = String::length; System.out.println(a.length("abc"));
}

Ссылки на методы потенциально более эффективны, чем использование лямбда-выражений. Кроме того, они предоставляют компилятору более качественную информацию о типе и при возможности выбора между использованием ссылки на существующий метод и использованием лямбда-выражения, следует всегда предпочитать использование ссылки на метод.
--------------------------------------------------------------------------------------------------------------------
Какие виды ссылок на методы вы знаете?

на статический метод;
на метод экземпляра;
на конструкторе.
--------------------------------------------------------------------------------------------------------------------
Объясните выражение System.out::println.

Данное выражение иллюстрирует механизм instance method reference: передачи ссылки на метод println() статического поля out класса System.

--------------------------------------------------------------------------------------------------------------------
Что такое «функциональные интерфейсы»?

Функциональный интерфейс - это интерфейс, который определяет только один абстрактный метод.
Чтобы точно определить интерфейс как функциональный, добавлена аннотация @FunctionalInterface, работающая по принципу @Override. Она обозначит замысел и не даст определить второй абстрактный метод в интерфейсе.
Интерфейс может включать сколько угодно default методов и при этом оставаться функциональным, потому что default методы - не абстрактные.
--------------------------------------------------------------------------------------------------------------------
Для чего нужны функциональные интерфейсы Function<T,R>, DoubleFunction<R>, IntFunction<R> и LongFunction<R>?

Function<T, R> - интерфейс, с помощью которого реализуется функция, получающая на вход экземпляр класса T и возвращающая на выходе экземпляр класса R.
Методы по умолчанию могут использоваться для построения цепочек вызовов (compose, andThen).

Типичный пример метода в Stream c аргументом Function — метод map, который принимает элементы одного типа, что-то с ними делает и передает дальше, но это уже могут быть элементы другого типа.

Function<String, Integer> toInteger = Integer::valueOf; Function<String, String> backToString = toInteger.andThen(String::valueOf); backToString.apply("123"); // "123"

DoubleFunction<R> - функция, получающая на вход Double и возвращающая на выходе экземпляр класса R;
IntFunction<R> - функция, получающая на вход Integer и возвращающая на выходе экземпляр класса R;
LongFunction<R> - функция, получающая на вход Long и возвращающая на выходе экземпляр класса R.
--------------------------------------------------------------------------------------------------------------------
Для чего нужны функциональные интерфейсы UnaryOperator<T>, DoubleUnaryOperator, IntUnaryOperator и LongUnaryOperator?

UnaryOperator<T> (унарный оператор) принимает в качестве параметра объект типа T, выполняет над ними операции и возвращает результат операций в виде объекта типа T:

В качестве метода, использующего UnaryOperator как аргумент, возьмем метод класса Stream — iterate.

UnaryOperator<Integer> operator = x -> x * x; System.out.println(operator.apply(5)); // 25

DoubleUnaryOperator - унарный оператор, получающий на вход Double;
IntUnaryOperator - унарный оператор, получающий на вход Integer;
LongUnaryOperator - унарный оператор, получающий на вход Long.
--------------------------------------------------------------------------------------------------------------------
Для чего нужны функциональные интерфейсы BinaryOperator<T>, DoubleBinaryOperator, IntBinaryOperator и LongBinaryOperator?

BinaryOperator<T> (бинарный оператор) - интерфейс, с помощью которого реализуется функция, получающая на вход два экземпляра класса T и возвращающая на выходе экземпляр класса T.

BinaryOperator<Integer> operator = (a, b) -> a + b; System.out.println(operator.apply(1, 2)); // 3

DoubleBinaryOperator - бинарный оператор, получающий на вход Double;
IntBinaryOperator - бинарный оператор, получающий на вход Integer;
LongBinaryOperator - бинарный оператор, получающий на вход Long.
--------------------------------------------------------------------------------------------------------------------
Для чего нужны функциональные интерфейсы Predicate<T>, DoublePredicate, IntPredicate и LongPredicate?

Predicate<T> (предикат) - интерфейс, с помощью которого реализуется функция, получающая на вход экземпляр класса T и возвращающая на выходе значение типа boolean.
Интерфейс содержит различные методы по умолчанию, позволяющие строить сложные условия (and, or, negate).

Для примера возьмем метод класса Stream — filter, который в качестве аргумента принимает Predicate и возвращает Stream только с теми элементами, которые удовлетворяют условию Predicate. В контексте Stream-а это означает, что он пропускает только те элементы, которые возвращают true при использовании их в методе test интерфейса Predicate.

Predicate<String> predicate = (s) -> s.length() > 0; predicate.test("foo"); // true predicate.negate().test("foo"); // false

DoublePredicate - предикат, получающий на вход Double;
IntPredicate - предикат, получающий на вход Integer;
LongPredicate - предикат, получающий на вход Long.
--------------------------------------------------------------------------------------------------------------------
Для чего нужны функциональные интерфейсы Consumer<T>, DoubleConsumer, IntConsumer и LongConsumer?

Consumer<T> (потребитель) - интерфейс, с помощью которого реализуется функция, которая получает на вход экземпляр класса T, производит с ним некоторое действие и ничего не возвращает.

Одним из методом в Stream, который использует функциональный интерфейс Consumer, является метод peek.
Consumer<String> hello = (name) -> System.out.println("Hello, " + name); hello.accept("world");

DoubleConsumer - потребитель, получающий на вход Double;
IntConsumer - потребитель, получающий на вход Integer;
LongConsumer - потребитель, получающий на вход Long.
--------------------------------------------------------------------------------------------------------------------
Для чего нужны функциональные интерфейсы Supplier<T>, BooleanSupplier, DoubleSupplier, IntSupplier и LongSupplier?

Supplier<T> (поставщик) - интерфейс, с помощью которого реализуется функция, ничего не принимающая на вход, но возвращающая на выход результат класса T;

Примером метода в Stream, использующего функциональный интерфейс Supplier, является generate, который генерирует бесконечную последовательность на основе переданного ему функционального интерфейса.

Supplier<LocalDateTime> now = LocalDateTime::now; now.get();

DoubleSupplier - поставщик, возвращающий Double;
IntSupplier - поставщик, возвращающий Integer;
LongSupplier - поставщик, возвращающий Long.
--------------------------------------------------------------------------------------------------------------------
Для чего нужен функциональный интерфейс BiConsumer<T,U>?

BiConsumer<T,U> представляет собой операцию, которая принимает два аргумента классов T и U производит с ними некоторое действие и ничего не возвращает.

--------------------------------------------------------------------------------------------------------------------
Для чего нужен функциональный интерфейс BiFunction<T,U,R>?

BiFunction<T,U,R> представляет собой операцию, которая принимает два аргумента классов T и U и возвращающая результат класса R.

--------------------------------------------------------------------------------------------------------------------
Для чего нужен функциональный интерфейс BiPredicate<T,U>?

BiPredicate<T,U> представляет собой операцию, которая принимает два аргумента классов T и U и возвращающая результат типа boolean.

--------------------------------------------------------------------------------------------------------------------
Для чего нужны функциональные интерфейсы вида _To_Function?

DoubleToIntFunction - операция, принимающая аргумент класса Double и возвращающая результат типа Integer;
DoubleToLongFunction - операция, принимающая аргумент класса Double и возвращающая результат типа Long;
IntToDoubleFunction - операция, принимающая аргумент класса Integer и возвращающая результат типа Double;
IntToLongFunction - операция, принимающая аргумент класса Integer и возвращающая результат типа Long;
LongToDoubleFunction - операция, принимающая аргумент класса Long и возвращающая результат типа Double;
LongToIntFunction - операция, принимающая аргумент класса Long и возвращающая результат типа Integer.
--------------------------------------------------------------------------------------------------------------------
Для чего нужны функциональные интерфейсы ToDoubleBiFunction<T,U>, ToIntBiFunction<T,U> и ToLongBiFunction<T,U>?

ToDoubleBiFunction<T,U> - операция принимающая два аргумента классов T и U и возвращающая результат типа Double;
ToLongBiFunction<T,U> - операция принимающая два аргумента классов T и U и возвращающая результат типа Long;
ToIntBiFunction<T,U> - операция принимающая два аргумента классов T и U и возвращающая результат типа Integer.
--------------------------------------------------------------------------------------------------------------------
Для чего нужны функциональные интерфейсы ToDoubleFunction<T>, ToIntFunction<T> и ToLongFunction<T>?

ToDoubleFunction<T> - операция, принимающая аргумент класса T и возвращающая результат типа Double;
ToLongFunction<T> - операция, принимающая аргумент класса T и возвращающая результат типа Long;
ToIntFunction<T> - операция, принимающая аргумент класса T и возвращающая результат типа Integer.
--------------------------------------------------------------------------------------------------------------------
Для чего нужны функциональные интерфейсы ObjDoubleConsumer<T>, ObjIntConsumer<T> и ObjLongConsumer<T>?

ObjDoubleConsumer<T> - операция, которая принимает два аргумента классов T и Double, производит с ними некоторое действие и ничего не возвращает;
ObjLongConsumer<T> - операция, которая принимает два аргумента классов T и Long, производит с ними некоторое действие и ничего не возвращает;
ObjIntConsumer<T> - операция, которая принимает два аргумента классов T и Integer, производит с ними некоторое действие и ничего не возвращает.
--------------------------------------------------------------------------------------------------------------------
Что такое StringJoiner?

Класс StringJoiner используется, чтобы создать последовательность строк, разделенных разделителем с возможностью присоединить к полученной строке префикс и суффикс:

StringJoiner joiner = new StringJoiner(".", "prefix-", "-suffix");
for (String s : "Hello the brave world".split(" ")) { joiner.add(s); }
System.out.println(joiner);
--------------------------------------------------------------------------------------------------------------------
Что такое default методы интрефейса?

Java 8 позволяет добавлять неабстрактные реализации методов в интерфейс, используя ключевое слово default:

interface Example { int process(int a);
default void show() { System.out.println("default show()"); } }

- Если класс реализует интерфейс, он может, но не обязан, реализовать методы по-умолчанию, уже реализованные в интерфейсе. Класс наследует реализацию по умолчанию.
- Если некий класс реализует несколько интерфейсов, которые имеют одинаковый метод по умолчанию, то класс должен реализовать метод с совпадающей сигнатурой самостоятельно. Ситуация аналогична, если один интерфейс имеет метод по умолчанию, а в другом этот же метод является абстрактным - никакой реализации по умолчанию классом не наследуется.
- Метод по умолчанию не может переопределить метод класса java.lang.Object.
- Помогают реализовывать интерфейсы без страха нарушить работу других классов.
- Позволяют избежать создания служебных классов, так как все необходимые методы могут быть представлены в самих интерфейсах.
- Дают свободу классам выбрать метод, который нужно переопределить.
- Одной из основных причин внедрения методов по умолчанию является возможность коллекций в Java 8 использовать лямбда-выражения.
--------------------------------------------------------------------------------------------------------------------
Как вызывать default метод интерфейса в реализующем этот интерфейс классе?

Используя ключевое слово super вместе с именем интерфейса:

interface Paper { default void show() { System.out.println("default show()"); } }
class Licence implements Paper {
public void show() { Paper.super.show(); } }
--------------------------------------------------------------------------------------------------------------------
Что такое static метод интерфейса?

Статические методы интерфейса похожи на методы по умолчанию, за исключением того, что для них отсутствует возможность переопределения в классах, реализующих интерфейс.
- Статические методы в интерфейсе являются частью интерфейса без возможности использовать их для объектов класса реализации;
- Методы класса java.lang.Object нельзя переопределить как статические;
- Статические методы в интерфейсе используются для обеспечения вспомогательных методов, например, проверки на null, сортировки коллекций и т.д.
--------------------------------------------------------------------------------------------------------------------
Как вызывать static метод интерфейса?

Используя имя интерфейса:
interface Paper { static void show() { System.out.println("static show()"); } }
class Licence {
public void showPaper() { Paper.show(); }
}
--------------------------------------------------------------------------------------------------------------------
Что такое Optional?

Опциональное значение Optional — это контейнер для объекта, который может содержать или не содержать значение null. Такая обёртка является удобным средством предотвращения NullPointerException, т.к. имеет некоторые функции высшего порядка, избавляющие от добавления повторяющихся if null/notNull проверок:

Optional<String> optional = Optional.of("hello"); optional.isPresent(); // true optional.ifPresent(s -> System.out.println(s.length())); // 5 optional.get(); // "hello" optional.orElse("ops..."); // "hello"

--------------------------------------------------------------------------------------------------------------------
Что такое Stream?

Интерфейс java.util.Stream представляет собой последовательность элементов, над которой можно производить различные операции.
Операции над стримами бывают или промежуточными (intermediate) или конечными (terminal). Конечные операции возвращают результат определенного типа, а промежуточные операции возвращают тот же стрим. Таким образом вы можете строить цепочки из несколько операций над одним и тем же стримом.
У стрима может быть сколько угодно вызовов промежуточных операций и последним вызов конечной операции. При этом все промежуточные операции выполняются лениво и пока не будет вызвана конечная операция никаких действий на самом деле не происходит (похоже на создание объекта Thread или Runnable, без вызова start()).
Стримы создаются на основе каких-либо источников, например классов из java.util.Collection.
Ассоциативные массивы (maps), например, HashMap, не поддерживаются.
Операции над стримами могут выполняться как последовательно, так и параллельно.
Потоки не могут быть использованы повторно. Как только была вызвана какая-нибудь конечная операция, поток закрывается.
Кроме универсальных объектных существуют особые виды стримов для работы с примитивными типами данных int, long и double: IntStream, LongStream и DoubleStream. Эти примитивные стримы работают так же, как и обычные объектные, но со следующими отличиями:
- используют специализированные лямбда-выражения, например, IntFunction или IntPredicate вместо Function и Predicate;
- поддерживают дополнительные конечные операции sum(), average(), mapToObj().
--------------------------------------------------------------------------------------------------------------------
Какие существуют способы создания стрима?

Из коллекции:
Stream<String> fromCollection = Arrays.asList("x", "y", "z").stream();
Из набора значений:
Stream<String> fromValues = Stream.of("x", "y", "z");
Из массива:
Stream<String> fromArray = Arrays.stream(new String[]{"x", "y", "z"});
Из файла (каждая строка в файле будет отдельным элементом в стриме):
Stream<String> fromFile = Files.lines(Paths.get("input.txt"));
Из строки:
IntStream fromString = "0123456789".chars();
С помощью Stream.builder():
Stream<String> fromBuilder = Stream.builder().add("z").add("y").add("z").build();
С помощью Stream.iterate() (бесконечный):
Stream<Integer> fromIterate = Stream.iterate(1, n -> n + 1);
С помощью Stream.generate() (бесконечный):
Stream<String> fromGenerate = Stream.generate(() -> "0");
--------------------------------------------------------------------------------------------------------------------
В чем разница между Collection и Stream?

Коллекции позволяют работать с элементами по-отдельности, тогда как стримы так делать не позволяют, но вместо этого предоставляют возможность выполнять функции над данными как над одним целым.
Также стоит отметить важность самой концепции сущностей: Collection - это прежде всего воплощение Структуры Данных. Например, Set не просто хранит в себе элементы, он реализует идею множества с уникальными элементами, тогда как Stream, это прежде всего абстракция необходимая для реализации конвейера вычислений, собственно, поэтому, результатом работы конвейера являются те или иные Структуры Данных или же результаты проверок/поиска и т.п.
--------------------------------------------------------------------------------------------------------------------
Для чего нужен метод collect() в стримах?

Метод collect() является конечной операцией, которая используется для представление результата в виде коллекции или какой-либо другой структуры данных.
collect() принимает на вход Collector<Тип_источника, Тип_аккумулятора, Тип_результата>, который содержит четыре этапа: supplier - инициализация аккумулятора, accumulator - обработка каждого элемента, combiner - соединение двух аккумуляторов при параллельном выполнении, [finisher] - необязательный метод последней обработки аккумулятора. В Java 8 в классе Collectors реализовано несколько распространённых коллекторов:
toList(), toCollection(), toSet() - представляют стрим в виде списка, коллекции или множества;
toConcurrentMap(), toMap() - позволяют преобразовать стрим в Map;
averagingInt(), averagingDouble(), averagingLong() - возвращают среднее значение;
summingInt(), summingDouble(), summingLong() - возвращает сумму;
summarizingInt(), summarizingDouble(), summarizingLong() - возвращают SummaryStatistics с разными агрегатными значениями;
partitioningBy() - разделяет коллекцию на две части по соответствию условию и возвращает их как Map<Boolean, List>;
groupingBy() - разделяет коллекцию на несколько частей и возвращает Map<N, List<T>>;
mapping() - дополнительные преобразования значений для сложных Collector-ов.
Так же существует возможность создания собственного коллектора через Collector.of():

Collector<String, List<String>, List<String>> toList = Collector.of( ArrayList::new, List::add, (l1, l2) -> { l1.addAll(l2); return l1; } );

--------------------------------------------------------------------------------------------------------------------
Для чего в стримах применяются методы forEach() и forEachOrdered()?

forEach() применяет функцию к каждому объекту стрима, порядок при параллельном выполнении не гарантируется;
forEachOrdered() применяет функцию к каждому объекту стрима с сохранением порядка элементов.
--------------------------------------------------------------------------------------------------------------------
Для чего в стримах предназначены методы map() и mapToInt(), mapToDouble(), mapToLong()?

Метод map() является промежуточной операцией, которая заданным образом преобразует каждый элемент стрима.
mapToInt(), mapToDouble(), mapToLong() - аналоги map(), возвращающие соответствующий числовой стрим (то есть стрим из числовых примитивов):
Stream .of("12", "22", "4", "444", "123") .mapToInt(Integer::parseInt) .toArray(); //[12, 22, 4, 444, 123]
--------------------------------------------------------------------------------------------------------------------
Какова цель метода filter() в стримах?

Метод filter() является промежуточной операцией принимающей предикат, который фильтрует все элементы, возвращая только те, что соответствуют условию.

--------------------------------------------------------------------------------------------------------------------
Для чего в стримах предназначен метод limit()?

Метод limit() является промежуточной операцией, которая позволяет ограничить выборку определенным количеством первых элементов.

--------------------------------------------------------------------------------------------------------------------
Для чего в стримах предназначен метод sorted()?

Метод sorted() является промежуточной операцией, которая позволяет сортировать значения либо в натуральном порядке, либо задавая Comparator.
Порядок элементов в исходной коллекции остается нетронутым - sorted() всего лишь создает его отсортированное представление.
--------------------------------------------------------------------------------------------------------------------
Для чего в стримах предназначены методы flatMap(), flatMapToInt(), flatMapToDouble(), flatMapToLong()?

Метод flatMap() похож на map, но может создавать из одного элемента несколько. Таким образом, каждый объект будет преобразован в ноль, один или несколько других объектов, поддерживаемых потоком. Наиболее очевидный способ применения этой операции — преобразование элементов контейнера при помощи функций, которые возвращают контейнеры.

Stream .of("H e l l o", "w o r l d !") .flatMap((p) -> Arrays.stream(p.split(" "))) .toArray(String[]::new);//["H", "e", "l", "l", "o", "w", "o", "r", "l", "d", "!"]

flatMapToInt(), flatMapToDouble(), flatMapToLong() - это аналоги flatMap(), возвращающие соответствующий числовой стрим.

--------------------------------------------------------------------------------------------------------------------
Расскажите о параллельной обработке в Java 8.

Стримы могут быть последовательными и параллельными. Операции над последовательными стримами выполняются в одном потоке процессора, над параллельными — используя несколько потоков процессора. Параллельные стримы используют общий ForkJoinPool доступный через статический ForkJoinPool.commonPool() метод. При этом, если окружение не является многоядерным, то поток будет выполняться как последовательный. Фактически применение параллельных стримов сводится к тому, что данные в стримах будут разделены на части, каждая часть обрабатывается на отдельном ядре процессора, и в конце эти части соединяются, и над ними выполняются конечные операции.
Для создания параллельного потока из коллекции можно также использовать метод parallelStream() интерфейса Collection.
Чтобы сделать обычный последовательный стрим параллельным, надо вызвать у объекта Stream метод parallel(). Метод isParallel() позволяет узнать является ли стрим параллельным.
С помощью, методов parallel() и sequential() можно определять какие операции могут быть параллельными, а какие только последовательными. Так же из любого последовательного стрима можно сделать параллельный и наоборот:

collection .
stream()
.peek(...) // операция последовательна
.parallel()
.map(...) // операция может выполняться параллельно, .sequential()
.reduce(...) // операция снова
последовательна

Как правило, элементы передаются в стрим в том же порядке, в котором они определены в источнике данных. При работе с параллельными стримами система сохраняет порядок следования элементов. Исключение составляет метод forEach(), который может выводить элементы в произвольном порядке. И чтобы сохранить порядок следования, необходимо применять метод forEachOrdered().

Критерии, которые могут повлиять на производительность в параллельных стримах:
- Размер данных - чем больше данных, тем сложнее сначала разделять данные, а потом их соединять.
- Количество ядер процессора. Теоретически, чем больше ядер в компьютере, тем быстрее программа будет работать. Если на машине одно ядро, нет смысла применять параллельные потоки.
- Чем проще структура данных, с которой работает поток, тем быстрее будут происходить операции. Например, данные из ArrayList легко использовать, так как структура данной коллекции предполагает последовательность несвязанных данных. А вот коллекция типа LinkedList - не лучший вариант, так как в последовательном списке все элементы связаны с предыдущими/последующими. И такие данные трудно распараллелить.
- Над данными примитивных типов операции будут производиться быстрее, чем над объектами классов.
- Крайне не рекомендуется использовать параллельные стримы для скольких-нибудь долгих операций (например, сетевых соединений), так как все параллельные стримы работают c одним ForkJoinPool, то такие долгие операции могут остановить работу всех параллельных стримов в JVM из-за отсутствия доступных потоков в пуле, т.е. параллельные стримы стоит использовать лишь для коротких операций, где счет идет на миллисекунды, но не для тех где счет может идти на секунды и минуты;
- Сохранение порядка в параллельных стримах увеличивает издержки при выполнении и если порядок не важен, то имеется возможность отключить его сохранение и тем самым увеличить производительность, использовав промежуточную
  операцию unordered():

collection.parallelStream()
.sorted()
.unordered() .collect(Collectors.toList());
--------------------------------------------------------------------------------------------------------------------
Какие конечные методы работы со стримами вы знаете?

findFirst() возвращает первый элемент;
findAny() возвращает любой подходящий элемент;
collect() представление результатов в виде коллекций и других структур данных;
count() возвращает количество элементов;
anyMatch() возвращает true, если условие выполняется хотя бы для одного элемента;
noneMatch() возвращает true, если условие не выполняется ни для одного элемента;
allMatch() возвращает true, если условие выполняется для всех элементов;
min() возвращает минимальный элемент, используя в качестве условия Comparator;
max() возвращает максимальный элемент, используя в качестве условия Comparator;
forEach() применяет функцию к каждому объекту (порядок при параллельном выполнении не гарантируется);
forEachOrdered() применяет функцию к каждому объекту с сохранением порядка элементов;
toArray() возвращает массив значений;
reduce()позволяет выполнять агрегатные функции и возвращать один результат.
Для числовых стримов дополнительно доступны:
sum() возвращает сумму всех чисел;
average() возвращает среднее арифметическое всех чисел.
--------------------------------------------------------------------------------------------------------------------
Какие промежуточные методы работы со стримами вы знаете?

filter() отфильтровывает записи, возвращая только записи, соответствующие условию;
skip() позволяет пропустить определённое количество элементов в начале;
distinct() возвращает стрим без дубликатов (для метода equals());
map() преобразует каждый элемент;
peek() возвращает тот же стрим, применяя к каждому элементу функцию;
limit() позволяет ограничить выборку определенным количеством первых элементов;
sorted() позволяет сортировать значения либо в натуральном порядке, либо задавая Comparator;
mapToInt(), mapToDouble(), mapToLong() - аналоги map() возвращающие стрим числовых примитивов;
flatMap(), flatMapToInt(), flatMapToDouble(), flatMapToLong() - похожи на map(), но могут создавать из одного элемента несколько.
Для числовых стримов дополнительно доступен метод mapToObj(), который преобразует числовой стрим обратно в объектный.
--------------------------------------------------------------------------------------------------------------------
Как вывести на экран 10 случайных чисел, используя forEach()

(new Random()) .ints() .limit(10) .forEach(System.out::println

--------------------------------------------------------------------------------------------------------------------
Как можно вывести на экран уникальные квадраты чисел используя метод map()?

Stream .of(1, 2, 3, 2, 1) .map(s -> s * s) .distinct() .forEach(System.out::println);

--------------------------------------------------------------------------------------------------------------------
Как вывести на экран количество пустых строк с помощью метода filter()?

System.out.println( Stream .of("Hello", "", ", ", "world", "!") .filter(String::isEmpty) .count());

--------------------------------------------------------------------------------------------------------------------
Как вывести на экран 10 случайных чисел в порядке возрастания?

(new Random()) .ints() .limit(10) .sorted() .forEach(System.out::println);

--------------------------------------------------------------------------------------------------------------------
Как найти максимальное число в наборе?

Stream .of(5, 3, 4, 55, 2) .mapToInt(a -> a) .max() .getAsInt(); //55

--------------------------------------------------------------------------------------------------------------------
Как найти минимальное число в наборе

Stream .of(5, 3, 4, 55, 2) .mapToInt(a -> a) .min() .getAsInt(); //2

--------------------------------------------------------------------------------------------------------------------
Как получить сумму всех чисел в наборе?

Stream .of(5, 3, 4, 55, 2) .mapToInt() .sum(); //69

--------------------------------------------------------------------------------------------------------------------
Как получить среднее значение всех чисел?

Stream .of(5, 3, 4, 55, 2) .mapToInt(a -> a) .average() .getAsDouble(); //13.8

--------------------------------------------------------------------------------------------------------------------
Какие дополнительные методы для работы с ассоциативными массивами (maps) появились в Java 8?

- putIfAbsent() добавляет пару «ключ-значение», только если ключ отсутствовал:
  map.putIfAbsent("a", "Aa");
- forEach() принимает функцию, которая производит операцию над каждым элементом:
  map.forEach((k, v) -> System.out.println(v));
- compute() создаёт или обновляет текущее значение на полученное в результате вычисления (возможно использовать ключ и текущее значение):
  map.compute("a", (k, v) -> String.valueOf(k).concat(v)); //["a", "aAa"]
- computeIfPresent() если ключ существует, обновляет текущее значение на полученное в результате вычисления (возможно использовать ключ и текущее значение):
  map.computeIfPresent("a", (k, v) -> k.concat(v));
- computeIfAbsent() если ключ отсутствует, создаёт его со значением, которое вычисляется (возможно использовать ключ):
  map.computeIfAbsent("a", k -> "A".concat(k)); //["a","Aa"]
- getOrDefault() в случае отсутствия ключа, возвращает переданное значение по-умолчанию:
  map.getOrDefault("a", "not found");
- merge() принимает ключ, значение и функцию, которая объединяет передаваемое и текущее значения. Если под заданным ключем значение отсутствует, то записывает туда передаваемое значение.
  map.merge("a", "z", (value, newValue) -> value.concat(newValue)); //["a","Aaz"]
--------------------------------------------------------------------------------------------------------------------
Что такое LocalDateTime?

LocalDateTime объединяет вместе LocaleDate и LocalTime, содержит дату и время в календарной системе ISO-8601 без привязки к часовому поясу. Время хранится с точностью до наносекунды. Содержит множество удобных методов, таких как plusMinutes, plusHours, isAfter, toSecondOfDay и т.д.

--------------------------------------------------------------------------------------------------------------------
Что такое ZonedDateTime?

java.time.ZonedDateTime — аналог java.util.Calendar, класс с самым полным объемом информации о временном контексте в календарной системе ISO-8601. Включает временную зону, поэтому все операции с временными сдвигами этот класс проводит с её учётом.

--------------------------------------------------------------------------------------------------------------------
Как получить текущую дату с использованием Date Time API из Java 8?

LocalDate.now();

--------------------------------------------------------------------------------------------------------------------
Как добавить 1 неделю, 1 месяц, 1 год, 10 лет к текущей дате с использованием Date Time API?

LocalDate.now().plusWeeks(1); LocalDate.now().plusMonths(1); LocalDate.now().plusYears(1); LocalDate.now().plus(1, ChronoUnit.DECADES);

--------------------------------------------------------------------------------------------------------------------
Как получить следующий вторник используя Date Time API?

LocalDate.now().with(TemporalAdjusters.next(DayOfWeek.TUESDAY));

--------------------------------------------------------------------------------------------------------------------
Как получить вторую субботу текущего месяца используя Date Time API?

LocalDate .of(LocalDate.now().getYear(), LocalDate.now().getMonth(), 1) .with(TemporalAdjusters.nextOrSame(DayOfWeek.SATURDAY)) .with(TemporalAdjusters.next(DayOfWeek.SATURDAY));

--------------------------------------------------------------------------------------------------------------------
Как получить текущее время с точностью до миллисекунд используя Date Time API

new Date().toInstant();

--------------------------------------------------------------------------------------------------------------------
Как получить текущее время по местному времени с точностью до миллисекунд используя Date Time API?

LocalDateTime.ofInstant(new Date().toInstant(), ZoneId.systemDefault());

--------------------------------------------------------------------------------------------------------------------
Как определить повторяемую аннотацию?

Чтобы определить повторяемую аннотацию, необходимо создать аннотацию-контейнер для списка повторяемых аннотаций и обозначить повторяемую мета-аннотацией @Repeatable:

@interface Schedulers { Scheduler[] value(); }

@Repeatable(Schedulers.class)

@interface Scheduler { String birthday() default "Jan 8 1935"; }

--------------------------------------------------------------------------------------------------------------------
Какой класс появился в Java 8 для кодирования/декодирования данных?

Base64 - потокобезопасный класс, который реализует кодировщик и декодировщик данных, используя схему кодирования base64 согласно RFC 4648 и RFC 2045.
Base64 содержит 6 основных методов:
getEncoder()/getDecoder() - возвращает кодировщик/декодировщик base64, соответствующий стандарту RFC 4648; getUrlEncoder()/getUrlDecoder() - возвращает URL-safe кодировщик/декодировщик base64, соответствующий стандарту RFC 4648; getMimeEncoder()/getMimeDecoder() - возвращает MIME кодировщик/декодировщик, соответствующий стандарту RFC 2045.
--------------------------------------------------------------------------------------------------------------------
Как создать Base64 кодировщик и декодировщик?

// Encode
String b64 = Base64.getEncoder().encodeToString("input".getBytes("utf-8")); //aW5wdXQ==
// Decode
new String(Base64.getDecoder().decode("aW5wdXQ=="), "utf-8");
//input
--------------------------------------------------------------------------------------------------------------------
empty()

Стрим, как и коллекция, может быть пустым, а значит всем последующем операторам нечего будет обрабатывать.
Stream.empty()
.forEach(System.out::println);
// Вывода нет
--------------------------------------------------------------------------------------------------------------------
of(T value)
of(T... values)

Стрим для одного или нескольких перечисленных элементов. Очень часто вижу, что используют такую конструкцию:

Arrays.asList(1, 2, 3).stream()
.forEach(System.out::println);

однако она излишня. Вот так проще:

Stream.of(1, 2, 3)
.forEach(System.out::println);
--------------------------------------------------------------------------------------------------------------------
ofNullable(T t)

Появился в Java 9. Возвращает пустой стрим, если в качестве аргумента передан null, в противном случае, возвращает стрим из одного элемента.

String str = Math.random() > 0.5 ? "I'm feeling lucky" : null;
Stream.ofNullable(str)
.forEach(System.out::println);
--------------------------------------------------------------------------------------------------------------------
generate(Supplier s)

Возвращает стрим с бесконечной последовательностью элементов, генерируемых функцией Supplier s.

Stream.generate(() -> 6)
.limit(6)
.forEach(System.out::println);
--------------------------------------------------------------------------------------------------------------------
iterate(T seed, UnaryOperator f)

Возвращает бесконечный стрим с элементами, которые образуются в результате последовательного применения функции f к итерируемому значению. Первым элементом будет seed, затем f(seed), затем f(f(seed)) и так далее.

Stream.iterate(2, x -> x + 6)
.limit(6)
.forEach(System.out::println);
// 2, 8, 14, 20, 26, 32
--------------------------------------------------------------------------------------------------------------------
iterate(T seed, Predicate hasNext, UnaryOperator f)

Появился в Java 9. Всё то же самое, только добавляется ещё один аргумент hasNext: если он возвращает false, то стрим завершается. Это очень похоже на цикл for:

for (i = seed; hasNext(i); i = f(i)) {
}

Таким образом, с помощью iterate теперь можно создать конечный стрим.

Stream.iterate(2, x -> x < 25, x -> x + 6)
.forEach(System.out::println);
// 2, 8, 14, 20
--------------------------------------------------------------------------------------------------------------------
concat(Stream a, Stream b)

Объединяет два стрима так, что вначале идут элементы стрима A, а по его окончанию последуют элементы стрима B.

Stream.concat(
Stream.of(1, 2, 3),
Stream.of(4, 5, 6))
.forEach(System.out::println);
// 1, 2, 3, 4, 5, 6
--------------------------------------------------------------------------------------------------------------------
builder()

Создаёт мутабельный объект для добавления элементов в стрим без использования какого-либо контейнера для этого.

Stream.Builder<Integer> streamBuider = Stream.<Integer>builder()
.add(0)
.add(1);
for (int i = 2; i <= 8; i += 2) {
streamBuider.accept(i);
}

streamBuider
.add(9)
.add(10)
.build()
.forEach(System.out::println);
// 0, 1, 2, 4, 6, 8, 9, 10
--------------------------------------------------------------------------------------------------------------------
IntStream.range(int startInclusive, int endExclusive)LongStream.range(long startInclusive, long endExclusive)

Создаёт стрим из числового промежутка [start..end), то есть от start (включительно) по end.

IntStream.range(0, 10)
.forEach(System.out::println);
// 0, 1, 2, 3, 4, 5, 6, 7, 8, 9

LongStream.range(-10L, -5L)
.forEach(System.out::println);
// -10, -9, -8, -7, -6
--------------------------------------------------------------------------------------------------------------------
IntStream.rangeClosed(int startInclusive, int endInclusive)LongStream.rangeClosed(long startInclusive, long endInclusive)

Создаёт стрим из числового промежутка [start..end], то есть от start (включительно) по end (включительно).

IntStream.rangeClosed(0, 5)
.forEach(System.out::println);
// 0, 1, 2, 3, 4, 5
LongStream.range(-8L, -5L)
.forEach(System.out::println);
// -8, -7, -6, -5
--------------------------------------------------------------------------------------------------------------------
Промежуточный оператор filter(Predicate predicate)

Фильтрует стрим, принимая только те элементы, которые удовлетворяют заданному условию.

Stream.of(1, 2, 3)
.filter(x -> x == 10)
.forEach(System.out::print);
// Вывода нет, так как после фильтрации стрим станет пустым
Stream.of(120, 410, 85, 32, 314, 12)
.filter(x -> x > 100)
.forEach(System.out::println);
// 120, 410, 314
--------------------------------------------------------------------------------------------------------------------
Промежуточный оператор map(Function mapper)

Применяет функцию к каждому элементу и затем возвращает стрим, в котором элементами будут результаты функции. map можно применять для изменения типа элементов.

Stream.mapToDouble(ToDoubleFunction mapper)
Stream.mapToInt(ToIntFunction mapper)
Stream.mapToLong(ToLongFunction mapper)
IntStream.mapToObj(IntFunction mapper)
IntStream.mapToLong(IntToLongFunction mapper)
IntStream.mapToDouble(IntToDoubleFunction mapper)

Специальные операторы для преобразования объектного стрима в примитивный, примитивного в объектный, либо примитивного стрима одного типа в примитивный стрим другого.

Stream.of("3", "4", "5")
.map(Integer::parseInt)
.map(x -> x + 10)
.forEach(System.out::println);
// 13, 14, 15

Stream.of(120, 410, 85, 32, 314, 12)
.map(x -> x + 11)
.forEach(System.out::println);
// 131, 421, 96, 43, 325, 23
--------------------------------------------------------------------------------------------------------------------
Промежуточный оператор flatMap(Function<T, Stream<R>> mapper)

Один из самых интересных операторов. Работает как map, но с одним отличием — можно преобразовать один элемент в ноль, один или множество других.

flatMapToDouble(Function mapper)
flatMapToInt(Function mapper)
flatMapToLong(Function mapper)

Как и в случае с map, служат для преобразования в примитивный стрим.Для того, чтобы один элемент преобразовать в ноль элементов, нужно вернуть null, либо пустой стрим. Чтобы преобразовать в один элемент, нужно вернуть стрим из одного элемента, например, через Stream.of(x). Для возвращения нескольких элементов, можно любыми способами создать стрим с этими элементами.

Stream.of(2, 3, 0, 1, 3)
.flatMap(x -> IntStream.range(0, x))
.forEach(System.out::println);
// 0, 1, 0, 1, 2, 0, 0, 1, 2
--------------------------------------------------------------------------------------------------------------------
Промежуточный оператор mapMulti(BiConsumer<T, Consumer<R>> mapper)

Появился в Java 16. Этот оператор похож на flatMap, но использует императивный подход при работе. Теперь вместе с элементом стрима приходит ещё и Consumer, в который можно передать одно или несколько значений, либо не передавать вовсе.

Stream.of(1, 2, 3, 4, 5, 6)
.mapMulti((x, consumer) -> {
if (x % 2 == 0) {
consumer.accept(-x);
consumer.accept(x);
}
})
.forEach(System.out::println);
// -2, 2, -4, 4, -6, 6


mapMultiToDouble(BiConsumer<T, DoubleConsumer> mapper)
mapMultiToInt(BiConsumer<T, IntConsumer> mapper)
mapMultiToLong(BiConsumer<T, LongConsumer> mapper)
--------------------------------------------------------------------------------------------------------------------
Промежуточный оператор limit(long maxSize)

Ограничивает стрим maxSize элементами.

Stream.of(120, 410, 85, 32, 314, 12)
.limit(4)
.forEach(System.out::println);
--------------------------------------------------------------------------------------------------------------------
Промежуточный оператор skip(long n)

Пропускает n элементов стрима.

Stream.of(5, 10)
.skip(40)
.forEach(System.out::println);
// Вывода нет
Stream.of(120, 410, 85, 32, 314, 12)
.skip(2)
.forEach(System.out::println);
// 85, 32, 314, 12
--------------------------------------------------------------------------------------------------------------------
Промежуточный оператор
sorted()
sorted(Comparator comparator)

Сортирует элементы стрима. Причём работает этот оператор очень хитро: если стрим уже помечен как отсортированный, то сортировка проводиться не будет, иначе соберёт все элементы, отсортирует их и вернёт новый стрим, помеченный как отсортированный.

IntStream.range(0, 100000000)
.sorted()
.limit(3)
.forEach(System.out::println);
// 0, 1, 2

IntStream.concat(
IntStream.range(0, 100000000),
IntStream.of(-1, -2))
.sorted()
.limit(3)
.forEach(System.out::println);
// Exception in thread "main" java.lang.OutOfMemoryError: Java heap space

Stream.of(120, 410, 85, 32, 314, 12)
.sorted()
.forEach(System.out::println);
// 12, 32, 85, 120, 314, 410
--------------------------------------------------------------------------------------------------------------------
Промежуточный оператор distinct()

Убирает повторяющиеся элементы и возвращаем стрим с уникальными элементами. Как и в случае с sorted, смотрит, состоит ли уже стрим из уникальных элементов и если это не так, отбирает уникальные и помечает стрим как содержащий уникальные элементы.

Stream.of(2, 1, 8, 1, 3, 2)
.distinct()
.forEach(System.out::println);
// 2, 1, 8, 3
--------------------------------------------------------------------------------------------------------------------
Промежуточный оператор peek(Consumer action)

Выполняет действие над каждым элементом стрима и при этом возвращает стрим с элементами исходного стрима. Служит для того, чтобы передать элемент куда-нибудь, не разрывая при этом цепочку операторов (вы же помните, что forEach — терминальный оператор и после него стрим завершается?), либо для отладки.

Stream.of(0, 3, 0, 0, 5)
.peek(x -> System.out.format("before distinct: %d%n", x))
.distinct()
.peek(x -> System.out.format("after distinct: %d%n", x))
.map(x -> x * x)
.forEach(x -> System.out.format("after map: %d%n", x));
--------------------------------------------------------------------------------------------------------------------
Промежуточный оператор takeWhile(Predicate predicate)

Появился в Java 9. Возвращает элементы до тех пор, пока они удовлетворяют условию, то есть функция-предикат возвращает true. Это как limit, только не с числом, а с условием.

Stream.of(1, 2, 3, 4, 2, 5)
.takeWhile(x -> x < 3)
.forEach(System.out::println);
// 1, 2
--------------------------------------------------------------------------------------------------------------------
Промежуточный оператор dropWhile(Predicate predicate)

Появился в Java 9. Пропускает элементы до тех пор, пока они удовлетворяют условию, затем возвращает оставшуюся часть стрима. Если предикат вернул для первого элемента false, то ни единого элемента не будет пропущено. Оператор подобен skip, только работает по условию.

Stream.of(1, 2, 3, 4, 2, 5)
.dropWhile(x -> x >= 3)
.forEach(System.out::println);
// 1, 2, 3, 4, 2, 5

Stream.of(1, 2, 3, 4, 2, 5)
.dropWhile(x -> x < 3)
.forEach(System.out::println);
// 3, 4, 2, 5
--------------------------------------------------------------------------------------------------------------------
Промежуточный оператор boxed()

Преобразует примитивный стрим в объектный.

DoubleStream.of(0.1, Math.PI)
.boxed()
.map(Object::getClass)
.forEach(System.out::println);
--------------------------------------------------------------------------------------------------------------------
Терминальный оператор void forEach(Consumer action)

Выполняет указанное действие для каждого элемента стрима.

Stream.of(120, 410, 85, 32, 314, 12)
.forEach(x -> System.out.format("%s, ", x));
--------------------------------------------------------------------------------------------------------------------
Терминальный оператор void forEachOrdered(Consumer action)

Выполняет указанное действие для каждого элемента стрима, но перед этим добивается правильного порядка вхождения элементов. Используется для параллельных стримов, когда нужно получить правильную последовательность элементов.

IntStream.range(0, 100000)
.parallel()
.filter(x -> x % 10000 == 0)
.map(x -> x / 10000)
.forEach(System.out::println);
// 5, 6, 7, 3, 4, 8, 0, 9, 1, 2

IntStream.range(0, 100000)
.parallel()
.filter(x -> x % 10000 == 0)
.map(x -> x / 10000)
.forEachOrdered(System.out::println);
// 0, 1, 2, 3, 4, 5, 6, 7, 8, 9
--------------------------------------------------------------------------------------------------------------------
Терминальный оператор long count()

Возвращает количество элементов стрима.

long count = IntStream.range(0, 10)
.flatMap(x -> IntStream.range(0, x))
.count();
System.out.println(count);
// 45

System.out.println(
IntStream.rangeClosed(-3, )
.count()
);
// 10

System.out.println(
Stream.of(0, 2, 9, 13, 5, 11)
.(x -> x 2)
.filter(x -> x % 2 == 1)
.count()
);
// 0
--------------------------------------------------------------------------------------------------------------------
Терминальный оператор R collect(Collector collector)

Один из самых мощных операторов Stream API. С его помощью можно собрать все элементы в список, множество или другую коллекцию, сгруппировать элементы по какому-нибудь критерию, объединить всё в строку и т.д.. В классе java.util.stream.Collectors очень много методов на все случаи жизни, мы рассмотрим их позже. При желании можно написать свой коллектор, реализовав интерфейс Collector.

List<Integer> list = Stream.of(1, 2, 3)
.collect(Collectors.toList());
// list: [1, 2, 3]

String s = Stream.of(1, 2, 3)
.map(String::valueOf)
.collect(Collectors.joining("-", "<", ">"));
// s: "<1-2-3>"
--------------------------------------------------------------------------------------------------------------------
Терминальный оператор R collect(Supplier supplier, BiConsumer accumulator, BiConsumer combiner)

То же, что и collect(collector), только параметры разбиты для удобства. Если нужно быстро сделать какую-то операцию, нет нужды реализовывать интерфейс Collector, достаточно передать три лямбда-выражения.supplier должен поставлять новые объекты (контейнеры), например new ArrayList(), accumulator добавляет элемент в контейнер, combiner необходим для параллельных стримов и объединяет части стрима воедино.

List<String> list = Stream.of("a", "b", "c", "d")
.collect(ArrayList::new, ArrayList::add, ArrayList::addAll);
// list: ["a", "b", "c", "d"]
--------------------------------------------------------------------------------------------------------------------
Терминальный оператор Object[] toArray()

Возвращает нетипизированный массив с элементами стрима.A[] toArray(IntFunction<A[]> generator)Аналогично, только возвращает типизированный массив.

String[] elements = Stream.of("a", "b", "c", "d")
.toArray(String[]::new);
// elements: ["a", "b", "c", "d"]
--------------------------------------------------------------------------------------------------------------------
Терминальный оператор List<T> toList()

Возвращает список, подобно collect(Collectors.toList()). Отличие в том, что теперь возвращаемый список гарантированно нельзя будет модифицировать. Любое добавление или удаление элементов в полученный список будет сопровождаться исключением UnsupportedOperationException.

List<String> elements = Stream.of("a", "b", "c", "d")
.map(String::toUpperCase)
.toList();
// elements: ["A", "B", "C", "D"]
--------------------------------------------------------------------------------------------------------------------
Терминальный оператор
T reduce(T identity, BinaryOperator accumulator)
U reduce(U identity, BiFunction accumulator, BinaryOperator combiner)

Позволяет преобразовать все элементы стрима в один объект. Например, посчитать сумму всех элементов, либо найти минимальный элемент.Сперва берётся объект identity и первый элемент стрима, применяется функция accumulator и identity становится её результатом. Затем всё продолжается для остальных элементов.
int sum = Stream.of(1, 2, 3, 4, 5)
.reduce(10, (acc, x) -> acc + x);
// sum: 25
--------------------------------------------------------------------------------------------------------------------
Терминальный оператор
Optional reduce(BinaryOperator accumulator)

Этот метод отличается тем, что у него нет начального объекта identity. В качестве него служит первый элемент стрима. Поскольку стрим может быть пустой и тогда identity объект не присвоится, то результатом функции служит Optional, позволяющий обработать и эту ситуацию, вернув Optional.empty().

Optional<Integer> result = Stream.<Integer>empty()
.reduce((acc, x) -> acc + x);
System.out.println(result.isPresent());
// false

Optional<Integer> sum = Stream.of(1, 2, 3, 4, 5)
.reduce((acc, x) -> acc + x);
System.out.println(sum.get());
// 15
--------------------------------------------------------------------------------------------------------------------
Терминальный оператор
Optional min(Comparator comparator)
Optional max(Comparator comparator)

Поиск минимального/максимального элемента, основываясь на переданном компараторе.
int min = Stream.of(20, 11, 45, 78, 13)
.min(Integer::compare).get();
// min: 11
int max = Stream.of(20, 11, 45, 78, 13)
.max(Integer::compare).get();
// max: 78
--------------------------------------------------------------------------------------------------------------------
Терминальный оператор Optional findAny()

Возвращает первый попавшийся элемент стрима. В параллельных стримах это может быть действительно любой элемент, который лежал в разбитой части последовательности.

--------------------------------------------------------------------------------------------------------------------
Терминальный оператор Optional findFirst()

Гарантированно возвращает первый элемент стрима, даже если стрим параллельный.Если нужен любой элемент, то для параллельных стримов быстрее будет работать findAny().

int anySeq = IntStream.range(4, 65536)
.findAny()
.getAsInt();
// anySeq: 4

int firstSeq = IntStream.range(4, 65536)
.findFirst()
.getAsInt();
// firstSeq: 4

int anyParallel = IntStream.range(4, 65536)
.parallel()
.findAny()
.getAsInt();
// anyParallel: 32770

int firstParallel = IntStream.range(4, 65536)
.parallel()
.findFirst()
.getAsInt();
// firstParallel: 4
--------------------------------------------------------------------------------------------------------------------
Терминальный оператор boolean allMatch(Predicate predicate)

Возвращает true, если все элементы стрима удовлетворяют условию predicate. Если встречается какой-либо элемент, для которого результат вызова функции-предиката будет false, то оператор перестаёт просматривать элементы и возвращает false.

boolean result = Stream.of(1, 2, 3, 4, 5)
.allMatch(x -> x <= 7);
// result: true
--------------------------------------------------------------------------------------------------------------------
Терминальный оператор boolean anyMatch(Predicate predicate)

Возвращает true, если хотя бы один элемент стрима удовлетворяет условию predicate. Если такой элемент встретился, нет смысла продолжать перебор элементов, поэтому сразу возвращается результат.

boolean result = Stream.of(1, 2, 3, 4, 5)
.anyMatch(x -> x == 3);
// result: true
--------------------------------------------------------------------------------------------------------------------
Терминальный оператор boolean noneMatch(Predicate predicate)

Возвращает true, если, пройдя все элементы стрима, ни один не удовлетворил условию predicate. Если встречается какой-либо элемент, для которого результат вызова функции-предиката будет true, то оператор перестаёт перебирать элементы и возвращает false.
boolean result = Stream.of(1, 2, 3, 4, 5)
.noneMatch(x -> x == 9);
// result: true
--------------------------------------------------------------------------------------------------------------------
Терминальный оператор OptionalDouble average()

Только для примитивных стримов. Возвращает среднее арифметическое всех элементов. Либо Optional.empty, если стрим пуст.
double result = IntStream.range(2, 16)
.average()
.getAsDouble();
// result: 8.5
--------------------------------------------------------------------------------------------------------------------
Терминальный оператор sum()

Возвращает сумму элементов примитивного стрима. Для IntStream результат будет типа int, для LongStream — long, для DoubleStream — double.

long result = LongStream.range(2, 16)
.sum();
// result: 119
--------------------------------------------------------------------------------------------------------------------
Терминальный оператор IntSummaryStatistics summaryStatistics()

Полезный метод примитивных стримов. Позволяет собрать статистику о числовой последовательности стрима, а именно: количество элементов, их сумму, среднее арифметическое, минимальный и максимальный элемент.

LongSummaryStatistics stats = LongStream.range(2, 16)
.summaryStatistics();
System.out.format(" count: %d%n", stats.getCount());
System.out.format(" sum: %d%n", stats.getSum());
System.out.format("average: %.1f%n", stats.getAverage());
System.out.format(" min: %d%n", stats.getMin());
System.out.format(" max: %d%n", stats.getMax());
// count: 14
// sum: 119
// average: 8,5
// min: 2
// max: 15
--------------------------------------------------------------------------------------------------------------------
Collector

Интерфейс java.util.stream.Collector служит для сбора элементов стрима в некоторый мутабельный контейнер. Он состоит из таких методов:
- Supplier\<A> supplier() — функция, которая создаёт экземпляры контейнеров.
- BiConsumer<A,T> accumulator() — функция, которая кладёт новый элемент в контейнер.
- BinaryOperator\<A> combiner() — функция, которая объединяет два контейнера в один. В параллельных стримах каждая часть может собираться в отдельный экземпляр контейнера и в итоге необходимо их объединять в один результирующий.
- Function<A,R> finisher() — функция, которая преобразовывает весь контейнер в конечный результат. Например, можно обернуть List в Collections.unmodifiableList.
- Set<Characteristics> characteristics() — возвращает характеристики коллектора, чтобы внутренняя реализация знала, с чем имеет дело. Например, можно указать, что коллектор поддерживает многопоточность.
  Характеристики: - CONCURRENT — коллектор поддерживает многопоточность, а значит отдельные части стрима могут быть успешно положены в контейнер из другого потока. - UNORDERED — коллектор не зависит от порядка поступаемых элементов. - IDENTITY_FINISH — функция finish() имеет стандартную реализацию (Function.identity()), а значит её можно не вызывать.
--------------------------------------------------------------------------------------------------------------------
Spliterator

Основное использование Java Spliterator - разделение ввода на разные части, а затем параллельная обработка каждой части отдельно. Полезно обрабатывать большие объемы данных с помощью параллельного программирования.

Методы интерфейса:
- trySplit — как следует из названия, пытается разделить элементы на две части. Если это сделать не получается, либо элементов недостаточно для разделения, то вернёт null. В остальных случаях возвращает ещё один Spliterator с частью данных.
- tryAdvance(Consumer action) — если имеются элементы, для которых можно применить действие, то оно применяется и возвращает true, в противном случае возвращается false, но действие не выполняется.
- estimateSize() — возвращает примерное количество элементов, оставшихся для обработки, либо Long.MAX_VALUE, если стрим бесконечный или посчитать количество невозможно.
- characteristics() — возвращает характеристики сплитератора.
--------------------------------------------------------------------------------------------------------------------
Что такое функциональное программирование?

Функциональное программирование - способ организации вычислений без состояния. Строго говоря, состояние у такой программы конечно есть, это - совокупность контекстов всех её функций. Но: главная проблема, стоящая за сложностями состояния, идентичности и изменения, состоит в том, что, введя присваивание, мы вынуждены внести в свои вычислительные модели понятие времени (time). До того, как появилось присваивание, наши программы от времени не зависели — в том смысле, что всякое выражение, обладающее значением, всегда имело одно и то же значение.

--------------------------------------------------------------------------------------------------------------------
TCP/IP vs UDP

Протокол TCP (Transmission Control Protocol) - это сетевой протокол, который «заточен» под соединение. Иными словами, прежде, чем начать обмен данными, данному протоколу требуется установить соединение между двумя хостами. Данный протокол имеет высокую надежность, поскольку позволяет не терять данные при передаче, запрашивает подтверждения о получении от принимающей стороны и в случае необходимости отправляет данные повторно. При этом отправляемые пакеты данных сохраняют порядок отправки, то есть можно сказать, что передача данных упорядочена. Минусом данного протокола является относительно низкая скорость передачи данных, за счет того что выполнение надежной и упорядоченной передачи занимает больше времени, чем в альтернативном протоколе UDP.

Протокол UDP (User Datagram Protocol), в свою очередь, более прост. Для передачи данных ему не обязательно устанавливать соединение между отправителем и получателем. Информация передается без предварительной проверки готовности принимающей стороны. Это делает протокол менее надежным - при передаче некоторые фрагменты данных могут теряться. Кроме того, упорядоченность данных не соблюдается - возможен непоследовательный прием данных получателем. Зато скорость передачи данных по данному транспортному протоколу будет более высокой.

Надежность: в этом случае предпочтительнее будет протокол TCP, за счет подтверждения получения данных, повторной отправки в случае необходимости, а также использованию такого инструмента как тайм-аут. Протокол UDP такого инструментария не имеет, а потому при получении отправленные данные могут приходить не полностью;

Упорядоченность: опять будет предпочтительнее TCP, поскольку этот протокол гарантирует передачу пакетов данных именно в том порядке, в котором они были отправлены. В случае с UDP такой порядок не соблюдается;

Скорость: здесь уже лидировать будет UDP, так как более тяжеловесному TCP-протоколу будет требоваться больше времени для установки соединения, подтверждения получения, повторной отправки данных и т.д. ;

Метод передачи данных: в случае с TCP данные передаются потоково, границы фрагментов данных не имеют обозначения. В случае с UDP данные передаются в виде датаграмм - проверка пакетов на целостность осуществляется принимающей стороной только в случае получения сообщения. Также пакеты данных имеют определенные обозначения границ;

--------------------------------------------------------------------------------------------------------------------