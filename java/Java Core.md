### Что такое класс Object? Какие в нем есть методы?

Object это базовый класс для всех остальных объектов в Java. Любой класс наследуется от Object и, соответственно, наследуют его методы:
public boolean equals(Object obj) - служит для сравнения объектов по значению;
int hashCode() - возвращает hash код для объекта;
String toString() - возвращает строковое представление объекта;
Class getClass() - возвращает класс объекта во время выполнения;
protected Object clone() - создает и возвращает копию объекта;
void notify() - возобновляет поток, ожидающий монитор;
void notifyAll() - возобновляет все потоки, ожидающие монитор;
void wait() - остановка вызвавшего метод потока до момента пока другой поток не вызовет метод notify() или notifyAll() для этого объекта;
void wait(long timeout) - остановка вызвавшего метод потока на определённое время или пока другой поток не вызовет метод notify() или
notifyAll() для этого объекта;
void wait(long timeout, int nanos) - остановка вызвавшего метод потока на определённое время или пока другой поток не вызовет метод notify()
или notifyAll() для этого объекта;
protected void finalize() - может вызываться сборщиком мусора в момент удаления объекта при сборке мусора.
--------------------------------------------------------------------------------------------------------------------

### Какие примитивы есть в Java?

«Пустой» тип - void. Логический (булевый) тип.
bolean - 1 бит

Целы числа
byte - 8 бит
short - 16 бит
int - 32 бита
long - 64 бита

Числа с плавающей запятой.
float - 32 бита
double - 64 бита

Символы - для хранения литералов.
char - 16 бит
--------------------------------------------------------------------------------------------------------------------

### Какие существуют модификаторы доступа?

private (приватный): члены класса доступны только внутри класса. Для обозначения используется служебное слово private.

default, package-private, package level (доступ на уровне пакета): видимость класса/членов класса только внутри пакета. Является модификатором доступа по умолчанию - специальное обозначение не требуется.

protected (защищённый): члены класса доступны внутри пакета и в наследниках. Для обозначения используется служебное слово protected.

public (публичный): класс/члены класса доступны всем. Для обозначения используется служебное слово public.

Последовательность модификаторов по возрастанию уровня закрытости: public, protected, default, private.
Во время наследования возможно изменения модификаторов доступа в сторону большей видимости (для поддержания соответствия принципу подстановки Барбары Лисков).
--------------------------------------------------------------------------------------------------------------------

### О чем говорит ключевое слово final?

Модификатор final может применяться к переменным, параметрам методов, полям и методам класса или самим классам.
1) Класс не может иметь наследников;
2) Метод не может быть переопределен в классах наследниках;
3) Поле не может изменить свое значение после инициализации;
4) Параметры методов не могут изменять своё значение внутри метода;
5) Локальные переменные не могут быть изменены после присвоения им значения.
--------------------------------------------------------------------------------------------------------------------

### Какими значениями инициализируются переменные по умолчанию?

1) Числа инициализируются 0 или 0.0;
2) char — \u0000;
3) boolean — false;
4) Объекты (в том числе String) — null.
--------------------------------------------------------------------------------------------------------------------

### Что вы знаете о функции main()?

Метод main() — точка входа в программу. В приложении может быть несколько таких методов. Если метод отсутствует, то компиляция возможна, но при запуске будет получена ошибка `Error: Main method not found`.
public static void main(String[] args) {}
--------------------------------------------------------------------------------------------------------------------

### Какие логические операции и операторы вы знаете?

&: Логическое AND (И);
&&: Сокращённое AND;
|: Логическое OR (ИЛИ);
||: Сокращённое OR;
^: Логическое XOR (исключающее OR (ИЛИ));
!: Логическое унарное NOT (НЕ);
&=: AND с присваиванием;
|=: OR с присваиванием;
^=: XOR с присваиванием;
==: Равно;
!=: Не равно;
?:: Тернарный (троичный) условный оператор.
--------------------------------------------------------------------------------------------------------------------

### Что такое тернарный оператор выбора?

Тернарный условный оператор ?: - оператор, которым можно заменить некоторые конструкции операторов if-then-else.
Выражение записывается в следующей форме:
условие ? выражение1 : выражение2
Если условие выполняется, то вычисляется выражение1 и его результат становится результатом выполнения всего оператора. Если же условие равно false, то вычисляется выражение2 и его значение становится результатом работы оператора. Оба операнда выражение1 и выражение2 должны возвращать значение одинакового (или совместимого) типа.
--------------------------------------------------------------------------------------------------------------------

### Какие побитовые операции вы знаете?

~: Побитовый унарный оператор NOT;

&: Побитовый AND;

&=: Побитовый AND с присваиванием;

|: Побитовый OR;
|=: Побитовый OR с присваиванием;

^: Побитовый исключающее XOR;

^=: Побитовый исключающее XOR с присваиванием;

\>>: Сдвиг вправо (деление на 2 в степени сдвига);

\>>=: Сдвиг вправо с присваиванием;

\>>>: Сдвиг вправо без учёта знака;

\>>>=: Сдвиг вправо без учёта знака с присваиванием;

<<: Сдвиг влево (умножение на 2 в степени сдвига);

<<=: Сдвиг влево с присваиванием.

--------------------------------------------------------------------------------------------------------------------

### Где и для чего используется модификатор abstract?

Класс, помеченный модификатором abstract, называется абстрактным классом. 
Такие классы могут выступать только предками для других классов. Создавать экземпляры самого абстрактного класса не разрешается.
При этом наследниками абстрактного класса могут быть как другие абстрактные классы, так и классы, допускающие создание объектов.
Метод, помеченный ключевым словом abstract - абстрактный метод, т.е. метод, который не имеет реализации.
Если в классе присутствует хотя бы один абстрактный метод, то весь класс должен быть объявлен абстрактным.
Использование абстрактных классов и методов позволяет описать некий шаблон объекта, который должен быть реализован в других классах.
В них же самих описывается лишь некое общее для всех потомков поведение.
--------------------------------------------------------------------------------------------------------------------

### Приведите пример использования abstract?

В Spring Framework абстрактные классы (abstract) часто используются для создания базовой логики, которую можно переиспользовать в дочерних классах. Это особенно полезно в:

Шаблонных сервисах (например, AbstractController, AbstractService).

Реализации частичной логики (например, JpaRepository в Spring Data).

Паттерне "Шаблонный метод" (Template Method Pattern).

--------------------------------------------------------------------------------------------------------------------

### Дайте определение понятию «интерфейс». Какие модификаторы по умолчанию имеют поля и методы интерфейсов?

Ключевое слово interface используется для создания полностью абстрактных классов.
Основное предназначение интерфейса - определять каким образом мы можем использовать класс, который его реализует. 
Создатель интерфейса определяет имена методов, списки аргументов и типы возвращаемых значений, но не реализует их поведение. 
Все методы неявно объявляются как public.
Начиная с Java 8 в интерфейсах разрешается размещать реализацию методов по умолчанию default и статических static методов.
Интерфейс также может содержать и поля. В этом случае они автоматически являются публичными public, статическими static и неизменяемыми final.
--------------------------------------------------------------------------------------------------------------------

### Приведите пример использования интерфейса?

Интерфейсы чаще всего используются для достижения гибкости, модульности и тестируемости кода.
Наиболее распространенные сценарии использования интерфейсов в Spring:

1. Определение контрактов для сервисов
   Интерфейсы широко применяются для определения контрактов бизнес-логики в сервисном слое. 
   Это позволяет отделить интерфейс (что делает сервис) от его реализации (как он это делает).
   
Пример: Интерфейс UserService и его реализация UserServiceImpl.
   
Почему это популярно:

Легко заменить реализацию (например, переключиться с in-memory хранения на базу данных).
Упрощает модульное тестирование: можно создать мок-объект для UserService с помощью Mockito.
Поддерживает принцип Open/Closed из SOLID: код открыт для расширения, но закрыт для модификации.

2. Работа с репозиториями (Spring Data)
   Spring Data JPA использует интерфейсы для автоматической генерации реализаций репозиториев.
   Вы определяете интерфейс, расширяющий JpaRepository или CrudRepository, а Spring создает реализацию во время выполнения.
   
Почему это популярно:

Минимизирует шаблонный код для работы с базой данных.
Позволяет добавлять пользовательские запросы через аннотации (@Query) или naming conventions.
Интерфейс служит контрактом для работы с данными, а Spring автоматически предоставляет реализацию.

3. Внедрение зависимостей через интерфейсы
   Spring активно использует интерфейсы для внедрения зависимостей, чтобы сделать код менее связанным. 
   Контроллеры, сервисы и другие компоненты зависят от интерфейсов, а не от конкретных реализаций.
   
Почему это популярно:
Позволяет Spring автоматически подставлять нужную реализацию через @Autowired или конструктор.
Упрощает замену реализаций (например, для разных окружений: тест, продакшен).
Улучшает читаемость и поддержку кода.
--------------------------------------------------------------------------------------------------------------------

### Чем абстрактный класс отличается от интерфейса? В каких случаях следует использовать абстрактный класс, а в каких интерфейс?

1) В Java класс может одновременно реализовать несколько интерфейсов, но наследоваться только от одного класса.
2) Абстрактные классы используются только тогда, когда присутствует тип отношений «is a» (является).
   Интерфейсы могут реализоваться классами, которые не связаны друг с другом.
3) Абстрактный класс - средство, позволяющее избежать написания повторяющегося кода, инструмент для частичной реализации поведения.
   Интерфейс - это средство выражения семантики класса, контракт, описывающий возможности.
   Все методы интерфейса неявно объявляются как public abstract
   или (начиная с Java 8) default - методами с реализацией по-умолчанию, а поля - public static final.
4) Интерфейсы позволяют создавать структуры типов без иерархии.
5) Наследуясь от абстрактного, класс «растворяет» собственную индивидуальность.
   Реализуя интерфейс, он расширяет собственную функциональность.

Абстрактные классы содержат частичную реализацию, которая дополняется или расширяется в подклассах.
При этом все подклассы схожи между собой в части реализации, унаследованной от абстрактного класса,
и отличаются лишь в части собственной реализации абстрактных методов родителя. 
Поэтому абстрактные классы применяются в случае построения иерархии однотипных, очень похожих друг на друга классов.
В этом случае наследование от абстрактного класса, реализующего поведение объекта по умолчанию может быть полезно, так как позволяет избежать написания повторяющегося кода. Во всех остальных случаях лучше использовать интерфейсы.

--------------------------------------------------------------------------------------------------------------------

### Почему в некоторых интерфейсах вообще не определяют методов?

Это так называемые маркерные интерфейсы. Они просто указывают что класс относится к определенному типу.
Примером может послужить интерфейс Clonable, который указывает на то, что класс поддерживает механизм клонирования.

--------------------------------------------------------------------------------------------------------------------

### Почему нельзя объявить метод интерфейса с модификатором final?

В случае интерфейсов указание модификатора final бессмысленно, т.к. все методы интерфейсов неявно объявляются как абстрактные, 
т.е. их невозможно выполнить, не реализовав где-то еще, а этого нельзя будет сделать, если у метода идентификатор final.

--------------------------------------------------------------------------------------------------------------------

### Что имеет более высокий уровень абстракции - класс, абстрактный класс или интерфейс?

Интерфейс.

--------------------------------------------------------------------------------------------------------------------

### Может ли объект получить доступ к члену класса, объявленному как private? Если да, то каким образом?

1) Внутри класса доступ к приватной переменной открыт без ограничений;
2) Вложенный класс имеет полный доступ ко всем (в том числе и приватным) членам содержащего его класса;
3) Доступ к приватным переменным извне может быть организован через отличные от приватных методов, которые предоставлены разработчиком класса.
   Например: getX() и setX().
4) Через механизм рефлексии (Reflection API):
    ```java
   class Victim {
   private int field = 42;
   }
   //...
   Victim victim = new Victim();
   Field field = Victim.class.getDeclaredField("field"); 
   field.setAccessible(true);
   int fieldValue = (int) field.get(victim);
   ```
--------------------------------------------------------------------------------------------------------------------

### Каков порядок вызова конструкторов и блоков инициализации с учётом иерархии классов?

1. **Статические блоки инициализации родительского класса**:
    - Выполняются **один раз** при загрузке класса в JVM (например, при создании первого объекта или обращении к статическому члену).
    - Выполняются в порядке наследования: от самого верхнего родителя к потомкам.

2. **Статические блоки инициализации текущего класса**:
    - Выполняются после статических блоков родителя, также один раз при загрузке класса.

3. **Нестатические (экземплярные) блоки инициализации родительского класса**:
    - Выполняются при создании каждого объекта, перед вызовом конструктора родителя.
    - Выполняются в порядке их объявления в коде.

4. **Конструктор родительского класса**:
    - Вызывается после нестатических блоков родителя.
    - Если конструктор явно вызывает другой конструктор родителя через `super()`, он выполняется первым.

5. **Нестатические (экземплярные) блоки инициализации текущего класса**:
    - Выполняются перед конструктором текущего класса, в порядке их объявления.

6. **Конструктор текущего класса**:
    - Завершает процесс создания объекта.
--------------------------------------------------------------------------------------------------------------------

### Зачем нужны и какие бывают блоки инициализации?

В Java блоки инициализации используются для инициализации полей или выполнения кода при создании объекта или загрузке класса. 
Они бывают двух типов:

1. **Статические блоки инициализации**:
    - Объявляются с ключевым словом `static {}`.
    - Выполняются **один раз** при загрузке класса в JVM.
    - Используются для инициализации статических полей или выполнения стартовой логики.

2. **Нестатические (экземплярные) блоки инициализации**:
    - Объявляются без `static {}`.
    - Выполняются при создании каждого объекта перед вызовом конструктора.
    - Используются для инициализации экземплярных полей или общей логики перед конструктором.

#### Порядок выполнения

- **Статические блоки**: выполняются при загрузке класса, в порядке объявления, от родителя к потомку.
- **Нестатические блоки**: выполняются при создании объекта, перед конструктором, после блоков и конструктора родителя.

####Особенности
- Блок инициализации способен генерировать исключения, если их объявления перечислены в throws всех конструкторов класса.
- Блок инициализации возможно создать и в анонимном классе.
--------------------------------------------------------------------------------------------------------------------

### Приведите примеры использования блоков иничиализации?
## 1. Статический блок инициализации
Статический блок используется для одноразовой инициализации статических данных, например, загрузки конфигурации.

```java
@Component
public class ConfigLoader {
    private static final Map<String, String> config = new HashMap<>();

    static {
        System.out.println("Loading static config");
        config.put("apiKey", "12345");
        config.put("endpoint", "https://api.example.com");
    }

    public String getConfigValue(String key) {
        return config.get(key);
    }
}
```
Когда выполняется: Один раз при загрузке класса ConfigLoader в Spring-контексте, например, при сканировании компонентов.

Применение: Подходит для инициализации статических ресурсов, таких как конфигурационные параметры или константы.
## 2. Нестатический блок инициализации
 Нестатический блок используется для инициализации полей экземпляра перед вызовом конструктора.

```java
@Service
public class UserService {
private Set<String> defaultPermissions;

    {
        System.out.println("Initializing default permissions");
        defaultPermissions = new HashSet<>();
        defaultPermissions.add("READ");
    }

    public UserService() {
        System.out.println("UserService constructor");
    }

    public Set<String> getDefaultPermissions() {
        return defaultPermissions;
    }
}
```
Когда выполняется: При создании каждого экземпляра бина UserService, перед вызовом конструктора.

Применение: Используется для установки общих начальных значений полей, которые должны быть инициализированы до конструктора.

--------------------------------------------------------------------------------------------------------------------

### К каким конструкциям Java применим модификатор static?

полям;
методам;
вложенным классам;
членам секции import.
--------------------------------------------------------------------------------------------------------------------

### Ключевое слово static

Static — модификатор, применяемый к полю, блоку, методу или внутреннему классу. 
Данный модификатор указывает на привязку субъекта к текущему классу.
При обозначении переменной уровня класса мы указываем на то, что это значение относится к классу.
Если этого не делать, то значение переменной будет привязываться к объекту, созданному по этому классу.
Есть два блока инициализации — обычный и статический.
Блок предназначен для инициализации внутренних переменных. 
Если блок обычный, то им инициализируют внутренние переменные объекта, если же статический, соответственно, им задают статические переменные (то есть переменные класса).
Статические методы отличаются от обычных тем, что они также привязаны к классу, а не к объекту.
Важным свойством статического метода является то, что он может обратиться только к статическим переменным/методам.
Статическим классом может быть только внутренний класс.
Опять же, этот класс привязан к внешнему классу, и если внешний наследуется другим классом, то этот не будет наследован. При этом данный класс можно наследовать, как и он может наследоваться от любого другого класса и имплементировать интерфейс.
По сути статический вложенный класс ничем не отличается от любого другого внутреннего класса за исключением того, что его объект не содержит ссылку на создавший его объект внешнего класса.
--------------------------------------------------------------------------------------------------------------------

### Что произойдёт, если в блоке инициализации возникнет исключительная ситуация?

Для нестатических блоков инициализации, если выбрасывание исключения прописано явным образом требуется,
чтобы объявления этих исключений были перечислены в throws всех конструкторов класса. Иначе будет ошибка компиляции.
Для статического блока выбрасывание исключения в явном виде, приводит к ошибке компиляции.
В остальных случаях, взаимодействие с исключениями будет проходить так же, как и в любом другом месте.
Класс не будет инициализирован, если ошибка происходит в статическом блоке и объект класса не будет создан, 
если ошибка возникает в нестатическом блоке.
--------------------------------------------------------------------------------------------------------------------

### Какое исключение выбрасывается при возникновении ошибки в блоке инициализации класса?

## 1. Исключение в статическом блоке инициализации

- Если в `static {}` блоке возникает исключение, JVM оборачивает его в `ExceptionInInitializerError`.
- Класс становится **непригодным для использования** в текущей JVM. Любая попытка создать объект этого класса или обратиться к его статическим членам вызовет `NoClassDefFoundError`.
- Программа может продолжить выполнение, если исключение обработано, но доступ к классу будет невозможен.

## 2. Исключение в нестатическом блоке инициализации в Java

- Если в нестатическом (экземплярном) блоке инициализации `{}` возникает исключение:
    - Создание объекта **прерывается**, конструктор **не вызывается**.
    - Исключение передается вызывающему коду **без оборачивания** в `ExceptionInInitializerError` будет проброшено исключение-источник.
    - Класс остается пригодным для использования, и другие объекты могут создаваться, если исключение обработано.

Если возникшее исключение - наследник Error, то в обоих случаях будет выброшено java.lang.Error. 
Исключение: java.lang.ThreadDeath - смерть потока. В этом случае никакое исключение выброшено не будет.

--------------------------------------------------------------------------------------------------------------------
### Особенности использования статических и нестатических блоков инициализации в Spring

## 1.Статический блок:
- Если исключение возникает в статическом блоке Spring-компонента, класс не загрузится, и Spring-контекст может не запуститься, выбросив BeanDefinitionStoreException или аналогичную ошибку.
- Решение: Обработать исключения в блоке или перенести логику в @PostConstruct или @Bean-методы.
## 2.Нестатический блок:
- Исключение в нестатическом блоке прерывает создание бина, что приводит к BeanCreationException.
- Spring позволяет другим бинам продолжить загрузку, если они не зависят от проблемного бина.
- Решение: Использовать @PostConstruct для инициализации, так как он лучше интегрирован с жизненным циклом бинов.
--------------------------------------------------------------------------------------------------------------------

### Может ли статический метод быть переопределён или перегружен?

Перегружен - да. Всё работает точно так же, как и с обычными методами - 2 статических метода могут иметь одинаковое имя, если количество их параметров или типов различается.

Переопределён - нет. Выбор вызываемого статического метода происходит при раннем связывании (на этапе компиляции, а не выполнения) и выполняться всегда будет родительский метод, хотя синтаксически переопределение статического метода - это вполне корректная языковая конструкция.

В целом, к статическим полям и методам рекомендуется обращаться через имя класса, а не объект.

--------------------------------------------------------------------------------------------------------------------

### Могут ли нестатические методы перегрузить статические?

Да. В итоге получится два разных метода. 

Статический будет принадлежать классу и будет доступен через его имя, а нестатический будет принадлежать конкретному объекту и доступен через вызов метода этого объекта.

--------------------------------------------------------------------------------------------------------------------

### Возможно ли при переопределении метода изменить: модификатор доступа, возвращаемый тип, тип аргумента или их количество, имена аргументов или их порядок; убирать, добавлять, изменять порядок следования элементов секции throws?

1. Модификатор доступа
   Можно: Расширить (сделать доступ более открытым), например:

`protected → public`

Нельзя: Сужать (делать более закрытым) т.к. это приведёт к нарушению принципа подстановки Барбары Лисков, например:

`public → protected → private`

2. Возвращаемый тип
   Можно:
- Оставить тот же тип.
- Использовать ковариантный тип (вместо родительского класса - наследника).

Нельзя:
- Возвращать родительский тип (расширять тип).
- Возвращать несвязанный тип.

3. Тип аргументов, их количество и порядок
   Нельзя:
- Менять тип аргументов.
- Менять количество аргументов.
- Менять порядок аргументов.

Можно:
- Изменить имена аргументов (это не влияет на сигнатуру метода).
  
⚠ Если изменить типы/количество аргументов — это будет уже не переопределение, а перегрузка (overload).

4. Исключения (throws)
   Можно:

- Не указывать исключения вообще (она остаётся действительной, если уже определена у метода родительского класса).
- Возможно добавлять новые исключения, являющиеся наследниками от уже объявленных или исключения RuntimeException.
  Порядок следования таких элементов при переопределении значения не имеет
- Указывать более конкретные (подклассы) исключения.

Нельзя:

- Добавлять новые проверяемые (checked) исключения.
- Указывать более общие (superclass) исключения.
--------------------------------------------------------------------------------------------------------------------

### Как получить доступ к переопределенным методам родительского класса?

С помощью ключевого слова super мы можем обратиться к любому члену родительского класса - методу или полю, 
если они не определены с модификатором private.
super.method();
--------------------------------------------------------------------------------------------------------------------

### Можно ли объявить метод абстрактным и статическим одновременно?

Нет. В таком случае компилятор выдаст ошибку: "Illegal combination of modifiers: 'abstract' and 'static'".
Модификатор abstract говорит, что метод будет реализован в другом классе, а static наоборот указывает,
что этот метод будет доступен по имени класса.

--------------------------------------------------------------------------------------------------------------------

### В чем разница между членом экземпляра класса и статическим членом класса?

Модификатор static говорит о том, что данный метод или поле принадлежат самому классу и доступ к ним возможен даже без создания экземпляра класса. 
Поля, помеченные static инициализируются при инициализации класса. 
На методы, объявленные как static, накладывается ряд ограничений:
- Они могут вызывать только другие статические методы.
- Они должны осуществлять доступ только к статическим переменным.
- Они не могут ссылаться на члены типа this или super.

В отличии от статических, поля экземпляра класса принадлежат конкретному объекту и могут иметь разные значения для каждого. 
Вызов метода экземпляра возможен только после предварительного создания объекта класса.

--------------------------------------------------------------------------------------------------------------------

### Где разрешена инициализация статических/нестатических полей?

- Статические поля можно инициализировать при объявлении, в статическом или нестатическом блоке инициализации.
- Нестатические поля можно инициализировать при объявлении, в нестатическом блоке инициализации или в конструкторе
--------------------------------------------------------------------------------------------------------------------

### Какие типы классов бывают в java?

##### 1. По модификаторам доступа
| Тип             | Модификатор        | Видимость             | Пример              |
|-----------------|--------------------|-----------------------|---------------------|
| Public          | `public`           | Доступен всем пакетам | `public class User` |
| Package-private | (нет модификатора) | Только в своём пакете | `class Logger`      |

> Классы верхнего уровня не могут быть `protected` или `private`

##### 2. По вложенности
| Тип           | Особенности                               | Пример                    |
|---------------|-------------------------------------------|---------------------------|
| Top-Level     | Обычный класс в пакете                    | `class Car`               |
| Static Nested | Вложенный static-класс                    | `Outer.StaticNested`      |
| Inner         | Нестатический вложенный класс             | `outer.new Inner()`       |
| Local         | Внутри метода/блока                       | `class Local {}` в методе |
| Anonymous     | Без имени, для одноразового использования | `new Runnable() {...}`    |

##### 3. По назначению
| Тип               | Характеристики               | Пример                 |
|-------------------|------------------------------|------------------------|
| Concrete          | Полноценный класс            | `class User`           |
| Abstract          | Нельзя создать экземпляр     | `abstract class Shape` |
| Final             | Запрещает наследование       | `final class Math`     |
| Record (Java 16+) | Неизменяемый data-класс      | `record Point(x,y)`    |
| Enum              | Фиксированные константы      | `enum Color {RED}`     |
| Singleton         | Один экземпляр на приложение | `Runtime.getRuntime()` |
| Immutable         | Все поля `final`             | `String`               |
| DTO               | Для передачи данных          | `class UserDTO`        |
| POJO              | Простой Java-объект          | `class Person`         |
| Utility           | Только static-методы         | `Collections`          |

##### 4. По ООП-роли
| Тип                  | Описание                | Пример                     |
|----------------------|-------------------------|----------------------------|
| Superclass           | Родительский класс      | `class Animal`             |
| Subclass             | Дочерний класс          | `class Dog extends Animal` |
| Interface            | Контракт для реализации | `interface Drawable`       |
| Functional Interface | 1 абстрактный метод     | `Runnable`                 |

##### 5. По потокобезопасности
| Тип             | Особенности                 | Пример          |
|-----------------|-----------------------------|-----------------|
| Thread-Safe     | Безопасен в многопоточности | `StringBuffer`  |
| Non-Thread-Safe | Требует синхронизации       | `StringBuilder` |

--------------------------------------------------------------------------------------------------------------------

### Расскажите про вложенные классы. В каких случаях они применяются?

Класс называется вложенным (Nested class), если он определен внутри другого класса. 
Вложенный класс должен создаваться только для того, чтобы обслуживать обрамляющий его класс. 
Если вложенный класс оказывается полезен в каком-либо ином контексте, он должен стать классом верхнего уровня. 
Вложенные классы имеют доступ ко всем (в том числе приватным) полям и методам внешнего класса, но не наоборот. 
Из-за этого разрешения использование вложенных классов приводит к некоторому нарушению инкапсуляции.

Существуют четыре категории вложенных классов:
-- Static nested class (Статический вложенный класс);
-- Member inner class (Простой внутренний класс);
-- Local inner class (Локальный класс);
-- Anonymous inner class (Анонимный класс).

Такие категории классов, за исключением первого, также называют внутренними (Inner class). 
Внутренние классы ассоциируются не с внешним классом, а с экземпляром внешнего.
Каждая из категорий имеет рекомендации по своему применению.
Если вложенный класс должен быть виден за пределами одного метода или он слишком длинный для того, 
чтобы его можно было удобно разместить в границах одного метода и если каждому экземпляру такого класса необходима ссылка на 
включающий его экземпляр, то используется нестатический внутренний класс.
В случае, если ссылка на обрамляющий класс не требуется - лучше сделать такой класс статическим. 
Если класс необходим только внутри какого-то метода и требуется создавать экземпляры этого класса только в этом методе,
то используется локальный класс. А, если к тому же применение класса сводится к использованию лишь в одном месте и уже существует тип, 
характеризующий этот класс, то рекомендуется делать его анонимным классом.
--------------------------------------------------------------------------------------------------------------------

### Что такое «статический класс»?

Это вложенный класс, объявленный с использованием ключевого слова static. К классам верхнего уровня модификатор static неприменим.

```java
public class Person {
    public static class Builder {
        // построение сложного объекта
    }
}
```
Когда использовать:
Когда класс тесно связан с внешним, но не требует доступа к его экземплярам (Builder)
Для создания вспомогательных классов (например, Map.Entry)
Когда нужно избежать загрязнения пространства имен пакета

--------------------------------------------------------------------------------------------------------------------

### Что такое «внутренний класс»? Где они применяются?

Внутренний класс — это нестатический вложенный класс, объявленный внутри другого класса. 
Он имеет доступ ко всем членам внешнего класса (включая приватные поля и методы)
и неявно хранит ссылку на экземпляр внешнего класса (`Outer.this`).

##### Особенности внутренних классов

- **Не объявляется с `static`**
  В отличие от статических вложенных классов, внутренний класс не имеет модификатора `static`.

- **Содержит скрытую ссылку на внешний класс (`Outer.this`)**
  Это позволяет обращаться к полям и методам внешнего класса, даже `private`.

- **Может быть создан только через экземпляр внешнего класса**
```java
  Outer outer = new Outer();
  Outer.Inner inner = outer.new Inner(); // так создается внутренний класс
```
- **Не может содержать статических членов (кроме static final констант)**
```java
class Outer {
    class Inner {
        // static int x = 10; // Ошибка!
        static final int MAX = 100; // Допустимо
    }
}
```
- **Может привести к утечке памяти, если его экземпляр живет дольше внешнего класса.**

📌 Преимущества внутренних классов
✅ Прямой доступ к приватным полям внешнего класса
✅ Логическая группировка тесно связанных классов
✅ Улучшенная инкапсуляция (скрытие деталей реализации)
✅ Гибкость в проектировании (коллбэки, итераторы, адаптеры)

📌 Проблемы внутренних классов
❌ Могут вызывать утечки памяти (если внутренний класс живет дольше внешнего)
❌ Усложняют код (если используются без необходимости)
❌ Не поддерживают статические методы (кроме static final констант)
--------------------------------------------------------------------------------------------------------------------

### Какие существуют особенности использования вложенных классов: статических и внутренних? В чем заключается разница между ними?

- Вложенные классы могут обращаться ко всем членам обрамляющего класса, в том числе и приватным.
- Для создания объекта статического вложенного класса объект внешнего класса не требуется.
- Из объекта статического вложенного класса нельзя обращаться к не статическим членам обрамляющего класса напрямую, а только через ссылку на экземпляр внешнего класса.
- Обычные вложенные классы не могут содержать статических методов, блоков инициализации и классов. Статические вложенные классы - могут.
- В объекте обычного вложенного класса хранится ссылка на объект внешнего класса. Внутри статической такой ссылки нет. Доступ к экземпляру обрамляющего класса осуществляется через указание .this после его имени. Например: Outer.this.
--------------------------------------------------------------------------------------------------------------------

### Что такое «локальный класс»? Каковы его особенности?

Local inner class (Локальный класс) - это вложенный класс, который может быть декларирован в любом блоке, в котором разрешается декларировать переменные.
Как и простые внутренние классы (Member inner class) локальные классы имеют имена и могут использоваться многократно. 
Как и анонимные классы, они имеют окружающий их экземпляр только тогда, когда применяются в нестатическом контексте.

```java
void method() {
    class Local {
        // виден только внутри метода
    }
}
```
Когда использовать:

Когда класс нужен только в одном методе
Для создания одноразовых реализаций интерфейсов
В сложных алгоритмах, требующих дополнительной структуры

Локальные классы имеют следующие особенности:
- Видны только в пределах блока, в котором объявлены;
- Не могут быть объявлены как private/public/protected или static;
- Не могут иметь внутри себя статических объявлений методов и классов, но могут иметь финальные статические поля, проинициализированные константой;
- Имеют доступ к полям и методам обрамляющего класса;
- Могут обращаться к локальным переменным и параметрам метода, если они объявлены с модификатором final.
--------------------------------------------------------------------------------------------------------------------

### Что такое «анонимные классы»? Где они применяются?

Это вложенный локальный класс без имени, который разрешено декларировать в любом месте обрамляющего класса, разрешающем размещение выражений.
Создание экземпляра анонимного класса происходит одновременно с его объявлением. 
В зависимости от местоположения анонимный класс ведет себя как статический либо как нестатический вложенный класс - в нестатическом контексте появляется окружающий его экземпляр.

```java
Runnable r = new Runnable() {
    public void run() {
        // реализация
    }
};
```
```java
button.addActionListener(new ActionListener() {
    public void actionPerformed(ActionEvent e) {
        // обработка события
    }
});
```
Когда использовать:

Для быстрой реализации интерфейсов с одним методом
В обработчиках событий (до Java 8)
Callback-механизмы
Когда нужен одноразовый класс

Анонимные классы имеют несколько ограничений:
- Их использование разрешено только в одном месте программы - месте его создания;
- Применение возможно только в том случае, если после порождения экземпляра нет необходимости на него ссылаться;
- Реализует лишь методы своего интерфейса или суперкласса, т.е. не может объявлять каких-либо новых методов, так как для доступа к ним нет поименованного типа.

Анонимные классы обычно применяются для:
- создания объекта функции (function object), например, реализация интерфейса Comparator;
- создания объекта процесса (process object), такого как экземпляры классов Thread, Runnable и подобных;
- в статическом методе генерации;
- инициализации открытого статического поля final, которое соответствует сложному перечислению типов, когда для каждого экземпляра в перечислении требуется отдельный подкласс.
--------------------------------------------------------------------------------------------------------------------

### Каким образом из вложенного класса получить доступ к полю внешнего класса?

Статический вложенный класс имеет прямой доступ только к статическим полям обрамляющего класса.
Простой внутренний класс, может обратиться к любому полю внешнего класса напрямую. В случае, если у вложенного класса уже существует поле с таким же литералом, то обращаться к такому полю следует через ссылку на его экземпляр. Например: Outer.this.field.
--------------------------------------------------------------------------------------------------------------------

### Для чего используется оператор assert?

Assert (Утверждение) — это специальная конструкция, позволяющая проверять предположения о значениях произвольных данных в произвольном месте программы. Утверждение может автоматически сигнализировать об обнаружении некорректных данных, что обычно приводит к аварийному завершению программы с указанием места обнаружения некорректных данных.
Утверждения существенно упрощают локализацию ошибок в коде. Даже проверка результатов выполнения очевидного кода может оказаться полезной при последующем рефакторинге, после которого код может стать не настолько очевидным и в него может закрасться ошибка.
Обычно утверждения оставляют включенными во время разработки и тестирования программ, но отключают в релиз-версиях программ.
Т.к. утверждения могут быть удалены на этапе компиляции либо во время исполнения программы, они не должны менять поведение программы. Если в результате удаления утверждения поведение программы может измениться, то это явный признак неправильного использования assert. Таким образом, внутри assert нельзя вызывать методы, изменяющие состояние программы, либо внешнего окружения программы.
В Java проверка утверждений реализована с помощью оператора assert, который имеет форму:
assert [Выражение типа boolean]; или assert [Выражение типа boolean] : [Выражение любого типа, кроме void];
Во время выполнения программы в том случае, если поверка утверждений включена, вычисляется значение булевского выражения, и если его результат false, то генерируется исключение java.lang.AssertionError. В случае использования второй формы оператора assert выражение после двоеточия задаёт детальное сообщение о произошедшей ошибке (вычисленное выражение будет преобразовано в строку и передано конструктору AssertionError).
--------------------------------------------------------------------------------------------------------------------

### Верно ли утверждение, что примитивные типы данных всегда хранятся в стеке, а экземпляры ссылочных типов данных в куче? Где хранятся примитивные типы в Java?
1. Примитивные типы 
   
Не всегда хранятся в стеке:

В стеке (Stack):
Локальные переменные методов (включая параметры)
Хранятся непосредственно в стековых фреймах методов

В куче (Heap):
Если примитив является полем объекта
В массивах примитивных типов (int[], double[] и т.д.)
При "упаковке" в классы-обертки (Integer, Double и др.)

2. Ссылочные типы
   
Всегда в куче, но с нюансами:

Сам объект всегда размещается в куче
Ссылка (переменная) на объект может находиться:
- В стеке (если это локальная переменная)
- В куче (если это поле другого объекта)


Особые случаи
Escape-анализ (в современных JVM):
JIT-компилятор может размещать объекты в стеке, если они не "убегают" из метода
Оптимизация называется "скаляризация объектов"

Пул строк:
Строковые литералы (String s = "text") хранятся в специальной области кучи - пуле строк

Кэширование оберток:
Integer.valueOf(127) возвращает кэшированные объекты из пула
--------------------------------------------------------------------------------------------------------------------

### Каким образом передаются переменные в методы, по значению или по ссылке?

В Java параметры всегда передаются только по значению, что определяется как «скопировать значение и передать копию». 
С примитивами это будет копия содержимого. Со ссылками - тоже копия содержимого, т.е. копия ссылки.
При этом внутренние члены ссылочных типов через такую копию изменить возможно, а вот саму ссылку, указывающую на экземпляр - нет.

--------------------------------------------------------------------------------------------------------------------

### Что такое finalize()? Зачем он нужен?

Через вызов метода finalize() (который наследуется от Java.lang.Object) JVM реализуется функциональность аналогичная функциональности деструкторов в С++, используемых для очистки памяти перед возвращением управления операционной системе. Данный метод вызывается при уничтожении объекта сборщиком мусора (garbage collector) и переопределяя finalize() можно запрограммировать действия необходимые для корректного удаления экземпляра класса - например, закрытие сетевых соединений, соединений с базой данных, снятие блокировок на файлы и т.д.
После выполнения этого метода объект должен быть повторно собран сборщиком мусора (и это считается серьезной проблемой метода finalize() т.к. он мешает сборщику мусора освобождать память). Вызов этого метода не гарантируется, т.к. приложение может быть завершено до того, как будет запущена сборка мусора.
Объект не обязательно будет доступен для сборки сразу же - метод finalize() может сохранить куда-нибудь ссылку на объект. Подобная ситуация называется «возрождением» объекта и считается антипаттерном. Главная проблема такого трюка - в том, что «возродить» объект можно только 1 раз.
--------------------------------------------------------------------------------------------------------------------

### Что произойдет со сборщиком мусора, если выполнение метода finalize() требует ощутимо много времени, или в процессе выполнения будет выброшено исключение?

Непосредственно вызов finalize() происходит в отдельном потоке Finalizer (java.lang.ref.Finalizer.FinalizerThread), который создаётся при запуске виртуальной машины (в статической секции при загрузке класса Finalizer). Методы finalize() вызываются последовательно в том порядке, в котором были добавлены в список сборщиком мусора. Соответственно, если какой-то finalize() зависнет, он подвесит поток Finalizer, но не сборщик мусора. Это в частности означает, что объекты, не имеющие метода finalize(), будут исправно удаляться, а вот имеющие будут добавляться в очередь, пока поток Finalizer не освободится, не завершится приложение или не кончится память.
То же самое применимо и выброшенным в процессе finalize() исключениям: метод runFinalizer() у потока Finalizer игнорирует все исключения выброшенные в момент выполнения finalize(). Таким образом возникновение исключительной ситуации никак не скажется на работоспособности сборщика мусора.
--------------------------------------------------------------------------------------------------------------------

### Чем отличаются final, finally и finalize()?

Модификатор final:
- Класс не может иметь наследников;
- Метод не может быть переопределен в классах наследниках;
- Поле не может изменить свое значение после инициализации;
- Локальные переменные не могут быть изменены после присвоения им значения;
- Параметры методов не могут изменять своё значение внутри метода.

Оператор finally гарантирует, что определенный в нём участок кода будет выполнен независимо от того, какие исключения были возбуждены и перехвачены в блоке try-catch.
Метод finalize() вызывается перед тем как сборщик мусора будет проводить удаление объекта.
--------------------------------------------------------------------------------------------------------------------

### Расскажите про приведение типов. Что такое понижение и повышение типа?

Java является строго типизированным языком программирования, а это означает, то что каждое выражение и каждая переменная имеет строго определенный тип уже на момент компиляции. Однако определен механизм приведения типов (casting) - способ преобразования значения переменной одного типа в значение другого типа.

В Java существуют несколько разновидностей приведения:
- Тождественное (identity). Преобразование выражения любого типа к точно такому же типу всегда допустимо и происходит автоматически.
- Расширение (повышение, upcasting) примитивного типа (widening primitive). Означает, что осуществляется переход от менее емкого типа к
  более ёмкому.

  byte → short → int → long → float → double
  char → int

    ```java
      byte a = 100;
      int b = a;  // Автоматическое расширение (byte → int)
      double c = b;  // int → double
      System.out.println(c);  // 100.0
    ```

  Например, от типа byte (длина 1 байт) к типу int (длина 4 байта).
  Такие преобразование безопасны в том смысле, что новый тип всегда гарантировано вмещает в себя все данные, которые хранились в старом типе
  и таким образом не происходит потери данных.
  Этот тип приведения всегда допустим и происходит автоматически.
- Сужение (понижение, downcasting) примитивного типа (narrowing primitive). Означает, что переход осуществляется от более емкого типа к
  менее емкому.

    ```java
    double x = 123.456;
    int y = (int) x;  // Явное сужение (double → int), y = 123 (дробная часть отброшена)
    
    long bigNum = 1_000_000;
    short smallNum = (short) bigNum;  // Переполнение! smallNum = 16960
    ```
  При таком преобразовании есть риск потерять данные. Например, если число типа int было больше 127, то при приведении его к byte значения
  битов старше восьмого будут потеряны.
  В Java такое преобразование должно совершаться явным образом, при этом все старшие биты,
  не умещающиеся в новом типе, просто отбрасываются - никакого округления или других действий для получения более корректного результата не
  производится.
- Расширение объектного типа (widening reference). Означает неявное восходящее приведение типов или переход от более конкретного типа к
  менее конкретному,

    ```java
    class Animal {}
    class Dog extends Animal {}
    
    Dog dog = new Dog();
    Animal animal = dog;  // Автоматическое upcasting (Dog → Animal)
    ```
  т.е. переход от потомка к предку. Разрешено всегда и происходит автоматически.
- Сужение объектного типа (narrowing reference). Означает нисходящее приведение, то есть приведение от предка к потомку (подтипу).
  Возможно только если исходная переменная является подтипом приводимого типа.
  При несоответствии типов в момент выполнения выбрасывается исключение ClassCastException. Требует явного указания типа.
    ```java
    Animal animal = new Dog();
    if (animal instanceof Dog) {
    Dog dog = (Dog) animal;  // Явное downcasting (Animal → Dog)
    }
    ```
- Преобразование к строке (to String). Любой тип может быть приведен к строке, т.е. к экземпляру класса String.
    ```java
    int num = 42;
    String str = Integer.toString(num);  // "42"
    String str2 = "" + num;  // "42"
    ```
- Запрещенные преобразования (forbidden). Не все приведения между произвольными типами допустимы.
    ```java
     int num = (int) new Object();  // Ошибка компиляции
     String str = (String) new Integer(10);  // ClassCastException
    ```
  Например, к запрещенным преобразованиям относятся приведения от любого ссылочного типа к примитивному и наоборот (кроме преобразования к
  строке).
  Кроме того, невозможно привести друг к другу классы, находящиеся на разных ветвях дерева наследования и т.п.

При приведении ссылочных типов с самим объектом ничего не происходит, - меняется лишь тип ссылки, через которую происходит обращение к объекту.

Для проверки возможности приведения нужно воспользоваться оператором instanceof:

```java
Parent parent = new Child();
if (parent instanceof Child) {
Child child = (Child) parent;
}
```
--------------------------------------------------------------------------------------------------------------------

### Когда в приложении может быть выброшено исключение ClassCastException?

ClassCastException (потомок RuntimeException) - исключение, которое будет выброшено при ошибке приведения типа.

--------------------------------------------------------------------------------------------------------------------

### Что такое литералы?

Литерал — это явное фиксированное значение, записанное в коде программы. В Java литералы представляют собой константные значения примитивных
типов, строк и null.

```java
class Test {
int a = 0b1101010110;
public static void main(String[] args) { System.out.println("Hello world!");
} }
```
В этом классе "Hello world!" — литерал.
Переменная a - тоже литерал.
Литералы бывают разных типов, которые определяются их назначением и способом написания.
--------------------------------------------------------------------------------------------------------------------

### Что такое autoboxing («автоупаковка») в Java и каковы правила упаковки примитивных типов в классы-обертки?

Autoboxing (автоупаковка) и Unboxing (распаковка) в Java
Autoboxing — это автоматическое преобразование примитивного типа в соответствующий класс-обертку (например, int → Integer).
Unboxing — обратный процесс: преобразование класса-обертки в примитив (Integer → int).

Эти механизмы появились в Java 5 для упрощения работы с примитивами и их объектными аналогами.

1. Классы-обертки и их примитивы
   Примитив | Класс-обертка |
   |----------|---------------|
   | byte | Byte |
   | short | Short |
   | int | Integer |
   | long | Long |
   | float | Float |
   | double | Double |
   | char | Character |
   | boolean | Boolean |
2. Правила Autoboxing/Unboxing
   2.1 Автоупаковка (Autoboxing)
   Происходит автоматически, когда:

- Примитив передается в метод, ожидающий объект-обертку.
- Примитив присваивается переменной класса-обертки.

```java
Integer a = 10;         // Автоупаковка: int → Integer
List<Integer> list = new ArrayList<>();
list.

add(5);            // Автоупаковка: int → Integer
```

2.2. Распаковка (Unboxing)
Происходит автоматически, когда:

- Объект-обертка используется в контексте, где требуется примитив.
- Обертка присваивается переменной примитивного типа.

```java
Integer b = 20;
int c = b;              // Распаковка: Integer → int

if(b< 30){           // Распаковка в условии
    System.out.

println(c +b);  // Распаковка в выражении
}
```

3. Особенности и подводные камни
   3.1. Сравнение объектов (== vs equals)

- == сравнивает ссылки, а не значения.
- equals сравнивает значения.

Пример:

```java
Integer x = 127;
Integer y = 127;
System.out.

println(x ==y);      // true (кэширование в диапазоне -128..127)
```

```java
Integer z = 128;
Integer w = 128;
System.out.

println(z ==w);      // false (новые объекты)
System.out.

println(z.equals(w)); // true (сравнение значений)
```

3.2. NullPointerException при распаковке
Если объект-обертка null, попытка распаковки вызовет исключение:

```java
Integer n = null;
int m = n;  // NullPointerException!
```

3.3. Производительность
Autoboxing создает временные объекты, что может влиять на производительность в циклах:

```java
for(Integer i = 0;
i< 100_000;i++){  // Медленно из-за автоупаковки
// ...
    }
```

4. Полезные методы классов-оберток
   Преобразование строки в число:

```java
int num = Integer.parseInt("42");
double d = Double.parseDouble("3.14");
```

Преобразование в строку:

```java
String s = Integer.toString(42);
```

Минимальные/максимальные значения:

```java
int max = Integer.MAX_VALUE;
int min = Integer.MIN_VALUE;
```

Дополнительной особенностью целочисленных классов-оберток, созданных автоупаковкой констант в диапазоне -128 ... +127 является то, что они кэшируются JVM. Поэтому такие обертки с одинаковыми значениями будут являться ссылками на один объект.

--------------------------------------------------------------------------------------------------------------------

### Как работает расширение и сужение типов при автоупаковке (Autoboxing) в Java?

Autoboxing (автоупаковка) в Java автоматически преобразует примитивные типы в соответствующие классы-обертки (например, int → Integer).
Однако при этом могут происходить расширение (widening) и сужение (narrowing) типов, аналогично примитивным преобразованиям.

1. Автоупаковка с расширением типов (Widening + Autoboxing)
   Если примитив меньшего типа передается в метод или присваивается переменной, требующей более широкой обертки,
   Java сначала выполняет расширение примитива, а затем автоупаковку.

```java
short s = 100;
Integer i = s;  // Сначала short → int (расширение), затем int → Integer (автоупаковка)

byte b = 50;
Double d = b;   // byte → double (расширение), затем double → Double (автоупаковка)
```

Порядок преобразований:
Расширение примитива (byte → short → int → long → float → double).
Автоупаковка в соответствующий класс-обертку.

Допустимые расширения при автоупаковке:

byte → Short, Integer, Long, Float, Double

short → Integer, Long, Float, Double

int → Long, Float, Double

long → Float, Double

float → Double

2. Автоупаковка с сужением типов (Narrowing + Autoboxing)
   Сужение (narrowing) при автоупаковке не выполняется автоматически!
   Если требуется преобразовать примитив большего типа в обертку меньшего, необходимо явное приведение.

Примеры:
❌ Ошибка компиляции (без явного приведения):

```java
int num = 100;
Short s = num;  // Ошибка: int → Short требует явного сужения!
```

✅ Правильный вариант:

```java
int num = 100;
Short s = (short) num;  // Сначала int → short (сужение), затем short → Short (автоупаковка)
```

Почему сужение требует явного приведения?

Риск потери данных (например, int → short может привести к переполнению).
Java требует явного подтверждения намерения.

3. Особые случаи

3.1. Автоупаковка и арифметические операции

При арифметике сначала происходит распаковка, затем вычисления, и только потом автоупаковка:

```java
Integer a = 10;
Integer b = 20;
Integer c = a + b;  // a и b распаковываются в int, складываются, результат упаковывается в Integer
```

3.2. Методы, принимающие Object
Если метод принимает Object, примитив сначала расширяется и упаковывается:

```java
void print(Object obj) {
  System.out.println(obj);
}

print(10);  // int → Integer (автоупаковка)

print(3.14f); // float → Float → Object (автоупаковка + полиморфизм)
```

3.3. Перегрузка методов

При перегрузке Java выбирает наиболее точный тип:

```java
void process(Integer x) {
}

void process(Double x) {
}

process(10);   // Вызовется process(Integer), т.к. int → Integer ближе, чем int → double → Double

process(10.0); // Вызовется process(Double)
```

--------------------------------------------------------------------------------------------------------------------

### Дайте определение понятию «конструктор».

Конструктор — это специальный метод, у которого отсутствует возвращаемый тип и который имеет то же имя, что и класс, в котором он используется. Конструктор вызывается при создании нового объекта класса и определяет действия необходимые для его инициализации.

--------------------------------------------------------------------------------------------------------------------

### Что такое «конструктор по умолчанию»?

Если у какого-либо класса не определить конструктор, то компилятор сгенерирует конструктор без аргументов - так называемый «конструктор по умолчанию».
public class ClassName() {}
Если у класса уже определен какой-либо конструктор, то конструктор по умолчанию создан не будет и, если он необходим, его нужно описывать явно.
--------------------------------------------------------------------------------------------------------------------

### Чем отличаются конструктор по-умолчанию, конструктор копирования и конструктор с параметрами?

У конструктора по умолчанию отсутствуют какие-либо аргументы. Конструктор копирования принимает в качестве аргумента уже существующий объект класса для последующего создания его клона. Конструктор с параметрами имеет в своей сигнатуре аргументы (обычно необходимые для инициализации полей класса).

--------------------------------------------------------------------------------------------------------------------

### Где и как вы можете использовать приватный конструктор?

Приватный (помеченный ключевым словом private, скрытый) конструктор может использоваться публичным статическим методом генерации объектов данного класса. Также доступ к нему разрешён вложенным классам и может использоваться для их нужд.

--------------------------------------------------------------------------------------------------------------------

### Что такое Reflection?

Рефлексия (Reflection) - это механизм получения данных о программе во время её выполнения (runtime). В Java Reflection осуществляется с помощью Java Reflection API, состоящего из классов пакетов java.lang и java.lang.reflect.

Возможности Java Reflection API:
- Определение класса объекта;
- Получение информации о модификаторах класса, полях, методах, конструкторах и суперклассах;
- Определение интерфейсов, реализуемых классом;
- Создание экземпляра класса;
- Получение и установка значений полей объекта;
- Вызов методов объекта;
- Создание нового массива.
--------------------------------------------------------------------------------------------------------------------

### Зачем нужен equals(). Чем он отличается от операции ==?

Метод equals() - определяет отношение эквивалентности объектов.
При сравнении объектов с помощью == сравнение происходит лишь между ссылками.
При сравнении по переопределённому разработчиком equals() - по внутреннему состоянию объекто
--------------------------------------------------------------------------------------------------------------------

### Какими свойствами обладает порождаемое equals() отношение эквивалентности?

- Рефлексивность: для любой ссылки на значение x, x.equals(x) вернет true;
- Симметричность: для любых ссылок на значения x и y, x.equals(y) должно вернуть true, тогда и только тогда, когда y.equals(x) возвращает true.
- Транзитивность: для любых ссылок на значения x, y и z, если x.equals(y) и y.equals(z) возвращают true, тогда и x.equals(z) вернёт true;
- Непротиворечивость: для любых ссылок на значения х и у, если несколько раз вызвать х.equals(y), постоянно будет возвращаться значение true либо постоянно будет возвращаться значение false при условии, что никакая информация, используемая при сравнении объектов, не поменялась.

Для любой ненулевой ссылки на значение х выражение х.equals(null) должно возвращать false.

--------------------------------------------------------------------------------------------------------------------

### Правила переопределения метода Object.equals().

1) Использование оператора == для проверки, является ли аргумент ссылкой на указанный объект. Если является, возвращается true. Если сравниваемый объект == null, должно вернуться false.
   2)Использование оператор instanceof и вызова метода getClass() для проверки, имеет ли аргумент правильный тип. Если не имеет, возвращается false.
3) Приведение аргумента к правильному типу. Поскольку эта операция следует за проверкой instanceof она гарантированно будет выполнена.
   4)Обход всех значимых полей класса и проверка того, что значение поля в текущем объекте и значение того же поля в проверяемом на эквивалентность аргументе соответствуют друг другу. Если проверки для всех полей прошли успешно, возвращается результат true, в противном случае - false.

По окончанию переопределения метода equals() следует проверить: является ли порождаемое отношение эквивалентности рефлексивным, симметричным, транзитивным и непротиворечивым? Если ответ отрицательный, метод подлежит соответствующей правке.

--------------------------------------------------------------------------------------------------------------------

### Какая связь между hashCode() и equals()?

Равные объекты должны возвращать одинаковые хэш коды. При переопределении equals() нужно обязательно переопределять и метод hashCode().

--------------------------------------------------------------------------------------------------------------------

### Что будет, если переопределить equals() не переопределяя hashCode()? Какие могут возникнуть проблемы?

Классы и методы, которые используют правила этого контракта могут работать некорректно.
Так для HashMap это может привести к тому, что пара «ключ-значение»,
которая была в неё помещена при использовании нового экземпляра ключа не будет в ней найдена.

--------------------------------------------------------------------------------------------------------------------

### Каким образом реализованы методы equals() в классе Object?

Реализация метода Object.equals() сводится к проверке на равенство двух ссылок:

```java
public boolean equals(Object obj)
{
return (this == obj);
}
```

--------------------------------------------------------------------------------------------------------------------

### Реализованы методы hashCode() в классе Object по умолчанию как адрес объекта в памяти?

На собеседованиях часто обсуждают методы equals и hashcode. За что отвечают, как соотносятся между собой, когда переопределять, а когда не
стоит.

Если хочется посмотреть, как думает человек за пределами стандартного ответа, возможен такой диалог:

— Как считается хэшкод по умолчанию?
— Это адрес объекта в памяти
— А почему так?
— Адрес каждого объекта уникален, то что надо для хэшкода
— Сборщик мусора перемещает объекты внутри памяти. Как это влияет на значения хэшей?
— 😥

Тут можно предположить, что хэшкод считается один раз и приписывается к самому объекту. Это будет логичная мысль.

А вот вычисление хэша на основе адреса в памяти — популярный миф

--------------------------------------------------------------------------------------------------------------------

### Каким образом реализованы методы hashCode() в классе Object?

В разных JVM реализации могут отличаться. Рассмотрим исходный код hashcode в OpenJDK.
Там 6(!) стратегий вычисления хэшкода. Стратегия задаётся опциями VM:
-XX:+UnlockExperimentalVMOptions -XX:hashCode={число}
При первом вызове хэш сохраняется внутри объекта и не меняется. Теперь к стратегиям:

🔸-XX:hashCode=0

Случайное число по алгоритму Lehmer RNG. Генератор один на всех, поэтому работает медленно

🔸-XX:hashCode=2

Чемпион по скорости, всегда возвращает 1:
java.lang.Object@1
Используется как отправная точка для тестов остальных стратегий

🔸-XX:hashCode=3

Обычная возрастающая последовательность:
java.lang.Object@a4
java.lang.Object@a5
java.lang.Object@a6

🔸-XX:hashCode=4

Текущий адрес в памяти. Популярный, но неправильный ответ на собеседованиях.
Отчасти в этом виновата спецификация: там адрес приводится как пример реализации.
Работает быстро, но не даёт равномерного распределения и должного уровня уникальности

🔸-XX:hashCode=1

Адрес объекта в памяти и немного манипуляций с битами

🔸 Стратегия по умолчанию

Случайное число по алгоритму Xorshift RNG.
Следующее значение вычисляется на основе предыдущего.
Значения равномерно распределены. Работает быстро, тк у каждого потока свой генератор, и синхронизации между потоками нет

--------------------------------------------------------------------------------------------------------------------

### Для чего нужен метод hashCode()?

Метод hashCode() необходим для вычисления хэш кода переданного в качестве входного параметра объекта.
В Java это целое число, в более широком смысле - битовая строка фиксированной длины, полученная из массива произвольной длины.
Этот метод реализован таким образом, что для одного и того же входного объекта, хэш код всегда будет одинаковым.
Следует понимать, что в Java множество возможных хэш кодов ограничено типом int, а множество объектов ничем не ограничено.
Из-за этого, вполне возможна ситуация, что хэш коды разных объектов могут совпасть:
- если хэш коды разные, то и объекты гарантированно разные;
- если хэш коды равны, то объекты могут не обязательно равны.
--------------------------------------------------------------------------------------------------------------------

### Каковы правила переопределения метода Object.hashCode()?

Как реализовать метод hashCode?

Если вы переопределили equals(), то обязательно также переопределить и hashCode(). Это не просто теоретическое требование. Если класс
нарушает это правило, хранение его экземпляров в качестве например ключей HashMap приводит к непредсказуемому поведению.

Результат hashCode() должен быть одинаковый для равных в смысле equals объектов. Обычно для этого значение хэш-кода вычисляется на основе
значений полей, которые участвуют в equals(). Но и возвращение одной и той же константы 42 для любого экземпляра класса тоже будет валидной
реализацией.

Результат hashCode() должен быть равномерно распределен. Это правило не такое строгое как остальные. Его нарушение не сломает программу,
хотя может сильно ухудшить производительность. Поэтому константа 42 – допустимая, но не лучшая идея. Вместо этого все значения полей сначала
приводятся к int: boolean превращается в любую пару констант, null в 0, для ссылочных типов берется их hashCode(). Затем все эти значения
смешиваются с помощью бинарного оператора XOR (^). Дополнительно для лучшего распределения можно применять битовые сдвиги. Если вы владеете
информацией о распределении значений полей в конкретно вашем случае, эту реализацию можно улучшить.

Результат hashCode() должен быть одинаковый на протяжении времени жизни объекта. Если вычисление хэш-кода зависит от переменных значений,
сохраните его значение во внутреннее поле при первом вызове. При следующих вызовах сразу возвращайте это закэшированное значение.

--------------------------------------------------------------------------------------------------------------------

### Могут ли у разных объектов быть одинаковые hashCode()?

Да, могут. Метод hashCode() не гарантирует уникальность возвращаемого значения.
Ситуация, когда у разных объектов одинаковые хэш коды называется коллизией. Вероятность возникновения коллизии зависит от используемого
алгоритма генерации хэш кода.

--------------------------------------------------------------------------------------------------------------------

### Если у класса Point{int x, y;} реализовать метод equals(Object that) {(return this.x == that.x && this.y == that.y)}, но сделать хэш код в виде int hashCode() {return x;}, то будут ли корректно такие точки помещаться и извлекаться из HashSet?

HashSet использует HashMap для хранения элементов. При добавлении элемента в HashMap вычисляется хэш код, по которому определяется позиция в массиве, куда будет вставлен новый элемент. У всех экземпляров класса Point хэш код будет одинаковым для всех объектов с одинаковым x, что приведёт к вырождению хэш таблицы в список.
При возникновении коллизии в HashMap осуществляется проверка на наличие элемента в списке: e.hash == hash && ((k = e.key) == key || key.equals(k)). Если элемент найден, то его значение перезаписывается. В нашем случае для разных объектов метод equals() будет возвращать false. Соответственно новый элемент будет успешно добавлен в HashSet. Извлечение элемента также будет осуществляться успешно. Но производительность такого кода будет невысокой и преимущества хэш таблиц использоваться не будут.
--------------------------------------------------------------------------------------------------------------------

### Могут ли у разных объектов (ref0 != ref1) быть ref0.equals(ref1) == true?

Да, могут. Для этого в классе этих объектов должен быть переопределен метод equals().
Если используется метод Object.equals(), то для двух ссылок x и y метод вернет true тогда и только тогда, когда обе ссылки указывают на один и тот же объект (т.е. x == y возвращает true).
--------------------------------------------------------------------------------------------------------------------

### Могут ли у разных ссылок на один объект (ref0 == ref1) быть ref0.equals(ref1) == false?

В общем случае - могут, если метод equals() реализован некорректно и не выполняет свойство рефлексивности: для любых ненулевых ссылок x метод x.equals(x) должен возвращать true.

--------------------------------------------------------------------------------------------------------------------

### Можно ли так реализовать метод equals(Object that) {return this.hashCode() == that.hashCode()}?

Строго говоря нельзя, поскольку метод hashCode() не гарантирует уникальность значения для каждого объекта. Однако для сравнения экземпляров класса Object такой код допустим, т.к. метод hashCode() в классе Object возвращает уникальные значения для разных объектов (его вычисление основано на использовании адреса объекта в памяти).

--------------------------------------------------------------------------------------------------------------------

### В equals() требуется проверять, что аргумент equals(Object that) такого же типа что и сам объект. В чем разница между this.getClass() == that.getClass() и that instanceof MyClass?

Оператор instanceof сравнивает объект и указанный тип. Его можно использовать для проверки является ли данный объект экземпляром некоторого класса, либо экземпляром его дочернего класса, либо экземпляром класса, который реализует указанный интерфейс.
this.getClass() == that.getClass() проверяет два класса на идентичность, поэтому для корректной реализации контракта метода equals() необходимо использовать точное сравнение с помощью метода getClass().
--------------------------------------------------------------------------------------------------------------------

### Можно ли реализовать метод equals() класса MyClass вот так: class MyClass {public boolean equals(MyClass that) {return this == that;}}?

Реализовать можно, но данный метод не переопределяет метод equals() класса Object, а перегружает его

--------------------------------------------------------------------------------------------------------------------

### Есть класс Point{int x, y;}. Почему хэш код в виде 31 * x + y предпочтительнее чем x + y?

Множитель создает зависимость значения хэш кода от очередности обработки полей, что в итоге порождает лучшую хэш функцию.

--------------------------------------------------------------------------------------------------------------------

### Расскажите про клонирование объектов.

Использование оператора присваивания не создает нового объекта, а лишь копирует ссылку на объект. Таким образом, две ссылки указывают на одну и ту же область памяти, на один и тот же объект. Для создания нового объекта с таким же состоянием используется клонирование объекта.
Класс Object содержит protected метод clone(), осуществляющий побитовое копирование объекта производного класса. Однако сначала необходимо переопределить метод clone() как public для обеспечения возможности его вызова. В переопределенном методе следует вызвать базовую версию метода super.clone(), которая и выполняет собственно клонирование.
Чтобы окончательно сделать объект клонируемым, класс должен реализовать интерфейс Cloneable. Интерфейс Cloneable не содержит методов относится к маркерным интерфейсам, а его реализация гарантирует, что метод clone() класса Object возвратит точную копию вызвавшего его объекта с воспроизведением значений всех его полей. В противном случае метод генерирует исключение CloneNotSupportedException. Следует отметить, что при использовании этого механизма объект создается без вызова конструктора.
Это решение эффективно только в случае, если поля клонируемого объекта представляют собой значения базовых типов и их обёрток или неизменяемых (immutable) объектных типов. Если же поле клонируемого типа является изменяемым ссылочным типом, то для корректного клонирования требуется другой подход. Причина заключается в том, что при создании копии поля оригинал и копия представляют собой ссылку на один и тот же объект. В этой ситуации следует также клонировать и сам объект поля класса.
Такое клонирование возможно только в случае, если тип атрибута класса также реализует интерфейс Cloneable и переопределяет метод clone(). Так как, если это будет иначе вызов метода невозможен из-за его недоступности. Отсюда следует, что если класс имеет суперкласс, то для реализации механизма клонирования текущего класса-потомка необходимо наличие корректной реализации такого механизма в суперклассе. При этом следует отказаться от использования объявлений final для полей объектных типов по причине невозможности изменения их значений при реализации клонирования.

Помимо встроенного механизма клонирования в Java для клонирования объекта можно использовать:
- Специализированный конструктор копирования - в классе описывается конструктор, который принимает объект этого же класса и инициализирует поля создаваемого объекта значениями полей переданного.
- Фабричный метод - (Factory method), который представляет собой статический метод, возвращающий экземпляр своего класса.
- Механизм сериализации - сохранение и последующее восстановление объекта в/из потока байтов.
--------------------------------------------------------------------------------------------------------------------

### В чем отличие между поверхностным и глубоким клонированием?

Поверхностное копирование копирует настолько малую часть информации об объекте, насколько это возможно. По умолчанию, клонирование в Java является поверхностным, т.е. класс Object не знает о структуре класса, которого он копирует. Клонирование такого типа осуществляется JVM по следующим правилам:
- Если класс имеет только члены примитивных типов, то будет создана совершенно новая копия объекта и возвращена ссылка на этот объект.
- Если класс помимо членов примитивных типов содержит члены ссылочных типов, то тогда копируются ссылки на объекты этих классов. Следовательно, оба объекта будут иметь одинаковые ссылки.
  Глубокое копирование дублирует абсолютно всю информацию объекта:
- Нет необходимости копировать отдельно примитивные данные;
- Все члены ссылочного типа в оригинальном классе должны поддерживать клонирование. Для каждого такого члена при переопределении метода clone() должен вызываться super.clone();
- Если какой-либо член класса не поддерживает клонирование, то в методе клонирования необходимо создать новый экземпляр этого класса и скопировать каждый его член со всеми атрибутами в новый объект класса, по одному.
--------------------------------------------------------------------------------------------------------------------

### Какой способ клонирования предпочтительней?

Наиболее безопасным и, следовательно, предпочтительным способом клонирования является использование специализированного конструктора копирования:
- Отсутствие ошибок наследования (не нужно беспокоиться, что у наследников появятся новые поля, которые не будут склонированы через метод clone());
- Поля для клонирования указываются явно;
- Возможность клонировать даже final поля.
--------------------------------------------------------------------------------------------------------------------

### Почему метод clone() объявлен в классе Object, а не в интерфейсе Cloneable?

Метод clone() объявлен в классе Object с указанием модификатора native, чтобы обеспечить доступ к стандартному механизму поверхностного копирования объектов. Одновременно он объявлен и как protected, чтобы нельзя было вызвать этот метод у не переопределивших его объектов. Непосредственно интерфейс Cloneable является маркерным (не содержит объявлений методов) и нужен только для обозначения самого факта, что данный объект готов к тому, чтобы быть клонированным. Вызов переопределённого метода clone() у не Cloneable объекта вызовет выбрасывание CloneNotSupportedException.

--------------------------------------------------------------------------------------------------------------------

### Имеет ли смысл объявлять метод private final?

Нет, такой метод и так не виден для наследников, а значит не может быть ими переопределен.

--------------------------------------------------------------------------------------------------------------------

### В чём разница между intrinsic и native методами?

Методы, помеченные модификатором native, реализованны на нативном языке платофрмы (например, C++). Например, Object.hashCode.
Intrinsic-методы, у которых нет модификатора native, но которые во время исполнения заменяются нативной реализацией. Например, String.equals. Т.е. скорость работы этого метода будет отличаться в ситуациях, когда вы вызываете его через API или скопируете реализацию в собственный метод.
Начиная с 9-ой версии в HotSpot JVM существует аннотация @HotSpotIntrinsicCandidate для метода(или конструктора), которая указыает, что аннотируемый метод может (но гарантий в этом нет) стать intrinsic-методом в будущем.
--------------------------------------------------------------------------------------------------------------------

### Что значит ключевое слово var?

Ключево слово var, введённо в Java 10, избавляет от указания типа локальной переменной (local-variable type inference). Пример. Выражение int i = 0 эквивалентно var i = 0;. При объяевления коллекций читаемость кода повышается var list = new ArrayList<Objet>(); Но, с другой стороны, при объявлении generics нельзя будет использовать сокращённый вариант без указания типа - <...>. В случаях, когда тип переменной не очевиден компилятору, будет выдана ошибка error: cannot infer type for local variable ....

--------------------------------------------------------------------------------------------------------------------

### Какие алгоритмы сортировки массивов используются в Java?


   |Метод                  | Алгоритм               | Тип данных               | Устойчивость | Сложность          |
      |------------------------|------------------------|--------------------------|--------------|--------------------|
   | Arrays.sort()          | Dual-Pivot Quicksort   | Примитивы (int[])        | ❌ Нет       | O(n log n) / O(n²) |
   | Arrays.sort()          | TimSort                | Объекты (Object[])       | ✅ Да        | O(n log n)         |
   | Collections.sort()      | TimSort                | Коллекции (List<T>)      | ✅ Да        | O(n log n)         |
   | Arrays.parallelSort()  | Гибрид (Quicksort + Merge) | Примитивы/Объекты | ❌/✅ Зависит от типа | O(n log n)         |


- Insertion Sort для малых массивов (ускоряет сортировку при n ≤ 47).

1. **Dual-Pivot Quicksort**:
Улучшенная версия классической быстрой сортировки (Quicksort).
Использует **два опорных элемента** (pivots) для разделения массива на три части: меньше первого pivot, между pivots, больше второго pivot.
Эффективнее обычного Quicksort для больших массивов, особенно с повторяющимися элементами.
Сложность: O(n log n) в среднем, O(n²) в худшем случае.
Используется, например, в Java для сортировки массивов примитивов.

2. **Timsort**:
Гибридная сортировка, комбинирующая **сортировку слиянием** и **вставками**.
Оптимизирована для реальных данных с частично отсортированными участками (runs).
Делит массив на runs, сортирует их вставками, затем объединяет слиянием.
Сложность: O(n log n) в среднем и в худшем случае, O(n) для почти отсортированных данных.
Используется в Python, Java (для объектов), Android.

3. **Insertion Sort (Сортировка вставками)**:
Простая сортировка, где каждый элемент вставляется в правильное место в уже отсортированной части массива.
Эффективна для **маленьких массивов** или почти отсортированных данных.
Сложность: O(n²) в среднем и в худшем случае, O(n) для почти отсортированных.
Проста в реализации, но не подходит для больших массивов.

--------------------------------------------------------------------------------------------------------------------

### Чем объект отличается от примитивных типов данных?

Первое отличие: количество занимаемой памяти: примитивы занимают очень мало, ведь они содержат лишь собственное значение,
в то время как объекты могут содержать очень и очень много различных значений: как примитивов, так и ссылок на другие объекты.

Второе отличие: Java —это объектно-ориентированный язык, поэтому в ней все работает через взаимодействие между объектами,
и примитивы тут не сильно вписываются (собственно, поэтому Java — это не 100% объектно-ориентированный язык).

Третье, вытекающее со второго: так как Java ориентирована на взаимодействие между объектами, у этих объектов есть много различных механизмов
для управления.
Например, конструкторы, методы, исключения (которые работают в первую очередь с объектами), и т.д.
Собственно, чтобы примитивы могли как-то ввязаться (работать) в этой объектно ориентированной среде
и были придуманы обертки (wrappers) для примитивных типов (Integer, Character, Double, Boolean...)

--------------------------------------------------------------------------------------------------------------------

### Объекты каких стандартных классов immutable в Java?

В языке Java объекты классов String, Integer, Byte, Character, Short, Boolean, Long, Double и Float являются immutable.
Таким образом, любые операции с ними, которые изменяют значение, на самом деле создают новый объект. 

--------------------------------------------------------------------------------------------------------------------
### Дайте краткую характеристику immutable object. Зачем они нужны?

**Immutable object (Неизменяемый объект)** — это объект, состояние которого нельзя изменить после создания. Все его поля фиксированы, и любые операции, кажущиеся изменяющими, создают новый объект.

**Характеристики**:
- **Неизменяемость**: После создания данные объекта (поля, значения) остаются постоянными.
- **Потокобезопасность**: Не требуют синхронизации в многопоточных средах, так как их нельзя модифицировать.
- **Простота**: Упрощают понимание и предсказуемость кода, так как объект всегда в одном состоянии.
- Примеры: В Java — `String`, `Integer`, в Python — `str`, `tuple`.

**Зачем нужны**:
1. **Безопасность**: Защищают данные от случайных или нежелательных изменений.
2. **Многопоточность**: Устраняют необходимость в блокировках, снижая ошибки в конкурентных программах.
3. **Кэширование и хэширование**: Могут безопасно использоваться как ключи в хэш-таблицах (например, в `HashMap`), так как их хэш-код не меняется.
4. **Простота отладки**: Постоянное состояние упрощает трассировку и тестирование.
5. **Функциональное программирование**: Поддерживают парадигму, где данные неизменяемы, что улучшает предсказуемость.

--------------------------------------------------------------------------------------------------------------------
### Как сделать immutable object?

1. **Объявите класс финальным**:
   - Используйте ключевое слово `final` (в Java) или аналогичный механизм, чтобы класс нельзя было наследовать. Это предотвращает изменение поведения через подклассы.

2. **Сделайте поля приватными и финальными**:
   - Поля должны быть `private` и `final`, чтобы их нельзя было изменить после инициализации.

3. **Инициализируйте поля через конструктор**:
   - Установите значения полей только в конструкторе, без сеттеров.

4. **Не предоставляйте методов, изменяющих состояние**:
   - Не создавайте сеттеры или методы, которые могут модифицировать поля.
   - Если метод кажется изменяющим объект, он должен возвращать новый объект.

5. **Обеспечьте защиту изменяемых объектов**:
   - Если поля содержат изменяемые объекты (например, списки или массивы), возвращайте их копии, а не оригиналы.

6. **Обеспечьте корректное хэширование** (если нужно):
   - Если объект будет использоваться в хэш-таблицах, реализуйте методы `hashCode()` и `equals()` так, чтобы они учитывали неизменяемые поля.

--------------------------------------------------------------------------------------------------------------------
