### Что такое класс Object? Какие в нем есть методы?

<details>
 <summary><b>Показать ответ</b></summary>
Object — это базовый класс для всех остальных объектов в Java. Любой класс наследуется от Object и, соответственно, наследует его методы:
- `public boolean equals(Object obj)` — служит для сравнения объектов по значению;
- `int hashCode()` — возвращает хэш-код для объекта;
- `String toString()` — возвращает строковое представление объекта;
- `Class getClass()` — возвращает класс объекта во время выполнения;
- `protected Object clone()` — создает и возвращает копию объекта;
- `void notify()` — возобновляет поток, ожидающий монитор;
- `void notifyAll()` — возобновляет все потоки, ожидающие монитор;
- `void wait()` — останавливает вызвавший метод поток до момента, пока другой поток не вызовет метод `notify()` или `notifyAll()` для этого объекта;
- `void wait(long timeout)` — останавливает вызвавший метод поток на определённое время или пока другой поток не вызовет метод `notify()` или `notifyAll()` для этого объекта;
- `void wait(long timeout, int nanos)` — останавливает вызвавший метод поток на определённое время или пока другой поток не вызовет метод `notify()` или `notifyAll()` для этого объекта;
- `protected void finalize()` — может вызываться сборщиком мусора в момент удаления объекта при сборке мусора.
</details>

---

### Какие примитивы есть в Java?

<details>
 <summary><b>Показать ответ</b></summary>
- «Пустой» тип: `void`
- Логический (булевый) тип: `boolean` (1 бит)
- Целые числа:
  - `byte` (8 бит)
  - `short` (16 бит)
  - `int` (32 бита)
  - `long` (64 бита)
- Числа с плавающей запятой:
  - `float` (32 бита)
  - `double` (64 бита)
- Символы: `char` (16 бит)
</details>

---

### Какие существуют модификаторы доступа?

<details>
 <summary><b>Показать ответ</b></summary>
- `private` (приватный): члены класса доступны только внутри класса.
- `default`, `package-private`, `package level` (доступ на уровне пакета): видимость класса/членов класса только внутри пакета.
- `protected` (защищённый): члены класса доступны внутри пакета и в наследниках.
- `public` (публичный): класс/члены класса доступны всем.
- Последовательность модификаторов по возрастанию уровня закрытости: `public`, `protected`, `default`, `private`.
- Во время наследования возможно изменение модификаторов доступа в сторону большей видимости (для поддержания соответствия принципу подстановки Барбары Лисков).
</details>

---

### О чем говорит ключевое слово final?

<details>
 <summary><b>Показать ответ</b></summary>
Модификатор `final` может применяться к переменным, параметрам методов, полям, методам класса или самим классам:
1) Класс не может иметь наследников.
2) Метод не может быть переопределён в классах-наследниках.
3) Поле не может изменить своё значение после инициализации.
4) Параметры методов не могут изменять своё значение внутри метода.
5) Локальные переменные не могут быть изменены после присвоения им значения.
</details>

---

### Какими значениями инициализируются переменные по умолчанию?

<details>
 <summary><b>Показать ответ</b></summary>
1) Числа инициализируются `0` или `0.0`.
2) `char` — ``.
3) `boolean` — `false`.
4) Объекты (в том числе `String`) — `null`.
</details>

---

### Что вы знаете о функции main()?

<details>
 <summary><b>Показать ответ</b></summary>
Метод `main()` — точка входа в программу. В приложении может быть несколько таких методов. Если метод отсутствует, то компиляция возможна, но при запуске будет получена ошибка `Error: Main method not found`.  
Сигнатура: `public static void main(String[] args) {}`
</details>

---

### Какие логические операции и операторы вы знаете?

<details>
 <summary><b>Показать ответ</b></summary>
- `&`: Логическое AND (И)
- `&&`: Сокращённое AND
- `|`: Логическое OR (ИЛИ)
- `||`: Сокращённое OR
- `^`: Логическое XOR (исключающее OR (ИЛИ))
- `!`: Логическое унарное NOT (НЕ)
- `&=` : AND с присваиванием
- `|=` : OR с присваиванием
- `^=` : XOR с присваиванием
- `==` : Равно
- `!=` : Не равно
- `?:` : Тернарный (троичный) условный оператор
</details>

---

### Что такое тернарный оператор выбора?

<details>
 <summary><b>Показать ответ</b></summary>
Тернарный условный оператор `?:` — оператор, которым можно заменить некоторые конструкции операторов `if-then-else`.  
Выражение записывается в форме: `условие ? выражение1 : выражение2`.  
Если условие выполняется, вычисляется `выражение1`, иначе — `выражение2`. Оба выражения должны возвращать значения одинакового (или совместимого) типа.
</details>

---

### Какие побитовые операции вы знаете?

<details>
 <summary><b>Показать ответ</b></summary>
- `~`: Побитовый унарный NOT
- `&`: Побитовый AND
- `&=` : Побитовый AND с присваиванием
- `|`: Побитовый OR
- `|=` : Побитовый OR с присваиванием
- `^`: Побитовый исключающий XOR
- `^=` : Побитовый исключающий XOR с присваиванием
- `>>`: Сдвиг вправо (деление на 2 в степени сдвига)
- `>>=` : Сдвиг вправо с присваиванием
- `>>>`: Сдвиг вправо без учёта знака
- `>>>=` : Сдвиг вправо без учёта знака с присваиванием
- `<<`: Сдвиг влево (умножение на 2 в степени сдвига)
- `<<=` : Сдвиг влево с присваиванием
</details>

---

### Где и для чего используется модификатор abstract?

<details>
 <summary><b>Показать ответ</b></summary>
Класс, помеченный модификатором `abstract`, называется абстрактным классом. Такие классы могут выступать только предками для других классов, экземпляры самого абстрактного класса создавать нельзя.  
Метод, помеченный `abstract`, — абстрактный метод, не имеющий реализации. Если в классе есть хотя бы один абстрактный метод, класс должен быть объявлен абстрактным.  
Использование абстрактных классов и методов позволяет описать шаблон объекта, который должен быть реализован в других классах, описывая общее поведение для всех потомков.
</details>

---

### Приведите пример использования abstract?

<details>
 <summary><b>Показать ответ</b></summary>
В Spring Framework абстрактные классы часто используются для:
- Шаблонных сервисов (например, `AbstractController`, `AbstractService`).
- Реализации частичной логики (например, `JpaRepository` в Spring Data).
- Паттерна "Шаблонный метод" (Template Method Pattern).
</details>

---

### Дайте определение понятию «интерфейс». Какие модификаторы по умолчанию имеют поля и методы интерфейсов?

<details>
 <summary><b>Показать ответ</b></summary>
Ключевое слово `interface` используется для создания полностью абстрактных классов. Интерфейс определяет, каким образом можно использовать класс, реализующий его, задавая имена методов, списки аргументов и типы возвращаемых значений без реализации их поведения.  
- Все методы неявно объявляются как `public`.
- Начиная с Java 8, интерфейсы могут содержать методы с реализацией по умолчанию (`default`) и статические методы (`static`).
- Поля интерфейса автоматически являются `public`, `static` и `final`.
</details>

---

### Приведите пример использования интерфейса?

<details>
 <summary><b>Показать ответ</b></summary>
Интерфейсы используются для достижения гибкости, модульности и тестируемости кода. В Spring популярны следующие сценарии:
1. **Определение контрактов для сервисов**: Например, интерфейс `UserService` и его реализация `UserServiceImpl`. Позволяет легко заменять реализацию и упрощает тестирование с помощью мок-объектов.
2. **Работа с репозиториями (Spring Data)**: Интерфейсы, расширяющие `JpaRepository` или `CrudRepository`, для автоматической генерации реализаций.
3. **Внедрение зависимостей**: Использование интерфейсов для внедрения зависимостей через `@Autowired`, что снижает связанность кода.
</details>

---

### Чем абстрактный класс отличается от интерфейса? В каких случаях следует использовать абстрактный класс, а в каких интерфейс?

<details>
 <summary><b>Показать ответ</b></summary>
1) Класс может реализовать несколько интерфейсов, но наследоваться только от одного класса.
2) Абстрактные классы применяются для отношений «is a» (является), интерфейсы — для классов, не связанных между собой.
3) Абстрактный класс позволяет частично реализовать поведение, интерфейс описывает контракт возможностей.
4) Интерфейсы позволяют создавать структуры типов без иерархии.
5) Абстрактные классы применяются для построения иерархии схожих классов, интерфейсы — для расширения функциональности.  
**Когда использовать**:  
- Абстрактные классы — для частичной реализации и иерархии схожих классов.  
- Интерфейсы — для гибкости, модульности и независимости от иерархии.
</details>

---

### Почему в некоторых интерфейсах вообще не определяют методов?

<details>
 <summary><b>Показать ответ</b></summary>
Это маркерные интерфейсы, которые указывают, что класс относится к определённому типу. Например, интерфейс `Cloneable` обозначает, что класс поддерживает механизм клонирования.
</details>

---

### Почему нельзя объявить метод интерфейса с модификатором final?

<details>
 <summary><b>Показать ответ</b></summary>
Указание модификатора `final` бессмысленно, так как все методы интерфейсов неявно объявляются как `abstract` (или `default` с Java 8), и их невозможно выполнить без реализации в другом классе, что невозможно, если метод `final`.
</details>

---

### Что имеет более высокий уровень абстракции — класс, абстрактный класс или интерфейс?

<details>
 <summary><b>Показать ответ</b></summary>
Интерфейс.
</details>

---

### Может ли объект получить доступ к члену класса, объявленному как private? Если да, то каким образом?

<details>
 <summary><b>Показать ответ</b></summary>
1) Внутри класса доступ к приватной переменной открыт без ограничений.
2) Вложенный класс имеет полный доступ ко всем (в том числе приватным) членам содержащего класса.
3) Доступ к приватным переменным извне может быть организован через публичные методы (например, `getX()` и `setX()`).
4) Через механизм рефлексии (`Reflection API`):
```java
class Victim {
    private int field = 42;
}
Victim victim = new Victim();
Field field = Victim.class.getDeclaredField("field");
field.setAccessible(true);
int fieldValue = (int) field.get(victim);
```
</details>

---

### Каков порядок вызова конструкторов и блоков инициализации с учётом иерархии классов?

<details>
 <summary><b>Показать ответ</b></summary>
1) Статические блоки инициализации родительского класса (один раз при загрузке класса).
2) Статические блоки инициализации текущего класса.
3) Нестатические (экземплярные) блоки инициализации родительского класса.
4) Конструктор родительского класса.
5) Нестатические (экземплярные) блоки инициализации текущего класса.
6) Конструктор текущего класса.
</details>

---

### К каким конструкциям Java применим модификатор static?

<details>
 <summary><b>Показать ответ</b></summary>
- Полям
- Методам
- Вложенным классам
- Членам секции `import`
</details>

---

### Ключевое слово static

<details>
 <summary><b>Показать ответ</b></summary>
Модификатор `static` применяется к полю, блоку, методу или внутреннему классу, указывая на привязку к классу, а не к объекту.  
- Статические поля и методы принадлежат классу и доступны без создания экземпляра.
- Статические блоки инициализируют статические переменные.
- Статические методы могут обращаться только к статическим членам.
- Статический вложенный класс не содержит ссылку на экземпляр внешнего класса.
</details>

---

### Что произойдёт, если в блоке инициализации возникнет исключительная ситуация?

<details>
 <summary><b>Показать ответ</b></summary>
- Для нестатических блоков: если исключение указано явно, оно должно быть объявлено в `throws` всех конструкторов класса, иначе — ошибка компиляции.
- Для статических блоков: явное выбрасывание исключения приводит к ошибке компиляции.
- Если исключение возникает:
  - В статическом блоке: класс не инициализируется.
  - В нестатическом блоке: объект не создаётся.
</details>

---

### Какое исключение выбрасывается при возникновении ошибки в блоке инициализации класса?

<details>
 <summary><b>Показать ответ</b></summary>
- **Статический блок**: Исключение оборачивается в `ExceptionInInitializerError`. Класс становится непригодным для использования, последующие попытки вызова приводят к `NoClassDefFoundError`.
- **Нестатический блок**: Исключение передаётся без оборачивания, создание объекта прерывается, но класс остаётся пригодным.
- Если исключение — наследник `Error`, выбрасывается `java.lang.Error`. Исключение: `java.lang.ThreadDeath` не выбрасывается.
</details>

---

### Может ли статический метод быть переопределён или перегружен?

<details>
 <summary><b>Показать ответ</b></summary>
- **Перегружен**: Да, статические методы могут быть перегружены, как и обычные, если различаются количество или типы параметров.
- **Переопределён**: Нет, выбор статического метода происходит на этапе компиляции (раннее связывание), и вызывается родительский метод.  
Рекомендуется обращаться к статическим членам через имя класса, а не через объект.
</details>

---

### Могут ли нестатические методы перегрузить статические?

<details>
 <summary><b>Показать ответ</b></summary>
Да, нестатический метод может перегрузить статический. Это будут два разных метода: статический принадлежит классу, нестатический — объекту.
</details>

---

### Возможно ли при переопределении метода изменить: модификатор доступа, возвращаемый тип, тип аргумента или их количество, имена аргументов или их порядок; убирать, добавлять, изменять порядок следования элементов секции throws?

<details>
 <summary><b>Показать ответ</b></summary>
1) **Модификатор доступа**: Можно расширить (например, `protected` → `public`), нельзя сузить (например, `public` → `private`).
2) **Возвращаемый тип**: Можно оставить тот же тип или использовать ковариантный тип (наследник). Нельзя возвращать родительский или несвязанный тип.
3) **Тип аргументов, их количество и порядок**: Нельзя менять. Изменение означает перегрузку, а не переопределение. Можно менять имена аргументов.
4) **Исключения (`throws`)**: Можно не указывать исключения, добавлять подклассы исключений или `RuntimeException`. Нельзя добавлять новые проверяемые исключения или более общие исключения.
</details>

---

### Как получить доступ к переопределённым методам родительского класса?

<details>
 <summary><b>Показать ответ</b></summary>
С помощью ключевого слова `super`: `super.method();`. Это позволяет вызвать метод родительского класса, если он не `private`.
</details>

---

### Можно ли объявить метод абстрактным и статическим одновременно?

<details>
 <summary><b>Показать ответ</b></summary>
Нет, компилятор выдаст ошибку: "Illegal combination of modifiers: 'abstract' and 'static'".  
`abstract` требует реализации в подклассе, а `static` привязывает метод к классу.
</details>

---

### В чем разница между членом экземпляра класса и статическим членом класса?

<details>
 <summary><b>Показать ответ</b></summary>
- **Статические члены** (`static`): Принадлежат классу, инициализируются при загрузке класса, доступны без создания объекта. Могут обращаться только к статическим членам, не используют `this` или `super`.
- **Члены экземпляра**: Принадлежат объекту, создаются при создании экземпляра, имеют разные значения для каждого объекта.
</details>

---

### Где разрешена инициализация статических/нестатических полей?

<details>
 <summary><b>Показать ответ</b></summary>
- **Статические поля**: При объявлении, в статическом или нестатическом блоке инициализации.
- **Нестатические поля**: При объявлении, в нестатическом блоке инициализации или в конструкторе.
</details>

---

### Какие типы классов бывают в Java?

<details>
 <summary><b>Показать ответ</b></summary>
1) **По модификаторам доступа**:
   - `Public`: Доступен всем.
   - `Package-private`: Доступен в пакете.
2) **По вложенности**:
   - Top-Level, Static Nested, Inner, Local, Anonymous.
3) **По назначению**:
   - Concrete, Abstract, Final, Record, Enum, Singleton, Immutable, DTO, POJO, Utility.
4) **По ООП-роли**:
   - Superclass, Subclass, Interface, Functional Interface.
5) **По потокобезопасности**:
   - Thread-Safe, Non-Thread-Safe.
</details>

---

### Расскажите про вложенные классы. В каких случаях они применяются?

<details>
 <summary><b>Показать ответ</b></summary>
Вложенный класс — класс, определённый внутри другого класса, обслуживающий внешний класс.  
**Типы**:
- **Static Nested**: Статический, не связан с экземпляром внешнего класса.
- **Inner**: Нестатический, хранит ссылку на внешний объект.
- **Local**: Определён в методе/блоке.
- **Anonymous**: Безымянный, для одноразового использования.  
**Применение**:
- Для логической группировки.
- Когда класс нужен только внешнему классу.
- Для реализации коллбэков, итераторов, адаптеров.
</details>

---

### Что такое «статический класс»?

<details>
 <summary><b>Показать ответ</b></summary>
Статический класс — вложенный класс с модификатором `static`. Привязан к внешнему классу, не содержит ссылку на его экземпляр.  
**Применение**:
- Для вспомогательных классов (например, `Builder`, `Map.Entry`).
- Для избежания загрязнения пространства имён.
</details>

---

### Что такое «внутренний класс»? Где они применяются?

<details>
 <summary><b>Показать ответ</b></summary>
Внутренний класс — нестатический вложенный класс, хранящий ссылку на экземпляр внешнего класса (`Outer.this`).  
**Особенности**:
- Доступ к приватным полям внешнего класса.
- Создаётся через экземпляр внешнего класса.
- Не может содержать статические методы (кроме `static final` констант).  
**Применение**:
- Логическая группировка.
- Коллбэки, итераторы, адаптеры.
- Упрощение инкапсуляции.
</details>

---

### Какие существуют особенности использования вложенных классов: статических и внутренних? В чем заключается разница между ними?

<details>
 <summary><b>Показать ответ</b></summary>
- Вложенные классы имеют доступ ко всем членам внешнего класса.
- **Статические**: Не требуют экземпляра внешнего класса, не имеют ссылки на `Outer.this`, могут содержать статические члены.
- **Внутренние**: Хранят ссылку на экземпляр внешнего класса, не могут содержать статические методы (кроме `static final` констант).  
**Разница**: Статические классы независимы от экземпляра внешнего класса, внутренние — связаны с ним.
</details>

---

### Что такое «локальный класс»? Каковы его особенности?

<details>
 <summary><b>Показать ответ</b></summary>
Локальный класс — класс, объявленный внутри метода/блока.  
**Особенности**:
- Виден только в блоке, где объявлен.
- Не может быть `private`, `public`, `protected` или `static`.
- Имеет доступ к полям внешнего класса и локальным переменным (если они `final`).
- Не может содержать статические методы/классы (кроме `static final` констант).  
**Применение**: Для одноразовых реализаций или сложных алгоритмов.
</details>

---

### Что такое «анонимные классы»? Где они применяются?

<details>
 <summary><b>Показать ответ</b></summary>
Анонимный класс — локальный класс без имени, создаваемый одновременно с объявлением.  
**Применение**:
- Быстрая реализация интерфейсов с одним методом.
- Обработчики событий.
- Callback-механизмы.
- Одноразовые классы.  
**Ограничения**:
- Используется только в месте создания.
- Не может объявлять новые методы.
</details>

---

### Каким образом из вложенного класса получить доступ к полю внешнего класса?

<details>
 <summary><b>Показать ответ</b></summary>
- **Статический вложенный класс**: Доступ только к статическим полям внешнего класса.
- **Внутренний класс**: Прямой доступ к любым полям внешнего класса. Если имена совпадают, используется `Outer.this.field`.
</details>

---

### Для чего используется оператор assert?

<details>
 <summary><b>Показать ответ</b></summary>
Оператор `assert` проверяет предположения о значениях данных в программе. Если выражение `false`, выбрасывается `AssertionError`.  
**Синтаксис**:  
- `assert [boolean выражение];`  
- `assert [boolean выражение] : [сообщение];`  
**Применение**: Локализация ошибок во время разработки и тестирования. Отключается в релиз-версиях.
</details>

---

### Верно ли утверждение, что примитивные типы данных всегда хранятся в стеке, а экземпляры ссылочных типов данных в куче? Где хранятся примитивные типы в Java?

<details>
 <summary><b>Показать ответ</b></summary>
**Примитивы**:  
- В стеке: локальные переменные методов.  
- В куче: поля объектов, массивы, классы-обёртки.  
**Ссылочные типы**:  
- Объекты — в куче.  
- Ссылки — в стеке (локальные переменные) или куче (поля объектов).  
**Особенности**:  
- Escape-анализ может размещать объекты в стеке.  
- Строки хранятся в пуле строк.  
- Обёртки (`Integer`, `Double`) кэшируются для определённых значений.
</details>

---

### Каким образом передаются переменные в методы, по значению или по ссылке?

<details>
 <summary><b>Показать ответ</b></summary>
В Java параметры передаются **по значению** (копия значения).  
- Для примитивов: копия значения.  
- Для ссылок: копия ссылки, но сам объект можно изменить, а ссылку — нет.
</details>

---

### Что такое finalize()? Зачем он нужен?

<details>
 <summary><b>Показать ответ</b></summary>
Метод `finalize()` вызывается сборщиком мусора перед удалением объекта для выполнения очистки (например, закрытие соединений).  
**Проблемы**:  
- Вызов не гарантируется.  
- Может препятствовать освобождению памяти.  
- «Возрождение» объекта (антипаттерн).
</details>

---

### Что произойдёт со сборщиком мусора, если выполнение метода finalize() требует ощутимо много времени, или в процессе выполнения будет выброшено исключение?

<details>
 <summary><b>Показать ответ</b></summary>
- Если `finalize()` зависает, поток `Finalizer` блокируется, но сборщик мусора продолжает работать для объектов без `finalize()`.  
- Исключения в `finalize()` игнорируются, сборщик мусора продолжает работу.
</details>

---

### Чем отличаются final, finally и finalize()?

<details>
 <summary><b>Показать ответ</b></summary>
- **`final`**: Модификатор, запрещающий изменение классов, методов, полей или переменных.  
- **`finally`**: Блок, гарантирующий выполнение кода после `try-catch`, независимо от исключений.  
- **`finalize()`**: Метод, вызываемый сборщиком мусора перед удалением объекта.
</details>

---

### Расскажите про приведение типов. Что такое понижение и повышение типа?

<details>
 <summary><b>Показать ответ</b></summary>
**Приведение типов (casting)**: Преобразование значения одного типа в другой.  
- **Повышение (upcasting)**:  
  - Примитивы: от менее ёмкого к более ёмкому (`byte` → `int`). Автоматическое.  
  - Объекты: от потомка к предку (`Dog` → `Animal`). Автоматическое.  
- **Понижение (downcasting)**:  
  - Примитивы: от более ёмкого к менее ёмкому (`int` → `byte`). Явное, с риском потери данных.  
  - Объекты: от предка к потомку (`Animal` → `Dog`). Явное, может вызвать `ClassCastException`.  
**Проверка**: Используется `instanceof`.  
**Запрещённые преобразования**: Между несвязанными типами или от ссылочных к примитивным (кроме строк).
</details>

---

### Когда в приложении может быть выброшено исключение ClassCastException?

<details>
 <summary><b>Показать ответ</b></summary>
`ClassCastException` выбрасывается при ошибке приведения типов, когда объект не является экземпляром целевого типа (например, при некорректном downcasting).
</details>

---

### Что такое литералы?

<details>
 <summary><b>Показать ответ</b></summary>
Литерал — фиксированное значение в коде (например, `42`, `"Hello"`, `0b1101`). Представляет константы примитивных типов, строк или `null`.
</details>

---

### Что такое autoboxing («автоупаковка») в Java и каковы правила упаковки примитивных типов в классы-обёртки?

<details>
 <summary><b>Показать ответ</b></summary>
**Autoboxing**: Автоматическое преобразование примитива в класс-обёртку (`int` → `Integer`).  
**Unboxing**: Обратное преобразование (`Integer` → `int`).  
**Правила**:  
- Автоупаковка: при передаче примитива в метод, ожидающий обёртку, или при присваивании обёртке.  
- Распаковка: при использовании обёртки в контексте, где нужен примитив.  
**Особенности**:  
- Кэширование обёрток (`Integer.valueOf(127)`).  
- Риск `NullPointerException` при распаковке `null`.  
- Производительность: создание объектов в циклах может быть затратным.
</details>

---

### Как работает расширение и сужение типов при автоупаковке (Autoboxing) в Java?

<details>
 <summary><b>Показать ответ</b></summary>
- **Расширение (Widening + Autoboxing)**: Примитив расширяется (например, `byte` → `int`), затем упаковывается в обёртку (`int` → `Integer`). Автоматически.  
- **Сужение (Narrowing + Autoboxing)**: Требует явного приведения (например, `int` → `(short)` → `Short`).  
**Примеры**:  
- `short s = 100; Integer i = s;` — расширение + автоупаковка.  
- `int num = 100; Short s = (short) num;` — явное сужение + автоупаковка.  
**Особенности**: Сужение не происходит автоматически из-за риска потери данных.
</details>

---

### Дайте определение понятию «конструктор».

<details>
 <summary><b>Показать ответ</b></summary>
Конструктор — специальный метод без возвращаемого типа, с именем, совпадающим с именем класса. Вызывается при создании объекта для его инициализации.
</details>

---

### Что такое «конструктор по умолчанию»?

<details>
 <summary><b>Показать ответ</b></summary>
Конструктор по умолчанию — сгенерированный компилятором конструктор без аргументов, если в классе не определён ни один конструктор.  
Сигнатура: `public ClassName() {}`.  
Если конструктор уже есть, он не создаётся.
</details>

---

### Чем отличаются конструктор по умолчанию, конструктор копирования и конструктор с параметрами?

<details>
 <summary><b>Показать ответ</b></summary>
- **По умолчанию**: Без аргументов, создаётся компилятором, если нет других конструкторов.  
- **Копирования**: Принимает объект класса для создания его клона.  
- **С параметрами**: Имеет аргументы для инициализации полей класса.
</details>

---

### Где и как вы можете использовать приватный конструктор?

<details>
 <summary><b>Показать ответ</b></summary>
Приватный конструктор используется публичным статическим методом для создания объектов (например, в паттерне Singleton) или вложенными классами.
</details>

---

### Что такое Reflection?

<details>
 <summary><b>Показать ответ</b></summary>
Рефлексия — механизм получения данных о программе во время выполнения. Java Reflection API (`java.lang`, `java.lang.reflect`) позволяет:  
- Определять класс объекта.  
- Получать информацию о полях, методах, конструкторах, суперклассах.  
- Создавать экземпляры, вызывать методы, изменять поля.
</details>

---

### Зачем нужен equals(). Чем он отличается от операции ==?

<details>
 <summary><b>Показать ответ</b></summary>
- **`equals()`**: Сравнивает объекты по их содержимому (внутреннему состоянию).  
- **`==`**: Сравнивает ссылки на объекты (указывают ли на один объект).  
Переопределённый `equals()` позволяет сравнивать объекты по значениям полей.
</details>

---

### Какими свойствами обладает порождаемое equals() отношение эквивалентности?

<details>
 <summary><b>Показать ответ</b></summary>
- **Рефлексивность**: `x.equals(x)` возвращает `true`.  
- **Симметричность**: Если `x.equals(y)` = `true`, то `y.equals(x)` = `true`.  
- **Транзитивность**: Если `x.equals(y)` и `y.equals(z)` = `true`, то `x.equals(z)` = `true`.  
- **Непротиворечивость**: Многократный вызов `x.equals(y)` возвращает одинаковый результат, если данные не изменились.  
- `x.equals(null)` возвращает `false`.
</details>

---

### Правила переопределения метода Object.equals().

<details>
 <summary><b>Показать ответ</b></summary>
1) Проверка с помощью `==`: Если аргумент — та же ссылка, вернуть `true`. Если `null`, вернуть `false`.  
2) Проверка типа с `instanceof` или `getClass()`. Если тип неверный, вернуть `false`.  
3) Приведение аргумента к правильному типу.  
4) Сравнение значимых полей. Если все совпадают, вернуть `true`, иначе — `false`.  
5) Проверка свойств: рефлексивность, симметричность, транзитивность, непротиворечивость.
</details>

---

### Какая связь между hashCode() и equals()?

<details>
 <summary><b>Показать ответ</b></summary>
Равные объекты (`equals()`) должны возвращать одинаковый хэш-код (`hashCode()`). При переопределении `equals()` необходимо переопределять `hashCode()`.
</details>

---

### Что будет, если переопределить equals() не переопределяя hashCode()? Какие могут возникнуть проблемы?

<details>
 <summary><b>Показать ответ</b></summary>
Нарушится контракт `hashCode()`: равные объекты могут иметь разные хэш-коды, что приведёт к некорректной работе структур, таких как `HashMap` или `HashSet` (например, объект не будет найден по ключу).
</details>

---

### Каким образом реализованы методы equals() в классе Object?

<details>
 <summary><b>Показать ответ</b></summary>
В классе `Object` метод `equals()` проверяет равенство ссылок:  
```java
public boolean equals(Object obj) {
    return (this == obj);
}
```
</details>

---

### Каким образом реализованы методы hashCode() в классе Object?

В разных JVM реализации могут отличаться. Рассмотрим исходный код hashcode в OpenJDK.
Там 6(!) стратегий вычисления хэшкода. Стратегия задаётся опциями VM:
-XX:+UnlockExperimentalVMOptions -XX:hashCode={число}
При первом вызове хэш сохраняется внутри объекта и не меняется. Теперь к стратегиям:

🔸-XX:hashCode=0

Случайное число по алгоритму Lehmer RNG. Генератор один на всех, поэтому работает медленно

🔸-XX:hashCode=2

Чемпион по скорости, всегда возвращает 1:
java.lang.Object@1
Используется как отправная точка для тестов остальных стратегий

🔸-XX:hashCode=3

Обычная возрастающая последовательность:
java.lang.Object@a4
java.lang.Object@a5
java.lang.Object@a6

🔸-XX:hashCode=4

Текущий адрес в памяти. Популярный, но неправильный ответ на собеседованиях.
Отчасти в этом виновата спецификация: там адрес приводится как пример реализации.
Работает быстро, но не даёт равномерного распределения и должного уровня уникальности

🔸-XX:hashCode=1

Адрес объекта в памяти и немного манипуляций с битами

🔸 Стратегия по умолчанию

Случайное число по алгоритму Xorshift RNG.
Следующее значение вычисляется на основе предыдущего.
Значения равномерно распределены. Работает быстро, тк у каждого потока свой генератор, и синхронизации между потоками нет

--------------------------------------------------------------------------------------------------------------------

### Для чего нужен метод hashCode()?

<details>
 <summary><b>Показать ответ</b></summary>
Метод `hashCode()` возвращает целое число (хэш-код) для объекта, используемое в структурах данных, таких как `HashMap` и `HashSet`.  
- Если хэш-коды разные, объекты разные.  
- Если хэш-коды равны, объекты могут быть равны (требуется проверка `equals()`).  
- Хэш-код должен быть одинаковым для одного объекта при многократных вызовах.
</details>

---

### Каковы правила переопределения метода Object.hashCode()?

<details>
 <summary><b>Показать ответ</b></summary>
- Равные объекты (`equals()`) должны иметь одинаковый хэш-код.  
- Хэш-код должен быть равномерно распределён для лучшей производительности.  
- Хэш-код не должен меняться во время жизни объекта.  
- Используйте поля, участвующие в `equals()`, для вычисления.  
- Пример: комбинация значений полей с помощью XOR и битовых сдвигов.
</details>

---

### Могут ли у разных объектов быть одинаковые hashCode()?

<details>
 <summary><b>Показать ответ</b></summary>
Да, это называется коллизией. Хэш-код не гарантирует уникальность, но хороший алгоритм минимизирует вероятность коллизий.
</details>

---

### Если у класса Point{int x, y;} реализовать метод equals(Object that) {(return this.x == that.x && this.y == that.y)}, но сделать хэш код в виде int hashCode() {return x;}, то будут ли корректно такие точки помещаться и извлекаться из HashSet?

<details>
 <summary><b>Показать ответ</b></summary>
Объекты будут добавляться и извлекаться корректно, но производительность `HashSet` снизится, так как хэш-код зависит только от `x`, что приводит к вырождению хэш-таблицы в список при коллизиях.
</details>

---

### Могут ли у разных объектов (ref0 != ref1) быть ref0.equals(ref1) == true?

<details>
 <summary><b>Показать ответ</b></summary>
Да, если метод `equals()` переопределён для сравнения по содержимому, а не по ссылкам.
</details>

---

### Могут ли у разных ссылок на один объект (ref0 == ref1) быть ref0.equals(ref1) == false?

<details>
 <summary><b>Показать ответ</b></summary>
Могут, если метод `equals()` реализован некорректно и нарушает рефлексивность (`x.equals(x)` должно быть `true`).
</details>

---

### Можно ли так реализовать метод equals(Object that) {return this.hashCode() == that.hashCode()}?

<details>
 <summary><b>Показать ответ</b></summary>
Нельзя, так как `hashCode()` не гарантирует уникальность. Для класса `Object` допустимо, но в общем случае нарушает контракт `equals()`.
</details>

---

### В equals() требуется проверять, что аргумент equals(Object that) такого же типа что и сам объект. В чем разница между this.getClass() == that.getClass() и that instanceof MyClass?

<details>
 <summary><b>Показать ответ</b></summary>
- `this.getClass() == that.getClass()`: Проверяет точное совпадение классов.  
- `that instanceof MyClass`: Проверяет, является ли объект экземпляром класса или его подкласса.  
Для `equals()` предпочтительно использовать `getClass()` для строгого соответствия типа.
</details>

---

### Можно ли реализовать метод equals() класса MyClass вот так: class MyClass {public boolean equals(MyClass that) {return this == that;}}?

<details>
 <summary><b>Показать ответ</b></summary>
Можно, но это **перегрузка**, а не переопределение метода `equals(Object)`. Такой метод не будет использоваться в стандартных проверках эквивалентности.
</details>

---

### Есть класс Point{int x, y;}. Почему хэш код в виде 31 * x + y предпочтительнее чем x + y?

<details>
 <summary><b>Показать ответ</b></summary>
Множитель (например, `31`) улучшает распределение хэш-кодов, учитывая порядок полей, что снижает вероятность коллизий по сравнению с простым сложением `x + y`.
</details>

---

### Расскажите про клонирование объектов.

<details>
 <summary><b>Показать ответ</b></summary>
Клонирование создаёт новый объект с таким же состоянием.  
- **Механизм**: Метод `clone()` класса `Object` (protected, native). Класс должен реализовать `Cloneable` и переопределить `clone()` как `public`.  
- **Поверхностное**: Копируются примитивы, ссылки — нет.  
- **Глубокое**: Копируются все объекты, включая ссылочные типы.  
- **Альтернативы**: Конструктор копирования, фабричный метод, сериализация.  
- **Ограничения**: Без `Cloneable` выбрасывается `CloneNotSupportedException`. Конструктор не вызывается.
</details>

---

### В чем отличие между поверхностным и глубоким клонированием?

<details>
 <summary><b>Показать ответ</b></summary>
- **Поверхностное**: Копируются примитивы, ссылки указывают на те же объекты.  
- **Глубокое**: Копируются все объекты, включая ссылочные типы, создавая независимые копии.  
Глубокое требует реализации `Cloneable` для всех ссылочных полей.
</details>

---

### Какой способ клонирования предпочтительней?

<details>
 <summary><b>Показать ответ</b></summary>
Конструктор копирования:  
- Не зависит от наследования.  
- Явно указывает поля для копирования.  
- Поддерживает `final` поля.
</details>

---

### Почему метод clone() объявлен в классе Object, а не в интерфейсе Cloneable?

<details>
 <summary><b>Показать ответ</b></summary>
Метод `clone()` в `Object` обеспечивает стандартное поверхностное копирование. Он `protected` и `native`, а `Cloneable` — маркерный интерфейс, указывающий, что клонирование разрешено. Без `Cloneable` выбрасывается `CloneNotSupportedException`.
</details>

---

### Имеет ли смысл объявлять метод private final?

<details>
 <summary><b>Показать ответ</b></summary>
Нет, так как `private` метод недоступен для наследников, и `final` избыточен.
</details>

---

### В чём разница между intrinsic и native методами?

<details>
 <summary><b>Показать ответ</b></summary>
- **Native**: Реализованы на платформенном языке (например, C++). Пример: `Object.hashCode`.  
- **Intrinsic**: Выглядят как обычные Java-методы, но JVM заменяет их нативной реализацией для оптимизации. Пример: `String.equals`.  
С Java 9: аннотация `@HotSpotIntrinsicCandidate`.
</details>

---

### Что значит ключевое слово var?

<details>
 <summary><b>Показать ответ</b></summary>
Ключевое слово `var` (Java 10) позволяет не указывать тип локальной переменной, если он очевиден компилятору.  
Пример: `var i = 0;` эквивалентно `int i = 0;`.  
Ограничение: не работает с неоднозначными типами (например, generics без указания типа).
</details>

---

### Какие алгоритмы сортировки массивов используются в Java?

<details>
 <summary><b>Показать ответ</b></summary>
| Метод                 | Алгоритм               | Тип данных             | Устойчивость | Сложность          |
|-----------------------|------------------------|-----------------------|--------------|--------------------|
| `Arrays.sort()`       | Dual-Pivot Quicksort   | Примитивы            | Нет          | O(n log n) / O(n²) |
| `Arrays.sort()`       | TimSort                | Объекты              | Да           | O(n log n)         |
| `Collections.sort()`  | TimSort                | Коллекции            | Да           | O(n log n)         |
| `Arrays.parallelSort()` | Гибрид (Quicksort + Merge) | Примитивы/Объекты | Зависит      | O(n log n)         |
- `Insertion Sort` используется для малых массивов (n ≤ 47).
</details>

---

### Чем объект отличается от примитивных типов данных?

<details>
 <summary><b>Показать ответ</b></summary>
- **Память**: Примитивы занимают меньше памяти, объекты содержат множество значений.  
- **ООП**: Объекты поддерживают механизмы (конструкторы, методы, исключения), примитивы — нет.  
- **Обёртки**: Примитивы могут быть преобразованы в объекты через классы-обёртки (`Integer`, `Double`).
</details>

---

### Объекты каких стандартных классов immutable в Java?

<details>
 <summary><b>Показать ответ</b></summary>
`String`, `Integer`, `Byte`, `Character`, `Short`, `Boolean`, `Long`, `Double`, `Float`.
</details>

---

### Дайте краткую характеристику immutable object. Зачем они нужны?

<details>
 <summary><b>Показать ответ</b></summary>
**Immutable object**: Объект, состояние которого не меняется после создания.  
**Характеристики**:  
- Неизменяемость, потокобезопасность, простота.  
- Примеры: `String`, `Integer`.  
**Зачем нужны**:  
- Безопасность данных.  
- Упрощение многопоточности.  
- Поддержка хэширования и кэширования.  
- Упрощение отладки и функционального программирования.
</details>

---

### Как сделать immutable object?

<details>
 <summary><b>Показать ответ</b></summary>
1) Объявить класс `final`.  
2) Сделать поля `private` и `final`.  
3) Инициализировать поля в конструкторе.  
4) Не предоставлять методов, изменяющих состояние.  
5) Возвращать копии изменяемых полей.  
6) Реализовать корректные `hashCode()` и `equals()` для хэширования.
</details>
```