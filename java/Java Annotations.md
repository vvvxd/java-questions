## Оглавление

1. [Что такое аннотации в Java?](#1-что-такое-аннотации-в-java)
2. [Плюсы использования аннотаций](#2-плюсы-использования-аннотаций)
3. [Какие функции выполняют аннотации?](#3-какие-функции-выполняют-аннотации)
4. [Какие встроенные аннотации в Java?](#4-какие-встроенные-аннотации-в-java)
5. [Что делают аннотации @Retention, @Documented, @Target, @Inherited?](#5-что-делают-аннотации-retention-documented-target-inherited)
6. [Что делают аннотации @Override, @Deprecated, @SafeVarargs, @SuppressWarnings?](#6-что-делают-аннотации-override-deprecated-safevarargs-suppresswarnings)
7. [Какой жизненный цикл аннотации можно указать с помощью @Retention?](#7-какой-жизненный-цикл-аннотации-можно-указать-с-помощью-retention)
8. [Как аннотации встроены в язык Java?](#8-как-аннотации-встроены-в-язык-java)
9. [Как аннотации хранятся в байт-коде?](#9-как-аннотации-хранятся-в-байт-коде)
10. [Как происходит компиляция аннотаций?](#10-как-происходит-компиляция-аннотаций)
11. [Рефлексия и обработка аннотаций во время выполнения](#11-рефлексия-и-обработка-аннотаций-во-время-выполнения)
12. [Как работают повторяемые аннотации (Java 8+)?](#12-как-работают-повторяемые-аннотации-java-8)
13. [Как JVM обрабатывает встроенные аннотации?](#13-как-jvm-обрабатывает-встроенные-аннотации)
14. [Производительность и ограничения аннотаций](#14-производительность-и-ограничения-аннотаций)
15. [К каким элементам можно применять аннотацию?](#15-к-каким-элементам-можно-применять-аннотацию)
16. [Как создать свою аннотацию?](#16-как-создать-свою-аннотацию)
17. [Атрибуты каких типов допустимы в аннотациях?](#17-атрибуты-каких-типов-допустимы-в-аннотациях)
18. [Для чего нужна аннотация @FunctionalInterface?](#18-для-чего-нужна-аннотация-functionalinterface)

---

## 1. Что такое аннотации в Java?

Аннотации — это метатеги, добавляемые к элементам Java-кода (пакетам, классам, конструкторам, методам, полям, параметрам, локальным переменным). Они содержат дополнительную информацию, не изменяя логику программы, и выступают как модификаторы.

**Пример**:
```java
@Override
public String toString() {
    return "Example";
}
```

[Назад к оглавлению](#оглавление)

---

## 2. Плюсы использования аннотаций

- **Информация для компилятора**: Обнаружение ошибок и подавление предупреждений.
- **Читаемость кода**: Упрощают понимание кода для разработчиков.
- **Обработка на этапе компиляции/развертывания**: Генерация кода, XML и других файлов.
- **Обработка во время выполнения**: Проверка аннотаций для тестов или логики.
- **Уменьшение дублирования кода**.
- **Автоматизация бойлерплейт-кода**: Например, через Lombok.
- **Отлов ошибок на этапе компиляции**: Например, потенциальных `NullPointerException`.
- **Настройка поведения в рантайме**: На основе наличия аннотаций.

[Назад к оглавлению](#оглавление)

---

## 3. Какие функции выполняют аннотации?

- Предоставляют информацию компилятору.
- Используются инструментами для генерации кода или конфигураций.
- Применяются во время выполнения программы для дополнительной логики.

**Пример популярной аннотации**:
- `@Override` — указывает, что метод переопределяет метод суперкласса.

[Назад к оглавлению](#оглавление)

---

## 4. Какие встроенные аннотации в Java?

Java SE включает следующие встроенные аннотации:
- **Из пакета `java.lang.annotation`**:
    - `@Retention`
    - `@Documented`
    - `@Target`
    - `@Inherited`
- **Из пакета `java.lang`**:
    - `@Override`
    - `@Deprecated`
    - `@SafeVarargs`
    - `@SuppressWarnings`
    - `@FunctionalInterface` (с Java 8)

Эти аннотации широко используются для упрощения кода и снижения связанности.

[Назад к оглавлению](#оглавление)

---

## 5. Что делают аннотации @Retention, @Documented, @Target, @Inherited?

### 5.1. Аннотация @Retention

Указывает жизненный цикл аннотации. Принимает значение из перечисления `RetentionPolicy`:
- `SOURCE`: Только в исходном коде, удаляется при компиляции.
- `CLASS`: В байт-коде, но не доступна в рантайме (редко используется).
- `RUNTIME`: В байт-коде и доступна через рефлексию во время выполнения.

**Пример**:
```java
@Retention(RetentionPolicy.RUNTIME)
public @interface MyAnnotation {}
```

### 5.2. Аннотация @Documented

Маркер, указывающий, что аннотация должна включаться в Javadoc.

**Пример**:
```java
@Documented
public @interface MyAnnotation {}
```

### 5.3. Аннотация @Target

Ограничивает элементы, к которым применима аннотация, через `ElementType`:
- `PACKAGE`, `TYPE`, `CONSTRUCTOR`, `METHOD`, `FIELD`, `PARAMETER`, `LOCAL_VARIABLE`, и др.

**Пример**:
```java
@Target({ElementType.FIELD, ElementType.LOCAL_VARIABLE})
public @interface MyAnnotation {}
```

### 5.4. Аннотация @Inherited

Маркер, позволяющий аннотации класса наследоваться подклассами.

**Пример**:
```java
@Inherited
public @interface MyAnnotation {}
```

[Назад к оглавлению](#оглавление)

---

## 6. Что делают аннотации @Override, @Deprecated, @SafeVarargs, @SuppressWarnings?

### 6.1. Аннотация @Override

Маркер, указывающий, что метод переопределяет метод суперкласса или реализует метод интерфейса.

**Пример**:
```java
@Override
public String toString() {
    return "Example";
}
```

### 6.2. Аннотация @Deprecated

Помечает элемент как устаревший, рекомендуя использовать альтернативу. Вызывает предупреждения компилятора.

**Пример**:
```java
@Deprecated
public void oldMethod() {}
```

### 6.3. Аннотация @SafeVarargs

Подавляет предупреждения о небезопасных операциях с переменным количеством аргументов (`varargs`). Применяется к `static` или `final` методам/конструкторам.

**Пример**:
```java
@SafeVarargs
public static <T> void printStrings(T... items) {}
```

### 6.4. Аннотация @SuppressWarnings

Подавляет указанные предупреждения компилятора (например, `"unchecked"`, `"deprecation"`).

**Пример**:
```java
@SuppressWarnings("unchecked")
public void unsafeCast() {}
```

[Назад к оглавлению](#оглавление)

---

## 7. Какой жизненный цикл аннотации можно указать с помощью @Retention?

Аннотации имеют три политики удержания, задаваемые через `@Retention`:

| Политика            | Описание                                                                 |
|---------------------|--------------------------------------------------------------------------|
| `RetentionPolicy.SOURCE` | Существует только в исходном коде, удаляется при компиляции (например, `@Override`). |
| `RetentionPolicy.CLASS`  | Записывается в `.class`-файл, но не доступна в рантайме (редко используется). |
| `RetentionPolicy.RUNTIME` | Записывается в `.class`-файл и доступна через рефлексию во время выполнения. |

**Пример**:
```java
@Retention(RetentionPolicy.RUNTIME)
public @interface MyAnnotation {}
```

[Назад к оглавлению](#оглавление)

---

## 8. Как аннотации встроены в язык Java?

Аннотации — это синтаксический сахар, основанный на интерфейсах. Они реализуются через специальный интерфейс, расширяющий `java.lang.annotation.Annotation`.

**Пример аннотации**:
```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface MyAnnotation {
    String value() default "default";
    int priority() default 1;
}
```

**Внутренняя реализация**:
- Компилятор (`javac`) преобразует `@interface` в интерфейс, наследующий `Annotation`.
- Элементы аннотации (`value`, `priority`) становятся абстрактными методами.
- JVM создаёт прокси-класс для аннотации в рантайме (для `RUNTIME`), реализующий доступ к значениям через рефлексию.

[Назад к оглавлению](#оглавление)

---

## 9. Как аннотации хранятся в байт-коде?

Аннотации записываются в `.class`-файл как атрибуты байт-кода:
- `RuntimeVisibleAnnotations`: Для `RetentionPolicy.RUNTIME`.
- `RuntimeInvisibleAnnotations`: Для `RetentionPolicy.CLASS`.
- `RuntimeVisibleParameterAnnotations`/`RuntimeInvisibleParameterAnnotations`: Для аннотаций параметров.

**Пример структуры**:
```
RuntimeVisibleAnnotations:
  annotation: MyAnnotation
    element_value_pairs:
      value: "test"
      priority: 5
```

[Назад к оглавлению](#оглавлению)

---

## 10. Как происходит компиляция аннотаций?

**Процесс**:
1. **Парсинг**: Компилятор распознаёт аннотации и проверяет их `@Target`.
2. **Проверка типов**: Убеждается, что значения элементов соответствуют их типам.
3. **Генерация байт-кода**: Добавляет аннотации в `.class`-файл (для `CLASS` и `RUNTIME`).
4. **Обработка аннотаций**: Использует процессоры аннотаций (APT) для `SOURCE` или `CLASS`.

**Пример процессора**:
```java
@SupportedAnnotationTypes("com.example.MyAnnotation")
@SupportedSourceVersion(SourceVersion.RELEASE_17)
public class MyAnnotationProcessor extends AbstractProcessor {
    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        for (Element element : roundEnv.getElementsAnnotatedWith(MyAnnotation.class)) {
            processingEnv.getMessager().printMessage(
                Diagnostic.Kind.NOTE,
                "Found @MyAnnotation on " + element.getSimpleName()
            );
        }
        return true;
    }
}
```

[Назад к оглавлению](#оглавление)

---

## 11. Рефлексия и обработка аннотаций во время выполнения

Для аннотаций с `RetentionPolicy.RUNTIME` JVM загружает их в память, а API рефлексии (`java.lang.reflect`) позволяет их читать.

**Пример**:
```java
Method method = MyClass.class.getMethod("myMethod");
if (method.isAnnotationPresent(MyAnnotation.class)) {
    MyAnnotation ann = method.getAnnotation(MyAnnotation.class);
    System.out.println(ann.value());
}
```

**Внутренний процесс**:
- JVM парсит `RuntimeVisibleAnnotations` из байт-кода.
- Создаёт прокси-объект через `java.lang.reflect.Proxy`.
- Методы аннотации возвращают значения через `InvocationHandler`.

[Назад к оглавлению](#оглавление)

---

## 12. Как работают повторяемые аннотации (Java 8+)?

Повторяемые аннотации оборачиваются в контейнерную аннотацию, которая хранит массив повторяемых аннотаций.

**Пример**:
```java
@Repeatable(MyAnnotations.class)
public @interface MyAnnotation {
    String value();
}

public @interface MyAnnotations {
    MyAnnotation[] value();
}

@MyAnnotation("first")
@MyAnnotation("second")
public void myMethod() {}
```

**В байт-коде**:
```
RuntimeVisibleAnnotations:
  annotation: MyAnnotations
    element_value_pairs:
      value: [{value: "first"}, {value: "second"}]
```

[Назад к оглавлению](#оглавление)

---

## 13. Как JVM обрабатывает встроенные аннотации?

- **`@Override`**: Проверяет переопределение метода, ошибка компиляции при несоответствии.
- **`@Deprecated`**: Добавляет атрибут `Deprecated` в байт-код, вызывает предупреждения.
- **`@SuppressWarnings`**: Подавляет указанные предупреждения компилятора.
- **`@FunctionalInterface`**: Проверяет наличие одного абстрактного метода.
- **`@SafeVarargs`**: Подавляет предупреждения о varargs, проверяет `static`/`final`.

[Назад к оглавлению](#оглавление)

---

## 14. Производительность и ограничения аннотаций

- **Рефлексия**: Медленная из-за загрузки классов и создания прокси.
- **Размер байт-кода**: Аннотации увеличивают `.class`-файлы.
- **Ограничения типов**: Поддерживаются только примитивы, `String`, `Class`, `enum`, аннотации и их одномерные массивы.
- **Потокобезопасность**: Прокси-объекты аннотаций неизменяемы и безопасны.

[Назад к оглавлению](#оглавление)

---

## 15. К каким элементам можно применять аннотацию?

Аннотация `@Target` ограничивает применимость аннотации:

| ElementType          | Описание                     |
|----------------------|------------------------------|
| `PACKAGE`            | Пакеты                      |
| `TYPE`               | Классы, интерфейсы, enum    |
| `CONSTRUCTOR`        | Конструкторы                |
| `METHOD`             | Методы                      |
| `FIELD`              | Поля класса                 |
| `PARAMETER`          | Параметры методов           |
| `LOCAL_VARIABLE`     | Локальные переменные        |

**Пример**:
```java
@Target({ElementType.PARAMETER, ElementType.LOCAL_VARIABLE})
public @interface MyAnnotation {}
```

[Назад к оглавлению](#оглавление)

---

## 16. Как создать свою аннотацию?

Создание аннотации использует ключевое слово `@interface`.

**Пример**:
```java
public @interface About {
    String info() default "";
}
```

**Особенности**:
- `@interface` заменяет `class` или `interface`.
- Элементы аннотации — это методы с возвращаемыми значениями.
- `default` задаёт значение по умолчанию.

[Назад к оглавлению](#оглавление)

---

## 17. Атрибуты каких типов допустимы в аннотациях?

Допустимые типы атрибутов:
- Примитивы (`int`, `boolean`, и т.д.)
- `String`
- `Class` (или его параметризованные формы)
- Перечисления (`enum`)
- Аннотации
- Одномерные массивы вышеуказанных типов

**Пример**:
```java
public @interface MyAnnotation {
    String name();
    int[] priorities();
    Class<?> type();
}
```

[Назад к оглавлению](#оглавление)

---

## 18. Для чего нужна аннотация @FunctionalInterface?

Аннотация `@FunctionalInterface` указывает, что интерфейс предназначен для лямбда-выражений и должен содержать ровно один абстрактный метод.

**Пример**:
```java
@FunctionalInterface
interface Print {
    void printString(String testString);
}
```

**Особенности**:
- Вызывает ошибку компиляции, если в интерфейсе более одного абстрактного метода.
- Защищает от случайного добавления методов в других модулях.
- Необязательна, но рекомендуется для ясности.

[Назад к оглавлению](#оглавление)