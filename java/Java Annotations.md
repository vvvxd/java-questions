Что такое Аннотации в Java?

Аннотации - это своего рода метатеги, которые добавляются к коду и применяются к объявлению пакетов, классов, конструкторов, методов, полей, параметров и локальных переменных. Аннотации всегда обладают некоторой информацией и связывают эти "дополнительные данные" и все перечисленные конструкции языка.Фактически аннотации представляют собой их дополнительные модификаторы, применение которых не влечет за собой изменений ранее созданного кода.

--------------------------------------------------------------------------------------------------------------------
Плюсы использования аннотаций

Информация для компилятора. Компилятор может использовать аннотации для обнаружения ошибок или подавления предупреждений.

Информация для разработчика. Когда кто-то просматривает код, аннотации помогают сделать его читабельным и более легким для понимания.

Обработка времени компиляции и развертывания. Программные средства могут обрабатывать аннотации для создания кода, XML-файлов и т.д.

Обработка во время выполнения. Аннотации могут проверяться во время выполнения для прохождения тестов.

Уменьшение дублирования кода.

Автоматизация генерации бойлерплейт кода.

Отлов ошибок во время компиляции, например, потенциальные Null Pointer Exception.

Настройка поведения в рантайме на основе наличия аннотации.

--------------------------------------------------------------------------------------------------------------------
Какие функции выполняет Аннотации?

Аннотация выполняет следующие функции:дает необходимую информацию для компилятора;дает информацию различным инструментам для генерации другого кода, конфигураций и т. д.;может использоваться во время работы кода;Самая часто встречаемая аннотация, которую встречал любой программист, даже начинающий это @Override.

--------------------------------------------------------------------------------------------------------------------
Какие встроенные аннотации в Java вы знаете?

В языке Java SE определено несколько встроенных аннотаций, большинство из их являются специализированными.
Четыре типа @Retention, @Documented, @Target и @Inherited - из пакета java.lang.annotation.
Из оставшиеся выделяются - @Override, @Deprecated, @SafeVarargs и @SuppressWarnings - из пакета java.lang. Широкое использование аннотаций в различных технологиях и фреймворках обуславливается возможностью сокращения кода и снижения его связанности.

--------------------------------------------------------------------------------------------------------------------
Что делают аннотации @Retention, @Documented, @Target и @Inherited?

Эти аннотации, имеют следующее значение:
@Retention - эта аннотация предназначена для применения только в качестве аннотации к другим аннотациям, позволяет указать жизненный цикл аннотации: будет она присутствовать только в исходном коде, в скомпилированном файле, или она будет также видна и в процессе выполнения. Выбор нужного типа зависит от того, как вы хотите использовать аннотацию.
@Documented - это маркер-интерфейс, который сообщает инструменту, что аннотация должна быть документирована.
@Target - эта аннотация задает тип объявления, к которым может быть применима аннотация. Принимает один аргумент, который должен быть константой из перечисления ElementType, это может быть поле, метод, тип и т.д. Например, чтобы указать, что аннотация применима только к полям и локальным переменным:
@Targer({ ElementType.FIELD, ElementTyle.LOCAL_VARIABLE } )
@Inherited - это аннотация-маркер, которая может применяться в другом объявление аннотации, она касается только тех аннотаций, что будут использованы в объявлениях классов. Эта аннотация позволяет аннотации супер класса быть унаследованной в подклассе.

--------------------------------------------------------------------------------------------------------------------
Что делают аннотации @Override, @Deprecated, @SafeVarargs и @SuppressWarnings?

Эти аннотации предназначены для:

@Override - аннотация-маркер, которая может применяться только к методам. Метод, аннотированный как @Override, должен переопределять метод супер класса.

@Deprecated - указывает, что объявление устарело и должно быть заменено более новой формой.

@SafeVarargs - аннотация-маркер, применяется к методам и конструкторам. Функциональность varargs позволяет создавать методы с переменным количеством аргументов. До Java 5 единственной возможностью создания методов с необязательными параметрами было создание нескольких методов, каждый из которых с разным количеством параметров. Varargs позволяет создать один метод с переменным количеством параметров с помощью следующего синтаксиса:
void printStrings(String... stringList)
Она указывает, что никакие небезопасные действия, связанные с параметром переменного количества аргументов, недопустимы. Применяется только к методам и конструкторам с переменным количеством аргументов, которые объявлены как static или final.

@SuppressWarnings - эта аннотация указывает, что одно или более предупреждений, которые могут быть выданы компилятором следует подавить.

--------------------------------------------------------------------------------------------------------------------
Какой жизненный цикл аннотации можно указать с помощью @Retention?

Существует 3 возможные варианты чтобы указать где аннотация будет жить. Они инкапсулированы в перечисление java.lang.annotation.RetentionPolicy. Это SOURSE, CLASS, RUNTIME.
SOURCE - содержаться только в исходном файле и отбрасываются при компиляции.
CLASS - сохраняются в файле, однако они недоступны JVM во время выполнения.
RUNTIME - сохраняются в файле во время компиляции и остаются доступными JVM во время выполнения.

--------------------------------------------------------------------------------------------------------------------
К каким элементам можно применять аннотацию, как это указать?

Для того чтобы ограничить использование аннотации её нужно проаннотировать. Для этого существует аннотация

@Target.@Target(ElementType.PACKAGE) - только для пакетов;
@Target(ElementType.TYPE) - только для классов;
@Target(ElementType.CONSTRUCTOR) - только для конструкторов;
@Target(ElementType.METHOD) - только для методов;
@Target(ElementType.FIELD) - только для атрибутов(переменных) класса;
@Target(ElementType.PARAMATER) - только для параметров метода;
@Target(ElementType.LOCAL_VARIABLE) - только для локальных переменных.

В случае если вы хотите, что бы ваша аннотация использовалась больше чем для одного типа параметров, то можно указать @Target следующим образом:
@Target({ ElementType. PARAMETER, ElementType. LOCAL_VARIABLE
тут мы говорим, аннотацию можно использовать только для параметров метода и для локальных переменных.

--------------------------------------------------------------------------------------------------------------------
Как создать свою Аннотацию?

Написать свою аннотацию не так сложно, как могло бы казаться. В следующем коде приведено объявление аннотации.

public @interface About{String info() default}

как вы видите на месте где обычно пишут class или interface у нас написано @interface.Структура практически та же, что и у интерфейсов, только пишется @interface.
@interface - указывает на то, что это аннотация
default - говорит про то, что метод по умолчанию будет возвращать определённое значение.
Аннотация готова теперь ею можно пользоваться, также аннотацию можно сконфигурировать.

--------------------------------------------------------------------------------------------------------------------
Атрибуты каких типов допустимы в аннотациях?

Атрибуты могут иметь только следующие типы:
String
Class или «any parameterized invocation of Class»
enum
annotation
массив элементов любого из вышеперечисленных типов
Последний пункт надо понимать как то, что допустимы только одномерные массивы.

--------------------------------------------------------------------------------------------------------------------
Для чего нужно аннотация @FunctionalInterface

Аннотация @FunctionalInterface используется для указания того, что в интерфейсе не может быть более одного абстрактного метода. Если абстрактных методов будет больше одного, то компилятор выдаст ошибку. Функциональные интерфейсы появились в Java 8 для реализации лямбда-выражений и гарантии того, что в них не более одного абстрактного метода.

Но и без аннотации @FunctionalInterface компилятор выдаст ошибку, если вы включите в интерфейс больше одного абстрактного метода. Так зачем же нужна необязательная аннотация @FunctionalInterface?
Давайте рассмотрим следующий пример:

@FunctionalInterface
interface Print {
void printString(String testString);
}

Если в интерфейс Print мы добавим еще один метод printString2(), то компилятор или IDE выдаст ошибку.

А что, если интерфейс Print находится в отдельном модуле и без аннотации @FunctionalInterface? Разработчики этого модуля могут легко добавить в интерфейс еще один метод и сломать ваш код. Добавив аннотацию @FunctionalInterface, мы сразу получим предупреждение в IDE:

Multiple non-overriding abstract methods found in interface com.reflectoring.Print

Поэтому рекомендуется всегда использовать аннотацию @FunctionalInterface, если интерфейс должен использоваться в качестве лямбды.

--------------------------------------------------------------------------------------------------------------------