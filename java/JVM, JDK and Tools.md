Frames

Frame используется для хранения данных и частичных результатов, а также для выполнения динамического связывания, возврата значений для методов и отправки исключений. Новый frame создается каждый раз, когда вызывается метод. Frame уничтожается, когда завершается вызов метода, является ли это завершение нормальным или резким (он генерирует неперехваченное исключение). Frames выделяются из стека потока, создающего frame. Каждый frame имеет свой собственный массив локальных переменных, свой собственный стек операндов и ссылку на пул констант во время выполнения класса текущего метода. Размеры массива локальных переменных и стека операндов определяются во время компиляции и предоставляются вместе с кодом для метода, связанного с фреймом. Таким образом, размер структуры данных, frame-а зависит только от реализации виртуальной машины Java, и память для этих структур может быть выделена одновременно при вызове метода.
Только один frame активен в любой точке данного потока управления - метода выполнения, и это frame называется текущим, а его метод известен как текущий метод. Класс, в котором определен текущий метод, является текущим классом. Операции над локальными переменными и стеком операндов обычно выполняются со ссылкой на текущий frame.
Frame перестает быть текущим, если его метод вызывает другой метод или если его метод завершается. Когда метод вызывается, новый frame создается и становится текущим, когда управление переходит к новому методу. При возврате метода текущий frame передает результат вызова метода, если таковой имеется, в предыдущий frame. Текущий frame затем отбрасывается, так как предыдущий frame становится текущим. Обратите внимание, что frame, созданный потоком, является локальным для этого потока и на него не может ссылаться ни один другой поток.
Локальные переменные
Каждый frame содержит массив переменных, известных как его локальные переменные. Длина массива локальных переменных frame определяется во время компиляции и предоставляется в двоичном представлении класса или интерфейса вместе с кодом для метода, связанного с frame-ом. Единичная локальная переменная может хранить значение типа: boolean, byte, char, short, int, float, reference, or returnAddress. Пара локальных переменных может хранить значение типов: long или double.
Локальные переменные адресуются путем индексации. Индекс первой локальной переменной равен нулю.
Значение типа long или типа double занимает две последовательные локальные переменные.
JVM использует локальные переменные для передачи параметров при вызове метода. При вызове метода класса все параметры передаются в последовательных локальных переменных, начиная с локальной переменной 0. При вызове метода экземпляра локальная переменная 0 всегда используется для передачи ссылки на объект, для которого вызывается метод экземпляра (this в Java). Любые параметры впоследствии передаются в последовательных локальных переменных, начиная с локальной переменной 1.

Стеки операндов (Operand Stacks)
Каждый frame содержит стек «последний вошел - первый вышел» (LIFO), известный как стек операндов. Максимальная глубина стека операндов frame-a определяется во время компиляции и предоставляется вместе с кодом для метода, связанного с frame-ом.
Стек операнда пуст при создании frame-a, который его содержит. JVM предоставляет инструкции для загрузки констант или значений из локальных переменных или полей в стек операндов. Другие инструкции JVM берут операнды из стека операндов, оперируют с ними и помещают результат обратно в стек операндов. Стек операндов также используется для подготовки параметров для передачи в методы и для получения результатов метода.
Для примера, инструкция iadd суммирует два int-вых значения. От стека операндов требуется, чтобы два int-вых значения были наверху стека. Значения удаляются из стека, операция pop. Суммируются и их сумма помещается в стек операндов.

Динамическое связывание (Dynamic Linking)
Каждый frame содержит ссылку на run-time constant pool для типа текущего метода для поддержки динамического связывания кода метода. Доступ к вызываемым методам и переменным осуществляется через символические ссылки из class файла. Динамическое связывание преобразует эти символьные ссылки на методы в конкретные ссылки на методы, загружая классы по мере необходимости для разрешения пока еще не определенных символов, и преобразует обращения к переменным в соответствующие смещения в структурах хранения, связанных с расположением этих переменных во время выполнения.
Позднее связывание методов и переменных вносит изменения в другие классы, которые метод использует с меньшей вероятностью нарушить этот код.
Нормальное завершение вызова метода
Вызов метода завершается нормально, если этот вызов не вызывает исключение, либо непосредственно из JVM, либо в результате выполнения явного оператора throw. Если вызов текущего метода завершается нормально, то значение может быть возвращено вызывающему методу. Это происходит, когда вызванный метод выполняет одну из инструкций возврата, выбор которых должен соответствовать типу возвращаемого значения (если оно есть).
Текущий frame используется в этом случае для восстановления состояния инициатора, включая его локальные переменные и стек операндов, с соответствующим образом увеличенным программным счетчиком инициатора, чтобы пропустить инструкцию вызова метода. Затем выполнение обычно продолжается в frame вызывающего метода с возвращенным значением (если оно есть), помещаемым в стек операндов этого frame.
Резкое завершение вызова метода
Вызов метода завершается преждевременно, если при выполнении инструкции JVM в методе выдает исключение, и это исключение не обрабатывается в методе. Выполнение команды throw также приводит к явному выбрасыванию исключения, и, если исключение не перехватывается текущим методом, приводит к неожиданному завершению вызова метода. Вызов метода, который завершается внезапно, никогда не возвращает значение своему вызывающему.

--------------------------------------------------------------------------------------------------------------------
Чем различаются JRE, JVM и JDK?

JVM, Java Virtual Machine (Виртуальная машина Java) — основная часть среды времени исполнения Java (JRE). Виртуальная машина Java исполняет байт-код Java, предварительно созданный из исходного текста Java-программы компилятором Java. JVM может также использоваться для выполнения программ, написанных на других языках программирования.
JRE, Java Runtime Environment (Среда времени выполнения Java) - минимально-необходимая реализация виртуальной машины для исполнения Java-приложений. Состоит из JVM и стандартного набора библиотек классов Java.
JDK, Java Development Kit (Комплект разработки на Java) - JRE и набор инструментов разработчика приложений на языке Java, включающий в себя компилятор Java, стандартные библиотеки классов Java, примеры, документацию, различные утилиты.
Коротко: JDK - среда для разработки программ на Java, включающая в себя JRE - среду для обеспечения запуска Java программ, которая в свою очередь содержит JVM - интерпретатор кода Java программ.

--------------------------------------------------------------------------------------------------------------------
За что отвечает JVM:

Загрузка, проверка и исполнение байт кода;
Предоставление среды выполнения для выполнения байт-кода;
Управление памятью и очисткой мусора (Garbage collection);
Виртуальная машина Java (Java Virtual Machine) - это механизм, предоставляющий среду выполнения для управления Java-кодом или приложениями. Виртуальная машина является независимой оболочкой исполнения кода, благодаря которой возможен её запуск на любой ОС, без влияния ОС на выполняемую программу.
JVM работает с 2мя типами данных: примитивные типы (primitive types) и ссылочные типы (reference types).
Примитивы
JVM работает с примитивными значениями (целыми числами и числами с плавающей точкой). По сути, JVM - это 32-битная машина. Типы long и double, которые являютсяterm-6 64-битными, поддерживаются изначально, но занимают две единицы памяти в frame's local или стеке операндов, поскольку каждая единица составляет 32 бита. Типы boolean, byte, short и char имеют расширенный знак (кроме char с нулевым расширением) и работают как 32-разрядные целые числа, так же, как и типы int. Меньшие типы имеют только несколько специфических для типа инструкций для загрузки, хранения и преобразования типов. boolean значение работает как 8-битное byte значения, где 0 представляет значение false, а 1 - значение true.
Типы ссылок и значения
Существует три типа ссылочных типов: типы классов, типы массивов и типы интерфейсов. Их значения являются ссылками на динамически создаваемые экземпляры классов, массивы или экземпляры классов, которые реализуют интерфейсы соответственно.

--------------------------------------------------------------------------------------------------------------------
Что такое JIT?

JIT Compiler в Java - это одна из составных частей Java Runtime Environment. Он в основном отвечает за оптимизацию производительности приложений во время выполнения. В общем, главный девиз компилятора - повышение производительности приложения для конечного пользователя и разработчика приложения.

Нюансы
Байт-код - это главный потенциал Java-среды WORA (пиши один раз, беги куда угодно). Скорость приложения зависит от способа преобразования байтового кода в машинный код. Байт-код может быть либо интерпретирован, либо скомпилирован в собственный код, либо непосредственно выполнен на процессоре. Но, если он интерпретируется, это напрямую влияет на скорость приложения.

Для повышения производительности, JIT-компилятор связывается с JVM во время выполнения, чтобы скомпилировать последовательности байт-кода в собственный машинный код. По сути, при использовании JIT Compiler нативный код легко исполняется аппаратными средствами по сравнению с JVM Interpreter. Таким образом, скорость выполнения будет значительно увеличена.

Когда JIT-компилятор компилирует последовательность байтового кода, он также выполняет определенную оптимизацию, такие как анализ данных, перевод из стековых операций в операции регистрации, устранение подвыражений и т. д. Это делает Java очень эффективной, когда речь идет о выполнении и производительности.
Источник: https://java-blog.ru/osnovy/jit-kompilyatsiya-java

--------------------------------------------------------------------------------------------------------------------
Just-In-Time компиляции

Механизм Just-In-Time компиляции заключается в следующем: если в программе присутствуют части кода, которые выполняются много раз, то их можно скомпилировать один раз в машинный код, чтобы в будущем ускорить их выполнение. После компиляции такой части программы в машинный код, при каждом следующем вызове этой части программы виртуальная машина будет сразу выполнять скомпилированный машинный код, а не интерпретировать его, что естественно ускорит выполнение программы.

Ускорение работы программы достигается за счет увеличения потребления памяти (где-то же нам нужно хранить скомпилированный машинный код!) и за счет увеличения временных затрат на компиляцию во время исполнения программы.

JIT компиляция — довольно сложный механизм, поэтому пройдемся по верхам. Всего существует 4 уровня JIT компиляции байт-кода в машинный код. Чем выше уровень компиляции, тем он сложнее, но и одновременно выполнение такого участка будет быстрее, чем участка с меньшим уровнем.

JIT — компилятор самостоятельно решает, какой уровень компиляции задать для каждого фрагмента программы на основе того, как часто выполняется этот фрагмент. Под капотом JVM использует 2 JIT-компилятора — C1 и C2. C1 компилятор так же называется клиентским компилятором и способен скомпилировать код только до 3-его уровня. За 4-ый, самый сложны и быстрый уровень компиляции отвечает компилятор C2.

Из вышесказанного можно сделать вывод о том, что для простых, клиентских приложений, выгоднее использовать компилятор C1, так как в этом случае нам важно как быстро стартует приложение. Серверные, долгоживущие приложения могут стартовать большее количество времени, однако в дальнейшем должны работать и выполнять свою функцию быстро — тут нам подойдет компилятор C2. При запуске Java — программы на x32 версии JVM мы в ручную можем указать, какой режим мы хотим использовать, при помощи флагов -client и -server.

При указании флага -client JVM не будет производить сложные оптимизации с байт-кодом, что ускорит время старта приложения и уменьшит количество потребляемой памяти. При указании флага -server приложение будет стартовать большее количество времени из-за сложных оптимизаций байт-кода и будет использовать больше памяти для хранения машинного кода, однако в дальнейшем работать такая программа будет быстрее. В x64 версии JVM флаг -client игнорируется и по умолчанию используется серверная конфигурация приложения.

--------------------------------------------------------------------------------------------------------------------
Принцип работы JIT

JIT или динамический компилятор ускоряет производительность приложений во время выполнения. Поскольку Java программа состоит из классов и объектов. По сути, представляет собой байт-код, который не зависит от платформы и выполняется JVM в различных архитектурах.

Когда вы кодируете Java-программу, JRE использует компилятор javac для компиляции исходного кода высокого уровня в байт-код. После этого JVM загружает байт-код во время выполнения и преобразует его в двоичный код машинного уровня для дальнейшего выполнения с использованием Interpreter.

Интерпретация байтового кода Java снижает производительность по сравнению с нативным приложением. Именно здесь JIT-компилятор помогает повысить производительность, компилируя байт-код в машинный код «точно в срок» для запуска.

JIT-компилятор активируется и включается по умолчанию, когда метод вызывается. Когда метод компилируется, виртуальная машина вызывает скомпилированный код метода напрямую, не интерпретируя его. Следовательно, не требует большого использования памяти и процессорного времени. Это в основном ускоряет производительность приложения.

--------------------------------------------------------------------------------------------------------------------
Аспекты безопасности JIT

Компиляция байтового кода в машинный код JIT-компилятором осуществляется непосредственно в памяти. т.е. компилятор передает машинный код непосредственно в память и выполняет его. В этом случае он не сохраняет машинный код на диске перед вызовом файла класса и его выполнением.
По сути, память должна быть помечена как исполняемая. В целях безопасности это должно быть выполнено после записи кода в память. Он также должен быть помечен как доступный только для чтения, поскольку исполняемая память является дырой в безопасности.

--------------------------------------------------------------------------------------------------------------------
Плюсы и минусы JIT в Java

Плюсы:
Код Java, который вы написали много лет назад, будет работать быстрее даже сегодня, что повышает производительность программ Java.
Собственные образы также выполняются быстрее, так как они не имеют начальных действий и требуют меньше памяти.

Минусы:
Увеличивает сложность программ Java.
Программы с меньшим количеством кода не получают преимущества при использовании Just-In-Time компиляции.
Источник: https://java-blog.ru/osnovy/jit-kompilyatsiya-java

--------------------------------------------------------------------------------------------------------------------
C каких типов памяти состоит JVM?

Stack - место под примитивы и ссылки на объекты (но не сами объекты). Хранит локальные переменные и возвращаемые значения функций. Здесь же хранятся ссылки на объекты пока те конструируются. Все данные в стеке - GC roots. Освобождается сразу на выходе из функции. Принадлежит потоку, размер по-умолчанию указывается параметром виртуальной машины -Xss, но при создании потока программно можно указать отличное значение.

PermGen - В этой области хранятся загруженные классы (экземпляры класса Class<T>). Здесь же с Java 7 хранится пул строк. Изначально размера -XX:PermSize, растет динамически до -XX:MaxPermSize. Не считается частью кучи.

Metaspace - с Java 8 заменяет permanent generation. Отличие в том, что по умолчанию metaspace ограничен только размерами доступной на машине памяти, но так же как PermGen может быть ограничен, параметром -XX:MaxMetaspaceSize.

Heap - куча, вся managed-память, в которой хранятся все пользовательские объекты. Все следующие разделы - части кучи. Параметры -Xms, -Xmn и -Xmx устанавливают начальный, минимальный и максимальный размеры хипа соответственно.

Eden, New Generation, Old Generation и другие - специфичные для сборщика мусора части кучи, поколения. Могут быть разные, но общий подход сохраняется: долго живущий объект постепенно двигается во всё более старое поколение; сборка мусора в разных поколениях происходит раздельно; чем поколение старше, тем сборка в нём реже, но и дороже.

--------------------------------------------------------------------------------------------------------------------
Куча (heap)

Здесь JVM хранит объекты и динамические данные. Это самая крупная область памяти, в ней работает сборщик мусора. Размером кучи можно управлять с помощью флагов Xms (начальный размер) и Xmx (максимальный размер). Куча не передаётся виртуальной машине целиком, какая-то часть резервируется в качестве виртуального пространства, за счёт которого куча может в будущем расти. Куча делится на пространства «молодого» и «старого» поколения.

Молодое поколение, или «новое пространство»: область, в которой живут новые объекты. Она делится на «рай» (Eden Space) и «область выживших» (Survivor Space). Областью молодого поколения управляет «младший сборщик мусора» (Minor GC), который также называют «молодым» (Young GC).

Рай: здесь выделяется память, когда мы создаём новые объекты.Область выживших: здесь хранятся объекты, которые остались после работы младшего сборщика мусора.

Область делится на две половины, S0 и S1.

Старое поколение, или «хранилище» (Tenured Space): сюда попадают объекты, которые достигли максимального порога хранения в ходе жизни младшего сборщика мусора. Этим пространством управляет «старший сборщик» (Major GC).

--------------------------------------------------------------------------------------------------------------------
Стеки потоков исполнения

Это стековая область, в которой на один поток выделяется один стек. Здесь хранятся специфические для потоков статичные данные, в том числе фреймы методов и функций, указатели на объекты. Размер стековой памяти можно задать с помощью флага Xss

--------------------------------------------------------------------------------------------------------------------
Кеш кода

Здесь компилятор Just In Time (JIT) хранит скомпилированные блоки кода, к которым приходится часто обращаться. Обычно JVM интерпретирует байткод в нативный машинный код, однако код, скомпилированный JIT-компилятором, не нужно интерпретировать, он уже представлен в нативном формате и закеширован в этой области памяти.

--------------------------------------------------------------------------------------------------------------------
Метапространство

Это часть нативной памяти, по умолчанию у неё нет верхней границы. В более ранних версиях JVM эта память называлась пространством постоянного поколения (Permanent Generation (PermGen) Space). Загрузчики классов хранили в нём определения классов. Если это пространство растёт, то ОС может переместить хранящиеся здесь данные из оперативной в виртуальную память, что может замедлить работу приложения. Избежать этого можно, задав размер метапространства с помощью флагов XX:MetaspaceSize и -XX:MaxMetaspaceSize, в этом случае приложение может выдавать ошибки памяти.

--------------------------------------------------------------------------------------------------------------------
Classloader

Загрузчик классов является частью JRE, которая динамически загружает Java классы в JVM. Обычно классы загружаются только по запросу. Система исполнения в Java не должна знать о файлах и файловых системах благодаря загрузчику классов. Делегирование является важной концепцией, которую выполняет загрузчик. Загрузчик классов отвечает за поиск библиотек, чтение их содержимого и загрузку классов, содержащихся в библиотеках. Эта загрузка обычно выполняется «по требованию», поскольку она не происходит до тех пор, пока программа не вызовет класс. Класс с именем может быть загружен только один раз данным загрузчиком классов.
При запуске JVM, используются три загрузчика классов:
Bootstrap class loader (Загрузчик класса Bootstrap)
Extensions class loader (Загрузчик класса расширений)
System class loader (Системный загрузчик классов)
Загрузчик класса Bootstrap загружает основные библиотеки Java, расположенные в папке <JAVA_HOME>/jre/lib. Этот загрузчик является частью ядра JVM, написан на нативном коде.
Загрузчик класса расширений загружает код в каталоги расширений (<JAVA_HOME>/jre/lib/ext, или любой другой каталог, указанный системным свойством java.ext.dirs).
Системный загрузчик загружает код, найденный в java.class.path, который сопоставляется с переменной среды CLASSPATH. Это реализуется классом sun.misc.Launcher$AppClassLoader.
Загрузчик классов выполняет три основных действия в строгом порядке:
Загрузка: находит и импортирует двоичные данные для типа.
Связывание: выполняет проверку, подготовку и (необязательно) разрешение.Проверка: обеспечивает правильность импортируемого типа.Подготовка: выделяет память для переменных класса и инициализация памяти значениями по умолчанию.Разрешение: преобразует символические ссылки из типа в прямые ссылки.
Инициализация: вызывает код Java, который инициализирует переменные класса их правильными начальными значениями.
Пользовательский загрузчик классов
Загрузчик классов написан на Java. Поэтому возможно создать свой собственный загрузчик классов, не понимая тонких деталей JVM. У каждого загрузчика классов Java есть родительский загрузчик классов, определенный при создании экземпляра нового загрузчика классов или в качестве системного загрузчика классов по умолчанию для виртуальной машины.
Что делает возможным следующее:
загружать или выгружать классы во время выполнения (например, динамически загружать библиотеки во время выполнения, даже из ресурса HTTP). Это важная особенность для:реализация скриптовых языков;использование bean builders;добавить пользовательскую расширение;позволяя нескольким пространствам имен общаться. Например, это одна из основ протоколов CORBA / RMI;
изменить способ загрузки байт-кода (например, можно использовать зашифрованный байт-код класса Java);
модифицировать загруженный байт-код (например, для переплетения аспектов во время загрузки при использовании аспектно-ориентированного программирования);

--------------------------------------------------------------------------------------------------------------------
Области данных времени выполнения

Run-Time Data Areas. JVM выделяет множество областей данных во время выполнения, которые используются во время выполнения программы. Некоторые участки данных созданы JVM во время старта и уничтожаются во время её выключения. Другие создаются для каждого потока и уничтожаются, когда поток уничтожается.
The pc Register (PCR)
Виртуальная машина Java может поддерживать много потоков исполнения одновременно. Каждый поток виртуальной машины Java имеет свой собственный регистр PC (program counter). В любой момент каждый поток виртуальной машины Java выполняет код одного метода, а именно текущий метод для этого потока. Если этот метод не является native, регистр pc содержит адрес инструкции виртуальной машины Java, выполняемой в настоящее время.
Коротко говоря: для одного потока, существует один PCR, который создается при запуске потока. PCR хранит адрес выполняемой сейчас инструкции JVM.
Java Virtual Machine Stacks
Каждый поток в JVM имеет собственный стек, созданный одновременно с потоком. Стек в JVM хранит frames. Cтеки в JVM могут иметь фиксированный размер или динамически расширяться и сжиматься в соответствии с требованиями вычислений.
Heap
JVM имеет heap (кучу), которая используется всеми потоками виртуальной машины Java. Куча - это область данных времени выполнения, из которой выделяется память для всех экземпляров и массивов классов. Куча создается при запуске виртуальной машины. Хранилище для объектов восстанавливается автоматической системой управления данными (известной как сборщик мусора); объекты никогда не освобождаются явно. JVM не предполагает какого-либо конкретного типа системы автоматического управления хранением данных, и метод управления может быть выбран в соответствии с системными требованиями разработчика. Куча может иметь фиксированный размер или может быть расширена в соответствии с требованиями вычислений и может быть сокращена, если большая куча становится ненужной. Память для кучи не должна быть смежной.
Method Area
JVM имеет область методов, которая является общей для всех потоков. Она хранит структуры для каждого класса, такие как пул констант, данные полей и методов, а также код для методов и конструкторов, включая специальные методы, используемые при инициализации классов и экземпляров, и инициализации интерфейса. Хотя область метода является логически частью кучи, простые реализации могут не обрабатываться сборщиком мусора. Область метода может иметь фиксированный размер или может быть расширена в соответствии с требованиями вычислений и может быть сокращена, если большая область метода становится ненужной.
Run-Time Constant Pool
A run-time constant pool существует для каждого класса или интерфейса в рантайме и представленно constant_pool таблицей в *.class файле. Он содержит несколько видов констант: от числовых литералов, известных во время компиляции, до ссылок на методы и поля, которые должны быть разрешены во время выполнения. Сам run-time constant pool выполняет функцию, аналогичную функции таблицы символов для обычного языка программирования, хотя он содержит более широкий диапазон данных, чем типичная таблица символов. Каждый run-time constant pool отделён от JVM's method area. JVM создаёт run-time constant pool вместе с созданием class или interface.
Native Method Stacks
Реализация виртуальной машины Java может использовать обычные стеки, обычно называемые «стеки Си», для поддержки native methods (методов, написанных на языке, отличном от языка программирования Java).

--------------------------------------------------------------------------------------------------------------------
Execution Engine

Байт-код, назначенный run-time data areas, будет выполнен execution engine. Механизм выполнения считывает байт-код и выполняет его по частям.
Interpreter
Интерпретатор интерпретирует байт-код быстро, но выполняется медленно. Недостаток интерпретатора заключается в том, что, когда один метод вызывается несколько раз, каждый раз требуется новая интерпретация.
JIT Compiler
JIT-компилятор устраняет недостатки интерпретатора. Механизм выполнения будет использовать помощь интерпретатора при преобразовании байт-кода, но когда он находит повторный код, он использует JIT-компилятор, который компилирует весь байт-код и изменяет его на собственный код. Этот нативный код будет использоваться непосредственно для повторных вызовов методов, которые улучшают производительность системы.
Генератор промежуточного кода (Intermediate Code Generator). Производит промежуточный код.
Code Optimizer. Отвечает за оптимизацию промежуточного кода, сгенерированного выше.
Генератор целевого кода (Target Code Generator). Отвечает за генерацию машинного кода или родной код.
Профилировщик (Profiler). Специальный компонент, отвечающий за поиск горячих точек, то есть, вызывается ли метод несколько раз или нет.
Garbage Collector

--------------------------------------------------------------------------------------------------------------------
Назовите несколько видов проверок которые выполняет верификатор байт-кода Java?

Ниже приведены некоторые виды проверок, выполняемых верификатором.

инициализация переменных перед их использованием.

согласование типов ссылок при вызове метода.

соблюдение правил доступа к закрытым данным и методам.

доступ к локальным переменным в стеке во время выполнения.

отсутствие переполнения стека.

При невыполнении какой-нибудь из этих проверок класс считается поврежденным и загружаться не будет.

--------------------------------------------------------------------------------------------------------------------
Что такое Heap и Stack память в Java? Какая разница между ними?

Heap (куча) используется Java Runtime для выделения памяти под объекты и классы. Создание нового объекта также происходит в куче. Это же является областью работы сборщика мусора. Любой объект, созданный в куче, имеет глобальный доступ и на него могут ссылаться из любой части приложения.
Stack (стек) это область хранения данных также находящееся в общей оперативной памяти (RAM). Всякий раз, когда вызывается метод, в памяти стека создается новый блок, который содержит примитивы и ссылки на другие объекты в методе. Как только метод заканчивает работу, блок также перестает использоваться, тем самым предоставляя доступ для следующего метода. Размер стековой памяти намного меньше объема памяти в куче. Стек в Java работает по схеме LIFO (Последний-зашел-Первый-вышел)
Различия между Heap и Stack памятью:

- Куча используется всеми частями приложения, в то время как стек используется только одним потоком исполнения программы.
- Всякий раз, когда создается объект, он всегда хранится в куче, а в памяти стека содержится лишь ссылка на него. Память стека содержит только локальные переменные примитивных типов и ссылки на объекты в куче.
- Объекты в куче доступны с любой точки программы, в то время как стековая память не может быть доступна для других потоков.
- Стековая память существует лишь какое-то время работы программы, а память в куче живет с самого начала до конца работы программы.
- Если память стека полностью занята, то Java Runtime бросает исключение java.lang.StackOverflowError. Если заполнена память кучи, то бросается исключение java.lang.OutOfMemoryError: Java Heap Space.
- Размер памяти стека намного меньше памяти в куче.
- Из-за простоты распределения памяти, стековая память работает намного быстрее кучи.

Для определения начального и максимального размера памяти в куче используются -Xms и -Xmx опции JVM. Для стека определить размер памяти можно с помощью опции -Xss.

--------------------------------------------------------------------------------------------------------------------
Что такое Metaspace?

В Metaspa ceвиртуальная машина хранит метаданные загруженных классов. Также здесь находятся всё статическое содержимое приложения, переменные примитивных типов и ссылки на статические объекты.
Более того Metaspace хранит данные о байткоде и JIT информацию.

В результате появления Metaspace, процесс очистки памяти получил некоторые преимущества. Теперь сборщик мусора автоматически удаляет из памяти ненужные классы, когда емкость, выделенная для хранения метаданных, достигает максимального значения. Вместе с этим, уменьшилась вероятность получения ошибки OutOfMemoryError.
Несмотря на все плюсы, нам все равно необходимо контролировать и, при необходимости, настраивать Metaspace чтобы избежать утечек памяти.

--------------------------------------------------------------------------------------------------------------------
Что такое bytecode?

Как я и говорил выше, компилятор преобразовывает Java-код в промежуточный — bytecode (файлы с расширением .java в файлы с расширением .class). Байткод во многом похож на машинный код, только он использует набор инструкций не реального процессора, а виртуального. При этом он может включать в себя участки, ориентированные на использование JIT-компилятора, оптимизирующего выполнение команд под реальный процессор, на котором запущена программа. JIT-компиляция, называемая ещё компиляцией на лету— это технология, которая увеличивает производительность программы, использующей байткод, через компиляции байткода в машинный или в другой формат во время работы программы. Как вы могли догадаться, JVM и использует JIT-компилятор, когда запускает байткод.

--------------------------------------------------------------------------------------------------------------------
Компиляция в байт-код

Когда мы пишем какое-либо приложение, мы создаем файл с расширением .java и помещаем в него код на языке программирования Java. Такой файл, содержащий код, понятный человеку, называется файлом с исходным кодом. После того, как файл с исходным кодом готов, нужно его выполнить! Но на стадии в нем содержится информация, понятная только человеку.
Java — мультиплатформенный язык программирования. Это значит, что программы, написанные на языке Java, можно выполнять на любой платформе, где установлена специальная исполняющая система Java. Такая система называется Java Virtual Machine (JVM). Для того, чтобы перевести программу из исходного кода в код, понятный JVM, нужно её скомпилировать. Код, понятный JVM называется байт-кодом и содержит набор инструкций, которые в дальнейшем будет исполнять виртуальная машина.
Для компиляции исходного кода в байт-код существует компилятор javac, входящий в поставку JDK (Java Development Kit). На вход компилятор принимает файл с расширением .java, содежащий исходный код программы, а на выходе выдает файл с расширением .class, содержащий байт-код, необходимый для исполнения программы виртуальной машиной.
После того, как программа была скомпилирована в байт-код, она может быть выполнена с помощью виртуальной машины.

--------------------------------------------------------------------------------------------------------------------
Выполнение программы виртуальной машиной

Итак, мы запустили написанную программу. Но что же происходит в момент запуска скомпилированной программы виртуальной машиной? Для начала разберемся, что означают понятия компиляции и интерпретации кода.
Компиляция — трансляция программы, составленной на исходном языке высокого уровня, в эквивалентную программу на низкоуровневом языке, близком машинному коду.

Интерпретация — пооператорный (покомандный, построчный) анализ, обработка и тут же выполнение исходной программы или запроса (в отличие от компиляции, при которой программа транслируется без её выполнения).

Язык Java обладает как компилятором (javac), так и интерпретатором, в роли которого выступает виртуальная машина, которая построчно преобразует байт-код в машинный код и тут же его исполняет. Таким образом, когда мы запускаем скомпилированную программу, виртуальная машина начинает её интерпретацию, то есть построчное преобразование байт-кода в машинный код, а так же его исполнение.
К сожалению, чистая интерпретация байт-кода является довольно долгим процессом и делает язык java медленным в сравнении с его конкурентами. Дабы избежать этого, был введен механизм, позволяющий ускорить интерпретацию байт-кода виртуальной машиной. Этот механизм называется Just-in-time компиляцией (JITC).

--------------------------------------------------------------------------------------------------------------------
Расскажите про классы-загрузчики и про динамическую загрузку классов.

Основа работы с классами в Java — классы-загрузчики, обычные Java-объекты, предоставляющие интерфейс для поиска и создания объекта класса по его имени во время работы приложения.
В начале работы программы создается 3 основных загрузчика классов:
- базовый загрузчик (bootstrap/primordial). Загружает основные системные и внутренние классы JDK (Core API - пакеты java.* (rt.jar и i18n.jar) . Важно заметить, что базовый - загрузчик является «Изначальным» или «Корневым» и частью JVM, вследствие чего его нельзя создать внутри кода программы.
- загрузчик расширений (extention). Загружает различные пакеты расширений, которые располагаются в директории <JAVA_HOME>/lib/ext или другой директории, описанной в системном параметре java.ext.dirs. Это позволяет обновлять и добавлять новые расширения без необходимости модифицировать настройки используемых приложений. Загрузчик расширений реализован классом sun.misc.Launcher$ExtClassLoader.
- системный загрузчик (system/application). Загружает классы, пути к которым указаны в переменной окружения CLASSPATH или пути, которые указаны в командной строке запуска JVM после ключей -classpath или -cp. Системный загрузчик реализован классом sun.misc.Launcher$AppClassLoader.

Загрузчики классов являются иерархическими: каждый из них (кроме базового) имеет родительский загрузчик и в большинстве случаев, перед тем как попробовать загрузить класс самостоятельно, он посылает вначале запрос родительскому загрузчику загрузить указанный класс. Такое делегирование позволяет загружать классы тем загрузчиком, который находится ближе всего к базовому в иерархии делегирования. Как следствие поиск классов будет происходить в источниках в порядке их доверия: сначала в библиотеке Core API, потом в папке расширений, потом в локальных файлах CLASSPATH.
Процесс загрузки класса состоит из трех частей:
- Loading - на этой фазе происходит поиск и физическая загрузка файла класса в определенном источнике (в зависимости от загрузчика). Этот процесс определяет базовое представление класса в памяти. На этом этапе такие понятия как «методы», «поля» и т.д. пока не известны.
- Linking - процесс, который может быть разбит на 3 части:
  -- Bytecode verification - проверка байт-кода на соответствие требованиям, определенным в спецификации JVM.
  -- Class preparation - создание и инициализация необходимых структур, используемых для представления полей, методов, реализованных интерфейсов и т.п., определенных в загружаемом классе.
  -- Resolving - загрузка набора классов, на которые ссылается загружаемый класс.
- Initialization - вызов статических блоков инициализации и присваивание полям класса значений по умолчанию.

Динамическая загрузка классов в Java имеет ряд особенностей:
- отложенная (lazy) загрузка и связывание классов. Загрузка классов производится только при необходимости, что позволяет экономить ресурсы и распределять нагрузку.
- проверка корректности загружаемого кода (type safeness). Все действия связанные с контролем использования типов производятся только во время загрузки класса, позволяя избежать дополнительной нагрузки во время выполнения кода.
- программируемая загрузка. Пользовательский загрузчик полностью контролирует процесс получения запрошенного класса — самому ли искать байт-код и создавать класс или делегировать создание другому загрузчику. Дополнительно существует возможность выставлять различные атрибуты безопасности для загружаемых классов, позволяя таким образом работать с кодом из ненадежных источников.
- множественные пространства имен. Каждый загрузчик имеет своё пространство имён для создаваемых классов. Соответственно, классы, загруженные двумя различными загрузчиками на основе общего байт-кода, в системе будут различаться.

Существует несколько способов инициировать загрузку требуемого класса:
- явный: вызов ClassLoader.loadClass() или Class.forName() (по умолчанию используется загрузчик, создавший текущий класс, но есть возможность и явного указания загрузчика);
- неявный: когда для дальнейшей работы приложения требуется ранее не использованный класс, JVM инициирует его загрузку.

--------------------------------------------------------------------------------------------------------------------
Для чего нужен сборщик мусора?

Сборщик мусора (Garbage Collector) должен делать всего две вещи:
- Находить мусор - неиспользуемые объекты. (Объект считается неиспользуемым, если ни одна из сущностей в коде, выполняемом в данный момент, не содержит ссылок на него, либо цепочка ссылок, которая могла бы связать объект с некоторой сущностью приложения, обрывается);
- Освобождать память от мусора.

Существует два подхода к обнаружению мусора:
- Reference counting;
- Tracing
  Reference counting (подсчёт ссылок). Суть этого подхода состоит в том, что каждый объект имеет счетчик. Счетчик хранит информацию о том, сколько ссылок указывает на объект. Когда ссылка уничтожается, счетчик уменьшается. Если значение счетчика равно нулю, - объект можно считать мусором. Главным минусом такого подхода является сложность обеспечения точности счетчика. Также при таком подходе сложно выявлять циклические зависимости (когда два объекта указывают друг на друга, но ни один живой объект на них не ссылается), что приводит к утечкам памяти.
  Главная идея подхода Tracing (трассировка) состоит в утверждении, что живыми могут считаться только те объекты, до которых мы можем добраться из корневых точек (GC Root) и те объекты, которые доступны с живого объекта. Всё остальное - мусор.

Существует 4 типа корневых точки:
- Локальные переменные и параметры методов;
- Потоки;
- Статические переменные;
- Ссылки из JNI.
  Самое простое java приложение будет иметь корневые точки:
- Локальные переменные внутри main() метода и параметры main() метода;
- Поток который выполняет main();
- Статические переменные класса, внутри которого находится main() метод.
  Таким образом, если мы представим все объекты и ссылки между ними как дерево, то нам нужно будет пройти с корневых узлов (точек) по всем рёбрам. При этом узлы, до которых мы сможем добраться - не мусор, все остальные - мусор. При таком подходе циклические зависимости легко выявляются. HotSpot VM использует именно такой подход.

Для очистки памяти от мусора существуют два основных метода:
- Copying collectors
- Mark-and-sweep

При copying collectors подходе память делится на две части «from-space» и «to-space», при этом сам принцип работы такой:
- Объекты создаются в «from-space»;
- Когда «from-space» заполняется, приложение приостанавливается;
- Запускается сборщик мусора. Находятся живые объекты в «from-space» и копируются в «to-space»;
- Когда все объекты скопированы «from-space» полностью очищается;
- «to-space» и «from-space» меняются местами.

Главный плюс такого подхода в том, что объекты плотно забивают память. Минусы подхода:
1 Приложение должно быть остановлено на время, необходимое для полного прохождения цикла сборки мусора;
2 В худшем случае (когда все объекты живые) «form-space» и «to-space» будут обязаны быть одинакового размера.

Алгоритм работы mark-and-sweep можно описать так:
- Объекты создаются в памяти;
- В момент, когда нужно запустить сборщик мусора приложение приостанавливается;
- Сборщик проходится по дереву объектов, помечая живые объекты;
- Сборщик проходится по всей памяти, находя все не отмеченные куски памяти и сохраняя их в «free list»;
- Когда новые объекты начинают создаваться они создаются в памяти доступной во «free list».

Минусы этого способа:
- Приложение не работает пока происходит сборка мусора;
- Время остановки напрямую зависит от размеров памяти и количества объектов;
- Если не использовать «compacting» память будет использоваться не эффективно.
  Сборщики мусора HotSpot VM используют комбинированный подход Generational Garbage Collection, который позволяет использовать разные алгоритмы для разных этапов сборки мусора. Этот подход опирается на том, что:
- большинство создаваемых объектов быстро становятся мусором;
- существует мало связей между объектами, которые были созданы в прошлом и только что созданными объектами.

--------------------------------------------------------------------------------------------------------------------
Как работает сборщик мусора?

Механизм сборки мусора - это процесс освобождения места в куче, для возможности добавления новых объектов.
Объекты создаются посредством оператора new, тем самым присваивая объекту ссылку. Для окончания работы с объектом достаточно просто перестать на него ссылаться, например, присвоив переменной ссылку на другой объект или значение null; прекратить выполнение метода, чтобы его локальные переменные завершили свое существование естественным образом. Объекты, ссылки на которые отсутствуют, принято называть мусором (garbage), который будет удален.
Виртуальная машина Java, применяя механизм сборки мусора, гарантирует, что любой объект, обладающий ссылками, остается в памяти — все объекты, которые недостижимы из исполняемого кода, ввиду отсутствия ссылок на них, удаляются с высвобождением отведенной для них памяти. Точнее говоря, объект не попадает в сферу действия процесса сборки мусора, если он достижим посредством цепочки ссылок, начиная с корневой (GC Root) ссылки, т.е. ссылки, непосредственно существующей в выполняемом коде.
Память освобождается сборщиком мусора по его собственному «усмотрению». Программа может успешно завершить работу, не исчерпав ресурсов свободной памяти или даже не приблизившись к этой черте и поэтому ей так и не потребуются «услуги» сборщика мусора.
Мусор собирается системой автоматически, без вмешательства пользователя или программиста, но это не значит, что этот процесс не требует внимания вовсе. Необходимость создания и удаления большого количества объектов существенным образом сказывается на производительности приложений и, если быстродействие программы является важным фактором, следует тщательно обдумывать решения, связанные с созданием объектов, — это, в свою очередь, уменьшит и объем мусора, подлежащего утилизации.

--------------------------------------------------------------------------------------------------------------------
Какие разновидности сборщиков мусора реализованы в виртуальной машине HotSpot?

Java HotSpot VM предоставляет разработчикам на выбор четыре различных сборщика мусора:
- Serial (последовательный) — самый простой вариант для приложений с небольшим объемом данных и не требовательных к задержкам. На данный момент используется сравнительно редко, но на слабых компьютерах может быть выбран виртуальной машиной в качестве сборщика по умолчанию. Использование Serial GC включается опцией -XX:+UseSerialGC.
- Parallel (параллельный) — наследует подходы к сборке от последовательного сборщика, но добавляет параллелизм в некоторые операции, а также возможности по автоматической подстройке под требуемые параметры производительности. Параллельный сборщик включается опцией -XX:+UseParallelGC.
- Concurrent Mark Sweep (CMS) — нацелен на снижение максимальных задержек путем выполнения части работ по сборке мусора параллельно с основными потоками приложения. Подходит для работы с относительно большими объемами данных в памяти. Использование CMS GC включается опцией -XX:+UseConcMarkSweepGC.
- Garbage-First (G1) — создан для замены CMS, особенно в серверных приложениях, работающих на многопроцессорных серверах и оперирующих большими объемами данных. G1 включается опцией Java -XX:+UseG1GC.

--------------------------------------------------------------------------------------------------------------------
Опишите алгоритм работы какого-нибудь сборщика мусора, реализованного в виртуальной машине HotSpot.

Serial Garbage Collector (Последовательный сборщик мусора) был одним из первых сборщиков мусора в HotSpot VM. Во время работы этого сборщика приложения приостанавливается и продолжает работать только после прекращения сборки мусора.

Память приложения делится на три пространства:
- Young generation. Объекты создаются именно в этом участке памяти.
- Old generation. В этот участок памяти перемещаются объекты, которые переживают «minor garbage collection».
- Permanent generation. Тут хранятся метаданные об объектах, Class data sharing (CDS), пул строк (String pool). Permanent область делится на две: только для чтения и для чтения-записи. Очевидно, что в этом случае область только для чтения не чистится сборщиком мусора никогда.

Область памяти Young generation состоит из трёх областей: Eden и двух меньших по размеру Survivor spaces - To space и From space. Большинство объектов создаются в области Eden, за исключением очень больших объектов, которые не могут быть размещены в ней и поэтому сразу размещаются в Old generation. В Survivor spaces перемещаются объекты, которые пережили по крайней мере одну сборку мусора, но ещё не достигли порога «старости» (tenuring threshold), чтобы быть перемещенными в Old generation.
Когда Young generation заполняется, то в этой области запускается процесс лёгкой сборки (minor collection), в отличие от процесса сборки, проводимого над всей кучей (full collection). Он происходит следующим образом: в начале работы одно из Survivor spaces - To space, является пустым, а другое - From space, содержит объекты, пережившие предыдущие сборки. Сборщик мусора ищет живые объекты в Eden и копирует их в To space, а затем копирует туда же и живые «молодые» (то есть не пережившие еще заданное число сборок мусора) объекты из From space. Старые объекты из From space перемещаются в Old generation. После лёгкой сборки From space и To space меняются ролями, область Eden становится пустой, а число объектов в Old generation увеличивается.

Если в процессе копирования живых объектов To space переполняется, то оставшиеся живые объекты из Eden и From space, которым не хватило места в To space, будут перемещены в Old generation, независимо от того, сколько сборок мусора они пережили.
Поскольку при использовании этого алгоритма сборщик мусора просто копирует все живые объекты из одной области памяти в другую, то такой сборщик мусора называется copying (копирующий). Очевидно, что для работы копирующего сборщика мусора у приложения всегда должна быть свободная область памяти, в которую будут копироваться живые объекты, и такой алгоритм может применяться для областей памяти сравнительно небольших по отношению к общему размеру памяти приложения. Young generation как раз удовлетворяет этому условию (по умолчанию на машинах клиентского типа эта область занимает около 10% кучи (значение может варьироваться в зависимости от платформы)).
Однако, для сборки мусора в Old generation, занимающем большую часть всей памяти, используется другой алгоритм.
В Old generation сборка мусора происходит с использованием алгоритма mark-sweep-compact, который состоит из трёх фаз. В фазе Mark (пометка) сборщик мусора помечает все живые объекты, затем, в фазе Sweep (очистка) все не помеченные объекты удаляются, а в фазе Сompact (уплотнение) все живые объекты перемещаются в начало Old generation, в результате чего свободная память после очистки представляет собой непрерывную область. Фаза уплотнения выполняется для того, чтобы избежать фрагментации и упростить процесс выделения памяти в Old generation.
Когда свободная память представляет собой непрерывную область, то для выделения памяти под создаваемый объект можно использовать очень быстрый (около десятка машинных инструкций) алгоритм bump-the-pointer: адрес начала свободной памяти хранится в специальном указателе, и когда поступает запрос на создание нового объекта, код проверяет, что для нового объекта достаточно места, и, если это так, то просто увеличивает указатель на размер объекта.
Последовательный сборщик мусора отлично подходит для большинства приложений, использующих до 200 мегабайт кучи, работающих на машинах клиентского типа и не предъявляющих жёстких требований к величине пауз, затрачиваемых на сборку мусора. В то же время модель «stop-the-world» может вызвать длительные паузы в работе приложения при использовании больших объёмов памяти. Кроме того, последовательный алгоритм работы не позволяет оптимально использовать вычислительные ресурсы компьютера, и последовательный сборщик мусора может стать узким местом при работе приложения на многопроцессорных машинах.

--------------------------------------------------------------------------------------------------------------------
AOT компиляция это?

Одним из новшеств Java 9 является Ahead-Of-Time (AOT) компиляция. Поэтому в данной статье я решил немного рассказать об основных аспектах того, что же это такое.

AOT компиляция - это статическая компиляция и те, кто работал с языком C хорошо знакомы с ней. Суть заключается в том, что на этапе компиляции наш исходный код превращается в исполняемый код. По итогу мы получаем исполняемый файл, который мы можем запустить в любой момент. Соответственно, до начала работы программы нам требуется больше времени. Поэтому данный вид компиляции так и называется Ahead-Of-Time.

На данный в Java мы привыкли иметь дело с Just-In-Time (JIT) компиляцией, которая происходит во время работы нашего приложения.

Но, не стоит думать, что в Java 9 мы полностью отказываемся от JIT компиляции в пользу AOT. Нет, в Java 9 планируется ДОБАВИТЬ возможность AOT.
Использовать её мы сможем с помощью jaotc. Данная утилита будет гарантированно работать для модуля java.base, который работает объектами, структурами данных и потоками. Следовательно, мы можем сказать, что AOT компиляция не является полноценным модулем Java 9, а находится на стадии внедрения.

Данный вид компиляции имеет следующие основные преимущества:

Время запуска приложения
Для холодного старта (первого запуска нашей программы) нам необходимо значительно большее время по сравнению с JIT компиляцией. Но, после того, как код статически скомпилирован, время старта не отличается от времени старта такой же программы на языке C.

Невозможность декомпиляции
Исполняемый код, который мы получаем в результате AOT компиляции можно дизассемблировать со значительными сложностями, а декомпилировать байт-код в Java код не составляет трудности.
Может возникнуть ложное мнение, что Java станет работать со скоростью языка C, но это не так.

В языке С высокая скорость работы достигается за счёт "предоставления свободы" разработчику за счёт безопасности поведения.
Например, если в массиве 100 элементов, а мы хотим получить доступ к 101 элементу и т.д, то в языке Java мы получим ArrayOutOfBoundsException, в то время, как в С, в лучшем случае, мы получим segfault. Т.е. Java проверяет, чтобы мы не нанесли вреда. За подобные проверки в Java мы и расплачиваемся скоростью.
Но, не стоит думать, что С работает быстрее Java во всех случаях, это не так.
Компилятор Java имеет доступ к коду всех доступных библиотек и, благодаря этому может оптимизировать работу нашего приложения.
Данная оптимизация, временами, становится крайне "дорогой", потому что дополнительные данные, возникающие во время выполнения этой оптимизации может "не помещаться" в оперативной памяти и временно, необходимо записывать её на диск. Это "непозволительная роскошь" для JIT компилятора.
Заключение
Не существует однозначного ответа на вопрос "Какой вид компиляции лучше?". Ответ крайне зависит от самого приложения и целей его использования. AOT компиляция крайне хорошо подходит для встраиваемых систем, так как они не имеют высоких вычислительных мощностей. Если "железо слабое", то и динамическая компиляция становится крайне слабым инструментом.

С другой стороны, для корпоративных систем динамическая (JIT) компиляция, вероятнее всего, останется более приоритетной.

--------------------------------------------------------------------------------------------------------------------
Что такое Safepoints (применительно к HotSpot JVM)?

В HotSpot JVM механизм паузы «stop-the-world» называется safepoint. Во время safepoint все потоки, исполняющие java-код приостанавливаются. Потоки, исполняющие нативный код, могут продолжать работать пока, не будут прерваны JVM (попытка доступа к объектам Java через JNI, вызов метода Java или возврат из нативного кода в Java приостановит поток до конца safepoint). Остановка всех потоков необходима, чтобы убедиться, что safepoint-инициатор имеет эксклюзивный доступ к структурам данных JVM и может делать всё что угодно, например перемещение объектов в куче или замена кода метода, который в настоящее время выполняется (перемещение в стеке).
Как работают safepoints? Протокол Safepoint в HotSpot JVM является общим. Каждый поток приложения проверяет статус safepoint и паркуется в безопасном состоянии в этой точке. Для скомпилированного кода JIT вставляет в код проверки safepoint в определенных точках (обычно после возврата вызовов или при обратном переходе цикла). Для интерпретируемого кода JVM имеет две таблицы диспетчеризации байт-кода, и если требуется safepoint, JVM переключает таблицы, чтобы включить его проверку.
Сама проверка статуса Safepoint реализована очень нетривиально. Обычная проверка переменных памяти потребует дорогостоящих барьеров памяти. Хотя проверка safepoints реализована через барьер. Затем требуется безопасная точка, JVM отключает отображение страницы с этим адресом, вызывая сбой страницы в потоке приложения (который обрабатывается обработчиком JVM). Таким образом, HotSpot поддерживает свой JITed-код, совместимый с конвейером процессора, но при этом обеспечивает правильную семантику памяти (unmap страницы создает барьер памяти для ядер обработки).

Когда safepoint используется?
Пауза GC
Деоптимизация кода
Flushing code cache
Class redefinition (e.g. hot swap or instrumentation)
Biased lock revocation
Various debug operation (e.g. deadlock check or stacktrace dump)

--------------------------------------------------------------------------------------------------------------------
Что такое HeapDump и TreadDump?

HeapDump - снимок текущей памяти, позволяет разобраться в потребление памяти, например, при её утечке.
ThreadDump - снимок стеков всех поток, позволяет разбираться в проблемах многопоточности, например, находить взаимные блокировки.

--------------------------------------------------------------------------------------------------------------------
Что такое профилирование?

Профилирование — сбор характеристик работы программы, таких как время выполнения отдельных фрагментов (обычно подпрограмм), число верно предсказанных условных переходов, число кэш-промахов и т. д. Инструмент, используемый для анализа работы, называют профилировщиком или профайлером (англ. profiler). Обычно выполняется совместно с оптимизацией программы.
Профилировщики - программы, производящие профилирование, делятся на 2 типа:

Инструментирующие - модифицируют программный код, оказывают значительное влияние н производительность.

Сэмплирующие - не влияют напрямую на исполняемый код.

--------------------------------------------------------------------------------------------------------------------
Как обнаружить причину утечки памяти (memory leak)?

Как правило, следствием утечки памяти становится замедление приложения и/или появление OutOfMemoryError: xxx.

Что может быть причиной:
Неверно сконфигурированная JVM - удалите все ключи jvm, и попробуйте воспроизвести проблему.

Объективная нехватка памяти - добавьте ее в Heap (-Xmx / -Xms) и PermGen (-XX:PermSize / -XX:MaxPermSize) для версий Java 7 и ниже.

Утечка в загрузчике классов (class loader) - ограничьте Metaspace -XX:MaxMetaSpaceSize={unlimited} для версий Java 8 и выше, чтобы ограничить потребление физической памяти и локализовать проблему.

Ошибки проектирования - незакрытые потоки ввод-вывода, зависшие потоки (threads), ...

Рекомендации по диагностированию:
Утилиты VisaulVM, MissonControl, jstat, jmap - для анализа состояния JVM в моменте.

Включение GC-логов - -XX:PrintGCDetails и других. Их можно анализировать с помощью GCLogAnalyzer или GCViewer.

Включение создания дампа памяти при ошибке OutOfMememoryError: xxx - XX:HeadDumpOnOutOfMemoryError и -XX:HeapDumpPath=<file_name>. Анализ дампа можно производить с помощью Memory Analyzer (MAT).

--------------------------------------------------------------------------------------------------------------------