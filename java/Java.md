Какие существуют модификаторы доступа?

private (приватный): члены класса доступны только внутри класса. Для обозначения используется служебное слово private.
default, package-private, package level (доступ на уровне пакета): видимость класса/членов класса только внутри пакета. Является модификатором доступа по умолчанию - специальное обозначение не требуется.
protected (защищённый): члены класса доступны внутри пакета и в наследниках. Для обозначения используется служебное слово protected.
public (публичный): класс/члены класса доступны всем. Для обозначения используется служебное слово public.
Последовательность модификаторов по возрастанию уровня закрытости: public, protected, default, private.
Во время наследования возможно изменения модификаторов доступа в сторону большей видимости (для поддержания соответствия принципу подстановки Барбары Лисков).
--------------------------------------------------------------------------------------------------------------------
О чем говорит ключевое слово final?

Модификатор final может применяться к переменным, параметрам методов, полям и методам класса или самим классам.
1) Класс не может иметь наследников;
2) Метод не может быть переопределен в классах наследниках;
3) Поле не может изменить свое значение после инициализации;
4) Параметры методов не могут изменять своё значение внутри метода;
5) Локальные переменные не могут быть изменены после присвоения им значения.
--------------------------------------------------------------------------------------------------------------------
Какими значениями инициализируются переменные по умолчанию?

1) Числа инициализируются 0 или 0.0;
2) char — \u0000;
3) boolean — false;
4) Объекты (в том числе String) — null.
--------------------------------------------------------------------------------------------------------------------
Что вы знаете о функции main()?

Метод main() — точка входа в программу. В приложении может быть несколько таких методов. Если метод отсутствует, то компиляция возможна, но при запуске будет получена ошибка `Error: Main method not found`.
public static void main(String[] args) {}
--------------------------------------------------------------------------------------------------------------------
Что такое тернарный оператор выбора?

Тернарный условный оператор ?: - оператор, которым можно заменить некоторые конструкции операторов if-then-else.
Выражение записывается в следующей форме:
условие ? выражение1 : выражение2
Если условие выполняется, то вычисляется выражение1 и его результат становится результатом выполнения всего оператора. Если же условие равно false, то вычисляется выражение2 и его значение становится результатом работы оператора. Оба операнда выражение1 и выражение2 должны возвращать значение одинакового (или совместимого) типа.
--------------------------------------------------------------------------------------------------------------------
Где и для чего используется модификатор abstract?

Класс, помеченный модификатором abstract, называется абстрактным классом. Такие классы могут выступать только предками для других классов. Создавать экземпляры самого абстрактного класса не разрешается. При этом наследниками абстрактного класса могут быть как другие абстрактные классы, так и классы, допускающие создание объектов.
Метод, помеченный ключевым словом abstract - абстрактный метод, т.е. метод, который не имеет реализации. Если в классе присутствует хотя бы один абстрактный метод, то весь класс должен быть объявлен абстрактным.
Использование абстрактных классов и методов позволяет описать некий шаблон объекта, который должен быть реализован в других классах. В них же самих описывается лишь некое общее для всех потомков поведение.
--------------------------------------------------------------------------------------------------------------------
Дайте определение понятию «интерфейс». Какие модификаторы по умолчанию имеют поля и методы интерфейсов?

Ключевое слово interface используется для создания полностью абстрактных классов. Основное предназначение интерфейса - определять каким образом мы можем использовать класс, который его реализует. Создатель интерфейса определяет имена методов, списки аргументов и типы возвращаемых значений, но не реализует их поведение. Все методы неявно объявляются как public.
Начиная с Java 8 в интерфейсах разрешается размещать реализацию методов по умолчанию default и статических static методов.
Интерфейс также может содержать и поля. В этом случае они автоматически являются публичными public, статическими static и неизменяемыми final.
--------------------------------------------------------------------------------------------------------------------
Чем абстрактный класс отличается от интерфейса? В каких случаях следует использовать абстрактный класс, а в каких интерфейс?

1) В Java класс может одновременно реализовать несколько интерфейсов, но наследоваться только от одного класса.
2) Абстрактные классы используются только тогда, когда присутствует тип отношений «is a» (является). Интерфейсы могут реализоваться классами, которые не связаны друг с другом.
3) Абстрактный класс - средство, позволяющее избежать написания повторяющегося кода, инструмент для частичной реализации поведения. Интерфейс - это средство выражения семантики класса, контракт, описывающий возможности. Все методы интерфейса неявно объявляются как public abstract или (начиная с Java 8) default - методами с реализацией по-умолчанию, а поля - public static final.
4) Интерфейсы позволяют создавать структуры типов без иерархии.
5) Наследуясь от абстрактного, класс «растворяет» собственную индивидуальность. Реализуя интерфейс, он расширяет собственную функциональность.

Абстрактные классы содержат частичную реализацию, которая дополняется или расширяется в подклассах. При этом все подклассы схожи между собой в части реализации, унаследованной от абстрактного класса, и отличаются лишь в части собственной реализации абстрактных методов родителя. Поэтому абстрактные классы применяются в случае построения иерархии однотипных, очень похожих друг на друга классов. В этом случае наследование от абстрактного класса, реализующего поведение объекта по умолчанию может быть полезно, так как позволяет избежать написания повторяющегося кода. Во всех остальных случаях лучше использовать интерфейсы.

--------------------------------------------------------------------------------------------------------------------
Почему в некоторых интерфейсах вообще не определяют методов?

Это так называемые маркерные интерфейсы. Они просто указывают что класс относится к определенному типу. Примером может послужить интерфейс Clonable, который указывает на то, что класс поддерживает механизм клонирования.

--------------------------------------------------------------------------------------------------------------------
Почему нельзя объявить метод интерфейса с модификатором final?

В случае интерфейсов указание модификатора final бессмысленно, т.к. все методы интерфейсов неявно объявляются как абстрактные, т.е. их невозможно выполнить, не реализовав где-то еще, а этого нельзя будет сделать, если у метода идентификатор final.

--------------------------------------------------------------------------------------------------------------------
Что имеет более высокий уровень абстракции - класс, абстрактный класс или интерфейс?

Интерфейс.

--------------------------------------------------------------------------------------------------------------------
Может ли объект получить доступ к члену класса, объявленному как private? Если да, то каким образом?

1) Внутри класса доступ к приватной переменной открыт без ограничений;
2) Вложенный класс имеет полный доступ ко всем (в том числе и приватным) членам содержащего его класса;
3) Доступ к приватным переменным извне может быть организован через отличные от приватных методов, которые предоставлены разработчиком класса. Например: getX() и setX().
4) Через механизм рефлексии (Reflection API):
   class Victim {
   private int field = 42;
   }
   //...
   Victim victim = new Victim();
   Field field = Victim.class.getDeclaredField("field"); field.setAccessible(true);
   int fieldValue = (int) field.get(victim);
--------------------------------------------------------------------------------------------------------------------
Каков порядок вызова конструкторов и блоков инициализации с учётом иерархии классов?

Сначала вызываются все статические блоки в очередности от первого статического блока корневого предка и выше по цепочке иерархии до статических блоков самого класса.
Затем вызываются нестатические блоки инициализации корневого предка, конструктор корневого предка и так далее вплоть до нестатических блоков и конструктора самого класса.
Parent static block(s) → Child static block(s) → Grandchild static block(s)
→ Parent non-static block(s) → Parent constructor →
→ Child non-static block(s) → Child constructor →
→ Grandchild non-static block(s) → Grandchild constructor
--------------------------------------------------------------------------------------------------------------------
Зачем нужны и какие бывают блоки инициализации?

Блоки инициализации представляют собой код, заключенный в фигурные скобки и размещаемый внутри класса вне объявления методов или конструкторов.
1) Существуют статические и нестатические блоки инициализации.
2) Блок инициализации выполняется перед инициализацией класса загрузчиком классов или созданием объекта класса с помощью конструктора.
3) Несколько блоков инициализации выполняются в порядке следования в коде класса.
4) Блок инициализации способен генерировать исключения, если их объявления перечислены в throws всех конструкторов класса.
5) Блок инициализации возможно создать и в анонимном классе.
--------------------------------------------------------------------------------------------------------------------
К каким конструкциям Java применим модификатор static?

полям;
методам;
вложенным классам;
членам секции import.
--------------------------------------------------------------------------------------------------------------------
Ключевое слово static

Static — модификатор, применяемый к полю, блоку, методу или внутреннему классу. Данный модификатор указывает на привязку субъекта к текущему классу.
При обозначении переменной уровня класса мы указываем на то, что это значение относится к классу. Если этого не делать, то значение переменной будет привязываться к объекту, созданному по этому классу.
Есть два блока инициализации — обычный и статический.
Блок предназначен для инициализации внутренних переменных. Если блок обычный, то им инициализируют внутренние переменные объекта, если же статический, соответственно, им задают статические переменные (то есть переменные класса).
Статические методы отличаются от обычных тем, что они также привязаны к классу, а не к объекту.
Важным свойством статического метода является то, что он может обратиться только к статическим переменным/методам.
Статическим классом может быть только внутренний класс.
Опять же, этот класс привязан к внешнему классу, и если внешний наследуется другим классом, то этот не будет наследован. При этом данный класс можно наследовать, как и он может наследоваться от любого другого класса и имплементировать интерфейс.
По сути статический вложенный класс ничем не отличается от любого другого внутреннего класса за исключением того, что его объект не содержит ссылку на создавший его объект внешнего класса.
--------------------------------------------------------------------------------------------------------------------
Для чего в Java используются статические блоки инициализации?

Статические блоки инициализация используются для выполнения кода, который должен выполняться один раз при инициализации класса загрузчиком классов, в момент, предшествующий созданию объектов этого класса при помощи конструктора. 
Такой блок (в отличие от нестатических, принадлежащих конкретном объекту класса) принадлежит только самому классу (объекту метакласса Class).
--------------------------------------------------------------------------------------------------------------------
Может ли статический метод быть переопределён или перегружен?

Перегружен - да. Всё работает точно так же, как и с обычными методами - 2 статических метода могут иметь одинаковое имя, если количество их параметров или типов различается.
Переопределён - нет. Выбор вызываемого статического метода происходит при раннем связывании (на этапе компиляции, а не выполнения) и выполняться всегда будет родительский метод, хотя синтаксически переопределение статического метода - это вполне корректная языковая конструкция.
В целом, к статическим полям и методам рекомендуется обращаться через имя класса, а не объект.
--------------------------------------------------------------------------------------------------------------------
Могут ли нестатические методы перегрузить статические?

Да. В итоге получится два разных метода. Статический будет принадлежать классу и будет доступен через его имя, а нестатический будет принадлежать конкретному объекту и доступен через вызов метода этого объекта.

--------------------------------------------------------------------------------------------------------------------
Можно ли сузить уровень доступа/тип возвращаемого значения при переопределении метода?

- При переопределении метода нельзя сузить модификатор доступа к методу (например с public в MainClass до private в Class extends MainClass).
- Изменить тип возвращаемого значения при переопределении метода нельзя, будет ошибка attempting to use incompatible return type.
- Можно сузить возвращаемое значение, если они совместимы.
--------------------------------------------------------------------------------------------------------------------
Возможно ли при переопределении метода изменить: модификатор доступа, возвращаемый тип, тип аргумента или их количество, имена аргументов или их порядок; убирать, добавлять, изменять порядок следования элементов секции throws?

При переопределении метода сужать модификатор доступа не разрешается, т.к. это приведёт к нарушению принципа подстановки Барбары Лисков. Расширение уровня доступа возможно.
Можно изменять все, что не мешает компилятору понять какой метод родительского класса имеется в виду:
- Изменять тип возвращаемого значения при переопределении метода разрешено только в сторону сужения типа (вместо родительского класса - наследника).
- При изменении типа, количества, порядка следования аргументов вместо переопределения будет происходить overloading (перегрузка) метода.
- Секцию throws метода можно не указывать, но стоит помнить, что она остаётся действительной, если уже определена у метода родительского класса. Так же, возможно добавлять новые исключения, являющиеся наследниками от уже объявленных или исключения RuntimeException. Порядок следования таких элементов при переопределении значения не имеет.
--------------------------------------------------------------------------------------------------------------------
Как получить доступ к переопределенным методам родительского класса?

С помощью ключевого слова super мы можем обратиться к любому члену родительского класса - методу или полю, если они не определены с модификатором private.
super.method();
--------------------------------------------------------------------------------------------------------------------
Можно ли объявить метод абстрактным и статическим одновременно?

Нет. В таком случае компилятор выдаст ошибку: "Illegal combination of modifiers: 'abstract' and 'static'". Модификатор abstract говорит, что метод будет реализован в другом классе, а static наоборот указывает, что этот метод будет доступен по имени класса.

--------------------------------------------------------------------------------------------------------------------
В чем разница между членом экземпляра класса и статическим членом класса?

Модификатор static говорит о том, что данный метод или поле принадлежат самому классу и доступ к ним возможен даже без создания экземпляра класса. Поля, помеченные static инициализируются при инициализации класса. На методы, объявленные как static, накладывается ряд ограничений:
- Они могут вызывать только другие статические методы.
- Они должны осуществлять доступ только к статическим переменным.
- Они не могут ссылаться на члены типа this или super.

В отличии от статических, поля экземпляра класса принадлежат конкретному объекту и могут иметь разные значения для каждого. Вызов метода экземпляра возможен только после предварительного создания объекта класса.

--------------------------------------------------------------------------------------------------------------------
Где разрешена инициализация статических/нестатических полей?

- Статические поля можно инициализировать при объявлении, в статическом или нестатическом блоке инициализации.
- Нестатические поля можно инициализировать при объявлении, в нестатическом блоке инициализации или в конструкторе
--------------------------------------------------------------------------------------------------------------------
Какие типы классов бывают в java?

Top level class (Обычный класс):
-- Abstract class (Абстрактный класс);
-- Final class (Финализированный класс).
Interfaces (Интерфейс).
Enum (Перечисление).
Nested class (Вложенный класс):
-- Static nested class (Статический вложенный класс);
-- Member inner class (Простой внутренний класс);
-- Local inner class (Локальный класс);
-- Anonymous inner class (Анонимный класс).
--------------------------------------------------------------------------------------------------------------------
Расскажите про вложенные классы. В каких случаях они применяются?

Класс называется вложенным (Nested class), если он определен внутри другого класса. Вложенный класс должен создаваться только для того, чтобы обслуживать обрамляющий его класс. Если вложенный класс оказывается полезен в каком-либо ином контексте, он должен стать классом верхнего уровня. Вложенные классы имеют доступ ко всем (в том числе приватным) полям и методам внешнего класса, но не наоборот. Из-за этого разрешения использование вложенных классов приводит к некоторому нарушению инкапсуляции.

Существуют четыре категории вложенных классов:
-- Static nested class (Статический вложенный класс);
-- Member inner class (Простой внутренний класс);
-- Local inner class (Локальный класс);
-- Anonymous inner class (Анонимный класс).

Такие категории классов, за исключением первого, также называют внутренними (Inner class). Внутренние классы ассоциируются не с внешним классом, а с экземпляром внешнего.
Каждая из категорий имеет рекомендации по своему применению. Если вложенный класс должен быть виден за пределами одного метода или он слишком длинный для того, чтобы его можно было удобно разместить в границах одного метода и если каждому экземпляру такого класса необходима ссылка на включающий его экземпляр, то используется нестатический внутренний класс. В случае, если ссылка на обрамляющий класс не требуется - лучше сделать такой класс статическим. Если класс необходим только внутри какого-то метода и требуется создавать экземпляры этого класса только в этом методе, то используется локальный класс. А, если к тому же применение класса сводится к использованию лишь в одном месте и уже существует тип, характеризующий этот класс, то рекомендуется делать его анонимным классом.
--------------------------------------------------------------------------------------------------------------------
Что такое «анонимные классы»? Где они применяются?

Это вложенный локальный класс без имени, который разрешено декларировать в любом месте обрамляющего класса, разрешающем размещение выражений. Создание экземпляра анонимного класса происходит одновременно с его объявлением. В зависимости от местоположения анонимный класс ведет себя как статический либо как нестатический вложенный класс - в нестатическом контексте появляется окружающий его экземпляр.

Анонимные классы имеют несколько ограничений:
- Их использование разрешено только в одном месте программы - месте его создания;
- Применение возможно только в том случае, если после порождения экземпляра нет необходимости на него ссылаться;
- Реализует лишь методы своего интерфейса или суперкласса, т.е. не может объявлять каких-либо новых методов, так как для доступа к ним нет поименованного типа.

Анонимные классы обычно применяются для:
- создания объекта функции (function object), например, реализация интерфейса Comparator;
- создания объекта процесса (process object), такого как экземпляры классов Thread, Runnable и подобных;
- в статическом методе генерации;
- инициализации открытого статического поля final, которое соответствует сложному перечислению типов, когда для каждого экземпляра в перечислении требуется отдельный подкласс.
--------------------------------------------------------------------------------------------------------------------
Каким образом из вложенного класса получить доступ к полю внешнего класса?

Статический вложенный класс имеет прямой доступ только к статическим полям обрамляющего класса.
Простой внутренний класс, может обратиться к любому полю внешнего класса напрямую. В случае, если у вложенного класса уже существует поле с таким же литералом, то обращаться к такому полю следует через ссылку на его экземпляр. Например: Outer.this.field.
--------------------------------------------------------------------------------------------------------------------
Верно ли утверждение, что примитивные типы данных всегда хранятся в стеке, а экземпляры ссылочных типов данных в куче?

Не совсем. Примитивное поле экземпляра класса хранится не в стеке, а в куче. Любой объект (всё, что явно или неявно создаётся при помощи оператора new) хранится в куче.

--------------------------------------------------------------------------------------------------------------------
Каким образом передаются переменные в методы, по значению или по ссылке?

В Java параметры всегда передаются только по значению, что определяется как «скопировать значение и передать копию». С примитивами это будет копия содержимого. Со ссылками - тоже копия содержимого, т.е. копия ссылки. При этом внутренние члены ссылочных типов через такую копию изменить возможно, а вот саму ссылку, указывающую на экземпляр - нет.

--------------------------------------------------------------------------------------------------------------------
Расскажите про приведение типов. Что такое понижение и повышение типа?

Java является строго типизированным языком программирования, а это означает, то что каждое выражение и каждая переменная имеет строго определенный тип уже на момент компиляции. Однако определен механизм приведения типов (casting) - способ преобразования значения переменной одного типа в значение другого типа.

В Java существуют несколько разновидностей приведения:
- Тождественное (identity). Преобразование выражения любого типа к точно такому же типу всегда допустимо и происходит автоматически.
- Расширение (повышение, upcasting) примитивного типа (widening primitive). Означает, что осуществляется переход от менее емкого типа к более ёмкому. Например, от типа byte (длина 1 байт) к типу int (длина 4 байта). Такие преобразование безопасны в том смысле, что новый тип всегда гарантировано вмещает в себя все данные, которые хранились в старом типе и таким образом не происходит потери данных. Этот тип приведения всегда допустим и происходит автоматически.
- Сужение (понижение, downcasting) примитивного типа (narrowing primitive). Означает, что переход осуществляется от более емкого типа к менее емкому. При таком преобразовании есть риск потерять данные. Например, если число типа int было больше 127, то при приведении его к byte значения битов старше восьмого будут потеряны. В Java такое преобразование должно совершаться явным образом, при этом все старшие биты, не умещающиеся в новом типе, просто отбрасываются - никакого округления или других действий для получения более корректного результата не производится.
- Расширение объектного типа (widening reference). Означает неявное восходящее приведение типов или переход от более конкретного типа к менее конкретному, т.е. переход от потомка к предку. Разрешено всегда и происходит автоматически.
- Сужение объектного типа (narrowing reference). Означает нисходящее приведение, то есть приведение от предка к потомку (подтипу). Возможно только если исходная переменная является подтипом приводимого типа. При несоответствии типов в момент выполнения выбрасывается исключение ClassCastException. Требует явного указания типа.
- Преобразование к строке (to String). Любой тип может быть приведен к строке, т.е. к экземпляру класса String.
- Запрещенные преобразования (forbidden). Не все приведения между произвольными типами допустимы. Например, к запрещенным преобразованиям относятся приведения от любого ссылочного типа к примитивному и наоборот (кроме преобразования к строке). Кроме того, невозможно привести друг к другу классы, находящиеся на разных ветвях дерева наследования и т.п.

При приведении ссылочных типов с самим объектом ничего не происходит, - меняется лишь тип ссылки, через которую происходит обращение к объекту.
Для проверки возможности приведения нужно воспользоваться оператором instanceof:
Parent parent = new Child();
if (parent instanceof Child) {
Child child = (Child) parent;
}
--------------------------------------------------------------------------------------------------------------------
Когда в приложении может быть выброшено исключение ClassCastException?

ClassCastException (потомок RuntimeException) - исключение, которое будет выброшено при ошибке приведения типа.

--------------------------------------------------------------------------------------------------------------------
Что такое литералы?

Литералы — это явно заданные значения в коде программы — константы определенного типа, которые находятся в коде в момент запуска.

class Test {
int a = 0b1101010110;
public static void main(String[] args) { System.out.println("Hello world!");
} }

В этом классе "Hello world!" — литерал.
Переменная a - тоже литерал.
Литералы бывают разных типов, которые определяются их назначением и способом написания.
--------------------------------------------------------------------------------------------------------------------
Что такое autoboxing («автоупаковка») в Java и каковы правила упаковки примитивных типов в классы-обертки?

Автоупаковка - это механизм неявной инициализации объектов классов-оберток (Byte, Short, Integer, Long, Float, Double, Character, Boolean) значениями соответствующих им исходных примитивных типов (byte, short, int...), без явного использования конструктора класса.
- Автоупаковка происходит при прямом присваивании примитива классу-обертке (с помощью оператора =), либо при передаче примитива в параметры метода (типа класса-обертки).
- Автоупаковке в классы-обертки могут быть подвергнуты как переменные примитивных типов, так и константы времени компиляции (литералы и final-примитивы). При этом литералы должны быть синтаксически корректными для инициализации переменной исходного примитивного типа.
- Автоупаковка переменных примитивных типов требует точного соответствия типа исходного примитива типу класса-обертки. Например, попытка упаковать переменную типа byte в Short, без предварительного явного приведения byte в short вызовет ошибку компиляции.
- Автоупаковка констант примитивных типов допускает более широкие границы соответствия. В этом случае компилятор способен предварительно осуществлять
  -- неявное расширение/сужение типа примитивов:
  неявное расширение/сужение исходного типа примитива до типа примитива, соответствующего классу-обертке (для преобразования int в Byte, сначала компилятор самостоятельно неявно сужает int к byte)
  -- автоупаковку примитива в соответствующий класс-обертку. Однако, в этом случае существуют два дополнительных ограничения: a) присвоение примитива обертке может производится только оператором = (нельзя передать такой примитив в параметры метода без явного приведения типов) b) тип левого операнда не должен быть старше чем Character, тип правого не должен старше, чем int: допустимо расширение/сужение byte в/из short, byte в/из char, short в/из char и только сужение byte из int, short из int, char из int. Все остальные варианты требуют явного приведения типов).

Дополнительной особенностью целочисленных классов-оберток, созданных автоупаковкой констант в диапазоне -128 ... +127 является то, что они кэшируются JVM. 
Поэтому такие обертки с одинаковыми значениями будут являться ссылками на один объект.
--------------------------------------------------------------------------------------------------------------------
Что такое класс Object? Какие в нем есть методы?

Object это базовый класс для всех остальных объектов в Java. Любой класс наследуется от Object и, соответственно, наследуют его методы:
public boolean equals(Object obj) - служит для сравнения объектов по значению;
int hashCode() - возвращает hash код для объекта;
String toString() - возвращает строковое представление объекта;
Class getClass() - возвращает класс объекта во время выполнения;
protected Object clone() - создает и возвращает копию объекта;
void notify() - возобновляет поток, ожидающий монитор;
void notifyAll() - возобновляет все потоки, ожидающие монитор;
void wait() - остановка вызвавшего метод потока до момента пока другой поток не вызовет метод notify() или notifyAll() для этого объекта;
void wait(long timeout) - остановка вызвавшего метод потока на определённое время или пока другой поток не вызовет метод notify() или notifyAll() для этого объекта;
void wait(long timeout, int nanos) - остановка вызвавшего метод потока на определённое время или пока другой поток не вызовет метод notify() или notifyAll() для этого объекта;
protected void finalize() - может вызываться сборщиком мусора в момент удаления объекта при сборке мусора.(Deprecated)
--------------------------------------------------------------------------------------------------------------------
Дайте определение понятию «конструктор».

Конструктор — это специальный метод, у которого отсутствует возвращаемый тип и который имеет то же имя, что и класс, в котором он используется. Конструктор вызывается при создании нового объекта класса и определяет действия необходимые для его инициализации.

--------------------------------------------------------------------------------------------------------------------
Что такое «конструктор по умолчанию»?

Если у какого-либо класса не определить конструктор, то компилятор сгенерирует конструктор без аргументов - так называемый «конструктор по умолчанию».
public class ClassName() {}
Если у класса уже определен какой-либо конструктор, то конструктор по умолчанию создан не будет и, если он необходим, его нужно описывать явно.
--------------------------------------------------------------------------------------------------------------------
Чем отличаются конструктор по-умолчанию, конструктор копирования и конструктор с параметрами?

У конструктора по умолчанию отсутствуют какие-либо аргументы. Конструктор копирования принимает в качестве аргумента уже существующий объект класса для последующего создания его клона. Конструктор с параметрами имеет в своей сигнатуре аргументы (обычно необходимые для инициализации полей класса).

--------------------------------------------------------------------------------------------------------------------
Где и как вы можете использовать приватный конструктор?

Приватный (помеченный ключевым словом private, скрытый) конструктор может использоваться публичным статическим методом генерации объектов данного класса. Также доступ к нему разрешён вложенным классам и может использоваться для их нужд.

--------------------------------------------------------------------------------------------------------------------
Что такое Reflection?

Рефлексия (Reflection) - это механизм получения данных о программе во время её выполнения (runtime). В Java Reflection осуществляется с помощью Java Reflection API, состоящего из классов пакетов java.lang и java.lang.reflect.

Возможности Java Reflection API:
- Определение класса объекта;
- Получение информации о модификаторах класса, полях, методах, конструкторах и суперклассах;
- Определение интерфейсов, реализуемых классом;
- Создание экземпляра класса;
- Получение и установка значений полей объекта;
- Вызов методов объекта;
- Создание нового массива.
--------------------------------------------------------------------------------------------------------------------
Зачем нужен equals(). Чем он отличается от операции ==?

Метод equals() - определяет отношение эквивалентности объектов.
При сравнении объектов с помощью == сравнение происходит лишь между ссылками. При сравнении по переопределённому разработчиком equals() - по внутреннему состоянию объекто
--------------------------------------------------------------------------------------------------------------------
Если вы хотите переопределить equals(), какие условия должны выполняться?

Метод equals() обозначает отношение эквивалентности объектов. Эквивалентным называется отношение, которое является симметричным, транзитивным и рефлексивным. Рефлексивность: для любого ненулевого x, x.equals(x) вернет true;
Транзитивность: для любого ненулевого x, y и z, если x.equals(y) и y.equals(z) вернет true, тогда и x.equals(z) вернет true;
Симметричность: для любого ненулевого x и y, x.equals(y) должно вернуть true, тогда и только тогда, когда y.equals(x) вернет true.
Также для любого ненулевого x, x.equals(null) должно вернуть false.
--------------------------------------------------------------------------------------------------------------------
Какими свойствами обладает порождаемое equals() отношение эквивалентности?

- Рефлексивность: для любой ссылки на значение x, x.equals(x) вернет true;
- Симметричность: для любых ссылок на значения x и y, x.equals(y) должно вернуть true, тогда и только тогда, когда y.equals(x) возвращает true.
- Транзитивность: для любых ссылок на значения x, y и z, если x.equals(y) и y.equals(z) возвращают true, тогда и x.equals(z) вернёт true;
- Непротиворечивость: для любых ссылок на значения х и у, если несколько раз вызвать х.equals(y), постоянно будет возвращаться значение true либо постоянно будет возвращаться значение false при условии, что никакая информация, используемая при сравнении объектов, не поменялась.

Для любой ненулевой ссылки на значение х выражение х.equals(null) должно возвращать false.

--------------------------------------------------------------------------------------------------------------------
Правила переопределения метода Object.equals().

1) Использование оператора == для проверки, является ли аргумент ссылкой на указанный объект. Если является, возвращается true. Если сравниваемый объект == null, должно вернуться false.
   2)Использование оператор instanceof и вызова метода getClass() для проверки, имеет ли аргумент правильный тип. Если не имеет, возвращается false.
3) Приведение аргумента к правильному типу. Поскольку эта операция следует за проверкой instanceof она гарантированно будет выполнена.
   4)Обход всех значимых полей класса и проверка того, что значение поля в текущем объекте и значение того же поля в проверяемом на эквивалентность аргументе соответствуют друг другу. Если проверки для всех полей прошли успешно, возвращается результат true, в противном случае - false.

По окончанию переопределения метода equals() следует проверить: является ли порождаемое отношение эквивалентности рефлексивным, симметричным, транзитивным и непротиворечивым? Если ответ отрицательный, метод подлежит соответствующей правке.

--------------------------------------------------------------------------------------------------------------------
Какая связь между hashCode() и equals()?

Равные объекты должны возвращать одинаковые хэш коды. При переопределении equals() нужно обязательно переопределять и метод hashCode().

--------------------------------------------------------------------------------------------------------------------
Что будет, если переопределить equals() не переопределяя hashCode()? Какие могут возникнуть проблемы?

Классы и методы, которые используют правила этого контракта могут работать некорректно. Так для HashMap это может привести к тому, что пара «ключ-значение», которая была в неё помещена при использовании нового экземпляра ключа не будет в ней найдена.

--------------------------------------------------------------------------------------------------------------------
Каким образом реализованы методы hashCode() и equals() в классе Object?

Реализация метода Object.equals() сводится к проверке на равенство двух ссылок:
public boolean equals(Object obj)
{
return (this == obj);
}

Реализация метода Object.hashCode() описана как native, т.е. определенной не с помощью Java кода и обычно возвращает адрес объекта в памяти:
public native int hashCode();
--------------------------------------------------------------------------------------------------------------------
Для чего нужен метод hashCode()?

Метод hashCode() необходим для вычисления хэш кода переданного в качестве входного параметра объекта. В Java это целое число, в более широком смысле - битовая строка фиксированной длины, полученная из массива произвольной длины. Этот метод реализован таким образом, что для одного и того же входного объекта, хэш код всегда будет одинаковым. Следует понимать, что в Java множество возможных хэш кодов ограничено типом int, а множество объектов ничем не ограничено. Из-за этого, вполне возможна ситуация, что хэш коды разных объектов могут совпасть:
- если хэш коды разные, то и объекты гарантированно разные;
- если хэш коды равны, то объекты могут не обязательно равны.
--------------------------------------------------------------------------------------------------------------------
Каковы правила переопределения метода Object.hashCode()?

Общий совет: выбирать поля, которые с большой долью вероятности будут различаться. Для этого необходимо использовать уникальные, лучше всего примитивные поля, например, такие как id, uuid. При этом нужно следовать правилу, если поля задействованы при вычислении hashCode(), то они должны быть задействованы и при выполнении equals().

--------------------------------------------------------------------------------------------------------------------
Могут ли у разных объектов быть одинаковые hashCode()?

Да, могут. Метод hashCode() не гарантирует уникальность возвращаемого значения. Ситуация, когда у разных объектов одинаковые хэш коды называется коллизией. Вероятность возникновения коллизии зависит от используемого алгоритма генерации хэш кода.

--------------------------------------------------------------------------------------------------------------------
В equals() требуется проверять, что аргумент equals(Object that) такого же типа что и сам объект. В чем разница между this.getClass() == that.getClass() и that instanceof MyClass?

Оператор instanceof сравнивает объект и указанный тип. Его можно использовать для проверки является ли данный объект экземпляром некоторого класса, либо экземпляром его дочернего класса, либо экземпляром класса, который реализует указанный интерфейс.
this.getClass() == that.getClass() проверяет два класса на идентичность, поэтому для корректной реализации контракта метода equals() необходимо использовать точное сравнение с помощью метода getClass().
--------------------------------------------------------------------------------------------------------------------
Есть класс Point{int x, y;}. Почему хэш код в виде 31 * x + y предпочтительнее чем x + y?

Множитель создает зависимость значения хэш кода от очередности обработки полей, что в итоге порождает лучшую хэш функцию.

--------------------------------------------------------------------------------------------------------------------
Расскажите про клонирование объектов.

Использование оператора присваивания не создает нового объекта, а лишь копирует ссылку на объект. Таким образом, две ссылки указывают на одну и ту же область памяти, на один и тот же объект. Для создания нового объекта с таким же состоянием используется клонирование объекта.
Класс Object содержит protected метод clone(), осуществляющий побитовое копирование объекта производного класса. Однако сначала необходимо переопределить метод clone() как public для обеспечения возможности его вызова. В переопределенном методе следует вызвать базовую версию метода super.clone(), которая и выполняет собственно клонирование.
Чтобы окончательно сделать объект клонируемым, класс должен реализовать интерфейс Cloneable. Интерфейс Cloneable не содержит методов относится к маркерным интерфейсам, а его реализация гарантирует, что метод clone() класса Object возвратит точную копию вызвавшего его объекта с воспроизведением значений всех его полей. В противном случае метод генерирует исключение CloneNotSupportedException. Следует отметить, что при использовании этого механизма объект создается без вызова конструктора.
Это решение эффективно только в случае, если поля клонируемого объекта представляют собой значения базовых типов и их обёрток или неизменяемых (immutable) объектных типов. Если же поле клонируемого типа является изменяемым ссылочным типом, то для корректного клонирования требуется другой подход. Причина заключается в том, что при создании копии поля оригинал и копия представляют собой ссылку на один и тот же объект. В этой ситуации следует также клонировать и сам объект поля класса.
Такое клонирование возможно только в случае, если тип атрибута класса также реализует интерфейс Cloneable и переопределяет метод clone(). Так как, если это будет иначе вызов метода невозможен из-за его недоступности. Отсюда следует, что если класс имеет суперкласс, то для реализации механизма клонирования текущего класса-потомка необходимо наличие корректной реализации такого механизма в суперклассе. При этом следует отказаться от использования объявлений final для полей объектных типов по причине невозможности изменения их значений при реализации клонирования.

Помимо встроенного механизма клонирования в Java для клонирования объекта можно использовать:
- Специализированный конструктор копирования - в классе описывается конструктор, который принимает объект этого же класса и инициализирует поля создаваемого объекта значениями полей переданного.
- Фабричный метод - (Factory method), который представляет собой статический метод, возвращающий экземпляр своего класса.
- Механизм сериализации - сохранение и последующее восстановление объекта в/из потока байтов.
--------------------------------------------------------------------------------------------------------------------
В чем отличие между поверхностным и глубоким клонированием?

Поверхностное копирование копирует настолько малую часть информации об объекте, насколько это возможно. По умолчанию, клонирование в Java является поверхностным, т.е. класс Object не знает о структуре класса, которого он копирует. Клонирование такого типа осуществляется JVM по следующим правилам:
- Если класс имеет только члены примитивных типов, то будет создана совершенно новая копия объекта и возвращена ссылка на этот объект.
- Если класс помимо членов примитивных типов содержит члены ссылочных типов, то тогда копируются ссылки на объекты этих классов. Следовательно, оба объекта будут иметь одинаковые ссылки.
  Глубокое копирование дублирует абсолютно всю информацию объекта:
- Нет необходимости копировать отдельно примитивные данные;
- Все члены ссылочного типа в оригинальном классе должны поддерживать клонирование. Для каждого такого члена при переопределении метода clone() должен вызываться super.clone();
- Если какой-либо член класса не поддерживает клонирование, то в методе клонирования необходимо создать новый экземпляр этого класса и скопировать каждый его член со всеми атрибутами в новый объект класса, по одному.
--------------------------------------------------------------------------------------------------------------------
Какой способ клонирования предпочтительней?

Наиболее безопасным и, следовательно, предпочтительным способом клонирования является использование специализированного конструктора копирования:
- Отсутствие ошибок наследования (не нужно беспокоиться, что у наследников появятся новые поля, которые не будут склонированы через метод clone());
- Поля для клонирования указываются явно;
- Возможность клонировать даже final поля.
--------------------------------------------------------------------------------------------------------------------
Почему метод clone() объявлен в классе Object, а не в интерфейсе Cloneable?

Метод clone() объявлен в классе Object с указанием модификатора native, чтобы обеспечить доступ к стандартному механизму поверхностного копирования объектов. Одновременно он объявлен и как protected, чтобы нельзя было вызвать этот метод у не переопределивших его объектов. Непосредственно интерфейс Cloneable является маркерным (не содержит объявлений методов) и нужен только для обозначения самого факта, что данный объект готов к тому, чтобы быть клонированным. Вызов переопределённого метода clone() у не Cloneable объекта вызовет выбрасывание CloneNotSupportedException.

--------------------------------------------------------------------------------------------------------------------
Что такое generics?

Generics - это технический термин, обозначающий набор свойств языка позволяющих определять и использовать обобщенные типы и методы. Обобщенные типы или методы отличаются от обычных тем, что имеют типизированные параметры.
Примером использования обобщенных типов может служить Java Collection Framework. Так, класс LinkedList<E> - типичный обобщенный тип. Он содержит параметр E, который представляет тип элементов, которые будут храниться в коллекции. Создание объектов обобщенных типов происходит посредством замены параметризированных типов реальными типами данных. Вместо того, чтобы просто использовать LinkedList, ничего не говоря о типе элемента в списке, предлагается использовать точное указание типа LinkedList<String>, LinkedList<Integer> и т.п.
--------------------------------------------------------------------------------------------------------------------
Какие механизмы обеспечивают безопасность в технологии Java?

В технологии Java безопасность обеспечивают следующие три механизма:
структурные функциональные возможности языка (например, проверка границ массивов, запрет на преобразования непроверенных типов, отсутствие указателей и т.д.).
средства контроля доступа, определяющие действия, которые разрешается или запрещается выполнять в коде (например, может ли код получать доступ к файлам, передавать данные по сети и т.д.).
механизм цифровой подписи, предоставляющий авторам возможность применять стандартные алгоритмы для аутентификации своих программ, а пользователям - точно определять, кто создал код и изменился ли он с момента его подписания.
--------------------------------------------------------------------------------------------------------------------
Что вы знаете о "диспетчере защиты" в Java?

В качестве диспетчера защиты служит класс, определяющий, разрешено ли коду выполнять ту или иную операцию. Ниже перечислены операции, подпадающие под контроль диспетчера защиты. Существует немало других проверок, выполняемых диспетчером защиты в библиотеке Java.

создание нового загрузчика классов.
выход из виртуальной машины.
получение доступа к члену другого класса с помощью рефлексии.
получение доступа к файлу.
установление соединения через сокет.
запуск задания на печать.
получение доступа к системному буферу обмена.
получение доступа к очереди событий в AWT.
обращение к окну верхнего уровня.
--------------------------------------------------------------------------------------------------------------------
Имеет ли смысл объявлять метод private final?

Нет, такой метод и так не виден для наследников, а значит не может быть ими переопределен.

--------------------------------------------------------------------------------------------------------------------
Какие примитивы есть в Java?

«Пустой» тип - void. Логический (булевый) тип.
bolean - 1 бит

Целы числа
byte - 8 бит
short - 16 бит
int - 32 бита
long - 64 бита

Числа с плавающей запятой.
float - 32 бита
double - 64 бита

Символы - для хранения литералов.
char - 16 бит
--------------------------------------------------------------------------------------------------------------------
В чём разница между intrinsic и native методами?

Методы, помеченные модификатором native, реализованны на нативном языке платофрмы (например, C++). Например, Object.hashCode.
Intrinsic-методы, у которых нет модификатора native, но которые во время исполнения заменяются нативной реализацией. Например, String.equals. Т.е. скорость работы этого метода будет отличаться в ситуациях, когда вы вызываете его через API или скопируете реализацию в собственный метод.
Начиная с 9-ой версии в HotSpot JVM существует аннотация @HotSpotIntrinsicCandidate для метода(или конструктора), которая указыает, что аннотируемый метод может (но гарантий в этом нет) стать intrinsic-методом в будущем.
--------------------------------------------------------------------------------------------------------------------
Что значит ключевое слово var?

Ключево слово var, введённо в Java 10, избавляет от указания типа локальной переменной (local-variable type inference). Пример. Выражение int i = 0 эквивалентно var i = 0;. При объяевления коллекций читаемость кода повышается var list = new ArrayList<Objet>(); Но, с другой стороны, при объявлении generics нельзя будет использовать сокращённый вариант без указания типа - <...>. В случаях, когда тип переменной не очевиден компилятору, будет выдана ошибка error: cannot infer type for local variable ....

--------------------------------------------------------------------------------------------------------------------
Какие алгоритмы сортировки массивов используются в Java?

Версия | Array.sort(primitives) | Array.sort(objects)
Java ...-6 | Quicksort | MergerSort
Java 7-... | DualPivotQuicksort | TimSort
--------------------------------------------------------------------------------------------------------------------
Чем объект отличается от примитивных типов данных?

Первое отличие: количество занимаемой памяти: примитивы занимают очень мало, ведь они содержат лишь собственное значение, в то время как объекты могут содержать очень и очень много различных значений: как примитивов, так и ссылок на другие объекты. Второе отличие: Java —это объектно-ориентированный язык, поэтому в ней все работает через взаимодействие между объектами, и примитивы тут не сильно вписываются (собственно, поэтому Java — это не 100% объектно-ориентированный язык). Третье, вытекающее со второго: так как Java ориентирована на взаимодействие между объектами, у этих объектов есть много различных механизмов для управления. Например, конструкторы, методы, исключения (которые работают в первую очередь с объектами), и т.д. Собственно, чтобы примитивы могли как-то ввязаться (работать) в этой объектно ориентированной среде и были придуманы обертки (wrappers) для примитивных типов (Integer, Character, Double, Boolean...)

--------------------------------------------------------------------------------------------------------------------
Что такое класс POJO?

POJO — Plain Old Java Object — старый добрый Java-объект: простой объект, класса, который не унаследован от какого-то специфического класса и не реализует никаких служебных интерфейсов сверх тех, которые нужны для бизнес-модели. Другими словами POJO класс — это просто класс без особых требований. Единственное требование — отсутствие различных наворотов, завязанных на определенном фреймворке. Как правило такие классы не наследуют от других классов (кроме классов POJO из того же пакета), не реализуют интерфейсов — иногда делается исключение для маркерных интерфейсов из стандартной библиотеки типа Serializable или Cloneable — не используют аннотаций и не зависят от сторонних библиотек. Но отмечу, что у POJO могут быть и методы с бизнес-логикой, и произвольного вида конструкторы. Если разрешить аннотации, не вносящие изменения в семантику класса (без которых назначение объекта и логика его работы не изменятся), к POJO также можно отнести Entity сущности JPA и объекты DTO, десериализуемые из XML или JSON, правила для которых заданы в аннотациях. Также для POJO классов желательно переопределить equals и hashCode, ведь это может помочь им лучше выполнять свою роль.

--------------------------------------------------------------------------------------------------------------------
Зачем нужны разные типы ссылок в Java?

Сильные, они же обычные, нужны для указания на объекты, которые должны обязательно оставаться в памяти всё то время, что эти ссылки на него существуют. Если не складывается, получите OutOfMemoryError.
Мягкие ссылки полезны для кэшей, чувствительных к доступному объёму оперативной памяти. Объекты по ним могут зачиститься, но только в случае необходимости. Например, если нужно насоздавать ещё объектов с сильными ссылками, а уже негде, лучше освободить кэш и замедлить работу, чем уронить процесс напрочь.
Слабые ссылки полезны для сопоставления объектов чему-нибудь без удерживания их от зачистки когда они больше не нужны (а-ля Map<Ключ, WeakRef<Значение>>). На возможность зачистки они не влияют вообще никак, слабые ссылки будут очищены при очередном запуске сборщика.
Фантомные ссылки возникают, когда объект уже признан мусором, финализирован и находится в процессе зачистки, о чём можно узнать с помощью класса Cleaner и выполнить в это время какие-то собственные действия.
Плюс общее правило: политика зачистки для некоего объекта и очистки ссылок на него определяется самыми жёсткими из всех ссылок, что на него указывают.
--------------------------------------------------------------------------------------------------------------------
Что такое «лямбда»? Какова структура и особенности использования лямбда-выражения?

Лямбда представляет собой набор инструкций, которые можно выделить в отдельную переменную и затем многократно вызвать в различных местах программы.
Основу лямбда-выражения составляет лямбда-оператор, который представляет стрелку ->. Этот оператор разделяет лямбда-выражение на две части: левая часть содержит список параметров выражения, а правая, собственно, представляет тело лямбда-выражения, где выполняются все действия.
Лямбда-выражение не выполняется само по себе, а образует реализацию метода, определенного в функциональном интерфейсе. При этом важно, что функциональный интерфейс должен содержать только один единственный метод без реализации.

interface Operationable { int calculate(int x, int y); }
public static void main(String[] args) {
Operationable operation = (x, y) -> x + y; int result = operation.calculate(10, 20); System.out.println(result); //30 }

По факту лямбда-выражения являются в некотором роде сокращенной формой внутренних анонимных классов, которые ранее применялись в Java.
Отложенное выполнение (deferred execution) лямбда-выражения- определяется один раз в одном месте программы, вызываются при необходимости, любое количество раз и в произвольном месте программы.
Параметры лямбда-выражения должны соответствовать по типу параметрам метода функционального интерфейса:
operation = (int x, int y) -> x + y; //При написании самого лямбда-выражения тип параметров разрешается не указывать: (x, y) -> x + y; //Если метод не принимает никаких параметров, то пишутся пустые скобки, например, () -> 30 + 20; //Если метод принимает только один параметр, то скобки можно опустить: n -> n * n;
Конечные лямбда-выражения не обязаны возвращать какое-либо значение.

interface Printable { void print(String s); }
public static void main(String[] args) {
Printable printer = s -> System.out.println(s); printer.print("Hello, world"); }

Блочные лямбда-выражения обрамляются фигурными скобками. В блочных лямбда-выражениях можно использовать внутренние вложенные блоки, циклы, конструкции if, switch, создавать переменные и т.д. Если блочное лямбда-выражение должно возвращать значение, то явным образом применяется оператор return:

Operationable operation = (int x, int y) -> { if (y == 0) { return 0; } else { return x / y; } };

Передача лямбда-выражения в качестве параметра метода:

interface Condition { boolean isAppropriate(int n); }
private static int sum(int[] numbers, Condition condition) { int result = 0; for (int i : numbers) {
if (condition.isAppropriate(i))
{ result += i; } } return result; }
public static void main(String[] args) { System.out.println(sum(new int[] {0, 1, 0, 3, 0, 5, 0, 7, 0, 9}, (n) -> n != 0)); }
--------------------------------------------------------------------------------------------------------------------
К каким переменным есть доступ у лямбда-выражений?

Доступ к переменным внешней области действия из лямбда-выражения очень схож к доступу из анонимных объектов. Можно ссылаться на:
- неизменяемые (effectively final - не обязательно помеченные как final) локальные переменные;
- поля класса;
- статические переменные.
  К методам по умолчанию реализуемого функционального интерфейса обращаться внутри лямбда-выражения запрещено.
--------------------------------------------------------------------------------------------------------------------
Как отсортировать список строк с помощью лямбда-выражения?

public static List<String> sort(List<String> list){ Collections.sort(list, (a, b) -> a.compareTo(b));
return list;
}
--------------------------------------------------------------------------------------------------------------------
Что такое «ссылка на метод»?

Если существующий в классе метод уже делает все, что необходимо, то можно воспользоваться механизмом method reference (ссылка на метод) для непосредственной передачи этого метода. Такая ссылка передается в виде:
имя_класса::имя_статического_метода для статического метода;
объект_класса::имя_метода для метода экземпляра;
название_класса::new для конструктора.
Результат будет в точности таким же, как в случае определения лямбда-выражения, которое вызывает этот метод.

private interface Measurable { public int length(String string); }
public static void main(String[] args) {
Measurable a = String::length; System.out.println(a.length("abc"));
}

Ссылки на методы потенциально более эффективны, чем использование лямбда-выражений. 
Кроме того, они предоставляют компилятору более качественную информацию о типе и при возможности выбора между использованием ссылки на существующий метод и использованием лямбда-выражения, следует всегда предпочитать использование ссылки на метод.
--------------------------------------------------------------------------------------------------------------------
Какие виды ссылок на методы вы знаете?

на статический метод;
на метод экземпляра;
на конструкторе.
--------------------------------------------------------------------------------------------------------------------
Объясните выражение System.out::println.

Данное выражение иллюстрирует механизм instance method reference: передачи ссылки на метод println() статического поля out класса System.

--------------------------------------------------------------------------------------------------------------------
Что такое «функциональные интерфейсы»?

Функциональный интерфейс - это интерфейс, который определяет только один абстрактный метод.
Чтобы точно определить интерфейс как функциональный, добавлена аннотация @FunctionalInterface, работающая по принципу @Override. Она обозначит замысел и не даст определить второй абстрактный метод в интерфейсе.
Интерфейс может включать сколько угодно default методов и при этом оставаться функциональным, потому что default методы - не абстрактные.
--------------------------------------------------------------------------------------------------------------------
Для чего нужны функциональные интерфейсы Function<T,R>, DoubleFunction<R>, IntFunction<R> и LongFunction<R>?

Function<T, R> - интерфейс, с помощью которого реализуется функция, получающая на вход экземпляр класса T и возвращающая на выходе экземпляр класса R.
Методы по умолчанию могут использоваться для построения цепочек вызовов (compose, andThen).

Типичный пример метода в Stream c аргументом Function — метод map, который принимает элементы одного типа, что-то с ними делает и передает дальше, но это уже могут быть элементы другого типа.

Function<String, Integer> toInteger = Integer::valueOf; Function<String, String> backToString = toInteger.andThen(String::valueOf); backToString.apply("123"); // "123"

DoubleFunction<R> - функция, получающая на вход Double и возвращающая на выходе экземпляр класса R;
IntFunction<R> - функция, получающая на вход Integer и возвращающая на выходе экземпляр класса R;
LongFunction<R> - функция, получающая на вход Long и возвращающая на выходе экземпляр класса R.
--------------------------------------------------------------------------------------------------------------------
Для чего нужны функциональные интерфейсы UnaryOperator<T>, DoubleUnaryOperator, IntUnaryOperator и LongUnaryOperator?

UnaryOperator<T> (унарный оператор) принимает в качестве параметра объект типа T, выполняет над ними операции и возвращает результат операций в виде объекта типа T:

В качестве метода, использующего UnaryOperator как аргумент, возьмем метод класса Stream — iterate.

UnaryOperator<Integer> operator = x -> x * x; System.out.println(operator.apply(5)); // 25

DoubleUnaryOperator - унарный оператор, получающий на вход Double;
IntUnaryOperator - унарный оператор, получающий на вход Integer;
LongUnaryOperator - унарный оператор, получающий на вход Long.
--------------------------------------------------------------------------------------------------------------------
Для чего нужны функциональные интерфейсы BinaryOperator<T>, DoubleBinaryOperator, IntBinaryOperator и LongBinaryOperator?

BinaryOperator<T> (бинарный оператор) - интерфейс, с помощью которого реализуется функция, получающая на вход два экземпляра класса T и возвращающая на выходе экземпляр класса T.

BinaryOperator<Integer> operator = (a, b) -> a + b; System.out.println(operator.apply(1, 2)); // 3

DoubleBinaryOperator - бинарный оператор, получающий на вход Double;
IntBinaryOperator - бинарный оператор, получающий на вход Integer;
LongBinaryOperator - бинарный оператор, получающий на вход Long.
--------------------------------------------------------------------------------------------------------------------
Для чего нужны функциональные интерфейсы Predicate<T>, DoublePredicate, IntPredicate и LongPredicate?

Predicate<T> (предикат) - интерфейс, с помощью которого реализуется функция, получающая на вход экземпляр класса T и возвращающая на выходе значение типа boolean.
Интерфейс содержит различные методы по умолчанию, позволяющие строить сложные условия (and, or, negate).

Для примера возьмем метод класса Stream — filter, который в качестве аргумента принимает Predicate и возвращает Stream только с теми элементами, которые удовлетворяют условию Predicate. В контексте Stream-а это означает, что он пропускает только те элементы, которые возвращают true при использовании их в методе test интерфейса Predicate.

Predicate<String> predicate = (s) -> s.length() > 0; predicate.test("foo"); // true predicate.negate().test("foo"); // false

DoublePredicate - предикат, получающий на вход Double;
IntPredicate - предикат, получающий на вход Integer;
LongPredicate - предикат, получающий на вход Long.
--------------------------------------------------------------------------------------------------------------------
Для чего нужны функциональные интерфейсы Consumer<T>, DoubleConsumer, IntConsumer и LongConsumer?

Consumer<T> (потребитель) - интерфейс, с помощью которого реализуется функция, которая получает на вход экземпляр класса T, производит с ним некоторое действие и ничего не возвращает.

Одним из методом в Stream, который использует функциональный интерфейс Consumer, является метод peek.
Consumer<String> hello = (name) -> System.out.println("Hello, " + name); hello.accept("world");

DoubleConsumer - потребитель, получающий на вход Double;
IntConsumer - потребитель, получающий на вход Integer;
LongConsumer - потребитель, получающий на вход Long.
--------------------------------------------------------------------------------------------------------------------
Для чего нужны функциональные интерфейсы Supplier<T>, BooleanSupplier, DoubleSupplier, IntSupplier и LongSupplier?

Supplier<T> (поставщик) - интерфейс, с помощью которого реализуется функция, ничего не принимающая на вход, но возвращающая на выход результат класса T;

Примером метода в Stream, использующего функциональный интерфейс Supplier, является generate, который генерирует бесконечную последовательность на основе переданного ему функционального интерфейса.

Supplier<LocalDateTime> now = LocalDateTime::now; now.get();

DoubleSupplier - поставщик, возвращающий Double;
IntSupplier - поставщик, возвращающий Integer;
LongSupplier - поставщик, возвращающий Long.
--------------------------------------------------------------------------------------------------------------------
Что такое StringJoiner?

Класс StringJoiner используется, чтобы создать последовательность строк, разделенных разделителем с возможностью присоединить к полученной строке префикс и суффикс:

StringJoiner joiner = new StringJoiner(".", "prefix-", "-suffix");
for (String s : "Hello the brave world".split(" ")) { joiner.add(s); }
System.out.println(joiner);
--------------------------------------------------------------------------------------------------------------------
Что такое default методы интрефейса?

Java 8 позволяет добавлять неабстрактные реализации методов в интерфейс, используя ключевое слово default:

interface Example { int process(int a);
default void show() { System.out.println("default show()"); } }

- Если класс реализует интерфейс, он может, но не обязан, реализовать методы по-умолчанию, уже реализованные в интерфейсе. Класс наследует реализацию по умолчанию.
- Если некий класс реализует несколько интерфейсов, которые имеют одинаковый метод по умолчанию, то класс должен реализовать метод с совпадающей сигнатурой самостоятельно. Ситуация аналогична, если один интерфейс имеет метод по умолчанию, а в другом этот же метод является абстрактным - никакой реализации по умолчанию классом не наследуется.
- Метод по умолчанию не может переопределить метод класса java.lang.Object.
- Помогают реализовывать интерфейсы без страха нарушить работу других классов.
- Позволяют избежать создания служебных классов, так как все необходимые методы могут быть представлены в самих интерфейсах.
- Дают свободу классам выбрать метод, который нужно переопределить.
- Одной из основных причин внедрения методов по умолчанию является возможность коллекций в Java 8 использовать лямбда-выражения.
--------------------------------------------------------------------------------------------------------------------
Как вызывать default метод интерфейса в реализующем этот интерфейс классе?

Используя ключевое слово super вместе с именем интерфейса:

interface Paper { default void show() { System.out.println("default show()"); } }
class Licence implements Paper {
public void show() { Paper.super.show(); } }
--------------------------------------------------------------------------------------------------------------------
Что такое static метод интерфейса?

Статические методы интерфейса похожи на методы по умолчанию, за исключением того, что для них отсутствует возможность переопределения в классах, реализующих интерфейс.
- Статические методы в интерфейсе являются частью интерфейса без возможности использовать их для объектов класса реализации;
- Методы класса java.lang.Object нельзя переопределить как статические;
- Статические методы в интерфейсе используются для обеспечения вспомогательных методов, например, проверки на null, сортировки коллекций и т.д.
--------------------------------------------------------------------------------------------------------------------
Как вызывать static метод интерфейса?

Используя имя интерфейса:
interface Paper { static void show() { System.out.println("static show()"); } }
class Licence {
public void showPaper() { Paper.show(); }
}
--------------------------------------------------------------------------------------------------------------------
Что такое Optional?

Опциональное значение Optional — это контейнер для объекта, который может содержать или не содержать значение null. Такая обёртка является удобным средством предотвращения NullPointerException, т.к. имеет некоторые функции высшего порядка, избавляющие от добавления повторяющихся if null/notNull проверок:

Optional<String> optional = Optional.of("hello"); optional.isPresent(); // true optional.ifPresent(s -> System.out.println(s.length())); // 5 optional.get(); // "hello" optional.orElse("ops..."); // "hello"

--------------------------------------------------------------------------------------------------------------------
Что такое LocalDateTime?

LocalDateTime объединяет вместе LocaleDate и LocalTime, содержит дату и время в календарной системе ISO-8601 без привязки к часовому поясу. Время хранится с точностью до наносекунды. Содержит множество удобных методов, таких как plusMinutes, plusHours, isAfter, toSecondOfDay и т.д.

--------------------------------------------------------------------------------------------------------------------
Что такое ZonedDateTime?

java.time.ZonedDateTime — аналог java.util.Calendar, класс с самым полным объемом информации о временном контексте в календарной системе ISO-8601. Включает временную зону, поэтому все операции с временными сдвигами этот класс проводит с её учётом.

--------------------------------------------------------------------------------------------------------------------
Как получить текущую дату с использованием Date Time API из Java 8?

LocalDate.now();

--------------------------------------------------------------------------------------------------------------------
Как добавить 1 неделю, 1 месяц, 1 год, 10 лет к текущей дате с использованием Date Time API?

LocalDate.now().plusWeeks(1); LocalDate.now().plusMonths(1); LocalDate.now().plusYears(1); LocalDate.now().plus(1, ChronoUnit.DECADES);

--------------------------------------------------------------------------------------------------------------------
Как получить следующий вторник используя Date Time API?

LocalDate.now().with(TemporalAdjusters.next(DayOfWeek.TUESDAY));

--------------------------------------------------------------------------------------------------------------------
Как получить вторую субботу текущего месяца используя Date Time API?

LocalDate .of(LocalDate.now().getYear(), LocalDate.now().getMonth(), 1) .with(TemporalAdjusters.nextOrSame(DayOfWeek.SATURDAY)) .with(TemporalAdjusters.next(DayOfWeek.SATURDAY));

--------------------------------------------------------------------------------------------------------------------
Как получить текущее время с точностью до миллисекунд используя Date Time API

new Date().toInstant();

--------------------------------------------------------------------------------------------------------------------
Как получить текущее время по местному времени с точностью до миллисекунд используя Date Time API?

LocalDateTime.ofInstant(new Date().toInstant(), ZoneId.systemDefault());

--------------------------------------------------------------------------------------------------------------------