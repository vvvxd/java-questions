## Оглавление

1. [Дайте определение понятию "исключение"](#1-дайте-определение-понятию-исключение)
2. [Какова внутренняя структура исключений?](#2-какова-внутренняя-структура-исключений)
3. [Как работает выброс исключения (throw)?](#3-как-работает-выброс-исключения-throw)
4. [Расскажи про обработку исключений?](#4-расскажи-про-обработку-исключений)
5. [Какая производительность исключений?](#5-какая-производительность-исключений)
6. [Актуальные особенности исключений (Java 21 и новее)?](#6-актуальные-особенности-исключений-java-21-и-новее)
7. [Цепочки исключений как работает?](#7-цепочки-исключений-как-работает)
8. [Опишите иерархию исключений](#8-опишите-иерархию-исключений)
9. [Какие виды исключений в Java вы знаете, чем они отличаются?](#9-какие-виды-исключений-в-java-вы-знаете-чем-они-отличаются)
10. [Может ли метод main() выбросить исключение во вне и если да, то где будет происходить обработка данного исключения?](#10-может-ли-метод-main-выбросить-исключение-во-вне-и-если-да-то-где-будет-происходить-обработка-данного-исключения)
11. [Какие исключения когда стоит использовать?](#11-какие-исключения-когда-стоит-использовать)
12. [Проверяемые и непроверяемые](#12-проверяемые-и-непроверяемые)
13. [Лучший способ работать с исключениями](#13-лучший-способ-работать-с-исключениями)
14. [Почему переменные, определенные в try, не могут быть использованы в catch или finally?](#14-почему-переменные-определенные-в-try-не-могут-быть-использованы-в-catch-или-finally)
15. [Почему Double.parseDouble(null) и Integer.parseInt(null) вызывают разные исключения?](#15-почему-doubleparsedouble-null-и-integerparseint-null-вызывают-разные-исключения)
16. [Как написать собственное («пользовательское») исключение?](#16-как-написать-собственное-пользовательское-исключение)
17. [Какие существуют unchecked exception?](#17-какие-существуют-unchecked-exception)
18. [О чем говорит ключевое слово throws?](#18-о-чем-говорит-ключевое-слово-throws)
19. [Какой оператор позволяет принудительно выбросить исключение?](#19-какой-оператор-позволяет-принудительно-выбросить-исключение)
20. [Что такое Error?](#20-что-такое-error)
21. [Что вы знаете о OutOfMemoryError?](#21-что-вы-знаете-о-outofmemoryerror)
22. [Опишите работу блока try-catch-finally](#22-опишите-работу-блока-try-catch-finally)
23. [Что такое механизм try-with-resources?](#23-что-такое-механизм-try-with-resources)
24. [Возможно ли использование блока try-finally (без catch)?](#24-возможно-ли-использование-блока-try-finally-без-catch)
25. [Может ли один блок catch отлавливать сразу несколько исключений?](#25-может-ли-один-блок-catch-отлавливать-сразу-несколько-исключений)
26. [Всегда ли исполняется блок finally?](#26-всегда-ли-исполняется-блок-finally)
27. [Может ли метод main() выбросить исключение во вне и если да, то где будет происходить обработка данного исключения?](#27-может-ли-метод-main-выбросить-исключение-во-вне-и-если-да-то-где-будет-происходить-обработка-данного-исключения)
28. [Предположим, есть метод, который может выбросить IOException и FileNotFoundException, в какой последовательности должны идти блоки catch? Сколько блоков catch будет выполнено?](#28-предположим-есть-метод-который-может-выбросить-ioexception-и-filenotfoundexception-в-какой-последовательности-должны-идти-блоки-catch-сколько-блоков-catch-будет-выполнено)
29. [Какие существуют способы обработки исключений?](#29-какие-существуют-способы-обработки-исключений)
30. [В чем особенность блока finally? Всегда ли он исполняется?](#30-в-чем-особенность-блока-finally-всегда-ли-он-исполняется)
31. [В чем особенность RuntimeException?](#31-в-чем-особенность-runtimeexception)
32. [Есть ли дополнительные условия к методу, который потенциально может выбросить исключение?](#32-есть-ли-дополнительные-условия-к-методу-который-потенциально-может-выбросить-исключение)
33. [Если оператор return содержится и в блоке catch и в finally, какой из них "главнее"?](#33-если-оператор-return-содержится-и-в-блоке-catch-и-в-finally-какой-из-них-главнее)
34. [Что вы знаете о SQLException? К какому типу checked или unchecked оно относится, почему?](#34-что-вы-знаете-о-sqlexception-к-какому-типу-checked-или-unchecked-оно-относится-почему)
35. [Предположим, есть блок try-finally. В блоке try возникло исключение и выполнение переместилось в блок finally. В блоке finally тоже возникло исключение. Какое из двух исключений "выпадет" из блока try-finally? Что случится со вторым исключением?](#35-предположим-есть-блок-try-finally-в-блоке-try-возникло-исключение-и-выполнение-переместилось-в-блок-finally-в-блоке-finally-тоже-возникло-исключение-какое-из-двух-исключений-выпадет-из-блока-try-finally-что-случится-со-вторым-исключением)
36. [Какие есть правила для проверки исключений при наследовании?](#36-какие-есть-правила-для-проверки-исключений-при-наследовании)
37. [Полезные советы по обработке исключений в Java](#37-полезные-советы-по-обработке-исключений-в-java)

---

## 1. Дайте определение понятию "исключение"

Исключение — это объект, представляющий ошибку или нештатную ситуацию, наследующийся от класса `java.lang.Throwable`. В Java существуют два типа исключений:

- **Error**: Серьёзные системные ошибки, которые обычно не обрабатываются (например, `OutOfMemoryError`, `StackOverflowError`).
- **Exception**: Ошибки, которые можно обрабатывать. Делятся на:
    - **Checked exceptions** (проверяемые, наследуются от `Exception`, но не от `RuntimeException`, например, `IOException`).
    - **Unchecked exceptions** (непроверяемые, наследуются от `RuntimeException`, например, `NullPointerException`).

**Пример:**
```java
public class Example {
    public static void main(String[] args) {
        try {
            throw new RuntimeException("Error occurred!");
        } catch (RuntimeException e) {
            System.out.println(e.getMessage()); // Error occurred!
        }
    }
}
```

[Назад к оглавлению](#оглавление)

---

## 2. Какова внутренняя структура исключений?

### 2.1. Класс Throwable

Все исключения наследуются от `java.lang.Throwable`. Его структура в OpenJDK 21:

```java
public class Throwable implements Serializable {
    private StackTraceElement[] stackTrace; // Трассировка стека
    private final String detailMessage; // Сообщение об ошибке
    private Throwable cause; // Причина исключения
    private transient Object backtrace; // Внутренние данные JVM
    // Другие поля и методы
}
```

- **Поля**:
    - `stackTrace`: Массив `StackTraceElement` с информацией о стеке вызовов (класс, метод, файл, строка).
    - `detailMessage`: Строка с описанием ошибки.
    - `cause`: Другое исключение, вызвавшее текущее (для цепочек исключений).
    - `backtrace`: Внутреннее поле для JVM, хранит низкоуровневые данные о стеке (не доступно в Java).
- **Конструкторы**:
    - `Throwable()`: Без параметров.
    - `Throwable(String message)`: С сообщением.
    - `Throwable(String message, Throwable cause)`: С сообщением и причиной.
    - `Throwable(Throwable cause)`: С причиной.
- **Основные методы**:
    - `getMessage()`: Возвращает `detailMessage`.
    - `getCause()`: Возвращает `cause`.
    - `getStackTrace()`: Возвращает массив `StackTraceElement`.
    - `printStackTrace()`: Выводит трассировку в консоль.
    - `fillInStackTrace()`: Заполняет `stackTrace` текущим стеком вызовов.

### 2.2. Создание исключения

- При создании объекта исключения JVM:
    1. Выделяет память для объекта `Throwable` или его подкласса (~24 байта заголовок + поля, например, ~80 байт для `RuntimeException` с сообщением).
    2. Инициализирует `detailMessage` и `cause` (если указаны).
    3. Вызывает `fillInStackTrace()`, чтобы зафиксировать текущий стек вызовов.

- **`fillInStackTrace`**:
    - Захватывает стек вызовов через низкоуровневые механизмы JVM (например, `walk_stack` в HotSpot).
    - Создаёт массив `StackTraceElement` (~48 байт на элемент), содержащий:
        - Имя класса.
        - Имя метода.
        - Имя файла и номер строки (если доступны).
    - Это **дорогая операция** (O(n), где n — глубина стека), так как требует обхода стека и аллокации памяти.

[Назад к оглавлению](#оглавление)

---

## 3. Как работает выброс исключения (throw)?

### 3.1. Синтаксис и компиляция

- Оператор `throw` выбрасывает объект, наследующий `Throwable`:
  ```java
  throw new RuntimeException("Error!");
  ```
- Компилятор (`javac`) преобразует `throw` в байт-код с инструкцией `athrow`.

### 3.2. Байт-код

Пример метода:
```java
public void method() {
    throw new RuntimeException("Error!");
}
```

Байт-код (упрощённый):
```
0: new           #2  // class java/lang/RuntimeException
3: dup
4: ldc           #3  // String Error!
6: invokespecial #4  // Method java/lang/RuntimeException."<init>":(Ljava/lang/String;)V
9: athrow
```

- **Создание**:
    - `new`: Создаёт объект `RuntimeException`.
    - `ldc`: Загружает строку `"Error!"`.
    - `invokespecial`: Вызывает конструктор.
- **Выброс**:
    - `athrow`: Передаёт управление JVM для обработки исключения.

### 3.3. Работа JVM

При выполнении `athrow` JVM:
1. **Проверяет объект**:
    - Убеждается, что объект наследует `Throwable`, иначе выбрасывается `IllegalArgumentException`.
2. **Ищет обработчик**:
    - Анализирует таблицу исключений (exception table) текущего метода, сгенерированную компилятором.
    - Таблица содержит:
        - Диапазон байт-кода (`from`, `to`).
        - Тип исключения (или `any` для всех).
        - Адрес обработчика (`target` — байт-код для `catch`).
    - Пример таблицы:
      ```
      Exception table:
         from    to  target type
             0     5     8   Class java/lang/RuntimeException
      ```
3. **Передача управления**:
    - Если обработчик найден, JVM передаёт управление в блок `catch`, помещая исключение на стек.
    - Если обработчик не найден, JVM **разворачивает стек** (stack unwinding), переходя к вызывающему методу, и повторяет поиск.
4. **Необработанные исключения**:
    - Если обработчик не найден в цепочке вызовов, исключение передаётся `Thread.UncaughtExceptionHandler`.
    - По умолчанию выводится в `System.err` через `printStackTrace`, и поток завершается.

[Назад к оглавлению](#оглавление)

---

## 4. Расскажи про обработку исключений?

### 4.1. Синтаксис

```java
try {
    riskyOperation();
} catch (RuntimeException e) {
    handleError(e);
} finally {
    cleanup();
}
```

### 4.2. Компиляция

- Компилятор создаёт байт-код для `try`, `catch` и `finally`, используя таблицу исключений и инструкции перехода (`goto`).
- Для `finally` код дублируется для всех путей выхода из `try` или `catch`, так как инструкция `jsr` (использовавшаяся в Java 6 и ранее) устарела.
- Пример байт-кода:
  ```
  0: invokestatic  #5  // riskyOperation()
  3: goto          11
  6: astore_1      // Сохранить исключение в e
  7: invokestatic  #6  // handleError(Throwable)
  10: nop
  11: invokestatic  #7 // cleanup()
  14: return
  Exception table:
     from    to  target type
         0     3     6   Class java/lang/RuntimeException
  ```

### 4.3. Работа JVM

- Если исключение выбрасывается в `try`, JVM проверяет таблицу исключений.
- При совпадении типа исключения с `catch` управление передаётся в соответствующий блок.
- `finally` выполняется **всегда** (при нормальном завершении, исключении или `return`), за счёт дублирования кода в байт-коде.

### 4.4. Оптимизации

- **Инлайнинг `finally`**: JVM встраивает код `finally`, минимизируя накладные расходы.
- **JIT-компиляция**: JIT-компилятор оптимизирует обработчики, инлайнируя быстрые пути и удаляя ненужные проверки.
- **Лёгкие исключения**: JVM может пропускать `fillInStackTrace` для оптимизированных исключений.

[Назад к оглавлению](#оглавление)

---

## 5. Какая производительность исключений?

Исключения в Java — дорогостоящий механизм, особенно при частом выбросе. Рассмотрим ключевые аспекты:

### 5.1. Создание исключения

- **fillInStackTrace**:
    - Захват стека — O(n), где n — глубина стека.
    - Создание `StackTraceElement` требует аллокации (~48 байт на элемент).
- Оптимизация:
    - Переопределение `fillInStackTrace` для "лёгких" исключений:
      ```java
      public class LightweightException extends RuntimeException {
          @Override
          public Throwable fillInStackTrace() {
              return this; // Без трассировки
          }
      }
      ```

### 5.2. Выброс и обработка

- **Поиск обработчика**: O(1) для текущего метода, O(n) при разворачивании глубокого стека.
- **Передача управления**: Быстрая, но JIT-деоптимизация может добавить задержки.
- **Разворачивание стека**: Затраты растут с глубиной стека.

### 5.3. Память

- **Объект исключения**:
    - `RuntimeException`: ~80 байт (12 байт заголовок + 8 `stackTrace` + 8 `detailMessage` + 8 `cause` + ~44 байт для строки).
    - Трассировка: ~48 байт на `StackTraceElement` * глубина (например, 50 элементов = ~2.4 КБ).
- Итого: ~2-5 КБ для типичного исключения.

### 5.4. Оптимизации в HotSpot JVM (Java 21+)

- **Zero-Fill Stack Trace**:
    - JVM может пропускать трассировку для внутренних исключений, если они не используются.
- **Кэширование стека**:
    - Повторяющиеся трассировки кэшируются для часто выбрасываемых исключений.
- **Виртуальные потоки (Project Loom)**:
    - Виртуальные потоки (стабильны в Java 21) имеют компактный стек, снижая затраты на трассировку.
    - Однако глубокие стеки в виртуальных потоках всё ещё могут быть дорогими.

[Назад к оглавлению](#оглавление)

---

## 6. Актуальные особенности исключений (Java 21 и новее)?

На основе Java 21 и предполагаемых улучшений в Java 22/23:

### 6.1. Виртуальные потоки (JEP 444, Java 21)

- Виртуальные потоки используют "лёгкие" стеки, что уменьшает затраты на захват трассировки.
- Исключения в виртуальных потоках обрабатываются так же, но с меньшими накладными расходами для неглубоких стеков.
- Пример:
  ```java
  try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
      executor.submit(() -> { throw new RuntimeException("Error in virtual thread"); });
  } catch (Exception e) {
      e.printStackTrace();
  }
  ```

### 6.2. Structured Concurrency (JEP 453, инкубатор в Java 21)

- Упрощает обработку исключений в многопоточных приложениях, автоматически распространяя ошибки от дочерних задач.
- Пример:
  ```java
  try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {
      scope.fork(() -> { throw new RuntimeException("Task failed"); });
      scope.join();
      scope.throwIfFailed();
  } catch (Exception e) {
      // Обработка
  }
  ```

### 6.3. Pattern Matching (JEP 441, Java 21)

- Pattern matching для `instanceof` и `switch` упрощает обработку исключений:
  ```java
  try {
      riskyOperation();
  } catch (Exception e) {
      switch (e) {
          case IOException io -> System.out.println("IO: " + io.getMessage());
          case RuntimeException re -> System.out.println("Runtime: " + re.getMessage());
          default -> System.out.println("Other");
      }
  }
  ```
- JVM оптимизирует такие конструкции через эффективный байт-код.

### 6.4. Deprecation of finalize() (JEP 421, Java 18)

- Финализация устарела, что поощряет использование `try-with-resources` для управления ресурсами, снижая вероятность исключений, связанных с финализацией.

### 6.5. Потенциальные улучшения в Java 22/23

- **Оптимизации JIT**:
    - В последних версиях HotSpot JVM улучшено инлайнинг обработчиков и управление стеком, что снижает накладные расходы.
- **Project Valhalla (будущее)**:
    - Хотя примитивные типы и value objects ещё не полностью внедрены, они могут повлиять на аллокацию памяти для исключений в будущем.
- **Улучшения Loom**:
    - Дальнейшая оптимизация виртуальных потоков может уменьшить затраты на исключения в многопоточных приложениях.

[Назад к оглавлению](#оглавление)

---

## 7. Цепочки исключений как работает?

Поддержка **chaining** позволяет указывать причину исключения:

```java
try {
    throw new IOException("File error");
} catch (IOException e) {
    throw new RuntimeException("Operation failed", e);
}
```

- **Реализация**:
    - Поле `cause` хранит ссылку на исходное исключение.
    - `initCause(Throwable)` задаёт причину после создания (если не задана в конструкторе).
    - `printStackTrace` выводит полную цепочку.
- **Память**: +8 байт на ссылку `cause`.

[Назад к оглавлению](#оглавление)

---

## 8. Опишите иерархию исключений

Все классы-исключения расширяют класс `Throwable` — непосредственное расширение класса `Object`. У класса `Throwable` и у всех его расширений по традиции два конструктора:

- `Throwable()` — конструктор по умолчанию.
- `Throwable(String message)` — создаваемый объект будет содержать произвольное сообщение `message`.

Записанное в конструкторе сообщение можно получить затем методом `getMessage()`. Если объект создавался конструктором по умолчанию, то данный метод возвратит `null`. Метод `toString` возвращает краткое описание события, именно он работал в предыдущих листингах.

Три метода выводят сообщения обо всех методах, встретившихся по пути "полета" исключения:

- `printStackTrace()` — выводит сообщения в стандартный вывод, как правило, это консоль.
- `printStackTrace(PrintStream stream)` — выводит сообщения в байтовый поток `stream`.
- `printStackTrace(PrintWriter stream)` — выводит сообщения в символьный поток `stream`.

У класса `Throwable` два непосредственных наследника — классы `Error` и `Exception`. Они не добавляют новых методов, а служат для разделения классов-исключений на два больших семейства — семейство классов-ошибок (`Error`) и семейство собственно классов-исключений (`Exception`).

Классы-ошибки, расширяющие класс `Error`, свидетельствуют о возникновении сложных ситуаций в виртуальной машине Java. Их обработка требует глубокого понимания всех тонкостей работы JVM. Её не рекомендуется выполнять в обычной программе. Не советуют даже выбрасывать ошибки оператором `throw`. Не следует делать свои классы-исключения расширениями класса `Error` или какого-то его подкласса. Имена классов-ошибок, по соглашению, заканчиваются словом `Error`.

Классы-исключения, расширяющие класс `Exception`, отмечают возникновение обычной нештатной ситуации, которую можно и даже нужно обработать. Такие исключения следует выбросить оператором `throw`. Классов-исключений очень много, более двухсот. Они разбросаны буквально по всем пакетам J2SDK. В большинстве случаев вы способны подобрать готовый класс-исключение для обработки исключительных ситуаций в своей программе. При желании можно создать и свой класс-исключение, расширив класс `Exception` или любой его подкласс.

Среди классов-исключений выделяется класс `RuntimeException` — прямое расширение класса `Exception`. В нем и его подклассах отмечаются исключения, возникшие при работе JVM, но не столь серьезные, как ошибки. Их можно обрабатывать и выбрасывать, расширять своими классами, но лучше доверить это JVM, поскольку чаще всего это просто ошибка в программе, которую надо исправить. Особенность исключений данного класса в том, что их не надо отмечать в заголовке метода пометкой `throws`. Имена классов-исключений, по соглашению, заканчиваются словом `Exception`.

[Назад к оглавлению](#оглавление)

---

## 9. Какие виды исключений в Java вы знаете, чем они отличаются?

Все исключительные ситуации можно разделить на две категории: проверяемые (`checked`) и непроверяемые (`unchecked`). Все исключения, порождаемые от `Throwable`, можно разбить на три группы. Они определяются тремя базовыми типами: наследниками `Throwable` — классами `Error` и `Exception`, а также наследником `Exception` — `RuntimeException`.

Ошибки, порожденные от `Exception` (и не являющиеся наследниками `RuntimeException`), являются проверяемыми. Т.е. во время компиляции проверяется, предусмотрена ли обработка возможных исключительных ситуаций. Как правило, это ошибки, связанные с окружением программы (сетевым, файловым вводом-выводом и др.), которые могут возникнуть вне зависимости от того, корректно написан код или нет. Например, открытие сетевого соединения или файла может привести к возникновению ошибки и компилятор требует от программиста предусмотреть некие действия для обработки возможных проблем. Таким образом повышается надежность программы, её устойчивость при возможных сбоях.

Исключения, порожденные от `RuntimeException`, являются непроверяемыми и компилятор не требует обязательной их обработки. Как правило, это ошибки программы, которые при правильном кодировании возникать не должны (например, `IndexOutOfBoundsException` — выход за границы массива, `java.lang.ArithmeticException` — деление на ноль). Поэтому, чтобы не загромождать программу, компилятор оставляет на усмотрение программиста обработку таких исключений с помощью блоков `try-catch`.

Исключения, порожденные от `Error`, также не являются проверяемыми. Они предназначены для того, чтобы уведомить приложение о возникновении фатальной ситуации, которую программным способом устранить практически невозможно (хотя формально обработчик допускается). Они могут свидетельствовать об ошибках программы, но, как правило, это неустранимые проблемы на уровне JVM. В качестве примера можно привести `StackOverflowError` (переполнение стека), `OutOfMemoryError` (нехватка памяти).

Методы, код которых может порождать проверяемые исключения, должны либо сами их обрабатывать, либо в заголовке метода должно быть указано ключевое слово `throws` с перечислением необрабатываемых проверяемых исключений. На непроверяемые ошибки это правило не распространяется.

Переопределенный (`overridden`) метод не может расширять список возможных исключений исходного метода.

[Назад к оглавлению](#оглавление)

---

## 10. Может ли метод main() выбросить исключение во вне и если да, то где будет происходить обработка данного исключения?

Может и оно будет передано в виртуальную машину Java (JVM).

[Назад к оглавлению](#оглавление)

---

## 11. Какие исключения когда стоит использовать?

Исключения: `checked` или `unchecked`?

Сегодня пост о разнице между типами исключений и о том, какой тип выбрать для ошибок бизнес-логики.

### Основы

🔸**Checked исключения** — наследники класса `Exception`:
```java
class IOException extends Exception
```
Явно указываются в определении метода:
```java
void write(int c) throws IOException
```
Код с обработкой исключения обязателен, иначе программа не скомпилируется.

🔸**Unchecked исключения** — наследники класса `RuntimeException`:
```java
class NullPointerException extends RuntimeException
```
О них не пишут в сигнатуре методов и редко ловят в блоке `try-catch`. Компилятор не предупредит о возможных ошибках, но иногда о них предупреждает IDE.

Оба типа можно поймать в блоке `try-catch`. Единственная техническая разница между `checked` и `unchecked` — обязательная обработка `checked` исключений. На уровне JVM разницы нет — производительность обоих типов одинакова.

### За что отвечают стандартные исключения JDK

▫️ `checked` говорят об ошибках с "внешними" причинами: файл не найден, поток прервали, сокет закрыт, указанный класс не найден. Исключения показывают возможные проблемы, которые в будущем могут повториться.

▫️ `unchecked` указывают на ошибки в коде: передали `null` вместо объекта, пришёл некорректный аргумент, нельзя привести объект к указанному типу. Исправляются при обнаружении, и в будущем такая ошибка не ожидается.

### Ошибки бизнес-логики

Не найден пользователь, не хватает прав, превышен лимит снятия денег со счёта. Какие это исключения: `checked` или `unchecked`?

В старых статьях по Java и на многих курсах ответ однозначен. Исключения должны быть `checked`, чтобы ошибка не дошла до пользователя.

На JavaRush и в других статьях пишут, что `checked` исключения никто не использует, потому что это неудобно.

Кто же прав?

Исключения бизнес-логики — ожидаемые события, которые нужно обработать. Пользователь должен увидеть не стектрейс, а красивое сообщение 💅.

Многие фреймворки облегчают работу с исключениями. Если в Spring задать обработчик для `UserNotFoundException`, то туда попадут `UserNotFoundException` из любой части сервиса. Spring в любом случае их поймает, поэтому исключения бизнес-логики делают `unchecked`. Код получается гораздо чище.

По этой же причине `checked` иногда переводят в `unchecked`:
```java
catch (SQLException e) {
    throw new IllegalStateException(e);
}
```

### Резюме

▫️ Если приложение написано на чистой Java, то исключения бизнес-логики будут скорее всего `checked`.
▫️ Если приложение использует фреймворк, который перехватывает исключения, их можно сделать `unchecked`.

Правильные ответы на вопросы перед постом:
⭐️ Вопрос 1: обработка `checked` исключений обязательна и проверяется на этапе компиляции.
⭐️ Вопрос 2: на практике чаще встречается `extends RuntimeException`, но вариант `extends Exception` тоже ок.

[Назад к оглавлению](#оглавление)

---

## 12. Проверяемые и непроверяемые

Проверяемые исключения должны быть явно пойманы в теле метода или объявлены в секции `throws` метода. Непроверяемые исключения вызваны проблемами, которые не могут быть решены, такими как деление на 0, нулевой указатель и т.п. Проверяемые исключения особенно важны потому, что от других разработчиков, использующих ваше API, вы ожидаете, что они будут знать, как обращаться с исключениями. Например, `IOException` — часто используемое проверяемое исключение, а `RuntimeException` — непроверяемое.

[Назад к оглавлению](#оглавление)

---

## 13. Лучший способ работать с исключениями

Если исключение может быть правильно обработано, его надо ловить, иначе, оно должно быть проброшено дальше.

[Назад к оглавлению](#оглавление)

---

## 14. Почему переменные, определенные в try, не могут быть использованы в catch или finally?

В следующем куске кода строку `s`, объявленную в блоке `try`, нельзя использовать в блоке `catch`. Этот код не скомпилируется.

```java
try {
    File file = new File("path");
    FileInputStream fis = new FileInputStream(file);
    String s = "inside";
}
catch (FileNotFoundException e) {
    e.printStackTrace();
    System.out.println(s);
}
```

Причина в том, что неизвестно, где именно в блоке `try` могло быть вызвано исключение. Вполне возможно, что исключение было вызвано до того, как был объявлен объект. И именно для данного примера это справедливо.

[Назад к оглавлению](#оглавление)

---

## 15. Почему Double.parseDouble(null) и Integer.parseInt(null) вызывают разные исключения?

Так и есть, они действительно вызывают разные исключения. Это проблема JDK. Они просто были разработаны разными людьми, и не стоит всерьёз заморачиваться над этим.

```java
Integer.parseInt(null);
// вызывает java.lang.NumberFormatException: null

Double.parseDouble(null);
// вызывает java.lang.NullPointerException
```

[Назад к оглавлению](#оглавление)

---

## 16. Как написать собственное («пользовательское») исключение?

Необходимо унаследоваться от базового класса требуемого типа исключений (например, от `Exception` или `RuntimeException`).

```java
class CustomException extends Exception {
    public CustomException() {
        super();
    }
    public CustomException(final String string) {
        super(string + " is invalid");
    }
    public CustomException(final Throwable cause) {
        super(cause);
    }
}
```

[Назад к оглавлению](#оглавление)

---

## 17. Какие существуют unchecked exception?

Наиболее часто встречающиеся: `ArithmeticException`, `ClassCastException`, `ConcurrentModificationException`, `IllegalArgumentException`, `IllegalStateException`, `IndexOutOfBoundsException`, `NoSuchElementException`, `NullPointerException`, `UnsupportedOperationException`.

[Назад к оглавлению](#оглавление)

---

## 18. О чем говорит ключевое слово throws?

Модификатор `throws` прописывается в заголовке метода и указывает на то, что метод потенциально может выбросить исключение с указанным типом.

[Назад к оглавлению](#оглавление)

---

## 19. Какой оператор позволяет принудительно выбросить исключение?

Это оператор `throw`:
```java
throw new Exception();
```

[Назад к оглавлению](#оглавление)

---

## 20. Что такое Error?

Исключения, порожденные от `Error`, не являются проверяемыми. Они предназначены для того, чтобы уведомить приложение о возникновении фатальной ситуации, которую программным способом устранить практически невозможно (хотя формально обработчик допускается). Они могут свидетельствовать об ошибках программы, но, как правило, это неустранимые проблемы на уровне JVM. В качестве примера можно привести `StackOverflowError` (переполнение стека), `OutOfMemoryError` (нехватка памяти).

Методы, код которых может порождать проверяемые исключения, должны либо сами их обрабатывать, либо в заголовке метода должно быть указано ключевое слово `throws` с перечислением необрабатываемых проверяемых исключений. На непроверяемые ошибки это правило не распространяется.

[Назад к оглавлению](#оглавление)

---

## 21. Что вы знаете о OutOfMemoryError?

`OutOfMemoryError` выбрасывается, когда виртуальная машина Java не может создать (разместить) объект из-за нехватки памяти, а сборщик мусора не может высвободить достаточное её количество.

Область памяти, занимаемая Java процессом, состоит из нескольких частей. Тип `OutOfMemoryError` зависит от того, в какой из них не хватило места:

- `java.lang.OutOfMemoryError: Java heap space`: Не хватает места в куче, а именно, в области памяти, в которую помещаются объекты, создаваемые в приложении программно. Обычно проблема кроется в утечке памяти. Размер задается параметрами `-Xms` и `-Xmx`.
- `java.lang.OutOfMemoryError: PermGen space`: (до версии Java 8) Данная ошибка возникает при нехватке места в Permanent области, размер которой задается параметрами `-XX:PermSize` и `-XX:MaxPermSize`.
- `java.lang.OutOfMemoryError: GC overhead limit exceeded`: Данная ошибка может возникнуть как при переполнении первой, так и второй областей. Связана она с тем, что памяти осталось мало и сборщик мусора постоянно работает, пытаясь высвободить немного места. Данную ошибку можно отключить с помощью параметра `-XX:-UseGCOverheadLimit`.
- `java.lang.OutOfMemoryError: unable to create new native thread`: Выбрасывается, когда нет возможности создавать новые потоки.

[Назад к оглавлению](#оглавление)

---

## 22. Опишите работу блока try-catch-finally

`try` — данное ключевое слово используется для отметки начала блока кода, который потенциально может привести к ошибке.

`catch` — ключевое слово для отметки начала блока кода, предназначенного для перехвата и обработки исключений в случае их возникновения.

`finally` — ключевое слово для отметки начала блока кода, который является дополнительным. Этот блок помещается после последнего блока `catch`. Управление передаётся в блок `finally` в любом случае, было выброшено исключение или нет.

[Назад к оглавлению](#оглавление)

---

## 23. Что такое механизм try-with-resources?

Данная конструкция, которая появилась в Java 7, позволяет использовать блок `try-catch` не заботясь о закрытии ресурсов, используемых в данном сегменте кода. Ресурсы объявляются в скобках сразу после `try`, а компилятор уже сам неявно создаёт секцию `finally`, в которой и происходит освобождение занятых в блоке ресурсов. Под ресурсами подразумеваются сущности, реализующие интерфейс `java.lang.AutoCloseable`.

Стоит заметить, что блоки `catch` и явный `finally` выполняются уже после того, как закрываются ресурсы в неявном `finally`.

[Назад к оглавлению](#оглавление)

---

## 24. Возможно ли использование блока try-finally (без catch)?

Такая запись допустима, но смысла в такой записи не так много, всё же лучше иметь блок `catch`, в котором будет обрабатываться необходимое исключение.

[Назад к оглавлению](#оглавление)

---

## 25. Может ли один блок catch отлавливать сразу несколько исключений?

В Java 7 стала доступна новая языковая конструкция, с помощью которой можно перехватывать несколько исключений одним блоком `catch`:

```java
try {
    //...
}
catch (IOException | SQLException ex) {
    //...
}
```

[Назад к оглавлению](#оглавление)

---

## 26. Всегда ли исполняется блок finally?

Код в блоке `finally` будет выполнен всегда, независимо от того, выброшено исключение или нет.

Например, в следующих ситуациях он может быть не выполнен:

- Существуют потоки-демоны — потоки, предоставляющие некие сервисы, работая в фоновом режиме во время выполнения программы, но при этом не являются её неотъемлемой частью. Таким образом, когда все потоки не демоны завершаются, программа завершает свою работу. В потоках-демонах блок `finally` не выполняется, они прерываются внезапно.
- `System.exit(0)`.
- Если в блоке `finally` произошло исключение и нет обработчика, то оставшийся код в блоке `finally` может не выполняться.

[Назад к оглавлению](#оглавление)

---

## 27. Может ли метод main() выбросить исключение во вне и если да, то где будет происходить обработка данного исключения?

Может и оно будет передано в виртуальную машину Java (JVM).

[Назад к оглавлению](#оглавление)

---

## 28. Предположим, есть метод, который может выбросить IOException и FileNotFoundException, в какой последовательности должны идти блоки catch? Сколько блоков catch будет выполнено?

Общее правило: обрабатывать исключения нужно от «младшего» к старшему. Т.е. нельзя поставить в первый блок `catch(Exception ex) {}`, иначе все дальнейшие блоки `catch()` уже ничего не смогут обработать, т.к. любое исключение будет соответствовать обработчику `catch(Exception ex)`.

Таким образом, исходя из факта, что `FileNotFoundException extends IOException`, сначала нужно обработать `FileNotFoundException`, а затем уже `IOException`:

```java
void method() {
    try {
        //...
    }
    catch (FileNotFoundException ex) {
        //...
    }
    catch (IOException ex) {
        //...
    }
}
```

[Назад к оглавлению](#оглавление)

---

## 29. Какие существуют способы обработки исключений?

В Java есть пять ключевых слов для работы с исключениями:

- `try` — данное ключевое слово используется для отметки начала блока кода, который потенциально может привести к ошибке.
- `catch` — ключевое слово для отметки начала блока кода, предназначенного для перехвата и обработки исключений.
- `finally` — ключевое слово для отметки начала блока кода, который является дополнительным. Этот блок помещается после последнего блока `catch`. Управление обычно передаётся в блок `finally` в любом случае.
- `throw` — служит для генерации исключений.
- `throws` — ключевое слово, которое прописывается в сигнатуре метода, и обозначающее, что метод потенциально может выбросить исключение с указанным типом.

[Назад к оглавлению](#оглавление)

---

## 30. В чем особенность блока finally? Всегда ли он исполняется?

Когда исключение передано, выполнение метода направляется по нелинейному пути. Это может стать источником проблем. Например, при входе метод открывает файл и закрывает при выходе. Чтобы закрытие файла не было пропущено из-за обработки исключения, был предложен механизм `finally`.

Ключевое слово `finally` создаёт блок кода, который будет выполнен после завершения блока `try/catch`, но перед кодом, следующим за ним. Блок будет выполнен, независимо от того, передано исключение или нет. Оператор `finally` не обязателен, однако каждый оператор `try` требует наличия либо `catch`, либо `finally`.

Код в блоке `finally` будет выполнен всегда.

[Назад к оглавлению](#оглавление)

---

## 31. В чем особенность RuntimeException?

`public class RuntimeException extends Exception` — базовый класс для ошибок во время выполнения. Относится к необрабатываемым исключениям (`uncatched`/`unchecked`). Как сказано в описании класса — это суперкласс, исключения которого могут быть выброшены во время нормальной работы JVM.

[Назад к оглавлению](#оглавление)

---

## 32. Есть ли дополнительные условия к методу, который потенциально может выбросить исключение?

Если это проверяемое исключение, то оно должно быть задекларировано в сигнатуре метода.

```java
public void someMethod() throws Exception {
}
```

[Назад к оглавлению](#оглавление)

---

## 33. Если оператор return содержится и в блоке catch и в finally, какой из них "главнее"?

Вернётся из блока `finally`.

```java
public static void main(String[] args) {
    String what = method();
    System.out.println(what);
}
public static String method() {
    try {
        return "SomeString";
    } catch(Exception ex) {
        return "Catch message";
    } finally {
        return "Finally message";
    }
}
// Вывод
Finally message
```

[Назад к оглавлению](#оглавление)

---

## 34. Что вы знаете о SQLException? К какому типу checked или unchecked оно относится, почему?

`SQLException` предоставляет информацию об ошибках доступа к базе данных или других ошибках, связанных с работой с базами данных.

`SQLException` относится к `checked` исключениям, а значит, проверяется на этапе компиляции.

Споры об этом типе исключения идут о том, что разработчику приходится постоянно обрабатывать это исключение в коде, хотя большая часть ошибок возникает во время выполнения программы, т.е., по мнению многих, лучше бы отнести его к `unchecked` runtime исключениям.

```java
try {
    // make some SQL call(s)
} catch (SQLException e) {
    // log the exception
    return; // and give up
}
```

Аргумент Joshua Bloch из *Effective Java Second Edition* такой: сделав `SQLException` проверяемым — это попытка заставить разработчиков обработать исключение и обернуть его в новом уровне абстракции.

[Назад к оглавлению](#оглавление)

---

## 35. Предположим, есть блок try-finally. В блоке try возникло исключение и выполнение переместилось в блок finally. В блоке finally тоже возникло исключение. Какое из двух исключений "выпадет" из блока try-finally? Что случится со вторым исключением?

Ответ аналогичный случаю с двумя `return` — будет обработано в `finally` блоке. Если было выброшено два исключения — одно в `try`, второе в `finally`, то исключение в `finally` "проглотит" исключение выше (см. пример). Если до блока `finally` исключение было обработано, то мы можем получить информацию об исключении в блоке `try` и тем самым не потерять исключение, которое впоследствии может быть перезаписано в `finally` другим исключением.

[Назад к оглавлению](#оглавление)

---

## 36. Какие есть правила для проверки исключений при наследовании?

Переопределяемый или реализуемый метод в наследнике/реализации не может выбрасывать контролируемые исключения, которые выше по иерархии, чем исключения в методе суперкласса/интерфейса.

[Назад к оглавлению](#оглавление)

---

## 37. Полезные советы по обработке исключений в Java

- **Не используйте для перехвата исключений класс `Exception`**. В иерархии исключений есть множество классов на все случаи жизни вашей программы, которые не только эффективно обработают конкретную ошибку, но и предоставят полезную для пользователя и отладки информацию.
- **Бросайте исключение как можно раньше**. Это является хорошей практикой программирования на Java.
- **Ловите исключения только тогда, когда сможете эффективно для пользователя и отладки их обработать**.
- **Освобождайте ресурсы**. Перехватывая исключение, всегда закрывайте открытые ресурсы. Ещё проще и эффективнее это делать с Java 7. Используйте `try` с ресурсами для лаконичного и красивого кода.
- **Логируйте исключения**. Логируйте сообщения, которые предоставляет исключение. В большинстве случаев это даст вам чёткое понимание причин и поможет в отладке. Не оставляйте пустым блок `catch`, иначе он будет просто поглощать исключение без каких-либо значимых деталей для отладки.
- **Один `catch` для нескольких исключений**. Используйте преимущества Java 7 для удобства и красоты вашего кода.
- **Используйте свои исключения**. Это позволит вам лучше чувствовать свою программу и эффективнее с ней работать.
- **Соглашения об именовании**. Когда вы создаёте свои классы исключений, следите за тем, чтобы из самого названия класса было ясно, что это исключение.
- **Используйте исключения с умом**. Бросить исключение — достаточно дорогостоящая в Java операция. Возможно, в некоторых случаях будет уместно не бросать исключений, а вернуть, например, логическую переменную, которая обозначала успешное или неуспешное выполнение метода.
- **Документируйте исключения**. Желательно писать Javadoc `@throws` для ваших исключений. Это будет особенно полезно в тех случаях, когда ваша программа предоставляет интерфейс для работы с другими приложениями.

[Назад к оглавлению](#оглавление)