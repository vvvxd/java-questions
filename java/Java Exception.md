Дайте определение понятию "исключение"

Исключение - это проблема(ошибка) возникающая во время выполнения программы. Исключения могут возникать во многих случаях, например:

Пользователь ввел некорректные данные.
Файл, к которому обращается программа, не найден.
Сетевое соединение с сервером было утеряно во время передачи данных. И т.д.

Все исключения в Java являются объектами. Поэтому они могут порождаться не только автоматически при возникновении исключительной ситуации, но и создаваться самим разработчиком.

--------------------------------------------------------------------------------------------------------------------
Опишите иерархию исключений

Все классы-исключения расширяют класс Throwable - непосредственное расширение класса object. У класса Throwable и у всех его расширений по традиции два конструктора:
Throwable о - конструктор по умолчанию;
Throwable (String message) - создаваемый объект будет содержать произвольное сообщение message.
Записанное в конструкторе сообщение можно получить затем методом getMessage (). Если объект создавался конструктором по умолчанию, то данный метод возвратит null. Метод toString возвращает краткое описание события, именно он работал в предыдущих листингах.
Три метода выводят сообщения обо всех методах, встретившихся по пути "полета" исключения:
printstackTrace() - выводит сообщения в стандартный вывод, как правило, это консоль;
printStackTrace(PrintStream stream) - выводит сообщения в байтовый поток stream;
printStackTrace(PrintWriter stream) - выводит сообщения в символьный поток stream.
У класса Throwable два непосредственных наследника - классы Error и Exception. Они не добавляют новых методов, а служат для разделения классов-исключений на два больших семейства - семейство классов-ошибок (error) и семейство собственно классов-исключений (exception).
Классы-ошибки, расширяющие класс Error, свидетельствуют о возникновении сложных ситуаций в виртуальной машине Java. Их обработка требует глубокого понимания всех тонкостей работы JVM. Ее не рекомендуется выполнять в обычной программе. Не советуют даже выбрасывать ошибки оператором throw. He следует делать свои классы-исключения расширениями класса Error или какого-то его подкласса.
Имена классов-ошибок, по соглашению, заканчиваются словом Error.
Классы-исключения, расширяющие класс Exception, отмечают возникновение обычной нештатной ситуации, которую можно и даже нужно обработать. Такие исключения следует выбросить оператором throw. Классов-исключений очень много, более двухсот. Они разбросаны буквально по всем пакетам J2SDK. В большинстве случаев вы способны подобрать готовый класс-исключение для обработки исключительных ситуаций в своей программе. При желании можно создать и свой класс-исключение, расширив класс Exception или любой его подкласс.
Среди классов-исключений выделяется класс RuntimeException - прямое расширение класса Exception. В нем и его подклассах отмечаются исключения, возникшие при работе JVM, но не столь серьезные, как ошибки. Их можно обрабатывать и выбрасывать, расширять своими классами, но лучше доверить это JVM, поскольку чаще всего это просто ошибка в программе, которую надо исправить. Особенность исключений данного класса в том, что их не надо отмечать в заголовке метода пометкой throws.
Имена классов-исключений, по соглашению, заканчиваются словом Exception.

--------------------------------------------------------------------------------------------------------------------
Какие виды исключений в Java вы знаете, чем они отличаются?

Все исключительные ситуации можно разделить на две категории: проверяемые(checked) и непроверяемые(unchecked).
Все исключения, порождаемые от Throwable, можно разбить на три группы. Они определяются тремя базовыми типами: наследниками Throwable - классами Errorи Exception, а также наследником Exception - RuntimeException.
Ошибки, порожденные от Exception (и не являющиеся наследниками RuntimeException ), являются проверяемыми. Т.е. во время компиляции проверяется, предусмотрена ли обработка возможных исключительных ситуаций. Как правило, это ошибки, связанные с окружением программы (сетевым, файловым вводом-выводом и др.), которые могут возникнуть вне зависимости от того, корректно написан код или нет. Например, открытие сетевого соединения или файла может привести к возникновению ошибки и компилятор требует от программиста предусмотреть некие действия для обработки возможных проблем. Таким образом повышается надежность программы, ее устойчивость при возможных сбоях.
Исключения, порожденные от RuntimeException, являются непроверяемыми и компилятор не требует обязательной их обработки.
Как правило, это ошибки программы, которые при правильном кодировании возникать не должны (например, IndexOutOfBoundsException- выход за границы массива, java.lang.ArithmeticException- деление на ноль). Поэтому, чтобы не загромождать программу, компилятор оставляет на усмотрение программиста обработку таких исключений с помощью блоков try-catch.
Исключения, порожденные от Error, также не являются проверяемыми. Они предназначены для того, чтобы уведомить приложение о возникновении фатальной ситуации, которую программным способом устранить практически невозможно (хотя формально обработчик допускается). Они могут свидетельствовать об ошибках программы, но, как правило, это неустранимые проблемы на уровне JVM. В качестве примера можно привести StackOverflowError (переполнение стека), OutOfMemoryError (нехватка памяти).
Методы, код которых может порождать проверяемые исключения, должны либо сами их обрабатывать, либо в заголовке метода должно быть указано ключевое слово throws с перечислением необрабатываемых проверяемых исключений. На непроверяемые ошибки это правило не распространяется.
Переопределенный (overridden) метод не может расширять список возможных исключений исходного метода.
--------------------------------------------------------------------------------------------------------------------
Может ли метод main() выбросить исключение во вне и если да, то где будет происходить обработка данного исключения?

Может и оно будет передано в виртуальную машину Java (JVM).

--------------------------------------------------------------------------------------------------------------------
Проверяемые и непроверяемые

Проверяемые исключения должны быть явно пойманы в теле метода или объявлены в секции throws метода. Непроверяемые исключения вызваны проблемами, которые не могут быть решены, такими как деление на 0, нулевой указатель и т.п. Проверяемые исключения особенно важны потому, что от других разработчиков, использующих ваше API, вы ожидаете, что они будут знать, как обращаться с исключениями. Например, IOException - часто используемое проверяемое исключение, а RuntimeException - непроверяемое

--------------------------------------------------------------------------------------------------------------------
Лучший способ работать с исключениями

Если исключение может быть правильно обработано, его надо ловить, иначе, оно должно быть проброшено дальше.

--------------------------------------------------------------------------------------------------------------------
Почему переменные, определенные в try не могут быть использованы в catch или finally?

В следующем куске кода строку s, объявленную в блоке try, нельзя использовать в блоке catch. Этот код не скомпилируется.

try {
File file = new File("path");
FileInputStream fis = new FileInputStream(file);
String s = "inside";
}
catch (FileNotFoundException e) {
e.printStackTrace(); System.out.println(s);
}

Причина в том, что неизвестно, где именно в блоке try могло быть вызвано исключение. Вполне возможно, что исключение было вызвано до того, как был объявлен объект. И именно для данного примера это справедливо.

--------------------------------------------------------------------------------------------------------------------
Почему Double.parseDouble(null) и Integer.parseInt(null) вызывают разные исключения?

Так и есть, они действительно вызывают разные исключения. Это проблема JDK. Они просто были разработаны разными людьми, и не стоит всерьёз заморачиваться над этим.

Integer.parseInt(null);
// вызывает java.lang.NumberFormatException: null

Double.parseDouble(null);
// вызывает java.lang.NullPointerException

--------------------------------------------------------------------------------------------------------------------
Как написать собственное («пользовательское») исключение?

Необходимо унаследоваться от базового класса требуемого типа исключений (например, от Exception или RuntimeException).

class CustomException extends Exception {
public CustomException() { super(); }
public CustomException(final String string) { super(string + " is invalid"); }
public CustomException(final Throwable cause) { super(cause);
} }

--------------------------------------------------------------------------------------------------------------------
Какие существуют unchecked exception?

Наиболее часто встречающиеся: ArithmeticException, ClassCastException, ConcurrentModificationException, IllegalArgumentException, IllegalStateException, IndexOutOfBoundsException, NoSuchElementException, NullPointerException, UnsupportedOperationException.

--------------------------------------------------------------------------------------------------------------------
О чем говорит ключевое слово throws?

Модификатор throws прописывается в заголовке метода и указывает на то, что метод потенциально может выбросить исключение с указанным типом.

--------------------------------------------------------------------------------------------------------------------
Какой оператор позволяет принудительно выбросить исключение?

Это оператор throw:
throw new Exception();

--------------------------------------------------------------------------------------------------------------------
Что такое Error?

Исключения, порожденные от Error, не являются проверяемыми. Они предназначены для того, чтобы уведомить приложение о возникновении фатальной ситуации, которую программным способом устранить практически невозможно (хотя формально обработчик допускается). Они могут свидетельствовать об ошибках программы, но, как правило, это неустранимые проблемы на уровне JVM. В качестве примера можно привести StackOverflowError (переполнение стека), OutOfMemoryError (нехватка памяти).
Методы, код которых может порождать проверяемые исключения, должны либо сами их обрабатывать, либо в заголовке метода должно быть указано ключевое слово throws с перечислением необрабатываемых проверяемых исключений. На непроверяемые ошибки это правило не распространяется.

--------------------------------------------------------------------------------------------------------------------
Что вы знаете о OutOfMemoryError?

OutOfMemoryError выбрасывается, когда виртуальная машина Java не может создать (разместить) объект из-за нехватки памяти, а сборщик мусора не может высвободить достаточное её количество.
Область памяти, занимаемая java процессом, состоит из нескольких частей. Тип OutOfMemoryError зависит от того, в какой из них не хватило места:
- java.lang.OutOfMemoryError: Java heap space: Не хватает места в куче, а именно, в области памяти в которую помещаются объекты, создаваемые в приложении программно. Обычно проблема кроется в утечке памяти. Размер задается параметрами -Xms и -Xmx.
- java.lang.OutOfMemoryError: PermGen space: (до версии Java 8) Данная ошибка возникает при нехватке места в Permanent области, размер которой задается параметрами -XX:PermSize и -XX:MaxPermSize.
- java.lang.OutOfMemoryError: GC overhead limit exceeded: Данная ошибка может возникнуть как при переполнении первой, так и второй областей. Связана она с тем, что памяти осталось мало и сборщик мусора постоянно работает, пытаясь высвободить немного места. Данную ошибку можно отключить с помощью параметра -XX:-UseGCOverheadLimit.
- java.lang.OutOfMemoryError: unable to create new native thread: Выбрасывается, когда нет возможности создавать новые потоки.

--------------------------------------------------------------------------------------------------------------------
Опишите работу блока try-catch-finally.

try — данное ключевое слово используется для отметки начала блока кода, который потенциально может привести к ошибке. catch — ключевое слово для отметки начала блока кода, предназначенного для перехвата и обработки исключений в случае их возникновения. finally — ключевое слово для отметки начала блока кода, который является дополнительным. Этот блок помещается после последнего блока catch. Управление передаётся в блок finally в любом случае, было выброшено исключение или нет.

--------------------------------------------------------------------------------------------------------------------
Что такое механизм try-with-resources?

Данная конструкция, которая появилась в Java 7, позволяет использовать блок try-catch не заботясь о закрытии ресурсов, используемых в данном сегменте кода. Ресурсы объявляются в скобках сразу после try, а компилятор уже сам неявно создаёт секцию finally, в которой и происходит освобождение занятых в блоке ресурсов. Под ресурсами подразумеваются сущности, реализующие интерфейс java.lang.Autocloseable.
Стоит заметить, что блоки catch и явный finally выполняются уже после того, как закрываются ресурсы в неявном finally.

--------------------------------------------------------------------------------------------------------------------
Возможно ли использование блока try-finally (без catch)?

Такая запись допустима, но смысла в такой записи не так много, всё же лучше иметь блок catch, в котором будет обрабатываться необходимое исключение.

--------------------------------------------------------------------------------------------------------------------
Может ли один блок catch отлавливать сразу несколько исключений?

В Java 7 стала доступна новая языковая конструкция, с помощью которой можно перехватывать несколько исключений одним блоком catch:
try { //... }
catch(IOException | SQLException ex)
{ //... }

--------------------------------------------------------------------------------------------------------------------
Всегда ли исполняется блок finally?

Код в блоке finally будет выполнен всегда, независимо от того, выброшено исключение или нет.

Например в следующих ситуациях он может быть не выполнен:

Существуют потоки-демоны - потоки предоставляющие некие сервисы, работая в фоновом режиме во время выполнения программы, но при этом не являются ее неотъемлеммой частью.Таким образом когда все потоки не демоны завершаются, программа завершает свою работу. В потоках демонах блок finally не выполняеться, они прерываются внезапно.

System.exit(0)

если в блоке finally произошло исключение и нет обработчика, то оставшийся код в блоке finally может не выполнятся.

--------------------------------------------------------------------------------------------------------------------
Может ли метод main() выбросить исключение во вне и если да, то где будет происходить обработка данного исключения?

Может и оно будет передано в виртуальную машину Java (JVM).

--------------------------------------------------------------------------------------------------------------------
Предположим, есть метод, который может выбросить IOException и FileNotFoundException в какой последовательности должны идти блоки catch? Сколько блоков catch будет выполнено?

Общее правило: обрабатывать исключения нужно от «младшего» к старшему. Т.е. нельзя поставить в первый блок catch(Exception ex) {}, иначе все дальнейшие блоки catch() уже ничего не смогут обработать, т.к. любое исключение будет соответствовать обработчику catch(Exception ex).
Таким образом, исходя из факта, что FileNotFoundException extends IOException сначала нужно обработать FileNotFoundException, а затем уже IOException:
void method() {
try { //... }
catch (FileNotFoundException ex) { //... }
catch (IOException ex) { //... }
}

--------------------------------------------------------------------------------------------------------------------
Какие существуют способы обработки исключений?

В Java есть пять ключевых слов для работы с исключениями:
try - данное ключевое слово используется для отметки начала блока кода, который потенциально может привести к ошибке.
catch - ключевое слово для отметки начала блока кода, предназначенного для перехвата и обработки исключений.
finally - ключевое слово для отметки начала блока кода, которой является дополнительным. Этот блок помещается после последнего блока 'catch'. Управление обычно передаётся в блок 'finally' в любом случае.
throw - служит для генерации исключений.
throws - ключевое слово, которое прописывается в сигнатуре метода, и обозначающее что метод потенциально может выбросить исключение с указанным типом.

--------------------------------------------------------------------------------------------------------------------
В чем особенность блока finally? Всегда ли он исполняется?

Когда исключение передано, выполнение метода направляется по нелинейному пути. Это может стать источником проблем. Например, при входе метод открывает файл и закрывает при выходе. Чтобы закрытие файла не было пропущено из-за обработки исключения, был предложен механизм finally.
Ключевое слово finally создаёт блок кода, который будет выполнен после завершения блока try/catch, но перед кодом, следующим за ним. Блок будет выполнен, независимо от того, передано исключение или нет. Оператор finally не обязателен, однако каждый оператор try требует наличия либо catch, либо finally. Код в блоке finally будет выполнен всегда.

--------------------------------------------------------------------------------------------------------------------
В чем особенность RuntimeException?

public class RuntimeException extends Exception - базовый класс для ошибок во время выполнения. Относится к необрабатываемым исключениям (uncatched\unchecked). Как сказано в описании класса - это суперкласс, исключения которого могут быть выброшены во время нормальной работы JVM.

--------------------------------------------------------------------------------------------------------------------
Есть ли дополнительные условия к методу, который потенциально может выбросить исключение?

Если это проверяемое исключение, то оно должно быть задекларировано в сигнатуре метода.

public void someMethod() throws Exception {
}

--------------------------------------------------------------------------------------------------------------------
Если оператор return содержится и в блоке catch и в finally, какой из них "главнее"?

Вернется из блока finally.

public static void main(String[] args) {
String what = method();
System.out.println(what);
}
public static String method() {
try {
return "SomeString";
} catch(Exception ex) {
return "Catch message";
} finally {
return "Finally message";
}
}
//Вывод
Finally message

--------------------------------------------------------------------------------------------------------------------
Что вы знаете о SQLException? К какому типу checked или unchecked оно относится, почему?

SQLException предоставляет информацию об ошибках доступа к базе данных или других ошибках связанных с работой с базами данных.
SQLException относится к checked исключениям, а значит проверяется на этапе компиляции.
Споры об этом типе исключения идут о том, что разработчику приходится постоянно обрабатывать это исключение в коде, хотя большая часть ошибок возникает во время выполнения программы, т.е., по мнению многих, лучше бы отнести его к unchecked runtime исключениям.

try {
// make some SQL call(s)
} catch {SQLException e) {
// log the exception
return; // and give up
}

Аргумент Joshua Bloch из Effective Java Second Edition такой: сделав SQLException проверяемым - это попытка заставить разработчиков обработать исключение и обернуть его в новом уровне абстракции.

--------------------------------------------------------------------------------------------------------------------
Предположим, есть блок try-finally. В блоке try возникло исключение и выполнение переместилось в блок finally. В блоке finally тоже возникло исключение. Какое из двух исключений "выпадет" из блока try-finally? Что случится со вторым исключением?

Ответ аналогичный случаю с двумя return - будет обработано в finally блоке. Если было выброшено два исключения - одно в try, второе в finally, то исключение в finally "проглотит" исключение выше (см. пример). Если до блока finally исключение было обработано, то мы можем получить информацию об исключении в блоке try и тем самым не потерять исключение, которое впоследствии может быть перезаписано в finally другим исключением.

--------------------------------------------------------------------------------------------------------------------
Какие есть правила для проверки исключений при наследовании?

Переопределяемый или реализуемый метод в наследнике / реализации не может выбрасывать контролируемые исключения, которые выше по иерархии чем исключения в методе суперкласса / интерфейса.

--------------------------------------------------------------------------------------------------------------------
Полезные советы по обработке исключений в Java

Не используйте для перехвата исключений класс Exception. В иерархии исключений есть множество классов на все случаи жизни вашей программы, которые не только эффективно обработают конкретную ошибку, но и предоставят полезную для пользователя и отладки информацию.

Бросайте исключение как можно раньше. Это является хорошей практикой программирования на Java.
Ловите исключения только тогда, когда сможете эффективно для пользователя и отладки их обработать.

Освобождайте ресурсы. Перехватывая исключение всегда закрывайте открытые ресурсы. Еще проще и эффективнее это делать с Java 7. Используйте try с ресурсами для лаконичного и красивого кода.

Логируйте исключения. Логируйте сообщения, которые предоставляет исключение. В большинстве случаев это даст вам четкое понимание причин и поможет в отладке. Не оставляйте пустым блок catch, иначе он будет просто поглощать исключение без каких-либо значимых деталей для отладки.

Один catch для нескольких исключений. Используйте преимущества Java 7 для удобства и красоты вашего кода.

Используйте свои исключения. Это позволит вам лучше чувствовать свою программу и эффективнее с ней работать.

Соглашения об именовании. Когда вы создать свои классы исключений, следите за тем, что из самого названия класса будет ясно, что это исключение.

Используйте исключения с умом. Бросить исключение — достаточно дорогостоящая в Java операция. Возможно, в некоторых случаях будем уместно не бросать исключений, а вернуть, например, логическую переменную, которая обозначала успешное или не успешное выполнение метода.

Документируйте исключения. Желательно писать javadoc @throws для ваших исключений. Это будет особенно полезно в тех случаях, когда ваша программа предоставляет интерфейс для работы с другими приложениями.

--------------------------------------------------------------------------------------------------------------------