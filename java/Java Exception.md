## Оглавление

1. [Дайте определение понятию "исключение"](#1-дайте-определение-понятию-исключение)
2. [Какова внутренняя структура исключений?](#2-какова-внутренняя-структура-исключений)
3. [Как работает выброс исключения (throw)?](#3-как-работает-выброс-исключения-throw)
4. [Расскажи про обработку исключений?](#4-расскажи-про-обработку-исключений)
5. [Какая производительность исключений?](#5-какая-производительность-исключений)
6. [Актуальные особенности исключений (Java 21 и новее)?](#6-актуальные-особенности-исключений-java-21-и-новее)
7. [Цепочки исключений как работает?](#7-цепочки-исключений-как-работает)
8. [Опишите иерархию исключений](#8-опишите-иерархию-исключений)
9. [Что такое таблица исключений?](#9-что-такое-таблица-исключений)
10. [Какие виды исключений в Java вы знаете, чем они отличаются?](#10-какие-виды-исключений-в-java-вы-знаете-чем-они-отличаются)
11. [Может ли метод main() выбросить исключение во вне и если да, то где будет происходить обработка данного исключения?](#11-может-ли-метод-main-выбросить-исключение-во-вне-и-если-да-то-где-будет-происходить-обработка-данного-исключения)
12. [Какие исключения когда стоит использовать?](#12-какие-исключения-когда-стоит-использовать)
13. [Проверяемые и непроверяемые](#13-проверяемые-и-непроверяемые)
14. [Лучший способ работать с исключениями](#14-лучший-способ-работать-с-исключениями)
15. [Почему переменные, определенные в try, не могут быть использованы в catch или finally?](#15-почему-переменные-определенные-в-try-не-могут-быть-использованы-в-catch-или-finally)
16. [Почему Double.parseDouble(null) и Integer.parseInt(null) вызывают разные исключения?](#16-почему-doubleparsedouble-null-и-integerparseint-null-вызывают-разные-исключения)
17. [Как написать собственное («пользовательское») исключение?](#17-как-написать-собственное-пользовательское-исключение)
18. [Какие существуют unchecked exception?](#18-какие-существуют-unchecked-exception)
19. [О чем говорит ключевое слово throws?](#19-о-чем-говорит-ключевое-слово-throws)
20. [Какой оператор позволяет принудительно выбросить исключение?](#20-какой-оператор-позволяет-принудительно-выбросить-исключение)
21. [Что такое Error?](#21-что-такое-error)
22. [Что вы знаете о OutOfMemoryError?](#22-что-вы-знаете-о-outofmemoryerror)
23. [Опишите работу блока try-catch-finally](#23-опишите-работу-блока-try-catch-finally)
24. [Что такое механизм try-with-resources?](#24-что-такое-механизм-try-with-resources)
25. [Возможно ли использование блока try-finally (без catch)?](#25-возможно-ли-использование-блока-try-finally-без-catch)
26. [Может ли один блок catch отлавливать сразу несколько исключений?](#26-может-ли-один-блок-catch-отлавливать-сразу-несколько-исключений)
27. [Всегда ли исполняется блок finally?](#27-всегда-ли-исполняется-блок-finally)
28. [Может ли метод main() выбросить исключение во вне и если да, то где будет происходить обработка данного исключения?](#28-может-ли-метод-main-выбросить-исключение-во-вне-и-если-да-то-где-будет-происходить-обработка-данного-исключения)
29. [Предположим, есть метод, который может выбросить IOException и FileNotFoundException, в какой последовательности должны идти блоки catch? Сколько блоков catch будет выполнено?](#29-предположим-есть-метод-который-может-выбросить-ioexception-и-filenotfoundexception-в-какой-последовательности-должны-идти-блоки-catch-сколько-блоков-catch-будет-выполнено)
30. [Какие существуют способы обработки исключений?](#30-какие-существуют-способы-обработки-исключений)
31. [В чем особенность блока finally? Всегда ли он исполняется?](#31-в-чем-особенность-блока-finally-всегда-ли-он-исполняется)
32. [В чем особенность RuntimeException?](#32-в-чем-особенность-runtimeexception)
33. [Есть ли дополнительные условия к методу, который потенциально может выбросить исключение?](#33-есть-ли-дополнительные-условия-к-методу-который-потенциально-может-выбросить-исключение)
34. [Если оператор return содержится и в блоке catch и в finally, какой из них "главнее"?](#34-если-оператор-return-содержится-и-в-блоке-catch-и-в-finally-какой-из-них-главнее)
35. [Что вы знаете о SQLException? К какому типу checked или unchecked оно относится, почему?](#35-что-вы-знаете-о-sqlexception-к-какому-типу-checked-или-unchecked-оно-относится-почему)
36. [Предположим, есть блок try-finally. В блоке try возникло исключение и выполнение переместилось в блок finally. В блоке finally тоже возникло исключение. Какое из двух исключений "выпадет" из блока try-finally? Что случится со вторым исключением?](#36-предположим-есть-блок-try-finally-в-блоке-try-возникло-исключение-и-выполнение-переместилось-в-блок-finally-в-блоке-finally-тоже-возникло-исключение-какое-из-двух-исключений-выпадет-из-блока-try-finally-что-случится-со-вторым-исключением)
37. [Какие есть правила для проверки исключений при наследовании?](#37-какие-есть-правила-для-проверки-исключений-при-наследовании)
38. [Полезные советы по обработке исключений в Java](#38-полезные-советы-по-обработке-исключений-в-java)

---

## 1. Дайте определение понятию "исключение"

Исключение — это объект, представляющий ошибку или нештатную ситуацию, наследующийся от класса `java.lang.Throwable`. В Java существуют два типа исключений:

- **Error**: Серьёзные системные ошибки, которые обычно не обрабатываются (например, `OutOfMemoryError`, `StackOverflowError`).
- **Exception**: Ошибки, которые можно обрабатывать. Делятся на:
    - **Checked exceptions** (проверяемые, наследуются от `Exception`, но не от `RuntimeException`, например, `IOException`).
    - **Unchecked exceptions** (непроверяемые, наследуются от `RuntimeException`, например, `NullPointerException`).

**Пример:**
```java
public class Example {
    public static void main(String[] args) {
        try {
            throw new RuntimeException("Error occurred!");
        } catch (RuntimeException e) {
            System.out.println(e.getMessage()); // Error occurred!
        }
    }
}
```

[Назад к оглавлению](#оглавление)

---

## 2. Какова внутренняя структура исключений?

### 2.1. Класс Throwable

Все исключения наследуются от `java.lang.Throwable`. Его структура в OpenJDK 21:

```java
public class Throwable implements Serializable {
    private StackTraceElement[] stackTrace; // Трассировка стека
    private final String detailMessage; // Сообщение об ошибке
    private Throwable cause; // Причина исключения
    private transient Object backtrace; // Внутренние данные JVM
    // Другие поля и методы
}
```

- **Поля**:
    - `stackTrace`: Массив `StackTraceElement` с информацией о стеке вызовов (класс, метод, файл, строка).
    - `detailMessage`: Строка с описанием ошибки.
    - `cause`: Другое исключение, вызвавшее текущее (для цепочек исключений).
    - `backtrace`: Внутреннее поле для JVM, хранит низкоуровневые данные о стеке (не доступно в Java).
- **Конструкторы**:
    - `Throwable()`: Без параметров.
    - `Throwable(String message)`: С сообщением.
    - `Throwable(String message, Throwable cause)`: С сообщением и причиной.
    - `Throwable(Throwable cause)`: С причиной.
- **Основные методы**:
    - `getMessage()`: Возвращает `detailMessage`.
    - `getCause()`: Возвращает `cause`.
    - `getStackTrace()`: Возвращает массив `StackTraceElement`.
    - `printStackTrace()`: Выводит трассировку в консоль.
    - `fillInStackTrace()`: Заполняет `stackTrace` текущим стеком вызовов.

### 2.2. Создание исключения

- При создании объекта исключения JVM:
    1. Выделяет память для объекта `Throwable` или его подкласса (~24 байта заголовок + поля, например, ~80 байт для `RuntimeException` с сообщением).
    2. Инициализирует `detailMessage` и `cause` (если указаны).
    3. Вызывает `fillInStackTrace()`, чтобы зафиксировать текущий стек вызовов.

- **`fillInStackTrace`**:
    - Захватывает стек вызовов через низкоуровневые механизмы JVM (например, `walk_stack` в HotSpot).
    - Создаёт массив `StackTraceElement` (~48 байт на элемент), содержащий:
        - Имя класса.
        - Имя метода.
        - Имя файла и номер строки (если доступны).
    - Это **дорогая операция** (O(n), где n — глубина стека), так как требует обхода стека и аллокации памяти.

[Назад к оглавлению](#оглавление)

---

## 3. Как работает выброс исключения (throw)?

### 3.1. Синтаксис и компиляция

- Оператор `throw` выбрасывает объект, наследующий `Throwable`:
  ```java
  throw new RuntimeException("Error!");
  ```
- Компилятор (`javac`) преобразует `throw` в байт-код с инструкцией `athrow`.

### 3.2. Байт-код

Пример метода:
```java
public void method() {
    throw new RuntimeException("Error!");
}
```

Байт-код (упрощённый):
```
0: new           #2  // class java/lang/RuntimeException
3: dup
4: ldc           #3  // String Error!
6: invokespecial #4  // Method java/lang/RuntimeException."<init>":(Ljava/lang/String;)V
9: athrow
```

- **Создание**:
    - `new`: Создаёт объект `RuntimeException`.
    - `ldc`: Загружает строку `"Error!"`.
    - `invokespecial`: Вызывает конструктор.
- **Выброс**:
    - `athrow`: Передаёт управление JVM для обработки исключения.

### 3.3. Работа JVM

При выполнении `athrow` JVM:
1. **Проверяет объект**:
    - Убеждается, что объект наследует `Throwable`, иначе выбрасывается `IllegalArgumentException`.
2. **Ищет обработчик**:
    - Анализирует таблицу исключений (exception table) текущего метода, сгенерированную компилятором.
    - Таблица содержит:
        - Диапазон байт-кода (`from`, `to`).
        - Тип исключения (или `any` для всех).
        - Адрес обработчика (`target` — байт-код для `catch`).
    - Пример таблицы:
      ```
      Exception table:
         from    to  target type
             0     5     8   Class java/lang/RuntimeException
      ```
3. **Передача управления**:
    - Если обработчик найден, JVM передаёт управление в блок `catch`, помещая исключение на стек.
    - Если обработчик не найден, JVM **разворачивает стек** (stack unwinding), переходя к вызывающему методу, и повторяет поиск.
4. **Необработанные исключения**:
    - Если обработчик не найден в цепочке вызовов, исключение передаётся `Thread.UncaughtExceptionHandler`.
    - По умолчанию выводится в `System.err` через `printStackTrace`, и поток завершается.

[Назад к оглавлению](#оглавление)

---

## 4. Расскажи про обработку исключений?

### 4.1. Синтаксис

```java
try {
    riskyOperation();
} catch (RuntimeException e) {
    handleError(e);
} finally {
    cleanup();
}
```

### 4.2. Компиляция

- Компилятор создаёт байт-код для `try`, `catch` и `finally`, используя таблицу исключений и инструкции перехода (`goto`).
- Для `finally` код дублируется для всех путей выхода из `try` или `catch`, так как инструкция `jsr` (использовавшаяся в Java 6 и ранее) устарела.
- Пример байт-кода:
  ```
  0: invokestatic  #5  // riskyOperation()
  3: goto          11
  6: astore_1      // Сохранить исключение в e
  7: invokestatic  #6  // handleError(Throwable)
  10: nop
  11: invokestatic  #7 // cleanup()
  14: return
  Exception table:
     from    to  target type
         0     3     6   Class java/lang/RuntimeException
  ```

### 4.3. Работа JVM

- Если исключение выбрасывается в `try`, JVM проверяет таблицу исключений.
- При совпадении типа исключения с `catch` управление передаётся в соответствующий блок.
- `finally` выполняется **всегда** (при нормальном завершении, исключении или `return`), за счёт дублирования кода в байт-коде.

### 4.4. Оптимизации

- **Инлайнинг `finally`**: JVM встраивает код `finally`, минимизируя накладные расходы.
- **JIT-компиляция**: JIT-компилятор оптимизирует обработчики, инлайнируя быстрые пути и удаляя ненужные проверки.
- **Лёгкие исключения**: JVM может пропускать `fillInStackTrace` для оптимизированных исключений.

[Назад к оглавлению](#оглавление)

---

## 5. Какая производительность исключений?

Исключения в Java — дорогостоящий механизм, особенно при частом выбросе. Рассмотрим ключевые аспекты:

### 5.1. Создание исключения

- **fillInStackTrace**:
    - Захват стека — O(n), где n — глубина стека.
    - Создание `StackTraceElement` требует аллокации (~48 байт на элемент).
- Оптимизация:
    - Переопределение `fillInStackTrace` для "лёгких" исключений:
      ```java
      public class LightweightException extends RuntimeException {
          @Override
          public Throwable fillInStackTrace() {
              return this; // Без трассировки
          }
      }
      ```

### 5.2. Выброс и обработка

- **Поиск обработчика**: O(1) для текущего метода, O(n) при разворачивании глубокого стека.
- **Передача управления**: Быстрая, но JIT-деоптимизация может добавить задержки.
- **Разворачивание стека**: Затраты растут с глубиной стека.

### 5.3. Память

- **Объект исключения**:
    - `RuntimeException`: ~80 байт (12 байт заголовок + 8 `stackTrace` + 8 `detailMessage` + 8 `cause` + ~44 байт для строки).
    - Трассировка: ~48 байт на `StackTraceElement` * глубина (например, 50 элементов = ~2.4 КБ).
- Итого: ~2-5 КБ для типичного исключения.

### 5.4. Оптимизации в HotSpot JVM (Java 21+)

- **Zero-Fill Stack Trace**:
    - JVM может пропускать трассировку для внутренних исключений, если они не используются.
- **Кэширование стека**:
    - Повторяющиеся трассировки кэшируются для часто выбрасываемых исключений.
- **Виртуальные потоки (Project Loom)**:
    - Виртуальные потоки (стабильны в Java 21) имеют компактный стек, снижая затраты на трассировку.
    - Однако глубокие стеки в виртуальных потоках всё ещё могут быть дорогими.

[Назад к оглавлению](#оглавление)

---

## 6. Актуальные особенности исключений (Java 21 и новее)?

На основе Java 21 и предполагаемых улучшений в Java 22/23:

### 6.1. Виртуальные потоки (JEP 444, Java 21)

- Виртуальные потоки используют "лёгкие" стеки, что уменьшает затраты на захват трассировки.
- Исключения в виртуальных потоках обрабатываются так же, но с меньшими накладными расходами для неглубоких стеков.
- Пример:
  ```java
  try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
      executor.submit(() -> { throw new RuntimeException("Error in virtual thread"); });
  } catch (Exception e) {
      e.printStackTrace();
  }
  ```

### 6.2. Structured Concurrency (JEP 453, инкубатор в Java 21)

- Упрощает обработку исключений в многопоточных приложениях, автоматически распространяя ошибки от дочерних задач.
- Пример:
  ```java
  try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {
      scope.fork(() -> { throw new RuntimeException("Task failed"); });
      scope.join();
      scope.throwIfFailed();
  } catch (Exception e) {
      // Обработка
  }
  ```

### 6.3. Pattern Matching (JEP 441, Java 21)

- Pattern matching для `instanceof` и `switch` упрощает обработку исключений:
  ```java
  try {
      riskyOperation();
  } catch (Exception e) {
      switch (e) {
          case IOException io -> System.out.println("IO: " + io.getMessage());
          case RuntimeException re -> System.out.println("Runtime: " + re.getMessage());
          default -> System.out.println("Other");
      }
  }
  ```
- JVM оптимизирует такие конструкции через эффективный байт-код.

### 6.4. Deprecation of finalize() (JEP 421, Java 18)

- Финализация устарела, что поощряет использование `try-with-resources` для управления ресурсами, снижая вероятность исключений, связанных с финализацией.

### 6.5. Потенциальные улучшения в Java 22/23

- **Оптимизации JIT**:
    - В последних версиях HotSpot JVM улучшено инлайнинг обработчиков и управление стеком, что снижает накладные расходы.
- **Project Valhalla (будущее)**:
    - Хотя примитивные типы и value objects ещё не полностью внедрены, они могут повлиять на аллокацию памяти для исключений в будущем.
- **Улучшения Loom**:
    - Дальнейшая оптимизация виртуальных потоков может уменьшить затраты на исключения в многопоточных приложениях.

[Назад к оглавлению](#оглавление)

---

## 7. Цепочки исключений как работает?

Поддержка **chaining** позволяет указывать причину исключения:

```java
try {
    throw new IOException("File error");
} catch (IOException e) {
    throw new RuntimeException("Operation failed", e);
}
```

- **Реализация**:
    - Поле `cause` хранит ссылку на исходное исключение.
    - `initCause(Throwable)` задаёт причину после создания (если не задана в конструкторе).
    - `printStackTrace` выводит полную цепочку.
- **Память**: +8 байт на ссылку `cause`.

[Назад к оглавлению](#оглавление)

---

## 8. Опишите иерархию исключений

Все классы-исключения расширяют класс `Throwable` — непосредственное расширение класса `Object`. У класса `Throwable` и у всех его расширений по традиции два конструктора:

- `Throwable()` — конструктор по умолчанию.
- `Throwable(String message)` — создаваемый объект будет содержать произвольное сообщение `message`.

Записанное в конструкторе сообщение можно получить затем методом `getMessage()`. Если объект создавался конструктором по умолчанию, то данный метод возвратит `null`. Метод `toString` возвращает краткое описание события, именно он работал в предыдущих листингах.

Три метода выводят сообщения обо всех методах, встретившихся по пути "полета" исключения:

- `printStackTrace()` — выводит сообщения в стандартный вывод, как правило, это консоль.
- `printStackTrace(PrintStream stream)` — выводит сообщения в байтовый поток `stream`.
- `printStackTrace(PrintWriter stream)` — выводит сообщения в символьный поток `stream`.

У класса `Throwable` два непосредственных наследника — классы `Error` и `Exception`. Они не добавляют новых методов, а служат для разделения классов-исключений на два больших семейства — семейство классов-ошибок (`Error`) и семейство собственно классов-исключений (`Exception`).

Классы-ошибки, расширяющие класс `Error`, свидетельствуют о возникновении сложных ситуаций в виртуальной машине Java. Их обработка требует глубокого понимания всех тонкостей работы JVM. Её не рекомендуется выполнять в обычной программе. Не советуют даже выбрасывать ошибки оператором `throw`. Не следует делать свои классы-исключения расширениями класса `Error` или какого-то его подкласса. Имена классов-ошибок, по соглашению, заканчиваются словом `Error`.

Классы-исключения, расширяющие класс `Exception`, отмечают возникновение обычной нештатной ситуации, которую можно и даже нужно обработать. Такие исключения следует выбросить оператором `throw`. Классов-исключений очень много, более двухсот. Они разбросаны буквально по всем пакетам J2SDK. В большинстве случаев вы способны подобрать готовый класс-исключение для обработки исключительных ситуаций в своей программе. При желании можно создать и свой класс-исключение, расширив класс `Exception` или любой его подкласс.

Среди классов-исключений выделяется класс `RuntimeException` — прямое расширение класса `Exception`. В нем и его подклассах отмечаются исключения, возникшие при работе JVM, но не столь серьезные, как ошибки. Их можно обрабатывать и выбрасывать, расширять своими классами, но лучше доверить это JVM, поскольку чаще всего это просто ошибка в программе, которую надо исправить. Особенность исключений данного класса в том, что их не надо отмечать в заголовке метода пометкой `throws`. Имена классов-исключений, по соглашению, заканчиваются словом `Exception`.

[Назад к оглавлению](#оглавление)

---

## 9. Что такое таблица исключений?

Таблица исключений (**Exception Table**) в Java — это внутренняя структура, встроенная в байт-код каждого метода, используемая JVM для управления обработкой исключений в байт-коде метода. Она является частью байт-кода, сгенерированного компилятором (`javac`), и указывает, как обрабатывать исключения, выбрасываемые в определённых участках кода. Таблица исключений играет ключевую роль в реализации механизма `try-catch-finally` и определяет, куда передать управление при выбросе исключения.

Она используется JVM для:
- Определения блоков `try`, соответствующих им `catch` и `finally`.
- Переноса управления при выбросе исключения (инструкция `athrow`).
- Поддержки механизма разворачивания стека (stack unwinding), если исключение не обработано в текущем методе.

Таблица исключений хранится в **атрибуте `Code`** описания метода в файле `.class` и применяется во время выполнения программы.

### 9.1. Структура таблицы исключений

Таблица исключений состоит из набора записей, каждая из которых описывает один обработчик исключений. Каждая запись содержит следующие поля (согласно JVMS):

| Поле            | Тип | Описание                                                                 |
|-----------------|-----|--------------------------------------------------------------------------|
| `start_pc`      | u2  | Начальный индекс байт-кода (program counter), где начинается защищённый блок (`try`). |
| `end_pc`        | u2  | Конечный индекс байт-кода (исключительно), где заканчивается защищённый блок. |
| `handler_pc`    | u2  | Индекс байт-кода, куда передать управление для обработки исключения (`catch`). |
| `catch_type`    | u2  | Индекс в пуле констант, указывающий на класс исключения (или 0 для `any`). |

- **u2**: 2-байтовое целое число без знака (0–65535).
- **`start_pc` и `end_pc`**: Определяют диапазон байт-кода, соответствующий блоку `try`. Если исключение выброшено в этом диапазоне, JVM проверяет запись.
- **`handler_pc`**: Указывает начало блока `catch`, куда передаётся управление.
- **`catch_type`**:
    - Если `catch_type` > 0, это индекс в пуле констант, ссылающийся на `CONSTANT_Class_info` (класс исключения, например, `java/lang/RuntimeException`).
    - Если `catch_type` = 0, запись соответствует **любому исключению** (аналог `catch (Throwable t)` или блоку `finally`).

Пример записи:
```
start_pc: 0
end_pc: 5
handler_pc: 8
catch_type: 2 // Ссылается на java/lang/RuntimeException в пуле констант
```

Эта запись означает, что если `RuntimeException` выброшено в байт-коде с индексами 0–4, управление перейдёт к индексу 8.

### 9.2. Как JVM использует таблицу исключений?

Когда исключение выбрасывается (инструкция `athrow`), JVM выполняет следующие шаги:

1. **Получение исключения**:
    - JVM извлекает объект исключения (подкласс `Throwable`) с вершины стека.
    - Проверяет, что объект наследует `Throwable`, иначе выбрасывает `IllegalArgumentException`.

2. **Проверка таблицы исключений**:
    - JVM получает текущий **program counter** (PC) — индекс байт-кода, где произошло исключение.
    - Проверяет таблицу исключений текущего метода, перебирая записи:
        - Если `start_pc ≤ PC < end_pc`, запись применима.
        - Если `catch_type=0` или класс исключения совпадает с `catch_type` (или является его подклассом), JVM передаёт управление на `handler_pc`.
    - Совпадение классов проверяется через механизм разрешения классов JVM (`instanceof`).

3. **Передача управления**:
    - JVM очищает стек операндов и помещает объект исключения в локальную переменную (например, `astore_1` для `catch`).
    - Устанавливает PC на `handler_pc` и продолжает выполнение.

4. **Разворачивание стека**:
    - Если подходящая запись не найдена, JVM завершает текущий метод, возвращается к вызывающему методу и повторяет поиск в его таблице исключений.
    - Этот процесс (stack unwinding) продолжается, пока не найдётся обработчик или исключение не дойдёт до `Thread.UncaughtExceptionHandler`.

5. **Необработанные исключения**:
    - Если обработчик не найден, JVM передаёт исключение в `UncaughtExceptionHandler` потока, который обычно выводит трассировку (`printStackTrace`) и завершает поток.

[Назад к оглавлению](#оглавление)

---

## 10. Какие виды исключений в Java вы знаете, чем они отличаются?

Все исключительные ситуации можно разделить на две категории: проверяемые (`checked`) и непроверяемые (`unchecked`). Все исключения, порождаемые от `Throwable`, можно разбить на три группы. Они определяются тремя базовыми типами: наследниками `Throwable` — классами `Error` и `Exception`, а также наследником `Exception` — `RuntimeException`.

Ошибки, порожденные от `Exception` (и не являющиеся наследниками `RuntimeException`), являются проверяемыми. Т.е. во время компиляции проверяется, предусмотрена ли обработка возможных исключительных ситуаций. Как правило, это ошибки, связанные с окружением программы (сетевым, файловым вводом-выводом и др.), которые могут возникнуть вне зависимости от того, корректно написан код или нет. Например, открытие сетевого соединения или файла может привести к возникновению ошибки и компилятор требует от программиста предусмотреть некие действия для обработки возможных проблем. Таким образом повышается надежность программы, её устойчивость при возможных сбоях.

Исключения, порожденные от `RuntimeException`, являются непроверяемыми и компилятор не требует обязательной их обработки. Как правило, это ошибки программы, которые при правильном кодировании возникать не должны (например, `IndexOutOfBoundsException` — выход за границы массива, `java.lang.ArithmeticException` — деление на ноль). Поэтому, чтобы не загромождать программу, компилятор оставляет на усмотрение программиста обработку таких исключений с помощью блоков `try-catch`.

Исключения, порожденные от `Error`, также не являются проверяемыми. Они предназначены для того, чтобы уведомить приложение о возникновении фатальной ситуации, которую программным способом устранить практически невозможно (хотя формально обработчик допускается). Они могут свидетельствовать об ошибках программы, но, как правило, это неустранимые проблемы на уровне JVM. В качестве примера можно привести `StackOverflowError` (переполнение стека), `OutOfMemoryError` (нехватка памяти).

Методы, код которых может порождать проверяемые исключения, должны либо сами их обрабатывать, либо в заголовке метода должно быть указано ключевое слово `throws` с перечислением необрабатываемых проверяемых исключений. На непроверяемые ошибки это правило не распространяется.

Переопределенный (`overridden`) метод не может расширять список возможных исключений исходного метода.

[Назад к оглавлению](#оглавление)

---

## 11. Может ли метод main() выбросить исключение во вне и если да, то где будет происходить обработка данного исключения?

Да, метод `main()` может выбросить исключение "во вне", то есть не обрабатывать его внутри себя. Поскольку `main()` — точка входа программы, такое исключение передаётся JVM и обрабатывается в `UncaughtExceptionHandler` основного потока. По умолчанию обработчик выводит трассировку стека в `System.err` через `printStackTrace` и завершает программу.

**Пример:**
```java
public class Main {
    public static void main(String[] args) throws IOException {
        throw new IOException("File error");
    }
}
```

**Вывод:**
```
Exception in thread "main" java.io.IOException: File error
    at Main.main(Main.java:3)
```

[Назад к оглавлению](#оглавление)

---

## 12. Какие исключения когда стоит использовать?

### Основы

🔸 **Checked исключения** — наследники класса `Exception` (но не `RuntimeException`):
```java
class IOException extends Exception
```
Явно указываются в сигнатуре метода:
```java
void write(int c) throws IOException
```
Обработка обязательна, иначе программа не скомпилируется.

🔸 **Unchecked исключения** — наследники класса `RuntimeException`:
```java
class NullPointerException extends RuntimeException
```
Не требуют указания в `throws` и обязательной обработки. Компилятор их не проверяет, но IDE может предупреждать.

Оба типа можно поймать в `try-catch`. Техническая разница — в обязательной обработке checked исключений. Производительность на уровне JVM одинакова.

### За что отвечают стандартные исключения JDK

- **Checked**: Ошибки, вызванные внешними факторами (например, файл не найден, сеть недоступна). Примеры: `IOException`, `SQLException`.
- **Unchecked**: Ошибки в коде (например, `NullPointerException`, `IndexOutOfBoundsException`). Исправляются в коде, повторение не ожидается.

### Ошибки бизнес-логики

Для бизнес-логики (например, `UserNotFoundException`):
- **Checked**: Традиционно используются в чистой Java, чтобы гарантировать обработку.
- **Unchecked**: Предпочитаются во фреймворках (например, Spring), где глобальные обработчики перехватывают исключения. Код чище, так как не требует явных `try-catch`.

**Пример перевода checked в unchecked:**
```java
catch (SQLException e) {
    throw new IllegalStateException(e);
}
```

**Резюме**:
- Чистая Java: используйте `checked` для бизнес-логики.
- Фреймворки: `unchecked` для упрощения кода.

[Назад к оглавлению](#оглавление)

---

## 13. Проверяемые и непроверяемые

Проверяемые исключения (`checked`) должны быть обработаны в `try-catch` или объявлены в `throws`. Примеры: `IOException`, `SQLException`.

Непроверяемые исключения (`unchecked`) не требуют обработки или объявления. Примеры: `NullPointerException`, `ArithmeticException`. Обычно это ошибки программирования или фатальные проблемы (`Error`).

[Назад к оглавлению](#оглавление)

---

## 14. Лучший способ работать с исключениями

Если исключение можно обработать, его следует поймать в `try-catch`. Если обработка невозможна или нежелательна, исключение нужно пробросить выше с помощью `throws` или обернуть в другое исключение.

[Назад к оглавлению](#оглавление)

---

## 15. Почему переменные, определенные в try, не могут быть использованы в catch или finally?

Переменные, объявленные в блоке `try`, недоступны в `catch` или `finally`, так как их область видимости ограничена блоком `try`. Исключение может возникнуть до инициализации переменной, что делает её использование небезопасным.

**Пример (не компилируется):**
```java
try {
    File file = new File("path");
    FileInputStream fis = new FileInputStream(file);
    String s = "inside";
} catch (FileNotFoundException e) {
    e.printStackTrace();
    System.out.println(s); // Ошибка: s не определена
}
```

[Назад к оглавлению](#оглавление)

---

## 16. Почему Double.parseDouble(null) и Integer.parseInt(null) вызывают разные исключения?

`Double.parseDouble(null)` выбрасывает `NullPointerException`, а `Integer.parseInt(null)` — `NumberFormatException`. Это связано с различиями в реализации методов, разработанных разными командами. Не стоит придавать этому большого значения.

**Пример:**
```java
Integer.parseInt(null); // NumberFormatException
Double.parseDouble(null); // NullPointerException
```

[Назад к оглавлению](#оглавление)

---

## 17. Как написать собственное («пользовательское») исключение?

Создайте класс, наследующий `Exception` (для checked) или `RuntimeException` (для unchecked):

```java
class CustomException extends Exception {
    public CustomException() {
        super();
    }
    public CustomException(String message) {
        super(message + " is invalid");
    }
    public CustomException(Throwable cause) {
        super(cause);
    }
}
```

[Назад к оглавлению](#оглавление)

---

## 18. Какие существуют unchecked exception?

Часто встречающиеся: `ArithmeticException`, `ClassCastException`, `ConcurrentModificationException`, `IllegalArgumentException`, `IllegalStateException`, `IndexOutOfBoundsException`, `NoSuchElementException`, `NullPointerException`, `UnsupportedOperationException`.

[Назад к оглавлению](#оглавление)

---

## 19. О чем говорит ключевое слово throws?

`throws` в сигнатуре метода указывает, что метод может выбросить проверяемые исключения указанного типа.

**Пример:**
```java
public void method() throws IOException {
    throw new IOException();
}
```

[Назад к оглавлению](#оглавление)

---

## 20. Какой оператор позволяет принудительно выбросить исключение?

Оператор `throw`:

```java
throw new Exception();
```

[Назад к оглавлению](#оглавление)

---

## 21. Что такое Error?

`Error` — это подкласс `Throwable`, представляющий серьёзные системные проблемы (например, `OutOfMemoryError`, `StackOverflowError`), которые обычно не обрабатываются. Они непроверяемые и указывают на неустранимые сбои JVM.

[Назад к оглавлению](#оглавление)

---

## 22. Что вы знаете о OutOfMemoryError?

`OutOfMemoryError` выбрасывается, когда JVM не может выделить память для объекта, а сборщик мусора не может освободить достаточно памяти. Типы:

- **Java heap space**: Утечка памяти в куче (`-Xms`, `-Xmx`).
- **PermGen space** (до Java 8): Нехватка места для метаданных.
- **GC overhead limit exceeded**: Сборщик мусора работает слишком долго.
- **Unable to create new native thread**: Нельзя создать новый поток.

[Назад к оглавлению](#оглавление)

---

## 23. Опишите работу блока try-catch-finally

- `try`: Отмечает блок кода, где могут возникнуть исключения.
- `catch`: Обрабатывает пойманные исключения.
- `finally`: Выполняется всегда, независимо от исключений, для очистки ресурсов.

[Назад к оглавлению](#оглавление)

---

## 24. Что такое механизм try-with-resources?

Введён в Java 7. Автоматически закрывает ресурсы, реализующие `AutoCloseable`, в неявном `finally`.

**Пример:**
```java
try (FileInputStream fis = new FileInputStream("file.txt")) {
    // Работа с файлом
} catch (IOException e) {
    e.printStackTrace();
}
```

[Назад к оглавлению](#оглавление)

---

## 25. Возможно ли использование блока try-finally (без catch)?

Да, но это менее распространено. Используется для гарантированного выполнения очистки, даже если исключение не перехватывается.

[Назад к оглавлению](#оглавление)

---

## 26. Может ли один блок catch отлавливать сразу несколько исключений?

С Java 7 возможно:

```java
try {
    // Код
} catch (IOException | SQLException ex) {
    // Обработка
}
```

[Назад к оглавлению](#оглавление)

---

## 27. Всегда ли исполняется блок finally?

`finally` выполняется всегда, кроме случаев:
- Вызов `System.exit(0)`.
- Прерывание демонического потока.
- Исключение в самом `finally`, если оно не обработано.

[Назад к оглавлению](#оглавление)

---

## 28. Может ли метод main() выбросить исключение во вне и если да, то где будет происходить обработка данного исключения?

См. [пункт 11](#11-может-ли-метод-main-выбросить-исключение-во-вне-и-если-да-то-где-будет-происходить-обработка-данного-исключения).

[Назад к оглавлению](#оглавление)

---

## 29. Предположим, есть метод, который может выбросить IOException и FileNotFoundException, в какой последовательности должны идти блоки catch? Сколько блоков catch будет выполнено?

- **Последовательность**: Сначала `FileNotFoundException`, затем `IOException`, так как `FileNotFoundException` является подклассом `IOException`.
- **Количество выполненных блоков**: Только один блок `catch` выполняется для первого подходящего исключения.

**Пример:**
```java
try {
    // Код
} catch (FileNotFoundException ex) {
    // Обработка
} catch (IOException ex) {
    // Обработка
}
```

[Назад к оглавлению](#оглавление)

---

## 30. Какие существуют способы обработки исключений?

Ключевые слова:
- `try`: Блок для кода, который может выбросить исключение.
- `catch`: Обработка исключений.
- `finally`: Гарантированная очистка.
- `throw`: Выброс исключения.
- `throws`: Объявление возможных исключений в методе.

[Назад к оглавлению](#оглавление)

---

## 31. В чем особенность блока finally? Всегда ли он исполняется?

`finally` обеспечивает выполнение кода (например, закрытие ресурсов) независимо от исключений. Выполняется всегда, кроме случаев, описанных в [пункте 27](#27-всегда-ли-исполняется-блок-finally).

[Назад к оглавлению](#оглавление)

---

## 32. В чем особенность RuntimeException?

`RuntimeException` — базовый класс для непроверяемых исключений, выбрасываемых JVM при ошибках выполнения (например, `NullPointerException`). Не требует `throws` в сигнатуре метода.

[Назад к оглавлению](#оглавление)

---

## 33. Есть ли дополнительные условия к методу, который потенциально может выбросить исключение?

Для checked исключений метод должен объявить их в `throws` или обработать в `try-catch`. Unchecked исключения не требуют таких условий.

[Назад к оглавлению](#оглавление)

---

## 34. Если оператор return содержится и в блоке catch и в finally, какой из них "главнее"?

`return` в `finally` имеет приоритет и перекрывает `return` в `catch` или `try`.

**Пример:**
```java
public static String method() {
    try {
        return "SomeString";
    } catch (Exception ex) {
        return "Catch message";
    } finally {
        return "Finally message";
    }
}
// Вывод: Finally message
```

[Назад к оглавлению](#оглавление)

---

## 35. Что вы знаете о SQLException? К какому типу checked или unchecked оно относится, почему?

`SQLException` — checked исключение, связанное с ошибками базы данных. Требует обработки или объявления в `throws`, так как ошибки БД могут возникать из-за внешних факторов. Некоторые считают, что его лучше сделать unchecked для упрощения кода.

**Пример:**
```java
try {
    // SQL-запрос
} catch (SQLException e) {
    // Логирование
}
```

[Назад к оглавлению](#оглавление)

---

## 36. Предположим, есть блок try-finally. В блоке try возникло исключение и выполнение переместилось в блок finally. В блоке finally тоже возникло исключение. Какое из двух исключений "выпадет" из блока try-finally? Что случится со вторым исключением?

Исключение из `finally` перекрывает исключение из `try`. Исключение из `try` теряется, если не сохранено.

**Пример:**
```java
try {
    throw new IOException("Try error");
} finally {
    throw new RuntimeException("Finally error");
}
// Выбросится RuntimeException
```

[Назад к оглавлению](#оглавление)

---

## 37. Какие есть правила для проверки исключений при наследовании?

Переопределяемый метод не может выбрасывать checked исключения, которые выше по иерархии, чем в суперклассе/интерфейсе.

**Пример:**
```java
class Parent {
    void method() throws IOException {}
}
class Child extends Parent {
    @Override
    void method() throws FileNotFoundException {} // OK, FileNotFoundException — подкласс IOException
    // void method() throws Exception {} // Ошибка, Exception шире
}
```

[Назад к оглавлению](#оглавление)

---

## 38. Полезные советы по обработке исключений в Java

- Избегайте перехвата общего `Exception`.
- Выбрасывайте исключения как можно раньше.
- Обрабатывайте исключения, только если можете это сделать эффективно.
- Закрывайте ресурсы, предпочтительно с `try-with-resources`.
- Логируйте исключения, избегайте пустых `catch`.
- Используйте множественный `catch` (Java 7+).
- Создавайте пользовательские исключения для ясности.
- Следуйте соглашениям именования (например, `CustomException`).
- Используйте исключения экономно, так как они дорогостоящи.
- Документируйте исключения с `@throws` в Javadoc.

[Назад к оглавлению](#оглавление)