
---

## Что такое «коллекция»?
<details> <summary>Ответ</summary>
«Коллекция» - это структура данных, набор каких-либо объектов. Данными (объектами в наборе) могут быть числа, строки, объекты пользовательских классов и т.п.

</details>

---

## Назовите основные интерфейсы JCF и их реализации
<details> <summary>Ответ</summary>
На вершине иерархии в Java Collection Framework располагаются 2 интерфейса: Collection и Map. Эти интерфейсы разделяют все коллекции, входящие во фреймворк на две части по типу хранения данных: простые последовательные наборы элементов и наборы пар «ключ — значение» соответственно.

### Интерфейс Collection
Расширяют интерфейсы:
- **List** (список) представляет собой коллекцию, в которой допустимы дублирующие значения. Элементы такой коллекции пронумерованы, начиная от нуля, к ним можно обратиться по индексу. Реализации:
  - **ArrayList** - инкапсулирует в себе обычный массив, длина которого автоматически увеличивается при добавлении новых элементов.
  - **LinkedList** (двунаправленный связный список) - состоит из узлов, каждый из которых содержит как собственно данные, так и две ссылки на следующий и предыдущий узел.
  - **Vector** — реализация динамического массива объектов, методы которой синхронизированы.
  - **Stack** — реализация стека LIFO (last-in-first-out).
- **Set** (сет) описывает неупорядоченную коллекцию, не содержащую повторяющихся элементов. Реализации:
  - **HashSet** - использует HashMap для хранения данных. В качестве ключа и значения используется добавляемый элемент. Из-за особенностей реализации порядок элементов не гарантируется при добавлении.
  - **LinkedHashSet** — гарантирует, что порядок элементов при обходе коллекции будет идентичен порядку добавления элементов.
  - **TreeSet** — предоставляет возможность управлять порядком элементов в коллекции при помощи объекта Comparator, либо сохраняет элементы с использованием «natural ordering».
- **Queue** (очередь) предназначена для хранения элементов с предопределённым способом вставки и извлечения FIFO (first-in-first-out):
  - **PriorityQueue** — предоставляет возможность управлять порядком элементов в коллекции при помощи объекта Comparator, либо сохраняет элементы с использованием «natural ordering».
  - **ArrayDeque** — реализация интерфейса Deque, который расширяет интерфейс Queue методами, позволяющими реализовать конструкцию вида LIFO (last-in-first-out).

### Интерфейс Map
Реализован классами:
- **Hashtable** — хэш-таблица, методы которой синхронизированы. Не позволяет использовать null в качестве значения или ключа и не является упорядоченной.
- **HashMap** — хэш-таблица. Позволяет использовать null в качестве значения или ключа и не является упорядоченной.
- **LinkedHashMap** — упорядоченная реализация хэш-таблицы.
- **TreeMap** — реализация, основанная на красно-чёрных деревьях. Является упорядоченной и предоставляет возможность управлять порядком элементов в коллекции при помощи объекта Comparator, либо сохраняет элементы с использованием «natural ordering».
- **WeakHashMap** — реализация хэш-таблицы, которая организована с использованием weak references для ключей (сборщик мусора автоматически удалит элемент из коллекции при следующей сборке мусора, если на ключ этого элемента нет жёстких ссылок).

</details>

---

## Расположите в виде иерархии следующие интерфейсы
<details> <summary>Ответ</summary>
```
Iterable
├── Collection
│   ├── List
│   ├── Set
│   │   ├── SortedSet
│   │   │   ├── NavigableSet
│   ├── Map
├── SortedMap
│   ├── NavigableMap
├── Iterator
```

</details>

---

## Почему Map — это не Collection?
<details> <summary>Ответ</summary>
Collection представляет собой совокупность некоторых элементов. Map - это совокупность пар «ключ-значение».

</details>

---

## В чем разница между классами java.util.Collection и java.util.Collections?
<details> <summary>Ответ</summary>
**java.util.Collections** - набор статических методов для работы с коллекциями.

**java.util.Collection** - один из основных интерфейсов Java Collections Framework.

</details>

---

## Что такое fail-fast поведение?
<details> <summary>Ответ</summary>
Fail-Fast (быстрое прерывание) — это поведение итераторов в Java, при котором коллекция немедленно выбрасывает ConcurrentModificationException, если обнаруживает изменение структуры коллекции (добавление, удаление элементов) во время итерации, кроме случаев, когда изменение делается через методы самого итератора. Использование fail-fast подхода позволяет избежать недетерминированного поведения программы в течение времени.

### Как работает Fail-Fast?
Механизм контроля изменений:
- Коллекции (например, ArrayList, HashMap) хранят счетчик modCount (modification count), который увеличивается при каждом изменении структуры.
- При создании итератора запоминается текущее значение modCount (expectedModCount).
- Перед каждым действием итератор проверяет, что modCount == expectedModCount.
- Если нет — бросает ConcurrentModificationException.

Пример с ArrayList:
```java
List<String> list = new ArrayList<>(List.of("A", "B"));
Iterator<String> it = list.iterator();
list.add("C");  // Изменяем коллекцию после создания итератора
it.next();      // Выбросит ConcurrentModificationException
```

### Где встречается Fail-Fast?
Коллекции из java.util:
- ArrayList, LinkedList, HashSet, HashMap и др.
- Итераторы этих коллекций (iterator(), listIterator()).

</details>

---

## Что такое fail-safe поведение?
<details> <summary>Ответ</summary>
Fail-Safe (отказоустойчивое) поведение — это подход, при котором итераторы работают с копией (snapshot) исходной коллекции, поэтому не выбрасывают ConcurrentModificationException, даже если исходная коллекция изменяется во время итерации.

### Как работают Fail-Safe итераторы?
**Создание копии:**
- При создании итератора коллекция создает неизменяемый снимок данных.
- Итератор работает с этой копией, а не с оригиналом.

**Изменения в исходной коллекции:**
- Все модификации (добавление/удаление) применяются только к оригиналу.
- Итератор не видит эти изменения, так как работает со своей версией данных.

Пример с CopyOnWriteArrayList:
```java
List<String> list = new CopyOnWriteArrayList<>(List.of("A", "B"));
Iterator<String> it = list.iterator();
list.add("C");  // Изменяем оригинал
while (it.hasNext()) {
    System.out.print(it.next() + " ");  // Выведет "A B" (без "C")
}
```

</details>

---

## Какая разница между fail-fast и fail-safe?
<details> <summary>Ответ</summary>
В противоположность fail-fast, итераторы fail-safe не вызывают никаких исключений при изменении структуры, потому что они работают с клоном коллекции вместо оригинала.

</details>

---

## Приведите примеры итераторов, реализующих поведение fail-safe
<details> <summary>Ответ</summary>
Итератор коллекции CopyOnWriteArrayList и итератор представления keySet коллекции ConcurrentHashMap являются примерами итераторов fail-safe.

</details>

---

## Расскажите про Weakly-Consistent Итераторы
<details> <summary>Ответ</summary>
Weakly-Consistent (слабо-согласованные) итераторы — это особый тип итераторов в потокобезопасных коллекциях (например, ConcurrentHashMap, ConcurrentLinkedQueue), которые не гарантируют точной согласованности данных на протяжении итерации, но при этом не выбрасывают ConcurrentModificationException. Они представляют компромисс между производительностью и актуальностью данных.

- Итерировать коллекцию без блокировок (lock-free).
- Частично учитывать изменения, внесенные другими потоками во время итерации.
- Не бросать ConcurrentModificationException.

### Как работает?
1. **Отказ от глобального состояния**
  - Обычные коллекции (как ArrayList) хранят счетчик изменений (modCount), но weakly-consistent коллекции:
    - Не используют modCount.
    - Не создают полную копию данных (в отличие от CopyOnWriteArrayList).
    - Позволяют параллельное изменение и чтение без полной синхронизации.
2. **Основа на "текущем представлении" данных**
  - Итератор работает с структурой данных на момент обхода, но:
    - Если элементы добавляются/удаляются в уже пройденную часть коллекции — итератор их не увидит.
    - Если изменения происходят в еще не пройденной части — итератор может их учесть (но не гарантируется).

</details>

---

## Чем различаются Enumeration и Iterator
<details> <summary>Ответ</summary>
Хотя оба интерфейса и предназначены для обхода коллекций между ними имеются существенные различия:
- с помощью Enumeration нельзя добавлять/удалять элементы;
- в Iterator исправлены имена методов для повышения читаемости кода (Enumeration.hasMoreElements() соответствует Iterator.hasNext(), Enumeration.nextElement() соответствует Iterator.next() и т.д);
- Enumeration присутствуют в устаревших классах, таких как Vector/Stack, тогда как Iterator есть во всех современных классах-коллекциях.

</details>

---

## Как между собой связаны Iterable и Iterator?
<details> <summary>Ответ</summary>
Интерфейс Iterable имеет только один метод - iterator(), который возвращает Iterator.

</details>

---

## Как между собой связаны Iterable, Iterator и «for-each»?
<details> <summary>Ответ</summary>
Цикл for-each (или расширенный цикл for) в Java — это удобный способ перебора элементов в коллекциях, массивах или других объектах, реализующих интерфейс Iterable. Он упрощает чтение кода, устраняя необходимость явного управления индексами или итераторами. Формально он был введён в Java 5.

### Как работает for-each
Цикл for-each автоматически итерируется по элементам объекта, предоставляя доступ к каждому элементу по очереди. Он основывается на интерфейсе Iterable<T>, который требует метод iterator(). Любая структура данных (например, массивы, списки, множества) может быть использована в for-each, если она поддерживает этот интерфейс или является массивом.

</details>

---

## Сравните Iterator и ListIterator
<details> <summary>Ответ</summary>
- ListIterator расширяет интерфейс Iterator
- ListIterator может быть использован только для перебора элементов коллекции List;
- Iterator позволяет перебирать элементы только в одном направлении, при помощи метода next(). Тогда как ListIterator позволяет перебирать список в обоих направлениях, при помощи методов next() и previous();
- ListIterator не указывает на конкретный элемент: его текущая позиция располагается между элементами, которые возвращают методы previous() и next().
- При помощи ListIterator вы можете модифицировать список, добавляя/удаляя элементы с помощью методов add() и remove(). Iterator не поддерживает данного функционала.

</details>

---

## Что произойдет при вызове Iterator.next() без предварительного вызова Iterator.hasNext()?
<details> <summary>Ответ</summary>
Если итератор указывает на последний элемент коллекции, то возникнет исключение NoSuchElementException, иначе будет возвращен следующий элемент.

</details>

---

## Сколько элементов будет пропущено, если Iterator.next() будет вызван после 10-ти вызовов Iterator.hasNext()?
<details> <summary>Ответ</summary>
Нисколько - hasNext() осуществляет только проверку наличия следующего элемента.

</details>

---

## Как поведёт себя коллекция, если вызвать iterator.remove()?
<details> <summary>Ответ</summary>
Если вызову iterator.remove() предшествовал вызов iterator.next(), то iterator.remove() удалит элемент коллекции, на который указывает итератор, в противном случае будет выброшено IllegalStateException().

</details>

---

## Как поведёт себя уже инстанциированный итератор для collection, если вызвать collection.remove()?
<details> <summary>Ответ</summary>
При следующем вызове методов итератора будет выброшено ConcurrentModificationException.

</details>

---

## Как избежать ConcurrentModificationException во время перебора коллекции?
<details> <summary>Ответ</summary>
- Попробовать подобрать или реализовать самостоятельно другой итератор, работающий по принципу fail-safe.
- Использовать ConcurrentHashMap и CopyOnWriteArrayList.
- Преобразовать список в массив и перебирать массив.
- Блокировать изменения списка на время перебора с помощью блока synchronized.

Отрицательная сторона последних двух вариантов - ухудшение производительности.

</details>

---

## Какая коллекция реализует дисциплину обслуживания FIFO?
<details> <summary>Ответ</summary>
FIFO, First-In-First-Out («первым пришел-первым ушел») - по этому принципу построена коллекция Queue.

</details>

---

## Какая коллекция реализует дисциплину обслуживания FILO?
<details> <summary>Ответ</summary>
FILO, First-In-Last-Out («первым пришел, последним ушел») - по этому принципу построена коллекция Stack.

</details>

---

## Расскажи про массивы в java?
<details> <summary>Ответ</summary>
Массивы в Java — это фундаментальная структура данных, используемая для хранения фиксированного количества элементов одного типа. Они являются объектами, обеспечивают быстрый доступ к элементам по индексу и широко применяются благодаря простоте и эффективности.

- **Фиксированный размер**: Размер массива задаётся при создании и не может быть изменён.
- **Индексация**: Индексы начинаются с 0 и идут до length - 1.
- **Типобезопасность**: Все элементы массива должны быть одного типа (или его подтипа, если это массив объектов).
- **Объект**: Массивы в Java являются объектами, наследующимися от java.lang.Object.

</details>

---

## Расскажи почему массивы такие быстрые?
<details> <summary>Ответ</summary>
Массивы в Java хранятся в куче как непрерывный блок памяти, что обеспечивает быстрый доступ к элементам по индексу (O(1)). Внутренняя структура массива включает:

### Заголовок объекта
Каждый массив, как объект, имеет заголовок, который содержит:
- Метаданные: Указатель на класс массива (например, [I для int[]).
- Размер: Значение length, определяющее количество элементов.
- Флаги и данные для сборщика мусора (garbage collector).
- Размер заголовка зависит от JVM, но обычно составляет 8–16 байт (например, 12 байт в 64-битной HotSpot JVM с сжатыми указателями).

### Данные элементов
- Элементы массива хранятся последовательно в памяти сразу после заголовка.
- Для примитивных типов хранятся сами значения:
  - byte[]: 1 байт на элемент.
  - int[]: 4 байта на элемент.
  - double[]: 8 байт на элемент.
- Для ссылочных типов (String[], Object[]) хранятся ссылки (указатели) на объекты в куче, обычно 4 или 8 байт в зависимости от архитектуры JVM.

### Выравнивание памяти
JVM выравнивает массивы в памяти (обычно по 8 байт), чтобы оптимизировать доступ. Это может добавить "padding" (дополнительные байты) в конец массива.

</details>

---

## Расскажи почему доступ к элементам массива O(1)?
<details> <summary>Ответ</summary>
Доступ к элементу массива по индексу (arr[i]) выполняется за O(1) благодаря непрерывному хранению:
- JVM вычисляет адрес элемента как: адрес_начала_массива + (индекс × размер_элемента).
- Например, для int[] с размером элемента 4 байта, адрес arr[2] будет адрес_начала + 2 × 4.

### Проверка границ
- JVM автоматически проверяет, находится ли индекс в пределах [0, length - 1].
- Если индекс выходит за границы, выбрасывается ArrayIndexOutOfBoundsException.
- Эта проверка выполняется на уровне байт-кода и добавляет небольшие накладные расходы.

</details>

---

## Расскажи про многомерный массив?
<details> <summary>Ответ</summary>
Многомерные массивы в Java реализованы как массивы указателей на другие массивы, а не как единый непрерывный блок памяти. Это ключевая особенность их реализации.

### Хранение в памяти
**Основной массив**: Многомерный массив (например, int[][]) — это объект в куче (heap), содержащий:
- Заголовок объекта: Содержит метаданные (тип массива, например, [[I для int[][], и поле length) и данные для сборщика мусора.
- Массив указателей: Каждый элемент основного массива — это ссылка (указатель) на другой массив (например, int[]).

**Подмассивы**: Каждый подмассив (например, int[] в int[][]) — это отдельный объект в куче с собственным заголовком и данными.

### Размер в памяти
- Основной массив: заголовок (обычно 12 байт в HotSpot JVM) + N × размер_указателя (4 или 8 байт, в зависимости от архитектуры).
- Подмассивы: для каждого подмассива — заголовок + данные элементов (например, 4 байта на int).

### Jagged arrays (неровные массивы)
- Подмассивы могут иметь разную длину, так как каждый подмассив — отдельный объект.
- Это позволяет создавать гибкие структуры, но увеличивает фрагментацию памяти, так как подмассивы не обязательно хранятся рядом.

### Преимущества
- Доступ к элементам по индексу — O(1) для каждого уровня (но требует нескольких операций для многомерных массивов).
- Компактное хранение примитивов в подмассивах.

### Недостатки
- Подмассивы хранятся отдельно, что может привести к фрагментации памяти и снижению локальности данных (хуже кэширование).
- Многомерные массивы менее эффективны, чем одномерные, из-за дополнительных указателей и заголовков объектов.
- Проверка границ на каждом уровне добавляет накладные расходы.

</details>

---

## Что такое ArrayList?
<details> <summary>Ответ</summary>
ArrayList в Java — это динамическая структура данных, реализующая интерфейс List из пакета java.util. Она представляет собой обёртку над массивом, которая позволяет динамически изменять размер, добавлять и удалять элементы.

### Основные поля ArrayList (на основе исходного кода OpenJDK):
```java
public class ArrayList<E> extends AbstractList<E> implements List<E>, RandomAccess, Cloneable, Serializable {
    private static final int DEFAULT_CAPACITY = 10; // Начальная ёмкость по умолчанию
    private transient Object[] elementData; // Внутренний массив для хранения элементов
    private int size; // Текущее количество элементов (не путать с длиной массива)
    // ... другие поля и методы
}
```
- **elementData**: Массив типа Object[], который хранит элементы. Он объявлен как transient, чтобы исключить его из стандартной сериализации.
- **size**: Хранит текущее количество элементов в списке, а не длину массива (elementData.length).
- **DEFAULT_CAPACITY**: Начальная ёмкость массива (10), если она не указана при создании.

</details>

---

## Как происходит расширение ArrayList?
<details> <summary>Ответ</summary>
Когда size достигает elementData.length, ArrayList увеличивает ёмкость массива:

### Алгоритм
- Новый массив создаётся с увеличенной ёмкостью (обычно в 1.5 раза больше текущей).
- Элементы копируются из старого массива в новый с помощью System.arraycopy.
- Ссылка elementData обновляется на новый массив.

</details>

---

## Что такое LinkedList?
<details> <summary>Ответ</summary>
LinkedList в Java — это реализация двусвязного списка. Она реализует интерфейсы List, Deque и Queue, что делает её универсальной структурой данных для различных сценариев. В отличие от ArrayList, который основан на массиве, LinkedList использует узлы, связанные указателями, что обеспечивает высокую эффективность для операций вставки и удаления в начале и конце списка.

LinkedList состоит из узлов, каждый из которых представлен внутренним классом Node<E>:
```java
private static class Node<E> {
    E item; // Данные элемента
    Node<E> next; // Ссылка на следующий узел
    Node<E> prev; // Ссылка на предыдущий узел
    Node(Node<E> prev, E element, Node<E> next) {
        this.item = element;
        this.next = next;
        this.prev = prev;
    }
}
```
- **item**: Хранит сам элемент (объект или null).
- **next**: Указатель на следующий узел.
- **prev**: Указатель на предыдущий узел.

### Основные поля LinkedList (на основе исходного кода OpenJDK):
```java
public class LinkedList<E> extends AbstractSequentialList<E> implements List<E>, Deque<E>, Cloneable, Serializable {
    transient int size = 0; // Количество элементов в списке
    transient Node<E> first; // Ссылка на первый узел
    transient Node<E> last; // Ссылка на последний узел
    // ... другие поля и методы
}
```
- **size**: Хранит текущее количество элементов.
- **first**: Указатель на первый узел списка (или null, если список пуст).
- **last**: Указатель на последний узел списка (или null, если список пуст).
- Поля помечены как transient, чтобы исключить их из стандартной сериализации (сериализация обрабатывается вручную).

</details>

---

## Чем отличается ArrayList от Vector?
<details> <summary>Ответ</summary>
- Методы класса Vector синхронизированы, а ArrayList - нет;
- По умолчанию, Vector удваивает свой размер, когда заканчивается выделенная под элементы память. ArrayList же увеличивает свой размер только на половину.

Vector это устаревший класс и его использование не рекомендовано.

</details>

---

## Чем отличается ArrayList от LinkedList? В каких случаях лучше использовать первый, а в каких второй?
<details> <summary>Ответ</summary>
ArrayList это список, реализованный на основе массива, а LinkedList — это классический двусвязный список, основанный на объектах с ссылками между ними.

### ArrayList
- доступ к произвольному элементу по индексу за константное время O(1);
- доступ к элементам по значению за линейное время O(N);
- вставка в конец в среднем производится за константное время O(1);
- удаление произвольного элемента из списка занимает значительное время т.к. при этом все элементы, находящиеся «правее» смещаются на одну ячейку влево (реальный размер массива (capacity) не изменяется);
- вставка элемента в произвольное место списка занимает значительное время т.к. при этом все элементы, находящиеся «правее» смещаются на одну ячейку вправо;
- минимум накладных расходов при хранении.

### LinkedList
- на получение элемента по индексу или значению потребуется линейное время O(N);
- на добавление и удаление в начало или конец списка потребуется константное O(1);
- вставка или удаление в/из произвольного место константное O(1);
- требует больше памяти для хранения такого же количества элементов, потому что кроме самого элемента хранятся еще указатели на следующий и предыдущий элементы списка.

В целом, LinkedList в абсолютных величинах проигрывает ArrayList и по потребляемой памяти, и по скорости выполнения операций. LinkedList предпочтительно применять, когда нужны частые операции вставки/удаления или в случаях, когда необходимо гарантированное время добавления элемента в список.

</details>

---

## Что работает быстрее ArrayList или LinkedList?
<details> <summary>Ответ</summary>
Смотря какие действия будут выполняться над структурой.

</details>

---

## Какое худшее время работы метода contains() для элемента, который есть в LinkedList?
<details> <summary>Ответ</summary>
O(N). Время поиска элемента линейно пропорционально количеству элементов в списке.

</details>

---

## Какое худшее время работы метода contains() для элемента, который есть в ArrayList?
<details> <summary>Ответ</summary>
O(N). Время поиска элемента линейно пропорционально количеству элементов с списке.

</details>

---

## Какое худшее время работы метода add() для LinkedList?
<details> <summary>Ответ</summary>
O(N). Добавление в начало/конец списка осуществляется за время O(1).

</details>

---

## Какое худшее время работы метода add() для ArrayList?
<details> <summary>Ответ</summary>
O(N). Вставка элемента в конец списка осуществляется за время O(1), но если вместимость массива недостаточна, то происходит создание нового массива с увеличенным размером и копирование всех элементов из старого массива в новый.

### Метод add(E e)
- Проверяет, достаточно ли ёмкости (size < elementData.length).
- Если нет, вызывает grow() для увеличения массива.
- Добавляет элемент: elementData[size++] = e.
- Сложность: O(1) в среднем, но O(n) при увеличении массива.

### Метод add(int index, E e)
- Сдвигает элементы вправо от index с помощью System.arraycopy.
- Вставляет элемент: elementData[index] = e.
- Сложность: O(n) из-за сдвига.

</details>

---

## Необходимо добавить 1 млн. элементов, какую структуру вы используете?
<details> <summary>Ответ</summary>
Однозначный ответ можно дать только исходя из информации о том в какую часть списка происходит добавление элементов, что потом будет происходить с элементами списка, существуют ли какие-то ограничения по памяти или скорости выполнения.

</details>

---

## Как происходит удаление элементов из ArrayList? Как меняется в этом случае размер ArrayList?
<details> <summary>Ответ</summary>
При удалении произвольного элемента из списка, все элементы, находящиеся «правее» смещаются на одну ячейку влево и реальный размер массива (его емкость, capacity) не изменяется никак. Механизм автоматического «расширения» массива существует, а вот автоматического «сжатия» нет, можно только явно выполнить «сжатие» командой trimToSize().

### Метод remove(int index)
- Проверяется, что 0 <= index < size. Если индекс вне диапазона, выбрасывается ArrayIndexOutOfBoundsException.
- Сдвигает элементы влево, начиная с index + 1, используя System.arraycopy.
- Устанавливает последний элемент в null для помощи сборщику мусора.
- Уменьшает size.
- Счётчик модификаций (modCount) увеличивается, чтобы отслеживать изменения структуры для итераторов (это предотвращает ошибки при параллельной модификации).
- Сложность: O(n).

### Метод remove(Object o)
- Ищет первый элемент, равный o, и удаляет его.
- Сложность: O(n) из-за поиска и сдвига.

</details>

---

## Предложите эффективный алгоритм удаления нескольких рядом стоящих элементов из середины списка, реализуемого ArrayList
<details> <summary>Ответ</summary>
Для удаления нескольких рядом стоящих элементов из середины ArrayList можно использовать один вызов System.arraycopy, чтобы сдвинуть элементы после удаляемого диапазона влево, и затем обновить размер списка. Это уменьшает сложность до O(n) для одного сдвига вместо O(k * n).

### Алгоритм
1. **Проверка входных данных**:
  - Убедитесь, что индексы start и end валидны: 0 <= start <= end <= size.
  - Если диапазон пуст (start == end), ничего не делать.
2. **Вычисление количества удаляемых элементов**:
  - Количество элементов для удаления: count = end - start.
3. **Сдвиг элементов**:
  - Используйте System.arraycopy для сдвига элементов, начиная с end, в позицию start, чтобы закрыть пробел.
4. **Очистка хвоста**:
  - Установите элементы в конце списка (от size - count до size - 1) в null, чтобы разорвать ссылки для сборщика мусора.
5. **Обновление размера**:
  - Уменьшите поле size на count.
6. **Обновление modCount**:
  - Увеличьте счётчик модификаций (modCount), чтобы итераторы могли обнаружить изменение структуры.

</details>

---

## Сколько необходимо дополнительной памяти при вызове ArrayList.add()?
<details> <summary>Ответ</summary>
Если в массиве достаточно места для размещения нового элемента, то дополнительной памяти не требуется.
- 0 байт для самого ArrayList, так как используется существующий массив.
- Однако, если добавляемый элемент — объект (например, String), память выделяется для этого объекта отдельно в куче. Размер зависит от типа объекта:
  - Например, для String память зависит от длины строки (примерно 40 байт для пустой строки + 2 байта на символ в UTF-16).
  - Ссылка на объект в elementData занимает 8 байт (или 4 байта при сжатых указателях в 64-битной JVM).

Иначе происходит создание нового массива размером в 1,5 раза превышающим существующий (это верно для JDK выше 1.7, в более ранних версиях размер увеличения иной).
1. **Новый массив**:
  - Размер: заголовок массива (~12 байт в HotSpot JVM) + newCapacity * sizeof(указатель).
  - Указатель занимает 8 байт (или 4 байта при сжатых указателях).
2. **Старый массив**: Временно сохраняется в памяти, пока не будет собран сборщиком мусора.
3. **Добавляемый объект**: Как и в первом случае, память для самого объекта (например, String).

</details>

---

## Сколько выделяется дополнительно памяти при вызове LinkedList.add()?
<details> <summary>Ответ</summary>
Создается один новый экземпляр вложенного класса Node.

</details>

---

## Оцените количество памяти на хранение одного примитива типа byte в LinkedList?
<details> <summary>Ответ</summary>
Каждый элемент LinkedList хранит ссылку на предыдущий элемент, следующий элемент и ссылку на данные.
```java
private static class Node<E> {
    E item;
    Node<E> next;
    Node<E> prev;
    //...
}
```
Для 32-битных систем каждая ссылка занимает 32 бита (4 байта). Сам объект (заголовок) вложенного класса Node занимает 8 байт. 4 + 4 + 4 + 8 = 20 байт, а т.к. размер каждого объекта в Java кратен 8, соответственно получаем 24 байта. Примитив типа byte занимает 1 байт памяти, но в JCF примитивы упаковываются: объект типа Byte занимает в памяти 16 байт (8 байт на заголовок объекта, 1 байт на поле типа byte и 7 байт для кратности 8). Также напомню, что значения от -128 до 127 кэшируются и для них новые объекты каждый раз не создаются. Таким образом, в x32 JVM 24 байта тратятся на хранение одного элемента в списке и 16 байт - на хранение упакованного объекта типа Byte. Итого 40 байт.
Для 64-битной JVM каждая ссылка занимает 64 бита (8 байт), размер заголовка каждого объекта составляет 16 байт (два машинных слова). Вычисления аналогичны: 8 + 8 + 8 + 16 = 40 байт и 24 байта. Итого 64 байта.

</details>

---

## Оцените количество памяти на хранение одного примитива типа byte в ArrayList?
<details> <summary>Ответ</summary>
ArrayList основан на массиве, для примитивных типов данных осуществляется автоматическая упаковка значения, поэтому 16 байт тратится на хранение упакованного объекта и 4 байта (8 для x64) - на хранение ссылки на этот объект в самой структуре данных. Таким образом, в x32 JVM 4 байта используются на хранение одного элемента и 16 байт - на хранение упакованного объекта типа Byte. Для x64 - 8 байт и 24 байта соответственно.

</details>

---

## Для ArrayList или для LinkedList операция добавления элемента в середину медленнее?
<details> <summary>Ответ</summary>
### Для ArrayList
- проверка массива на вместимость. Если вместимости недостаточно, то увеличение размера массива и копирование всех элементов в новый массив (O(N));
- копирование всех элементов, расположенных правее от позиции вставки, на одну позицию вправо (O(N));
- вставка элемента (O(1)).

### Для LinkedList
- поиск позиции вставки (O(N));
- вставка элемента (O(1)).

В худшем случае вставка в середину списка эффективнее для LinkedList. В остальных - скорее всего, для ArrayList, поскольку копирование элементов осуществляется за счет вызова быстрого системного метода System.arraycopy().

</details>

---

## В реализации класса ArrayList есть следующие поля: Object[] elementData, int size. Объясните, зачем хранить отдельно size, если всегда можно взять elementData.length?
<details> <summary>Ответ</summary>
Размер массива elementData.length представляет собой вместимость (capacity) ArrayList, которая всегда больше переменной size - реального количества хранимых элементов. При необходимости вместимость автоматически возрастает.

</details>

---

## Кто кого расширяет: Queue расширяет Deque, или Deque расширяет Queue?
<details> <summary>Ответ</summary>
Queue - это очередь, которая обычно (но необязательно) строится по принципу FIFO (First-In-First-Out) - соответственно извлечение элемента осуществляется с начала очереди, вставка элемента - в конец очереди. Хотя этот принцип нарушает, к примеру, PriorityQueue, использующая «natural ordering» или переданный Comparator при вставке нового элемента. Deque (Double Ended Queue) расширяет Queue и согласно документации, это линейная коллекция, поддерживающая вставку/извлечение элементов с обоих концов. Помимо этого, реализации интерфейса Deque могут строится по принципу FIFO, либо LIFO. Реализации и Deque, и Queue обычно не переопределяют методы equals() и hashCode(), вместо этого используются унаследованные методы класса Object, основанные на сравнении ссылок.

</details>

---

## Почему LinkedList реализует и List, и Deque?
<details> <summary>Ответ</summary>
LinkedList позволяет добавлять элементы в начало и конец списка за константное время, что хорошо согласуется с поведением интерфейса Deque.

</details>

---

## LinkedList — это односвязный, двусвязный или четырехсвязный список?
<details> <summary>Ответ</summary>
Двусвязный: каждый элемент LinkedList хранит ссылку на предыдущий и следующий элементы.

</details>

---

## Как перебрать элементы LinkedList в обратном порядке, не используя медленный get(index)?
<details> <summary>Ответ</summary>
Для этого в LinkedList есть обратный итератор, который можно получить вызва метод descendingIterator().

</details>

---

## Какие FIFO-очереди есть в java?
<details> <summary>Ответ</summary>
1. **Обычная FIFO-очередь**:
  - **ArrayDeque** (лучшая производительность)
  - **LinkedList** (если нужен List функционал)
2. **Приоритетная очередь**:
  - **PriorityQueue**
  - **PriorityBlockingQueue** (потокобезопасная)
3. **Многопоточные сценарии**:
  - **ConcurrentLinkedQueue** (неблокирующая)
  - **ArrayBlockingQueue/LinkedBlockingQueue** (блокирующие)
4. **Специальные случаи**:
  - **DelayQueue** для отложенных элементов
  - **TransferQueue (LinkedTransferQueue)** Поддерживает передачу элементов между потоками

</details>

---

## Расскажи как изнутри работает ArrayDeque?
<details> <summary>Ответ</summary>
ArrayDeque — это реализация двусторонней очереди (Deque) на основе циклического массива, которая обеспечивает эффективное добавление и удаление элементов с обоих концов. Рассмотрим его внутреннее устройство и ключевые механизмы работы.

### Внутренняя структура
#### Хранение данных
ArrayDeque использует массив (Object[]) для хранения элементов и два указателя:
- **head** — индекс первого элемента (начало очереди).
- **tail** — индекс, куда будет вставлен следующий элемент (конец очереди).
```java
transient Object[] elements; // Массив элементов
transient int head;          // Указатель на начало
transient int tail;          // Указатель на конец
```

#### Циклическая организация
Массив работает по принципу кольцевого буфера:
- Когда head или tail достигают конца массива, они "переходят" в начало (0).
- Это позволяет эффективно использовать память без постоянного копирования данных.

Пример:
```java
Исходный массив: [A, B, C, D, E, F, G, H]
head = 2 (начало на "C")
tail = 6 (конец на "G")

Добавление элемента "X":
elements[tail] = X → elements[6] = X
tail = (tail + 1) % capacity → 7
```
</details>

---

## Расскажи как изнутри работает PriorityQueue?
<details> <summary>Ответ</summary>
PriorityQueue в Java — это структура данных, реализующая очередь с приоритетами, которая хранит элементы в порядке, определённом их естественным сравнением или пользовательским компаратором. Она входит в состав Java Collections Framework (java.util.PriorityQueue) и основана на бинарной куче (binary heap), что обеспечивает эффективное управление элементами с приоритетами. В этом ответе я подробно разберу, как PriorityQueue работает внутри, включая её реализацию, ключевые операции, использование памяти и особенности.

PriorityQueue использует минимальную бинарную кучу (min-heap), реализованную в виде массива Object[] queue. Бинарная куча — это полное бинарное дерево, где:
- Значение каждого узла меньше или равно значениям его потомков (для min-heap).
- Дерево заполняется слева направо, обеспечивая компактное представление в массиве.

**Свойства кучи**:
- Корень: Элемент с наименьшим приоритетом находится в queue[0].
- Родитель и потомки:
  - Для узла с индексом i:
    - Левый потомок: 2 * i + 1.
    - Правый потомок: 2 * i + 2.
    - Родитель: (i - 1) / 2 (целочисленное деление).
- Компактность: Элементы хранятся в массиве последовательно, без пропусков, пока не достигнут текущий размер (size).

#### Поля класса
Основные поля PriorityQueue (на основе исходного кода OpenJDK):
```java
public class PriorityQueue<E> extends AbstractQueue<E> implements Serializable {
    private transient Object[] queue; // Массив для хранения кучи
    private int size = 0; // Текущее количество элементов
    private transient Comparator<? super E> comparator; // Компаратор (null для естественного порядка)
    private transient int modCount; // Счётчик модификаций для итераторов
    private static final int DEFAULT_INITIAL_CAPACITY = 11; // Начальная ёмкость по умолчанию
    // ... другие поля и методы
}
```
- **queue**: Массив Object[], хранящий элементы кучи.
- **size**: Текущее количество элементов в куче (не путать с queue.length, которое является ёмкостью).
- **comparator**: Если не null, определяет порядок элементов; иначе используется естественный порядок (Comparable).
- **modCount**: Используется для отслеживания структурных изменений (для итераторов).

### Основные операции
#### Добавление элемента (offer(e))
- **Проверка емкости**:
  - Если массив заполнен, увеличивается в 1.5 раза (аналогично ArrayList).
- **Добавление в конец**:
  - Элемент помещается в первую свободную позицию (queue[size+1]).
- **Восстановление кучи (siftUp)**:
  - Элемент "поднимается" по куче, пока не найдет правильное место.
  - Сравнение идет через Comparator или compareTo() (если Comparable).
```java
Пример добавления 5:
Исходная куча: [3, 8, 10]
1. Добавляем 5 в конец: [3, 8, 10, 5]
2. Сравниваем 5 с родителем (10):
   5 < 10 → меняем местами.
3. Новая куча: [3, 5, 8, 10]
```

#### Извлечение элемента (poll())
- **Извлечение корня**:
  - Возвращается queue[1] (минимальный элемент).
- **Замена корня последним элементом**:
  - queue[1] = queue[size], затем size--.
- **Восстановление кучи (siftDown)**:
  - Новый корень "опускается" вниз, пока куча не упорядочится.
  - На каждом шаге выбирается меньший из двух потомков.
```java
Пример удаления корня (3):
Исходная куча: [3, 8, 5, 10]
1. Удаляем 3, заменяем его на 10: [10, 8, 5]
2. Сравниваем 10 с потомками (8 и 5):
   - 5 < 8 → меняем 10 и 5.
3. Новая куча: [5, 8, 10]
```

</details>

---

## Какие наследники интерфейса Map есть в Java?
<details> <summary>Ответ</summary>
| Класс               | Особенности                                                                 | Порядок элементов                                      | Потокобезопасность       |
|---------------------|-----------------------------------------------------------------------------|-------------------------------------------------------|--------------------------|
| HashMap             | Хэш-таблица, разрешение коллизий через цепочки/деревья (Java 8+)            | Не гарантируется                                       | Нет                      |
| LinkedHashMap       | Сохраняет порядок вставки/доступа                                          | В порядке вставки или доступа (LRU)                    | Нет                      |
| TreeMap             | Красно-черное дерево, сортировка по ключам                                  | В порядке сортировки (natural ordering/comparator)    | Нет                      |
| Hashtable           | Устаревший synchronized аналог HashMap                                      | Не гарантируется                                       | Да (блокировка на весь экземпляр) |
| IdentityHashMap     | Сравнение ключей через == вместо equals()                                   | Не гарантируется                                       | Нет                      |
| WeakHashMap         | WeakReference для ключей (GC может удалять записи)                          | Не гарантируется                                       | Нет                      |

</details>

---

## Расскажи как работает HashMap?
<details> <summary>Ответ</summary>
`HashMap` в Java — это структура данных из Java Collections Framework (`java.util.HashMap`), реализующая интерфейс `Map`. Она представляет собой хэш-таблицу, которая хранит пары ключ-значение и обеспечивает быстрый доступ, добавление и удаление элементов за среднее время O(1).


Основные поля `HashMap` (на основе исходного кода OpenJDK):
```java
public class HashMap<K,V> extends AbstractMap<K,V> implements Map<K,V>, Cloneable, Serializable {
    transient Node<K,V>[] table; // Массив бакетов
    transient Set<Map.Entry<K,V>> entrySet; // Кэш для набора записей
    transient int size; // Количество пар ключ-значение
    transient int modCount; // Счётчик модификаций для итераторов
    int threshold; // Порог для увеличения размера (capacity * loadFactor)
    final float loadFactor; // Коэффициент загрузки
    static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // 16
    static final float DEFAULT_LOAD_FACTOR = 0.75f;
    static final int TREEIFY_THRESHOLD = 8; // Порог для преобразования в дерево
    static final int UNTREEIFY_THRESHOLD = 6; // Порог для обратного преобразования
    static final int MIN_TREEIFY_CAPACITY = 64; // Минимальная ёмкость для использования деревьев
}
```
- **table**: Массив бакетов, где каждый бакет хранит связный список (`Node`) или красно-чёрное дерево (`TreeNode`).
- **size**: Количество пар ключ-значение.
- **threshold**: Порог, при котором массив увеличивается (`capacity * loadFactor`).
- **loadFactor**: Коэффициент загрузки (по умолчанию 0.75), определяет, когда нужно увеличивать массив.
- **modCount**: Отслеживает изменения структуры для предотвращения ошибок итерации.

#### Структура узла
Каждый элемент хранится в узле типа `Node<K,V>` (или `TreeNode<K,V>` для деревьев):
```java
static class Node<K,V> implements Map.Entry<K,V> {
    final int hash; // Хэш-код ключа
    final K key; // Ключ
    V value; // Значение
    Node<K,V> next; // Ссылка на следующий узел в бакете (для коллизий)
}
```
- Для `TreeNode` (красно-чёрное дерево) добавляются поля: `parent`, `left`, `right`, `red` (ещё ~20 байт).

#### Хэш-таблица
- **Массив бакетов (`table`)**: Хранит элементы в виде связных списков или деревьев.
- **Хэширование**: Ключ преобразуется в индекс бакета с помощью хэш-функции:
```java
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```
- `key.hashCode()` вычисляет хэш-код.
- Сдвиг и XOR (`h >>> 16`) улучшают распределение, уменьшая коллизии для больших хэш-кодов.
- Индекс: `index = hash & (table.length - 1)` (использует битовую операцию вместо деления, так как `table.length` — степень двойки).
- **Размер массива**: Всегда степень двойки (например, 16, 32, 64), чтобы оптимизировать вычисление индекса.

#### Обработка коллизий
Когда несколько ключей попадают в один бакет (из-за одинаковых хэш-кодов или индексов):
- **До Java 8**: Коллизии обрабатывались только связным списком (`Node`).
- **С Java 8**: Если в бакете становится больше `TREEIFY_THRESHOLD` (8) элементов и общая ёмкость таблицы ≥ `MIN_TREEIFY_CAPACITY` (64), связный список преобразуется в **красно-чёрное дерево** (`TreeNode`).
- **Обратное преобразование**: Если количество элементов в бакете уменьшается до `UNTREEIFY_THRESHOLD` (6), дерево преобразуется обратно в связный список.
- **Почему деревья?**:
  - Связный список: O(n) для поиска/вставки в бакете.
  - Красно-чёрное дерево: O(log n), что лучше при большом количестве коллизий (например, если `hashCode` плохо распределён).

### Основные операции
#### Добавление элемента (`put(K key, V value)`)
- **Процесс**:
  1. **Вычисление индекса**:
    - Вычисляется `hash(key)` и индекс: `hash & (table.length - 1)`.
  2. **Проверка таблицы**:
    - Если `table == null`, инициализируется с начальной ёмкостью (по умолчанию 16).
  3. **Добавление в бакет**:
    - Если бакет пуст, создаётся новый узел `Node`.
    - Если бакет занят:
      - **Связный список**: Проверяется ключ (`equals`), если совпадает — обновляется значение; иначе добавляется новый узел в конец.
      - **Дерево**: Выполняется вставка в красно-чёрное дерево.
  4. **Увеличение размера**: `size++`.
  5. **Проверка порога**:
    - Если `size > threshold` (обычно `capacity * 0.75`), вызывается `resize()` для увеличения массива.
- **Сложность**:
  - Средняя: O(1) (при хорошем хэш-коде).
  - Худшая: O(log n) (для деревьев) или O(n) (для длинных списков при плохом `hashCode`).
- **Память**: Новый узел (~40 байт) + память для ключа и значения.

**Пример**:
```java
HashMap<String, Integer> map = new HashMap<>();
map.put("A", 1); // Новый узел в бакете
map.put("B", 2); // Ещё один узел
```

#### Получение элемента (`get(Object key)`)
- **Процесс**:
  1. Вычисляется `hash(key)` и индекс.
  2. В бакете ищется узел:
    - **Связный список**: Линейный поиск с помощью `equals`.
    - **Дерево**: Поиск в красно-чёрном дереве.
  3. Возвращается значение или `null`, если ключ не найден.
- **Сложность**: O(1) в среднем, O(log n) для деревьев, O(n) в худшем случае.

#### Удаление элемента (`remove(Object key)`)
- **Процесс**:
  1. Находит узел по хэшу и ключу.
  2. Удаляет узел:
    - **Связный список**: Обновляет ссылки `next`.
    - **Дерево**: Выполняет удаление из красно-чёрного дерева.
  3. Уменьшает `size`.
- **Сложность**: O(1) в среднем, O(log n) для деревьев, O(n) в худшем случае.

#### Изменение размера (`resize()`)
- **Процесс**:
  1. Новая ёмкость: Обычно удваивается (например, с 16 до 32).
  2. Создаётся новый массив `Node[]`.
  3. Все элементы перераспределяются:
    - Для связных списков: Элементы либо остаются в том же бакете, либо перемещаются в новый (индекс = `hash & (newCapacity - 1)`).
    - Для деревьев: Дерево разделяется на два (для старого и нового индексов).
  4. Старый массив становится доступным для сборки мусора.
- **Сложность**: O(n).
- **Память**: Новый массив (12 + `newCapacity * 8` байт) + временное хранение старого массива.

### Особенности
- **Null-обработка**:
  - Один `null`-ключ хранится в `table[0]` (так как `hash(null) = 0`).
  - Значения могут быть `null`.
- **Итерация**:
  - Итераторы (`entrySet`, `keySet`, `values`) проходят по бакетам и узлам.
  - Изменение структуры во время итерации вызывает ConcurrentModificationException (fail-fast).

</details>

---

## Как работает красно черное дерево?
<details> <summary>Ответ</summary>
Красно-чёрное дерево — это бинарное дерево поиска с дополнительным атрибутом цвета (красный или чёрный) для каждого узла, которое обеспечивает балансировку через соблюдение определённых правил.
Эти правила гарантируют, что дерево остаётся сбалансированным, а высота дерева ограничена O(log n), что делает операции эффективными.

### Свойства красно-чёрного дерева
1. **Цвет узла**: Каждый узел либо **красный**, либо **чёрный**.
2. **Корень чёрный**: Корень дерева всегда чёрный.
3. **Листы (NIL)**: Все листья (внешние null-узлы) считаются чёрными.
4. **Красные узлы**: Если узел красный, оба его потомка должны быть чёрными (запрещены два последовательных красных узла).
5. **Чёрная высота**: Для каждого узла все пути от него до листьев (NIL) содержат одинаковое количество чёрных узлов.

Эти свойства гарантируют, что самый длинный путь от корня до листа не более чем в два раза длиннее самого короткого пути, что обеспечивает балансировку.


### 1. **Реализация в Java**
В Java красно-чёрные деревья используются в:
- **`TreeMap` и `TreeSet`**: Основная структура данных для хранения элементов.
- **`HashMap`**: С Java 8 для обработки коллизий в бакетах, когда их длина превышает `TREEIFY_THRESHOLD` (8).

#### a) **Внутренняя структура**
В `HashMap` красно-чёрное дерево реализовано через внутренний класс `TreeNode<K,V>`, который расширяет `Node<K,V>`:
```java
static final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V> {
    TreeNode<K,V> parent; // Ссылка на родителя
    TreeNode<K,V> left;   // Левый потомок
    TreeNode<K,V> right;  // Правый потомок
    TreeNode<K,V> prev;   // Для сохранения порядка в LinkedHashMap
    boolean red;          // Цвет узла (true = красный, false = чёрный)
}
```
- **Поля**:
  - `parent`, `left`, `right`: Ссылки для структуры дерева.
  - `red`: Булево поле для цвета (1 байт, но из-за выравнивания может занимать больше).
  - Наследует от `Node`: `hash`, `key`, `value`, `next` (для совместимости с цепочкой коллизий).

#### b) **Хранение в `HashMap`**
- В `HashMap` красно-чёрное дерево используется в бакетах вместо связного списка, если:
  - Количество узлов в бакете ≥ `TREEIFY_THRESHOLD` (8).
  - Размер таблицы ≥ `MIN_TREEIFY_CAPACITY` (64).
- Преобразование из списка в дерево (`treeify`):
  - Узлы `Node` заменяются на `TreeNode`, и структура перестраивается в красно-чёрное дерево.
- Обратное преобразование (`untreeify`):
  - Если узлов становится ≤ `UNTREEIFY_THRESHOLD` (6), дерево преобразуется обратно в связный список.


### 2. **Основные операции**

#### a) **Поиск (`get` в `HashMap`)**
- **Процесс**:
  1. Вычисляется хэш ключа и индекс бакета.
  2. Если бакет — дерево, выполняется поиск в красно-чёрном дереве:
  - Сравнивается ключ с корневым узлом (через `compareTo` или `Comparator`).
  - Переход в левое или правое поддерево в зависимости от сравнения.
  - Для равных ключей (по `compareTo`) проверяется `equals` и хэш-код.
  3. Возвращается значение или `null`, если ключ не найден.
- **Сложность**: O(log n), где `n` — количество узлов в бакете.
- **Особенность**: В `HashMap` сравнение ключей учитывает не только `compareTo` (или компаратор), но и `hashCode` и `equals` для корректной обработки равных ключей с разными хэшами.

#### b) **Вставка (`put` в `HashMap`)**
- **Процесс**:
  1. Если бакет — связный список, проверяется порог `TREEIFY_THRESHOLD`. При превышении вызывается `treeifyBin` для преобразования в дерево.
  2. Вставка в дерево:
  - Новый узел `TreeNode` создаётся и добавляется как в обычное бинарное дерево поиска.
  - После вставки проверяются свойства красно-чёрного дерева:
    - Если новый узел красный и нарушает свойство (например, два красных узла подряд), выполняются **ротации** и/или **перекрашивание**.
  3. **Балансировка**:
  - **Ротации**: Левый или правый поворот для восстановления баланса.
  - **Перекрашивание**: Изменение цветов узлов для соблюдения свойств (например, красный родитель и красный ребёнок).
  4. Корень бакета становится чёрным.

- **Сложность**: O(log n) для вставки и балансировки.
- **Память**: Новый узел `TreeNode` (~60 байт) + память для ключа и значения.

#### c) **Удаление (`remove` в `HashMap`)**
- **Процесс**:
  1. Находит узел по ключу (O(log n)).
  2. Удаляет узел, как в бинарном дереве поиска:
  - Если узел — лист, он просто удаляется.
  - Если у узла один ребёнок, ребёнок заменяет узел.
  - Если два ребёнка, узел заменяется минимальным элементом из правого поддерева.
  3. Выполняется балансировка:
  - Перекрашивание и ротации для восстановления свойств.
  - Проверяется чёрная высота путей.
  4. Если узлов в бакете становится ≤ `UNTREEIFY_THRESHOLD` (6), дерево преобразуется в связный список.
- **Сложность**: O(log n).
- **Память**: Удалённый узел становится доступным для сборки мусора.

#### d) **Перестройка при изменении размера `HashMap` (`resize`)**
- При увеличении размера таблицы (`table`) бакеты перераспределяются:
  - Дерево в бакете может разделиться на два поддерева (для старого и нового индексов).
  - Если поддерево становится маленьким, оно преобразуется в связный список.
- **Сложность**: O(n) для всей таблицы, O(log n) для обработки одного дерева.


### 3. **Особенности в `HashMap`**
- **Преобразование в дерево**:
  - Происходит, только если `table.length ≥ 64` и бакет содержит ≥ 8 узлов.
  - Это предотвращает ненужное усложнение для маленьких таблиц.
- **Сравнение ключей**:
  - Используется `Comparable` (или `Comparator`), но также учитываются `hashCode` и `equals` для корректной обработки коллизий.
  - Пример:
    ```java
    if (p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k))))
    ```
- **Балансировка**:
  - Ротации и перекрашивание минимизируют высоту дерева.
  - Чёрная высота гарантирует, что дерево не вырождается в список.
- **Обратное преобразование**:
  - Если узлов в бакете ≤ 6, дерево превращается в связный список для экономии памяти.

### 4. **Ограничения**
- **Память**: `TreeNode` требует больше памяти, чем `Node` (~60 байт против ~40 байт).
- **Сложность преобразования**: Переход от списка к дереву (O(n log n)) и обратно (O(n)) может быть дорогим для маленьких бакетов.
- **Сравнение ключей**: Требуется реализация `Comparable` или предоставление `Comparator`, иначе выбросится `ClassCastException`.

</details>

---

## Расскажи как работает LinkedHashMap?

<details> <summary>Ответ</summary>

`LinkedHashMap` в Java — это структура данных из пакета `java.util`, которая является расширением `HashMap` и сочетает в себе хэш-таблицу с двусвязным списком для сохранения порядка элементов.
Она реализует интерфейс `Map` и предоставляет функциональность хэш-таблицы с быстрым доступом по ключу (O(1) в среднем), одновременно поддерживая либо **порядок вставки**, либо **порядок доступа** (LRU — Least Recently Used).

`LinkedHashMap` наследуется от `HashMap` и добавляет поля для поддержки двусвязного списка:
```java
public class LinkedHashMap<K,V> extends HashMap<K,V> implements Map<K,V> {
    // Двусвязный список
    transient LinkedHashMap.Entry<K,V> head; // Голова списка
    transient LinkedHashMap.Entry<K,V> tail; // Хвост списка
    // Режим порядка: true = порядок доступа, false = порядок вставки
    final boolean accessOrder;
    // Поля, унаследованные от HashMap:
    transient Node<K, V>[] table; // Массив бакетов
  transient int size; // Количество пар ключ-значение
  int threshold; // Порог для увеличения размера
  final float loadFactor; // Коэффициент загрузки
}
```
- `head`, `tail`: Указатели на начало и конец двусвязного списка, связывающего все записи.
- `accessOrder`: Определяет порядок:
  - `false` (по умолчанию): Порядок вставки (элементы в порядке добавления).
  - `true`: Порядок доступа (элементы переупорядочиваются при `get` или `put`, помещая недавно использованные в конец).
- Унаследованные поля от `HashMap`: `table` (массив бакетов), `size`, `threshold`, `loadFactor`.

`LinkedHashMap` использует специализированный класс `Entry<K,V>`, который расширяет `HashMap.Node<K,V>`:
```java
static class Entry<K,V> extends HashMap.Node<K,V> {
    Entry<K,V> before, after; // Ссылки на предыдущий и следующий узлы в двусвязном списке
    Entry(int hash, K key, V value, Node<K,V> next) {
        super(hash, key, value, next);
        this.before = null;
        this.after = null;
    }
}
```
</details>

---

### Расскажи как работает TreeMap?

<details> <summary>Ответ</summary>

`TreeMap` в Java — это структура данных из пакета `java.util`, реализующая интерфейс `NavigableMap` (расширяющий `SortedMap` и `Map`). Она основана на **красно-чёрном дереве**, что обеспечивает упорядоченное хранение пар ключ-значение и гарантированную производительность операций (`get`, `put`, `remove`) на уровне O(log n). `TreeMap` хранит ключи в отсортированном порядке, что делает её подходящей для задач, требующих естественного порядка или пользовательской сортировки.


Основные поля `TreeMap` (на основе исходного кода OpenJDK):
```java
public class TreeMap<K,V> extends AbstractMap<K,V> implements NavigableMap<K,V>, Cloneable, Serializable {
    private final Comparator<? super K> comparator; // Компаратор для сортировки ключей
    private transient Entry<K,V> root; // Корень красно-чёрного дерева
    private transient int size = 0; // Количество пар ключ-значение
    private transient int modCount = 0; // Счётчик модификаций для итераторов
}
```
- `comparator`: Если `null`, используется естественный порядок ключей (через `Comparable`); иначе — заданный компаратор.
- `root`: Указатель на корневой узел дерева (`null`, если дерево пусто).
- `size`: Количество элементов.
- `modCount`: Отслеживает структурные изменения для предотвращения ошибок при итерации.

Каждый элемент хранится в узле типа `Entry<K,V>`:
```java
static final class Entry<K,V> implements Map.Entry<K,V> {
    K key; // Ключ
    V value; // Значение
    Entry<K,V> left; // Левый потомок
    Entry<K,V> right; // Правый потомок
    Entry<K,V> parent; // Родитель
    boolean color; // Цвет узла (true = красный, false = чёрный)
}
```
- **Поля**:
  - `key`, `value`: Ссылки на ключ и значение.
  - `left`, `right`, `parent`: Ссылки для структуры бинарного дерева.
  - `color`: Булево поле для цвета (1 байт, выравнивается до 4 байт).

</details>

---

###  Расскажи как работает IdentityHashMap?

<details> <summary>Ответ</summary>

`IdentityHashMap` в Java — это специализированная реализация интерфейса `Map` из пакета `java.util`, которая использует **сравнение по ссылочной идентичности** (==) вместо логического равенства (`equals`) для ключей. Это отличает её от других реализаций, таких как `HashMap`, `LinkedHashMap` или `TreeMap`, которые полагаются на методы `equals` и `hashCode`. `IdentityHashMap` оптимизирована для случаев, когда важно учитывать физическое равенство объектов (их адреса в памяти), а не их логическое содержимое.


Основные поля `IdentityHashMap` (на основе исходного кода OpenJDK):
```java
public class IdentityHashMap<K,V> extends AbstractMap<K,V> implements Map<K,V>, Serializable, Cloneable {
    private transient Object[] table; // Массив для хранения ключей и значений
    private int size; // Количество пар ключ-значение
    private transient int modCount; // Счётчик модификаций для итераторов
    private static final int DEFAULT_CAPACITY = 32; // Начальная ёмкость (2^5)
    private static final int MINIMUM_CAPACITY = 4; // Минимальная ёмкость (2^2)
    private static final int MAXIMUM_CAPACITY = 1 << 29; // Максимальная ёмкость (2^29)
}
```
- `table`: Массив `Object[]`, где хранятся ключи и значения в чередующемся порядке (ключ в `table[2*i]`, значение в `table[2*i+1]`).
- `size`: Количество пар ключ-значение.
- `modCount`: Отслеживает изменения структуры для итераторов.
- **Отсутствие `loadFactor`**: В отличие от `HashMap`, `IdentityHashMap` не использует коэффициент загрузки; вместо этого массив увеличивается, когда заполняется примерно на 2/3.

#### b) **Структура хранения**
- **Массив `table`**:
  - Размер массива всегда является степенью двойки (например, 4, 8, 16, ..., 2²⁹).
  - Каждая пара ключ-значение занимает **две смежные ячейки**: ключ в `table[2*i]`, значение в `table[2*i+1]`.
  - Это упрощает доступ, так как ключ и значение хранятся рядом, улучшая локальность данных.
- **Линейное зондирование**:
  - Коллизии (когда несколько ключей претендуют на один индекс) обрабатываются путём поиска следующей свободной пары ячеек в массиве.
  - Зондирование продолжается, пока не найдётся свободная пара или ключ не будет найден/подтверждён отсутствующим.

#### c) **Хэш-функция**
`IdentityHashMap` использует `System.identityHashCode` вместо пользовательского `hashCode`:
```java
int hash = System.identityHashCode(key);
```
- **Особенности**:
  - `System.identityHashCode(obj)` возвращает хэш-код, основанный на адресе объекта в памяти, даже если класс переопределяет `hashCode`.
  - Для `null` возвращается 0.
- **Преобразование в индекс**:
  - Хэш-код преобразуется в индекс с помощью функции `nextKeyIndex`:
    ```java
    static int nextKeyIndex(int i, int len) {
        return (i + 2 < len ? i + 2 : 0);
    }
    ```
  - Начальный индекс: `hash & (table.length - 2)` (гарантирует чётный индекс для ключа).
  - Если ячейка занята, поиск продолжается с шагом +2 (линейное зондирование).
- **Оптимизация хэш-кода**:
  - Для улучшения распределения используется дополнительное смешивание:
    ```java
    static int hash(Object x, int length) {
        int h = System.identityHashCode(x);
        h += ~(h << 9);
        h ^= (h >>> 14);
        h += (h << 4);
        h ^= (h >>> 10);
        return h & (length - 2);
    }
    ```
  - Это уменьшает вероятность коллизий, смешивая биты хэш-кода.

#### d) **Обработка коллизий**
- **Линейное зондирование**:
  - Если индекс `i` занят, проверяется следующий чётный индекс (`i + 2`, затем `i + 4`, и так далее, с обёртыванием в начало массива при `i + 2 ≥ table.length`).
  - Поиск останавливается, когда:
    - Найден ключ (сравнение через `==`).
    - Найдена свободная ячейка (`table[i] == null`).
    - Пройден весь массив (гарантирует отсутствие ключа).
- **Преимущества**:
  - Простота реализации.
  - Хорошая локальность данных, так как ключи и значения хранятся рядом.
- **Недостатки**:
  - При высокой загрузке (близкой к 2/3) зондирование может стать длинным, увеличивая сложность до O(n).

</details>

---

##  Расскажи как работает WeakHashMap?
<details> <summary>Ответ</summary>
`WeakHashMap` в Java — это специализированная реализация интерфейса `Map` из пакета `java.util`, которая использует **слабые ссылки** (`WeakReference`) для ключей, позволяя сборщику мусора (Garbage Collector) автоматически удалять записи, если на ключ больше нет сильных ссылок. Это делает `WeakHashMap` полезной для реализации кэшей, где записи должны автоматически очищаться, когда ключи становятся недоступными. В отличие от `HashMap`, `WeakHashMap` не предотвращает сборку мусора ключей, что существенно влияет на её поведение.

Основные поля `WeakHashMap` (на основе исходного кода OpenJDK):
```java
public class WeakHashMap<K,V> extends AbstractMap<K,V> implements Map<K,V> {
    private transient Entry<K,V>[] table; // Массив бакетов
    private transient int size; // Количество пар ключ-значение
    private int threshold; // Порог для увеличения размера (capacity * loadFactor)
    private final float loadFactor; // Коэффициент загрузки
    private final ReferenceQueue<Object> queue = new ReferenceQueue<>(); // Очередь для удалённых ключей
    transient int modCount; // Счётчик модификаций для итераторов
    private static final int DEFAULT_INITIAL_CAPACITY = 16;
    private static final float DEFAULT_LOAD_FACTOR = 0.75f;
}
```
- `table`: Массив бакетов, где каждый бакет содержит связный список узлов `Entry`.
- `size`: Количество активных пар ключ-значение.
- `threshold`: Порог, при котором массив увеличивается (`capacity * loadFactor`).
- `loadFactor`: Коэффициент загрузки (по умолчанию 0.75).
- `queue`: `ReferenceQueue` для хранения `WeakReference`, чьи ключи были собраны сборщиком мусора.
- `modCount`: Отслеживает изменения структуры для итераторов.

#### b) **Структура узла**
Каждый элемент хранится в узле типа `Entry<K,V>`, который расширяет `WeakReference`:
```java
private static class Entry<K,V> extends WeakReference<Object> implements Map.Entry<K,V> {
    V value; // Значение
    int hash; // Хэш-код ключа
    Entry<K,V> next; // Ссылка на следующий узел в бакете
}
```
- **Поля**:
  - `WeakReference<Object>`: Хранит ключ как слабую ссылку, связанную с `queue`.
  - `value`: Ссылка на значение.
  - `hash`: Хэш-код ключа, вычисленный на момент вставки.
  - `next`: Ссылка на следующий узел в бакете для обработки коллизий.

#### c) **Хэш-таблица**
- **Массив бакетов (`table`)**:
  - Как в `HashMap`, размер массива — степень двойки (16, 32, 64, ...).
  - Каждый бакет содержит связный список узлов `Entry` или `null`.
- **Хэширование**:
  - Используется та же хэш-функция, что в `HashMap`:
  - Индекс бакета: `hash & (table.length - 1)`.
- **Обработка коллизий**:
  - Коллизии разрешаются через связные списки (в отличие от `HashMap`, где могут использоваться красно-чёрные деревья при большом количестве узлов).
  - Это упрощает реализацию, но может привести к O(n) при большом количестве коллизий.

#### d) **Слабые ссылки и `ReferenceQueue`**
- **Слабые ссылки**:
  - Ключи обёрнуты в `WeakReference`, что позволяет сборщику мусора удалять их, если на них нет сильных или мягких ссылок.
  - Когда ключ собирается, объект `WeakReference` помещается в `queue`.
- **Очистка записей**:
  - Перед каждой операцией (`get`, `put`, `remove`, `size`, и т.д.) вызывается метод `expungeStaleEntries`:
  - Удаляет записи, чьи ключи были собраны, из `table` и уменьшает `size`.
  - Синхронизация на `queue` предотвращает проблемы при многопоточном доступе к очереди.
</details>

---

## Stack считается «устаревшим». Чем его рекомендуют заменять? Почему?
<details> <summary>Ответ</summary>
Stack был добавлен в Java 1.0 как реализация стека LIFO (last-in-first-out) и является расширением коллекции Vector, хотя это несколько нарушает понятие стека (например, класс Vector предоставляет возможность обращаться к любому элементу по индексу). Является частично синхронизированной коллекцией (кроме метода добавления push()) с вытекающими отсюда последствиями в виде негативного воздействия на производительность. После добавления в Java 1.6 интерфейса Deque, рекомендуется использовать реализации именно этого интерфейса, например, ArrayDeque.

</details>

---

## Зачем нужен HashMap, если есть Hashtable?
<details> <summary>Ответ</summary>
- Методы класса Hashtable синхронизированы, что приводит к снижению производительности, а HashMap - нет;
- HashTable не может содержать элементы null, тогда как HashMap может содержать один ключ null и любое количество значений null;
- Iterator у HashMap, в отличие от Enumeration у HashTable, работает по принципу «fail-fast» (выдает исключение при любой несогласованности данных).

Hashtable это устаревший класс и его использование не рекомендовано.

</details>

---

## В чем разница между HashMap и IdentityHashMap?
<details> <summary>Ответ</summary>
#### **HashMap**
- Использует методы `equals()` и `hashCode()` для сравнения ключей и определения их хэш-кодов.
- Два разных объекта, которые считаются равными по `equals()`, **не могут быть разными ключами**.
- Стандартная реализация ассоциативного массива.

```java
Map<String, Integer> map = new HashMap<>();
map.put(new String("a"), 1);
map.put(new String("a"), 2); // перезапишет значение
```

#### **IdentityHashMap**
- Сравнивает **ключи по ссылке (==)**, игнорируя метод `equals()`.
- Вычисляет хэш-код с помощью **`System.identityHashCode()`**, а не метода `hashCode()` объекта.
- Подходит для случаев, когда нужно гарантировать уникальность **именно объектов по ссылке**.

```java
Map<String, Integer> map = new IdentityHashMap<>();
map.put(new String("a"), 1);
map.put(new String("a"), 2); // добавит новый элемент — это разные объекты
```

#### 📌 Ключевая разница:

| Критерий                  | `HashMap`                        | `IdentityHashMap`               |
|---------------------------|----------------------------------|----------------------------------|
| Сравнение ключей          | через `equals()`                 | через `==` (по ссылке)           |
| Хэширование               | через `hashCode()`               | через `System.identityHashCode()`|
| Когда использовать       | обычное использование            | когда важна идентичность ссылок   |

</details>

---

## В чем разница между HashMap и WeakHashMap?
<details> <summary>Ответ</summary>
#### **HashMap**
- Ключи в `HashMap` **предотвращают удаление объектов сборщиком мусора (GC)**.
- Обычная реализация ассоциативного массива "ключ-значение".
- Объекты остаются в памяти, пока они есть в карте.

#### **WeakHashMap**
- Использует **слабые ссылки (WeakReference)** на ключи.
- Если на ключ **нет других сильных ссылок**, он автоматически удаляется из карты при следующей работе GC.
- Полезен, когда нужно связать данные с объектами, **не мешая их удалению**.

```java
Map<Key, Value> map = new WeakHashMap<>();
map.put(new Key(), new Value()); // после GC: если нет других ссылок — запись исчезнет
```

## 📋 Таблица сравнения:
<details> <summary>Ответ</summary>
| Характеристика           | `HashMap`                        | `WeakHashMap`                      |
|--------------------------|----------------------------------|------------------------------------|
| Тип ссылок               | Сильные (strong)                 | Слабые (weak) для ключей           |
| Удаление неиспользуемых  | Нет                              | Да (автоматически через GC)        |
| Потенциальная утечка     | Может быть                       | Минимизирована                     |
| Использование            | Общее хранение данных            | Кэши, временные маппинги            |

</details>

---

## В WeakHashMap используются WeakReferences. А почему бы не создать SoftHashMap на SoftReferences или PhantomHashMap на PhantomReferences?
<details> <summary>Ответ</summary>

- **WeakReference**:
  - Объект, на который ссылается `WeakReference`, собирается сборщиком мусора (Garbage Collector, GC), как только на него **не остаётся сильных ссылок**. Очистка происходит довольно агрессивно, обычно в следующем цикле GC.
  - Используется в `WeakHashMap` для автоматического удаления записей, когда ключи становятся недоступными.
  - Подходит для временных кэшей, где записи не должны задерживаться в памяти.
  - Доступ к объекту возможен через `get()`, пока он не собран.

- **SoftReference**:
  - Объект, на который ссылается `SoftReference`, сохраняется дольше и собирается только при **нехватке памяти**, обычно перед `OutOfMemoryError`. JVM старается удерживать такие объекты как можно дольше, в зависимости от реализации и настроек (например, `-XX:SoftRefLRUPolicyMSPerMB`).
  - Подходит для кэшей, где данные желательно сохранять, пока память позволяет.
  - Доступ к объекту возможен через `get()`.

- **PhantomReference**:
  - Объект, на который ссылается `PhantomReference`, становится **финализируемым** и может быть собран GC, когда на него нет сильных, мягких или слабых ссылок. Метод `get()` **всегда возвращает `null`**, что делает объект недоступным.
  - Используется для уведомлений о том, что объект стал финализируемым, через `ReferenceQueue`, чтобы выполнить очистку ресурсов (например, закрытие файлов) **до** полной сборки.
  - Подходит для низкоуровневого управления ресурсами, а не для хранения данных.

**Ключевые отличия**:
- `WeakReference` и `SoftReference` позволяют получать объект через `get()`, что делает их подходящими для кэшей.
- `SoftReference` удерживает объекты дольше, чем `WeakReference`, что полезно для кэшей с долгосрочным хранением.
- `PhantomReference` не даёт доступа к объекту и предназначена для финализации, а не для хранения данных.

### 2. **Почему нет `SoftHashMap` в стандартной библиотеке Java?**

#### a) **Ограниченная универсальность и недетерминированность**
- **Поведение `SoftReference`**:
  - Время жизни объектов, на которые ссылается `SoftReference`, зависит от состояния памяти и реализации JVM. Например, параметр `-XX:SoftRefLRUPolicyMSPerMB` в HotSpot JVM влияет на то, как долго объекты сохраняются. Это делает поведение `SoftHashMap` менее предсказуемым по сравнению с `WeakHashMap`, где очистка происходит сразу после потери сильных ссылок.
  - Недетерминированность затрудняет использование `SoftHashMap` в приложениях, где требуется точное управление содержимым кэша.
- **Сравнение с `WeakHashMap`**:
  - `WeakHashMap` обеспечивает чёткое поведение: записи удаляются, как только ключ становится недоступным. Это подходит для задач, таких как канонизация объектов или временные кэши.
  - `SoftHashMap` была бы полезна для кэшей с более долгим удержанием данных, но её поведение слишком зависит от внешних факторов (память, JVM), что снижает её универсальность.

#### b) **Сложность управления `SoftReference`**
- Управление `SoftReference` требует учёта состояния памяти, что усложняет реализацию. JVM может очищать `SoftReference` в разное время в зависимости от нагрузки, что делает тестирование и отладку сложнее.
- В `WeakHashMap` используется `ReferenceQueue` для отслеживания удалённых ключей, что уже добавляет накладные расходы. Для `SoftHashMap` пришлось бы реализовать аналогичную логику, но с учётом менее агрессивной очистки, что увеличило бы сложность.

### 3. **Почему нет `PhantomHashMap` в стандартной библиотеке Java?**

`PhantomHashMap`, использующая `PhantomReference` для ключей, ещё менее вероятна, чем `SoftHashMap`, из-за фундаментальных ограничений `PhantomReference`:

#### a) **Недоступность ключей**
- `PhantomReference.get()` всегда возвращает `null`, что делает невозможным доступ к ключу для операций `get`, `put` или `remove`. Без ключа нельзя выполнить сравнение (`equals`) или вычислить хэш-код, что ломает основную функциональность карты.
- В `WeakHashMap` ключи, обёрнутые в `WeakReference`, доступны через `get()`, что позволяет использовать их для поиска. `PhantomReference` этого не предоставляет, делая реализацию полноценной карты невозможной без хранения копий ключей.

#### b) **Назначение `PhantomReference`**
- `PhantomReference` предназначена для **финализации** и уведомлений о том, что объект стал финализируемым (готов к сборке после финализации). Её используют для выполнения очистки ресурсов (например, закрытия файлов или освобождения нативных ресурсов) через `ReferenceQueue`.
- В контексте `Map` это означало бы, что `PhantomHashMap` могла бы только отслеживать момент удаления ключей, но не предоставлять доступ к значениям по ключам, что противоречит назначению структуры `Map`.

</details>

---

## LinkedHashMap - что в нем от LinkedList, а что от HashMap?
<details> <summary>Ответ</summary>
Реализация LinkedHashMap отличается от HashMap поддержкой двухсвязанного списка, определяющего порядок итерации по элементам структуры данных. По умолчанию элементы списка упорядочены согласно их порядку добавления в LinkedHashMap (insertion-order). Однако порядок итерации можно изменить, установив параметр конструктора accessOrder в значение true. В этом случае доступ осуществляется по порядку последнего обращения к элементу (access-order). Это означает, что при вызове методов get() или put() элемент, к которому обращаемся, перемещается в конец списка.
При добавлении элемента, который уже присутствует в LinkedHashMap (т.е. с одинаковым ключом), порядок итерации по элементам не изменяется.

</details>

---

## Что такое SortedMap?
<details> <summary>Ответ</summary>
SortedMap — это интерфейс , а TreeMap — его наиболее популярная реализация в стандартной библиотеке Java.

</details>

---

## Согласно Кнуту и Кормену существует две основных реализации хэш-таблицы
<details> <summary>Ответ</summary>
**`HashMap` в Java реализована на основе метода цепочек (chaining).**

Начиная с Java 8, если в одной "цепочке" накапливается много элементов (по умолчанию — 8), то **связный список заменяется на красно-черное дерево**, чтобы улучшить производительность поиска.

### Причины выбора:
1. **Устойчивость к коллизиям:** позволяет эффективно обрабатывать ситуации, когда разные ключи попадают в один индекс.
2. **Простая реализация:** проще управлять списками/деревьями, чем перераспределять элементы при изменении размера таблицы.
3. **Гибкость:** легко масштабируется под разные типы данных и распределения хэшей.
4. **Производительность на практике:** для большинства реальных сценариев дает хорошие результаты без излишней сложности.

### Еще существует Метод открытой адресации

Это способ разрешения коллизий в хэш-таблицах, при котором **все элементы хранятся непосредственно в массиве таблицы**, а не в отдельных структурах (например, списках или деревьях), как в методе цепочек.
Когда происходит коллизия (два ключа хэшируются в один и тот же индекс), метод открытой адресации использует **функцию пробирования (probing)**, чтобы найти **следующую свободную ячейку** в массиве.
1. **Линейное пробирование**
   ```java
   index = (hash(key) + i) % capacity;
   ```
   Где `i` — шаг пробирования (обычно 1). Просто, но может приводить к **кластеризации**.

2. **Квадратичное пробирование**
   ```java
   index = (hash(key) + i^2) % capacity;
   ```
   Уменьшает кластеризацию, но всё равно возможны **вторичные кластеры**.

3. **Двойное хэширование**  
   Используется вторая хэш-функция для определения шага:
   ```java
   index = (hash1(key) + i * hash2(key)) % capacity;
   ```
   Самый эффективный из этих методов, минимизирует кластеры.

### Плюсы открытой адресации:

- **Экономия памяти:** не нужны дополнительные структуры (списки/деревья).
- **Хорошая локальность данных:** все элементы находятся в одном массиве → лучше использование CPU-кеша.
- **Простота сериализации:** проще сохранить/загрузить всю таблицу.

### Минусы открытой адресации:

- **Сложность удаления:** нельзя просто удалить элемент, т.к. это может нарушить последовательность поиска → требуется маркировка "удалённых" записей.
- **Ухудшение производительности при высокой загрузке:** чем больше элементов, тем больше коллизий и длиннее пробирование.
- **Риск переполнения:** если таблица заполнена, операции становятся очень медленными.

Метод открытой адресации — это **экономичный по памяти и быстрый по доступу** способ реализации хэш-таблиц, особенно полезный при хорошем хэшировании и невысокой нагрузке. Однако он сложнее в управлении (особенно при удалении элементов) и менее устойчив к высокому числу коллизий, чем метод цепочек.

## 🧠 Вывод:
<details> <summary>Ответ</summary>
> **`HashMap` реализована через метод цепочек**, потому что он:
> - лучше справляется с коллизиями,
> - проще в реализации,
> - обеспечивает хорошую производительность в реальных условиях.

</details>

---

## Как работает HashMap при попытке сохранить в него два элемента по ключам с одинаковым hashCode(), но для которых equals() == false?
<details> <summary>Ответ</summary>
По значению hashCode() вычисляется индекс ячейки массива, в список которой этот элемент будет добавлен. Перед добавлением осуществляется проверка на наличие элементов в этой ячейке. Если элементы с таким hashCode() уже присутствует, но их equals() методы не равны, то элемент будет добавлен в конец списка.

</details>

---

## Какое начальное количество корзин в HashMap?
<details> <summary>Ответ</summary>
В конструкторе по умолчанию - 16, используя конструкторы с параметрами можно задавать произвольное начальное количество корзин.

</details>

---

## Какова оценка временной сложности операций над элементами из HashMap? Гарантирует ли HashMap указанную сложность выборки элемента?
<details> <summary>Ответ</summary>
В общем случае операции добавления, поиска и удаления элементов занимают константное время.
Данная сложность не гарантируется, т.к. если хэш-функция распределяет элементы по корзинам равномерно, временная сложность станет не хуже Логарифмического времени O(log(N)), а в случае, когда хэш-функция постоянно возвращает одно и то же значение, HashMap превратится в связный список со сложностью О(n).

</details>

---

## Возможна ли ситуация, когда HashMap выродится в список даже с ключами имеющими разные hashCode()?
<details> <summary>Ответ</summary>
Это возможно в случае, если метод, определяющий номер корзины будет возвращать одинаковые значения.

</details>

---

## В каком случае может быть потерян элемент в HashMap?
<details> <summary>Ответ</summary>
Допустим, в качестве ключа используется не примитив, а объект с несколькими полями. После добавления элемента в HashMap у объекта, который выступает в качестве ключа, изменяют одно поле, которое участвует в вычислении хэш-кода. В результате при попытке найти данный элемент по исходному ключу, будет происходить обращение к правильной корзине, а вот equals уже не найдет указанный ключ в списке элементов. Тем не менее, даже если equals реализован таким образом, что изменение данного поля объекта не влияет на результат, то после увеличения размера корзин и пересчета хэш-кодов элементов, указанный элемент, с измененным значением поля, с большой долей вероятности попадет в совершенно другую корзину и тогда уже потеряется совсем.

</details>

---

## Почему нельзя использовать byte[] в качестве ключа в HashMap?
<details> <summary>Ответ</summary>
Хэш-код массива не зависит от хранимых в нем элементов, а присваивается при создании массива (метод вычисления хэш-кода массива не переопределен и вычисляется по стандартному Object.hashCode() на основании адреса массива). Так же у массивов не переопределен equals и выполняется сравнение указателей. Это приводит к тому, что обратиться к сохраненному с ключом-массивом элементу не получится при использовании другого массива такого же размера и с такими же элементами, доступ можно осуществить лишь в одном случае — при использовании той же самой ссылки на массив, что использовалась для сохранения элемента.

</details>

---

## Какова роль equals() и hashCode() в HashMap?
<details> <summary>Ответ</summary>
hashCode позволяет определить корзину для поиска элемента, а equals используется для сравнения ключей элементов в списке корзины и искомого ключа.

</details>

---

## Каково максимальное число значений hashCode()?
<details> <summary>Ответ</summary>
Число значений следует из сигнатуры int hashCode() и равно диапазону типа int — 2^32.

</details>

---

## Какое худшее время работы метода get(key) для ключа, которого нет в HashMap?
<details> <summary>Ответ</summary>
O(N). Худший случай - это поиск ключа в HashMap, вырожденного в список по причине совпадения ключей по hashCode() и для выяснения хранится ли элемент с определённым ключом может потребоваться перебор всего списка.

</details>

---

## Сколько переходов происходит в момент вызова HashMap.get(key) по ключу, который есть в таблице?
<details> <summary>Ответ</summary>
- ключ равен null: 1 - выполняется единственный метод getForNullKey().
- любой ключ отличный от null: 4 - вычисление хэш-кода ключа; определение номера корзины; поиск значения; возврат значения.

</details>

---

## Сколько создается новых объектов, когда вы добавляете новый элемент в HashMap?
<details> <summary>Ответ</summary>
Один новый объект статического вложенного класса Entry<K,V>.

</details>

---

## Как и когда происходит увеличение количества корзин в HashMap?
<details> <summary>Ответ</summary>
Помимо capacity у HashMap есть еще поле loadFactor, на основании которого, вычисляется предельное количество занятых корзин capacity * loadFactor. По умолчанию loadFactor = 0.75. По достижению предельного значения, число корзин увеличивается в 2 раза и для всех хранимых элементов вычисляется новое «местоположение» с учетом нового числа корзин.

</details>

---

## Объясните смысл параметров в конструкторе HashMap(int initialCapacity, float loadFactor).
<details> <summary>Ответ</summary>
- initialCapacity - исходный размер HashMap, количество корзин в хэш-таблице в момент её создания.
- loadFactor - коэффициент заполнения HashMap, при превышении которого происходит увеличение количества корзин и автоматическое перехэширование. Равен отношению числа уже хранимых элементов в таблице к её размеру.

</details>

---

## Будет ли работать HashMap, если все добавляемые ключи будут иметь одинаковый hashCode()?
<details> <summary>Ответ</summary>
Да, будет, но в этом случае HashMap вырождается в связный список и теряет свои преимущества.

</details>

---

## Как перебрать все ключи Map?
<details> <summary>Ответ</summary>
Использовать метод keySet(), который возвращает множество Set<K> ключей.

</details>

---

## Как перебрать все значения Map?
<details> <summary>Ответ</summary>
Использовать метод values(), который возвращает коллекцию Collection<V> значений.

</details>

---

## Как перебрать все пары «ключ-значение» в Map?
<details> <summary>Ответ</summary>
Использовать метод entrySet(), который возвращает множество Set<Map.Entry<K, V> пар «ключ-значение».

</details>

---

## Что такое Entry, какие в нем поля, и для чего они используются
<details> <summary>Ответ</summary>
Интерфейс Map.Entry в Java позволяет работать с записями Map.
Метод entrySet(), объявленный интерфейсом Map, возвращает Set, содержащий записи Map. Каждый из этих элементов является объектом Map.Entry.
В следующей таблице приведены методы, объявленные этим интерфейсом:

| Метод                | Описание                                                                 |
|----------------------|--------------------------------------------------------------------------|
| Object getKey()      | Возвращает ключ для этой записи в Map.                                   |
| Object getValue()    | Возвращает значение для этой записи в Map.                               |

</details>

---

## Реализации Set в Java?
<details> <summary>Ответ</summary>
Вот список реализаций интерфейса `Set` в Java:

### **Реализации `Set` в Java**

1. **`HashSet`**
  - Основан на хэш-таблице.
  - Не сохраняет порядок элементов.
  - Операции `add`, `remove`, `contains` — `O(1)` в среднем.
  - Не потокобезопасен.

2. **`LinkedHashSet`**
  - Наследует `HashSet`, но сохраняет порядок вставки.
  - Немного медленнее `HashSet` из-за поддержки связанного списка.
  - Операции — `O(1)`.

3. **`TreeSet`**
  - Основан на красно-черном дереве (`NavigableSet`).
  - Хранит элементы в отсортированном порядке.
  - Операции — `O(log n)`.
  - Можно задать `Comparator`.

4. **`CopyOnWriteArraySet`** (`java.util.concurrent`)
  - Потокобезопасная реализация.
  - Медленный при частых изменениях.
  - Итераторы не поддерживают `remove()`.

5. **`ConcurrentSkipListSet`** (`java.util.concurrent`)
  - Потокобезопасный аналог `TreeSet`.
  - Элементы хранятся в отсортированном порядке.
  - Операции — `O(log n)`.

6. **`EnumSet`**
  - Оптимизирован для `enum`.
  - Крайне эффективен (битовая маска).
  - Быстрее `HashSet` для перечислений.

### **Специальные обертки**
- **`Collections.synchronizedSet(Set)`** – синхронизированная версия любого `Set`.
- **`ImmutableSet`** (из Guava) – неизменяемый `Set`.

Если нужна **потокобезопасность** → `ConcurrentSkipListSet`, `CopyOnWriteArraySet`.  
Если нужен **порядок** → `LinkedHashSet` (вставка) или `TreeSet` (сортировка).  
Если важна **производительность** → `HashSet`.  
Если работаете с **`enum`** → `EnumSet`.

</details>

---

## Внутренняя реализация и как внутри работают основные операции HashSet?
<details> <summary>Ответ</summary>
`HashSet` — это реализация интерфейса `Set`, основанная на **хэш-таблице**. Внутри он использует `HashMap` для хранения элементов.

- `HashSet` хранит элементы в виде **ключей `HashMap`**, а значения (`values`) заполняются "заглушкой" (`PRESENT`).
- По умолчанию начальная ёмкость (`capacity`) = **16**, а коэффициент загрузки (`loadFactor`) = **0.75**.

```java
// Внутри HashSet
private transient HashMap<E, Object> map;

// Заглушка для значений в HashMap
private static final Object PRESENT = new Object();

// Конструктор
public HashSet() {
    map = new HashMap<>(); // Внутри используется HashMap
}
```


</details>

---

## Внутренняя реализация и как внутри работают основные операции LinkedHashSet?
<details> <summary>Ответ</summary>
`LinkedHashSet` — это наследник `HashSet`, который сохраняет **порядок добавления элементов** за счёт использования **связанного списка**. Внутри он основан на `LinkedHashMap`.

#### **1. Базовая структура данных**
- `LinkedHashSet` использует `LinkedHashMap` для хранения элементов.
- Каждый элемент связан с предыдущим и следующим через **двусвязный список**.
- Как и в `HashSet`, значения (`values`) заполняются заглушкой `PRESENT`.

```java
// Внутри LinkedHashSet
public class LinkedHashSet<E> extends HashSet<E> {
  public LinkedHashSet() {
    super(16, 0.75f, true); // вызывает конструктор HashSet с accessOrder = false
  }
}

// В HashSet есть специальный конструктор для LinkedHashSet
HashSet(int initialCapacity, float loadFactor, boolean dummy) {
  map = new LinkedHashMap<>(initialCapacity, loadFactor); // Здесь используется LinkedHashMap!
}
```


</details>

---

## Внутренняя реализация и как внутри работают основные операции TreeSet?
<details> <summary>Ответ</summary>
`TreeSet` — это реализация интерфейса `NavigableSet`, основанная на **красно-черном дереве (Red-Black Tree)**. В отличие от `HashSet` и `LinkedHashSet`, элементы в `TreeSet` хранятся **в отсортированном порядке** (по умолчанию — natural ordering, либо через `Comparator`).

### **1. Базовая структура данных**
- Внутри `TreeSet` использует `TreeMap` для хранения элементов.
- Каждый элемент является **ключом (`key`)** в `TreeMap`, а значение (`value`) — это заглушка `PRESENT`.

```java
// Внутри TreeSet
private transient NavigableMap<E, Object> map; // TreeMap по умолчанию
private static final Object PRESENT = new Object();

// Конструктор
public TreeSet() {
  this(new TreeMap<>()); // Использует TreeMap внутри
}
```

### **3. Как поддерживается сортировка?**
- Если `Comparator` не задан, используется **natural ordering** (`Comparable`).
- Если задан `Comparator`, порядок определяется им.

</details>

---

## В чем отличия TreeSet и HashSet?
<details> <summary>Ответ</summary>
Начнем с того, что Set — это множество (так же называют «набором»). Set не допускает хранение двух одинаковых элементов. Формально говоря, термин «множество» и так обозначает совокупность различных элементов, очень важно, что именно различных элементов, так как это главное свойство Set. С учетом такого определения, пояснение про хранение одинаковых элементом не требуется, но в обиходе, понятие «множество» потеряло свой строгий смысл касательно уникальности элементов, входящих в него, поэтому все же уточняйте отдельно данное свойство множества.

TreeSet обеспечивает упорядоченно хранение элементов в виде красно-черного дерева. Сложность выполнения основных операций не хуже O(log(N)) (Логарифмическое время).
HashSet использует для хранения элементов такой же подход, что и HashMap, за тем отличием, что в HashSet в качестве ключа и значения выступает сам элемент, кроме того, HashSet не поддерживает упорядоченное хранение элементов и обеспечивает временную сложность выполнения операций аналогично HashMap.

</details>

---

## Что будет, если добавлять элементы в TreeSet по возрастанию?
<details> <summary>Ответ</summary>
В основе TreeSet лежит красно-черное дерево, которое умеет само себя балансировать. В итоге, TreeSet все равно в каком порядке вы добавляете в него элементы, преимущества этой структуры данных будут сохраняться.

</details>

---

## Чем LinkedHashSet отличается от HashSet?
<details> <summary>Ответ</summary>
LinkedHashSet отличается от HashSet только тем, что в его основе лежит LinkedHashMap вместо HashMap. Благодаря этому порядок элементов при обходе коллекции является идентичным порядку добавления элементов (insertion-order). При добавлении элемента, который уже присутствует в LinkedHashSet (т.е. с одинаковым ключом), порядок обхода элементов не изменяется.

</details>

---

## Для Enum есть специальный класс java.util.EnumSet. Зачем? Чем авторов не устраивал HashSet или TreeSet?
<details> <summary>Ответ</summary>
EnumSet - это реализация интерфейса Set для использования с перечислениями (Enum). В структуре данных хранятся объекты только одного типа Enum, указываемого при создании. Для хранения значений EnumSet использует массив битов (bit vector), - это позволяет получить высокую компактность и эффективность. Проход по EnumSet осуществляется согласно порядку объявления элементов перечисления.
Все основные операции выполняются за O(1) и обычно (но негарантированно) быстрей аналогов из HashSet, а пакетные операции (bulk operations), такие как containsAll() и retainAll() выполняются даже горазда быстрей.
Помимо всего EnumSet предоставляет множество статических методов инициализации для упрощенного и удобного создания экземпляров.

</details>

---

## Каким образом можно получить синхронизированные объекты стандартных коллекций?
<details> <summary>Ответ</summary>
С помощью статических методов synchronizedMap() и synchronizedList() класса Collections. Данные методы возвращают синхронизированный декоратор переданной коллекции. При этом все равно в случае обхода по коллекции требуется ручная синхронизация.
```java
Map m = Collections.synchronizedMap(new HashMap());
List l = Collections.synchronizedList(new ArrayList());
```
Начиная с Java 6 JCF был расширен специальными коллекциями, поддерживающими многопоточный доступ, такими как CopyOnWriteArrayList и ConcurrentHashMap.

</details>

---

## Как получить коллекцию только для чтения?
<details> <summary>Ответ</summary>
При помощи:
```java
Collections.unmodifiableList(list);
Collections.unmodifiableSet(set);
Collections.unmodifiableMap(map);
```
Эти методы принимают коллекцию в качестве параметра, и возвращают коллекцию только для чтения с теми же элементами внутри.

</details>

---

## Напишите однопоточную программу, которая заставляет коллекцию выбросить ConcurrentModificationException.
<details> <summary>Ответ</summary>
```java
public static void main(String[] args) {
    List<Integer> list = new ArrayList<>();
    list.add(1);
    list.add(2);
    list.add(3);
    for (Integer integer : list) {
        list.remove(1);
    }
}
```

</details>

---

## Приведите пример, когда какая-либо коллекция выбрасывает UnsupportedOperationException.
<details> <summary>Ответ</summary>
```java
public static void main(String[] args) {
    List<Integer> list = Collections.emptyList();
    list.add(0);
}
```

</details>

---

## Реализуйте симметрическую разность двух коллекций используя методы Collection (addAll(...), removeAll(...), retainAll(...)).
<details> <summary>Ответ</summary>
Симметрическая разность двух коллекций - это множество элементов, одновременно не принадлежащих обоим исходным коллекциям.
```java
<T> Collection<T> symmetricDifference(Collection<T> a, Collection<T> b) {
    // Объединяем коллекции.
    Collection<T> result = new ArrayList<>(a);
    result.addAll(b);
    // Получаем пересечение коллекций.
    Collection<T> intersection = new ArrayList<>(a);
    intersection.retainAll(b);
    // Удаляем элементы, расположенные в обоих коллекциях.
    result.removeAll(intersection);
    return result;
}
```

</details>

---

## Как, используя LinkedHashMap, сделать кэш c «invalidation policy»?
<details> <summary>Ответ</summary>
Необходимо использовать LRU-алгоритм (Least Recently Used algorithm) и LinkedHashMap с access-order. В этом случае при обращении к элементу он будет перемещаться в конец списка, а наименее используемые элементы будут постепенно группироваться в начале списка. Так же в стандартной реализации LinkedHashMap есть метод removeEldestEntry(), который возвращает true, если текущий объект LinkedHashMap должен удалить наименее используемый элемент из коллекции при использовании методов put() и putAll().

```java
public class LRUCache<K, V> extends LinkedHashMap<K, V> {
    private static final int MAX_ENTRIES = 10;
    public LRUCache(int initialCapacity) {
        super(initialCapacity, 0.85f, true);
    }
    @Override
    protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
        return size() > MAX_ENTRIES;
    }
}
```

Стоит заметить, что LinkedHashMap не позволяет полностью реализовать LRU-алгоритм, поскольку при вставке уже имеющегося в коллекции элемента порядок итерации по элементам не меняется.

</details>

---

## Чем отличается ArrayList от HashSet?
<details> <summary>Ответ</summary>
Если ArrayList и LinkedList можно было сравнить по операциям — где кто лучше — то с ArrayList с HashSet сравнить уже не так просто, ведь это совершенно разные коллекции.
Можно сравнить одно сладкое блюдо с другим, но с мясным уже получится — больно уж они разные. Тем не менее, я попробую привести их некоторые различия:

- ArrayList реализует интерфейс List, в то время как HashSet реализует интерфейс Set;
- В ArrayList возможен доступ по индексу элемента: операция get имеет алгоритмическую сложность O(1), а в HashSet необходимый элемент можно получить лишь путём перебора, а это у нас от O(1) до O(n);
- ArrayList допускает присутствие дубликатов элементов. В HashSet все элементы уникальны: добавить в HashSet элемент, аналог которого уже присутствует в коллекции, не получится (проверка дубликатов ведется по hashcode, отсюда и название этой коллекции);
- ArrayList реализован с помощью внутреннего массива, а HashSet реализован с помощью внутренней HashMap;
- ArrayList поддерживает порядок вставки элементов, в то время как HashSet — это неупорядоченное множество и не поддерживает порядок элементов;
- ArrayList допускает любое количество пустых значений (null), в HashSet можно вставить лишь одно значение null (как-никак, уникальность элементов).

</details>

---

## Зачем в Java такое разнообразие имплементации динамического массива?
<details> <summary>Ответ</summary>
Ну, это скорее философский вопрос. Ну а зачем придумывают такое количество новых разнообразных технологий? Для удобства. Собственно, так же и с большим количеством имплементаций динамического массива. Ни одну из них нельзя назвать лучшей или идеальной. У каждой есть преимущество в какой-то конкретной ситуации. И наша задача — знать их различия, их сильные/слабые стороны: чтобы суметь в нужной ситуации использовать самую подходящую из них.

</details>

---

## Как отсортировать коллекцию элементов?
<details> <summary>Ответ</summary>
Первое, что нужно сказать, — класс элемента коллекции должен имплементировать интерфейс Comparable и его метод compareTo. Или же нужен класс, который имплементирует Comparator с его методом comparator.
Оба способа указывают, каким образом нужно сравнивать объекты данного типа. При сортировке это критически важно, ведь нужно понимать принцип, по которому элементы можно сравнить. В основном используется способ через имплементацию Comparable, реализуемый непосредственно в классе, который вы хотите сортировать. В то же время применение Comparator-а более редко. Скажем, вы используете класс с какой-то библиотеки, у которого нет реализации Comparable, но вам как-то нужно будет его сортировать. Не имея возможности изменить код данного класса (кроме как расширить его), вы можете написать реализацию Comparator-а, в котором укажете, по какому принципу нужно сравнивать объекты данного класса. И еще один пример. Допустим, вам нужны разные принципы сортировки объектов одного и того же типа, поэтому вы пишете несколько Comparator-ов которые используете в разных ситуациях. Как правило, многие классы из коробки уже реализуют интерфейс Comparable — тот же String. Собственно, при их использовании вам не нужно париться, как их сравнить. Вы просто берете и используете их.

Первый и самый очевидный способ — использовать коллекцию типа TreeSet или TreeMap, которые хранят элементы в ужеотсортированном порядке, согласно компаратору класса элементов. Не забывайте, что TreeMap сортирует ключи, но не значения. Если вы используете имплементацию Comparator вместо Comparable, вам нужно будет передать его объект в конструктор коллекции при создании:
```java
TreeSet treeSet = new TreeSet(customComparator);
```
А что если у вас коллекция другого типа? Как её отсортировать?

В этом случае подходит второй способ утилитного класса Collections — метод sort(). Он статический, поэтому всё, что вам нужно — имя класса и метод, в который передается необходимый список. Например:
```java
Collections.sort(someList);
```
Если вы используете не Comparable, а реализацию Comparator, его нужно передать вторым параметром:
```java
Collections.sort(someList, customComparator);
```
В итоге внутренний порядок элементов переданного списка изменится: он будет отсортирован согласно компаратору элементов. Отмечу, что передаваемый список элементов должен быть мутабельным, т.е. изменяемым, иначе метод не сработает и будет выброшено UnsupportedOperationException.

В качестве третьего способа можно использовать Stream операцию sort, которая сортирует элементы коллекции, если используется имплементация Comparable:
```java
someList = someList.stream().sorted().collect(Collectors.toList());
```
если Comparator:
```java
someList = someList.stream().sorted(customComparator).collect(Collectors.toList());
```
Подробнее о Stream можно почитать в этой статье.

Четвертый способ — ручная реализация сортировки, например, сортировки пузырьком или сортировки слиянием.

</details>

---

## В чем разница между HashMap, TreeMap, и Hashtable
<details> <summary>Ответ</summary>
- **Порядок элементов.** HashMap и Hashtable не гарантируют, что элементы будут храниться в порядке добавления. Кроме того, они не гарантируют, что порядок элементов не будет меняться со временем. В свою очередь, TreeMap гарантирует хранение элементов в порядке добавления или же в соответствии с заданным компаратором.
- **Допустимые значения.** HashMap позволяет иметь ключ и значение null, HashTable — нет. TreeMap может использовать значения null только если это позволяет компаратор. Без использования компаратора (при хранении пар в порядке добавления) значение null не допускается.
- **Синхронизация.** Только HashTable синхронизирована, остальные — нет. Если к мапе не будут обращаться разные потоки, рекомендуется использовать HashMap вместо HashTable.

</details>

---

## HashMap one optimization?
<details> <summary>Ответ</summary>
Когда TREEIFY_THRESHOLD = 8 (Количество объектов в односвязном списке) становится слишком большой (в настоящее время: TREEIFY_THRESHOLD = 8 ), HashMap динамически заменяет ее специальной реализацией древовидной карты. Таким образом, вместо пессимистического O (n) мы получаем намного лучше O (logn). Как это работает? Что ж, ранее записи с конфликтующими ключами просто добавлялись в связанный список, который позже нужно было просмотреть. Теперь HashMap преобразует список в двоичное дерево, используя хеш-код в качестве переменной ветвления. Если два хэша различны, но попали в одно и то же ведро, один считается больше и идет вправо. Если хэши равны (как в нашем случае), HashMap надеется, что ключи Comparable , чтобы он мог установить некоторый порядок. Это не требование ключей HashMap , но, видимо, хорошая практика. Если ключи несопоставимы, не ожидайте каких-либо улучшений производительности в случае сильных коллизий хешей.

</details>

---

## Как создать двунаправленную мапу
<details> <summary>Ответ</summary>
Иногда появляется необходимость использовать структуру данных, в которой и ключи, и значения будут уникальными, то есть мапа будет содержать пары "ключ-ключ".
Такая структура данных позволяет создать "инвертированный просмотр/поиск" по мапе. То есть, мы можем найти ключ по его значению.Эту структуру данных называют двунаправленной мапой, которая, к сожалению, не поддерживается JDK. Но, к счастью, ее реализацию можно найти в библиотеках Apache Common Collections или Guava. Там она называется BidiMap и BiMap соответственно. Эти реализации вводят ограничения на уникальность ключей и значений. Таким образом получаются отношения one-to-one.

</details>

---

## Как конвертировать Map в List
<details> <summary>Ответ</summary>
У интерфейса Map существует 3 метода, которые возвращают перечень элементов:

- keySet() — возвращает множество(Set) ключей;
- values() — возвращает коллекцию(Collection) значений;
- entrySet() — возвращает множество(Set) наборов "ключ-значение".

Если заглянуть в конструкторы класса ArrayList, можно заметить, что существует конструктор с аргументом типа Collection. Так как Set является наследником Collection, результаты всех вышеупомянутых методов можно передать в конструктор класса ArrayList. Таким образом, мы создадим новые списки и заполним их значениями из Map:
```java
// key list
List<Integer> keyList = new ArrayList<>(map.keySet());
// value list
List<String> valueList = new ArrayList<>(map.values());
// key-value list
List<Map.Entry<Integer, String>> entryList = new ArrayList<>(map.entrySet());
```

</details>

---

## Расскажите про реализации деревьев.
<details> <summary>Ответ</summary>
- **TreeMap** - Упорядоченная по ключам. Основана на красно-черных деревьях. Может использовать компаратов в конструкторе. Красно-черные деревья это самобалансирующееся дерево которое гарантирует логарифмический рост высоты дерева от числа узлов.
- **TreeSet** - основан на сбалансированном двоичном дереве, в результате элементы упорядочены по возрастанию hashCode()'ов. Можно управлять порядком при помощи компаратора.

</details>

---

## Какие существуют методы для разрешения коллизий?
<details> <summary>Ответ</summary>
### Метод цепочек
Метод цепочек является наиболее простым методом разрешения коллизий. В ячейке массива мы будем хранить не элементы, а связанный список данных элементов. Потому как добавление в начало списка (а нам все равно в какую часть списка добавлять элемент) обладает асимптотикой О(1), мы не испортим общую асимптотику, и она останется равной О(1).У данной реализации есть проблема: если списки будут очень сильно вырастать (в качестве крайнего случая можно рассмотреть хеш-функцию, которая возвращает константу для любого объекта), то мы получим асимптотику O(m), где m — число элементов во множестве, если размер массива фиксирован. Для избежания таких неприятностей вводится понятие коэффициент заполнения(он может быть равен, например, 1.5). Если при добавлении элемента оказывается, что доля числа элементов, находящихся в структуре данных по отношению к размеру массива, превосходит коэффициент заполнения, то происходит следующее: выделяется новый массив, размер которого превосходит размер старого массива (например в 2 раза), и структура данных перестраивается на новом массиве.Данный метод разрешения коллизий и применяется в Java, а структура данных называется HashSet.

### Метод открытой адресации
В данном методе в ячейках хранятся сами элементы, а в случае коллизии происходит последовательность проб, то есть мы начинаем по некоторому алгоритму перебирать ячейки в надежде найти свободную. Это можно делать разными алгоритмами (линейная / квадратичная последовательности проб,двойное хеширование), каждый из которых обладает своими проблемами (например, возникновение первичных или вторичных кластеров).

</details>