## Оглавление

- [Что такое «коллекция»?](#что-такое-коллекция)
- [Назовите основные интерфейсы JCF и их реализации](#назовите-основные-интерфейсы-jcf-и-их-реализации)
- [Расположите в виде иерархии следующие интерфейсы](#расположите-в-виде-иерархии-следующие-интерфейсы)
- [Почему Map — это не Collection?](#почему-map--это-не-collection)
- [В чем разница между классами java.util.Collection и java.util.Collections?](#в-чем-разница-между-классами-javautilcollection-и-javautilcollections)
- [Что такое fail-fast поведение?](#что-такое-fail-fast-поведение)
- [Что такое fail-safe поведение?](#что-такое-fail-safe-поведение)
- [Какая разница между fail-fast и fail-safe?](#какая-разница-между-fail-fast-и-fail-safe)
- [Приведите примеры итераторов, реализующих поведение fail-safe](#приведите-примеры-итераторов-реализующих-поведение-fail-safe)
- [Расскажите про Weakly-Consistent Итераторы](#раскажите-про-weakly-consistent-итераторы)
- [Чем различаются Enumeration и Iterator](#чем-различаются-enumeration-и-iterator)
- [Как между собой связаны Iterable и Iterator?](#как-между-собой-связаны-iterable-и-iterator)
- [Как между собой связаны Iterable, Iterator и «for-each»?](#как-между-собой-связаны-iterable-iterator-и-for-each)
- [Сравните Iterator и ListIterator](#сравните-iterator-и-listiterator)
- [Что произойдет при вызове Iterator.next() без предварительного вызова Iterator.hasNext()?](#что-произойдет-при-вызове-iteratornext-без-предварительного-вызова-iteratorhasnext)
- [Сколько элементов будет пропущено, если Iterator.next() будет вызван после 10-ти вызовов Iterator.hasNext()?](#сколько-элементов-будет-пропущено-если-iteratornext-будет-вызван-после-10-ти-вызовов-iteratorhasnext)
- [Как поведёт себя коллекция, если вызвать iterator.remove()?](#как-поведёт-себя-коллекция-если-вызвать-iteratorremove)
- [Как поведёт себя уже инстанциированный итератор для collection, если вызвать collection.remove()?](#как-поведёт-себя-уже-инстанциированный-итератор-для-collection-если-вызвать-collectionremove)
- [Как избежать ConcurrentModificationException во время перебора коллекции?](#как-избежать-concurrentmodificationexception-во-время-перебора-коллекции)
- [Какая коллекция реализует дисциплину обслуживания FIFO?](#какая-коллекция-реализует-дисциплину-обслуживания-fifo)
- [Какая коллекция реализует дисциплину обслуживания FILO?](#какая-коллекция-реализует-дисциплину-обслуживания-filo)
- [Расскажи про массивы в java?](#раскажи-про-массивы-в-java)
- [Расскажи почему массивы такие быстрые?](#раскажи-почему-массивы-такие-быстрые)
- [Расскажи почему доступ к элементам массива O(1)?](#раскажи-почему-доступ-к-элементам-массива-o1)
- [Расскажи про многомерный массив?](#раскажи-про-многомерный-массив)
- [Что такое ArrayList?](#что-такое-arraylist)
- [Как происходит расширение ArrayList?](#как-происходит-расширение-arraylist)
- [Что такое LinkedList?](#что-такое-linkedlist)
- [Чем отличается ArrayList от Vector?](#чем-отличается-arraylist-от-vector)
- [Чем отличается ArrayList от LinkedList? В каких случаях лучше использовать первый, а в каких второй?](#чем-отличается-arraylist-от-linkedlist-в-каких-случаях-лучше-использовать-первый-а-в-каких-второй)
- [Что работает быстрее ArrayList или LinkedList?](#что-работает-быстрее-arraylist-или-linkedlist)
- [Какое худшее время работы метода contains() для элемента, который есть в LinkedList?](#какое-худшее-время-работы-метода-contains-для-элемента-который-есть-в-linkedlist)
- [Какое худшее время работы метода contains() для элемента, который есть в ArrayList?](#какое-худшее-время-работы-метода-contains-для-элемента-который-есть-в-arraylist)
- [Какое худшее время работы метода add() для LinkedList?](#какое-худшее-время-работы-метода-add-для-linkedlist)
- [Какое худшее время работы метода add() для ArrayList?](#какое-худшее-время-работы-метода-add-для-arraylist)
- [Необходимо добавить 1 млн. элементов, какую структуру вы используете?](#необходимо-добавить-1-млн-элементов-какую-структуру-вы-используете)
- [Как происходит удаление элементов из ArrayList? Как меняется в этом случае размер ArrayList?](#как-происходит-удаление-элементов-из-arraylist-как-меняется-в-этом-случае-размер-arraylist)
- [Предложите эффективный алгоритм удаления нескольких рядом стоящих элементов из середины списка, реализуемого ArrayList](#предложите-эффективный-алгоритм-удаления-нескольких-рядом-стоящих-элементов-из-середины-списка-реализуемого-arraylist)
- [Сколько необходимо дополнительной памяти при вызове ArrayList.add()?](#сколько-необходимо-дополнительной-памяти-при-вызове-arraylistadd)
- [Сколько выделяется дополнительно памяти при вызове LinkedList.add()?](#сколько-выделяется-дополнительно-памяти-при-вызове-linkedlistadd)
- [Оцените количество памяти на хранение одного примитива типа byte в LinkedList?](#оцените-количество-памяти-на-хранение-одного-примитива-типа-byte-в-linkedlist)
- [Оцените количество памяти на хранение одного примитива типа byte в ArrayList?](#оцените-количество-памяти-на-хранение-одного-примитива-типа-byte-в-arraylist)
- [Для ArrayList или для LinkedList операция добавления элемента в середину медленнее?](#для-arraylist-или-для-linkedlist-операция-добавления-элемента-в-середину-медленнее)
- [В реализации класса ArrayList есть следующие поля: Object[] elementData, int size. Объясните, зачем хранить отдельно size, если всегда можно взять elementData.length?](#в-реализации-класса-arraylist-есть-следующие-поля-object-elementdata-int-size-объясните-зачем-хранить-отдельно-size-если-всегда-можно-взять-elementdatalength)
- [Кто кого расширяет: Queue расширяет Deque, или Deque расширяет Queue?](#кто-кого-расширяет-queue-расширяет-deque-или-deque-расширяет-queue)
- [Почему LinkedList реализует и List, и Deque?](#почему-linkedlist-реализует-и-list-и-deque)
- [LinkedList — это односвязный, двусвязный или четырехсвязный список?](#linkedlist--это-односвязный-двусвязный-или-четырехсвязный-список)
- [Как перебрать элементы LinkedList в обратном порядке, не используя медленный get(index)?](#как-перебрать-элементы-linkedlist-в-обратном-порядке-не-используя-медленный-getindex)
- [Какие FIFO-очереди есть в java?](#какие-fifo-очереди-есть-в-java)
- [Расскажи как изнутри работает ArrayDeque?](#раскажи-как-изнутри-работает-arraydeque)
- [Расскажи как изнутри работает PriorityQueue?](#раскажи-как-изнутри-работает-priorityqueue)
- [Какие наследники интерфейса Map есть в Java?](#какие-наследники-интерфейса-map-есть-в-java)
- [Расскажи как работает HashMap?](#раскажи-как-работает-hashmap)
- [Как работает красно черное дерево?](#как-работает-красно-черное-дерево)
- [Как работает красно черное дерево?](#расскажи-как-работает-linkedhashmap)
- [Расскажи как работает TreeMap?](#расскажи-как-работает-treemap)
- [Расскажи как работает IdentityHashMap?](#расскажи-как-работает-identityhashmap)
- [Расскажи как работает WeakHashMap?](#Расскажи-как-работает-WeakHashMap)
- [Stack считается «устаревшим». Чем его рекомендуют заменять? Почему?](#stack-считается-устаревшим-чем-его-рекомендуют-заменять-почему)
- [Зачем нужен HashMap, если есть Hashtable?](#зачем-нужен-hashmap-если-есть-hashtable)
- [В чем разница между HashMap и IdentityHashMap?](#в-чем-разница-между-hashmap-и-identityhashmap)
- [В чем разница между HashMap и WeakHashMap?](#в-чем-разница-между-hashmap-и-weakhashmap)
- [В WeakHashMap используются WeakReferences. А почему бы не создать SoftHashMap на SoftReferences или PhantomHashMap на PhantomReferences?](#в-weakhashmap-используются-weakreferences-а-почему-бы-не-создать-softhashmap-на-softreferences-или-phantomhashmap-на-phantomreferences)
- [LinkedHashMap - что в нем от LinkedList, а что от HashMap?](#linkedhashmap---что-в-нем-от-linkedlist-а-что-от-hashmap)
- [Что такое SortedMap?](#что-такое-sortedmap)
- [Согласно Кнуту и Кормену существует две основных реализации хэш-таблицы](#согласно-кнуту-и-кормену-существует-две-основных-реализации-хэш-таблицы)
- [Как работает HashMap при попытке сохранить в него два элемента по ключам с одинаковым hashCode(), но для которых equals() == false?](#как-работает-hashmap-при-попытке-сохранить-в-него-два-элемента-по-ключам-с-одинаковым-hashcode-но-для-которых-equals--false)
- [Какое начальное количество корзин в HashMap?](#какое-начальное-количество-корзин-в-hashmap)
- [Какова оценка временной сложности операций над элементами из HashMap? Гарантирует ли HashMap указанную сложность выборки элемента?](#какова-оценка-временной-сложности-операций-над-элементами-из-hashmap-гарантирует-ли-hashmap-указанную-сложность-выборки-элемента)
- [Возможна ли ситуация, когда HashMap выродится в список даже с ключами имеющими разные hashCode()?](#возможна-ли-ситуация-когда-hashmap-выродится-в-список-даже-с-ключами-имеющими-разные-hashcode)
- [В каком случае может быть потерян элемент в HashMap?](#в-каком-случае-может-быть-потерян-элемент-в-hashmap)
- [Почему нельзя использовать byte[] в качестве ключа в HashMap?](#почему-нельзя-использовать-byte-в-качестве-ключа-в-hashmap)
- [Какова роль equals() и hashCode() в HashMap?](#какова-роль-equals-и-hashcode-в-hashmap)
- [Каково максимальное число значений hashCode()?](#каково-максимальное-число-значений-hashcode)
- [Какое худшее время работы метода get(key) для ключа, которого нет в HashMap?](#какое-худшее-время-работы-метода-getkey-для-ключа-которого-нет-в-hashmap)
- [Сколько переходов происходит в момент вызова HashMap.get(key) по ключу, который есть в таблице?](#сколько-переходов-происходит-в-момент-вызова-hashmapgetkey-по-ключу-который-есть-в-таблице)
- [Сколько создается новых объектов, когда вы добавляете новый элемент в HashMap?](#сколько-создается-новых-объектов-когда-вы-добавляете-новый-элемент-в-hashmap)
- [Как и когда происходит увеличение количества корзин в HashMap?](#как-и-когда-происходит-увеличение-количества-корзин-в-hashmap)
- [Объясните смысл параметров в конструкторе HashMap(int initialCapacity, float loadFactor)](#объясните-смысл-параметров-в-конструкторе-hashmapint-initialcapacity-float-loadfactor)
- [Будет ли работать HashMap, если все добавляемые ключи будут иметь одинаковый hashCode()?](#будет-ли-работать-hashmap-если-все-добавляемые-ключи-будут-иметь-одинаковый-hashcode)
- [Как перебрать все ключи Map?](#как-перебрать-все-ключи-map)
- [Как перебрать все значения Map?](#как-перебрать-все-значения-map)
- [Как перебрать все пары «ключ-значение» в Map?](#как-перебрать-все-пары-ключ-значение-в-map)
- [Что такое Entry, какие в нем поля, и для чего они используются](#что-такое-entry-какие-в-нем-поля-и-для-чего-они-используются)
- [Реализации Set в Java?](#реализации-set-в-java)
- [Внутренняя реализация и как внутри работают основные операции HashSet?](#внутренняя-реализация-и-как-внутри-работают-основные-операции-hashset)
- [Внутренняя реализация и как внутри работают основные операции LinkedHashSet?](#внутренняя-реализация-и-как-внутри-работают-основные-операции-linkedhashset)
- [Внутренняя реализация и как внутри работают основные операции TreeSet?](#внутренняя-реализация-и-как-внутри-работают-основные-операции-treeset)
- [В чем отличия TreeSet и HashSet?](#в-чем-отличия-treeset-и-hashset)
- [Что будет, если добавлять элементы в TreeSet по возрастанию?](#что-будет-если-добавлять-элементы-в-treeset-по-возрастанию)
- [Чем LinkedHashSet отличается от HashSet?](#чем-linkedhashset-отличается-от-hashset)
- [Для Enum есть специальный класс java.util.EnumSet. Зачем? Чем авторов не устраивал HashSet или TreeSet?](#для-enum-есть-специальный-класс-javautilenumset-зачем-чем-авторов-не-устраивал-hashset-или-treeset)
- [Каким образом можно получить синхронизированные объекты стандартных коллекций?](#каким-образом-можно-получить-синхронизированные-объекты-стандартных-коллекций)
- [Как получить коллекцию только для чтения?](#как-получить-коллекцию-только-для-чтения)
- [Напишите однопоточную программу, которая заставляет коллекцию выбросить ConcurrentModificationException](#напишите-однопоточную-программу-которая-заставляет-коллекцию-выбросить-concurrentmodificationexception)
- [Приведите пример, когда какая-либо коллекция выбрасывает UnsupportedOperationException](#приведите-пример-когда-какая-либо-коллекция-выбрасывает-unsupportedoperationexception)
- [Реализуйте симметрическую разность двух коллекций используя методы Collection](#реализуйте-симметрическую-разность-двух-коллекций-используя-методы-collection)
- [Как, используя LinkedHashMap, сделать кэш c «invalidation policy»?](#как-используя-linkedhashmap-сделать-кэш-c-invalidation-policy)
- [Чем отличается ArrayList от HashSet?](#чем-отличается-arraylist-от-hashset)
- [Зачем в Java такое разнообразие имплементации динамического массива?](#зачем-в-java-такое-разнообразие-имплементации-динамического-массива)
- [Как отсортировать коллекцию элементов?](#как-отсортировать-коллекцию-элементов)
- [В чем разница между HashMap, TreeMap, и Hashtable](#в-чем-разница-между-hashmap-treemap-и-hashtable)
- [HashMap one optimization?](#hashmap-one-optimization)
- [Как создать двунаправленную мапу](#как-создать-двунаправленную-мапу)
- [Как конвертировать Map в List](#как-конвертировать-map-в-list)
- [Расскажите про реализации деревьев](#раскажите-про-реализации-деревьев)
- [Какие существуют методы для разрешения коллизий?](#какие-существуют-методы-для-разрешения-коллизий)


---

## Что такое «коллекция»?

«Коллекция» - это структура данных, набор каких-либо объектов. Данными (объектами в наборе) могут быть числа, строки, объекты пользовательских классов и т.п.

[К оглавлению](#оглавление)

---

## Назовите основные интерфейсы JCF и их реализации

На вершине иерархии в Java Collection Framework располагаются 2 интерфейса: Collection и Map. Эти интерфейсы разделяют все коллекции, входящие во фреймворк на две части по типу хранения данных: простые последовательные наборы элементов и наборы пар «ключ — значение» соответственно.

### Интерфейс Collection
Расширяют интерфейсы:
- **List** (список) представляет собой коллекцию, в которой допустимы дублирующие значения. Элементы такой коллекции пронумерованы, начиная от нуля, к ним можно обратиться по индексу. Реализации:
  - **ArrayList** - инкапсулирует в себе обычный массив, длина которого автоматически увеличивается при добавлении новых элементов.
  - **LinkedList** (двунаправленный связный список) - состоит из узлов, каждый из которых содержит как собственно данные, так и две ссылки на следующий и предыдущий узел.
  - **Vector** — реализация динамического массива объектов, методы которой синхронизированы.
  - **Stack** — реализация стека LIFO (last-in-first-out).
- **Set** (сет) описывает неупорядоченную коллекцию, не содержащую повторяющихся элементов. Реализации:
  - **HashSet** - использует HashMap для хранения данных. В качестве ключа и значения используется добавляемый элемент. Из-за особенностей реализации порядок элементов не гарантируется при добавлении.
  - **LinkedHashSet** — гарантирует, что порядок элементов при обходе коллекции будет идентичен порядку добавления элементов.
  - **TreeSet** — предоставляет возможность управлять порядком элементов в коллекции при помощи объекта Comparator, либо сохраняет элементы с использованием «natural ordering».
- **Queue** (очередь) предназначена для хранения элементов с предопределённым способом вставки и извлечения FIFO (first-in-first-out):
  - **PriorityQueue** — предоставляет возможность управлять порядком элементов в коллекции при помощи объекта Comparator, либо сохраняет элементы с использованием «natural ordering».
  - **ArrayDeque** — реализация интерфейса Deque, который расширяет интерфейс Queue методами, позволяющими реализовать конструкцию вида LIFO (last-in-first-out).

### Интерфейс Map
Реализован классами:
- **Hashtable** — хэш-таблица, методы которой синхронизированы. Не позволяет использовать null в качестве значения или ключа и не является упорядоченной.
- **HashMap** — хэш-таблица. Позволяет использовать null в качестве значения или ключа и не является упорядоченной.
- **LinkedHashMap** — упорядоченная реализация хэш-таблицы.
- **TreeMap** — реализация, основанная на красно-чёрных деревьях. Является упорядоченной и предоставляет возможность управлять порядком элементов в коллекции при помощи объекта Comparator, либо сохраняет элементы с использованием «natural ordering».
- **WeakHashMap** — реализация хэш-таблицы, которая организована с использованием weak references для ключей (сборщик мусора автоматически удалит элемент из коллекции при следующей сборке мусора, если на ключ этого элемента нет жёстких ссылок).

[К оглавлению](#оглавление)

---

## Расположите в виде иерархии следующие интерфейсы

```
Iterable
├── Collection
│   ├── List
│   ├── Set
│   │   ├── SortedSet
│   │   │   ├── NavigableSet
│   ├── Map
├── SortedMap
│   ├── NavigableMap
├── Iterator
```

[К оглавлению](#оглавление)

---

## Почему Map — это не Collection?

Collection представляет собой совокупность некоторых элементов. Map - это совокупность пар «ключ-значение».

[К оглавлению](#оглавление)

---

## В чем разница между классами java.util.Collection и java.util.Collections?

**java.util.Collections** - набор статических методов для работы с коллекциями.

**java.util.Collection** - один из основных интерфейсов Java Collections Framework.

[К оглавлению](#оглавление)

---

## Что такое fail-fast поведение?

Fail-Fast (быстрое прерывание) — это поведение итераторов в Java, при котором коллекция немедленно выбрасывает ConcurrentModificationException, если обнаруживает изменение структуры коллекции (добавление, удаление элементов) во время итерации, кроме случаев, когда изменение делается через методы самого итератора. Использование fail-fast подхода позволяет избежать недетерминированного поведения программы в течение времени.

### Как работает Fail-Fast?
Механизм контроля изменений:
- Коллекции (например, ArrayList, HashMap) хранят счетчик modCount (modification count), который увеличивается при каждом изменении структуры.
- При создании итератора запоминается текущее значение modCount (expectedModCount).
- Перед каждым действием итератор проверяет, что modCount == expectedModCount.
- Если нет — бросает ConcurrentModificationException.

Пример с ArrayList:
```java
List<String> list = new ArrayList<>(List.of("A", "B"));
Iterator<String> it = list.iterator();
list.add("C");  // Изменяем коллекцию после создания итератора
it.next();      // Выбросит ConcurrentModificationException
```

### Где встречается Fail-Fast?
Коллекции из java.util:
- ArrayList, LinkedList, HashSet, HashMap и др.
- Итераторы этих коллекций (iterator(), listIterator()).

[К оглавлению](#оглавление)

---

## Что такое fail-safe поведение?

Fail-Safe (отказоустойчивое) поведение — это подход, при котором итераторы работают с копией (snapshot) исходной коллекции, поэтому не выбрасывают ConcurrentModificationException, даже если исходная коллекция изменяется во время итерации.

### Как работают Fail-Safe итераторы?
**Создание копии:**
- При создании итератора коллекция создает неизменяемый снимок данных.
- Итератор работает с этой копией, а не с оригиналом.

**Изменения в исходной коллекции:**
- Все модификации (добавление/удаление) применяются только к оригиналу.
- Итератор не видит эти изменения, так как работает со своей версией данных.

Пример с CopyOnWriteArrayList:
```java
List<String> list = new CopyOnWriteArrayList<>(List.of("A", "B"));
Iterator<String> it = list.iterator();
list.add("C");  // Изменяем оригинал
while (it.hasNext()) {
    System.out.print(it.next() + " ");  // Выведет "A B" (без "C")
}
```

[К оглавлению](#оглавление)

---

## Какая разница между fail-fast и fail-safe?

В противоположность fail-fast, итераторы fail-safe не вызывают никаких исключений при изменении структуры, потому что они работают с клоном коллекции вместо оригинала.

[К оглавлению](#оглавление)

---

## Приведите примеры итераторов, реализующих поведение fail-safe

Итератор коллекции CopyOnWriteArrayList и итератор представления keySet коллекции ConcurrentHashMap являются примерами итераторов fail-safe.

[К оглавлению](#оглавление)

---

## Расскажите про Weakly-Consistent Итераторы

Weakly-Consistent (слабо-согласованные) итераторы — это особый тип итераторов в потокобезопасных коллекциях (например, ConcurrentHashMap, ConcurrentLinkedQueue), которые не гарантируют точной согласованности данных на протяжении итерации, но при этом не выбрасывают ConcurrentModificationException. Они представляют компромисс между производительностью и актуальностью данных.

- Итерировать коллекцию без блокировок (lock-free).
- Частично учитывать изменения, внесенные другими потоками во время итерации.
- Не бросать ConcurrentModificationException.

### Как работает?
1. **Отказ от глобального состояния**
  - Обычные коллекции (как ArrayList) хранят счетчик изменений (modCount), но weakly-consistent коллекции:
    - Не используют modCount.
    - Не создают полную копию данных (в отличие от CopyOnWriteArrayList).
    - Позволяют параллельное изменение и чтение без полной синхронизации.
2. **Основа на "текущем представлении" данных**
  - Итератор работает с структурой данных на момент обхода, но:
    - Если элементы добавляются/удаляются в уже пройденную часть коллекции — итератор их не увидит.
    - Если изменения происходят в еще не пройденной части — итератор может их учесть (но не гарантируется).

[К оглавлению](#оглавление)

---

## Чем различаются Enumeration и Iterator

Хотя оба интерфейса и предназначены для обхода коллекций между ними имеются существенные различия:
- с помощью Enumeration нельзя добавлять/удалять элементы;
- в Iterator исправлены имена методов для повышения читаемости кода (Enumeration.hasMoreElements() соответствует Iterator.hasNext(), Enumeration.nextElement() соответствует Iterator.next() и т.д);
- Enumeration присутствуют в устаревших классах, таких как Vector/Stack, тогда как Iterator есть во всех современных классах-коллекциях.

[К оглавлению](#оглавление)

---

## Как между собой связаны Iterable и Iterator?

Интерфейс Iterable имеет только один метод - iterator(), который возвращает Iterator.

[К оглавлению](#оглавление)

---

## Как между собой связаны Iterable, Iterator и «for-each»?

Цикл for-each (или расширенный цикл for) в Java — это удобный способ перебора элементов в коллекциях, массивах или других объектах, реализующих интерфейс Iterable. Он упрощает чтение кода, устраняя необходимость явного управления индексами или итераторами. Формально он был введён в Java 5.

### Как работает for-each
Цикл for-each автоматически итерируется по элементам объекта, предоставляя доступ к каждому элементу по очереди. Он основывается на интерфейсе Iterable<T>, который требует метод iterator(). Любая структура данных (например, массивы, списки, множества) может быть использована в for-each, если она поддерживает этот интерфейс или является массивом.

[К оглавлению](#оглавление)

---

## Сравните Iterator и ListIterator

- ListIterator расширяет интерфейс Iterator
- ListIterator может быть использован только для перебора элементов коллекции List;
- Iterator позволяет перебирать элементы только в одном направлении, при помощи метода next(). Тогда как ListIterator позволяет перебирать список в обоих направлениях, при помощи методов next() и previous();
- ListIterator не указывает на конкретный элемент: его текущая позиция располагается между элементами, которые возвращают методы previous() и next().
- При помощи ListIterator вы можете модифицировать список, добавляя/удаляя элементы с помощью методов add() и remove(). Iterator не поддерживает данного функционала.

[К оглавлению](#оглавление)

---

## Что произойдет при вызове Iterator.next() без предварительного вызова Iterator.hasNext()?

Если итератор указывает на последний элемент коллекции, то возникнет исключение NoSuchElementException, иначе будет возвращен следующий элемент.

[К оглавлению](#оглавление)

---

## Сколько элементов будет пропущено, если Iterator.next() будет вызван после 10-ти вызовов Iterator.hasNext()?

Нисколько - hasNext() осуществляет только проверку наличия следующего элемента.

[К оглавлению](#оглавление)

---

## Как поведёт себя коллекция, если вызвать iterator.remove()?

Если вызову iterator.remove() предшествовал вызов iterator.next(), то iterator.remove() удалит элемент коллекции, на который указывает итератор, в противном случае будет выброшено IllegalStateException().

[К оглавлению](#оглавление)

---

## Как поведёт себя уже инстанциированный итератор для collection, если вызвать collection.remove()?

При следующем вызове методов итератора будет выброшено ConcurrentModificationException.

[К оглавлению](#оглавление)

---

## Как избежать ConcurrentModificationException во время перебора коллекции?

- Попробовать подобрать или реализовать самостоятельно другой итератор, работающий по принципу fail-safe.
- Использовать ConcurrentHashMap и CopyOnWriteArrayList.
- Преобразовать список в массив и перебирать массив.
- Блокировать изменения списка на время перебора с помощью блока synchronized.

Отрицательная сторона последних двух вариантов - ухудшение производительности.

[К оглавлению](#оглавление)

---

## Какая коллекция реализует дисциплину обслуживания FIFO?

FIFO, First-In-First-Out («первым пришел-первым ушел») - по этому принципу построена коллекция Queue.

[К оглавлению](#оглавление)

---

## Какая коллекция реализует дисциплину обслуживания FILO?

FILO, First-In-Last-Out («первым пришел, последним ушел») - по этому принципу построена коллекция Stack.

[К оглавлению](#оглавление)

---

## Расскажи про массивы в java?

Массивы в Java — это фундаментальная структура данных, используемая для хранения фиксированного количества элементов одного типа. Они являются объектами, обеспечивают быстрый доступ к элементам по индексу и широко применяются благодаря простоте и эффективности.

- **Фиксированный размер**: Размер массива задаётся при создании и не может быть изменён.
- **Индексация**: Индексы начинаются с 0 и идут до length - 1.
- **Типобезопасность**: Все элементы массива должны быть одного типа (или его подтипа, если это массив объектов).
- **Объект**: Массивы в Java являются объектами, наследующимися от java.lang.Object.

[К оглавлению](#оглавление)

---

## Расскажи почему массивы такие быстрые?

Массивы в Java хранятся в куче как непрерывный блок памяти, что обеспечивает быстрый доступ к элементам по индексу (O(1)). Внутренняя структура массива включает:

### Заголовок объекта
Каждый массив, как объект, имеет заголовок, который содержит:
- Метаданные: Указатель на класс массива (например, [I для int[]).
- Размер: Значение length, определяющее количество элементов.
- Флаги и данные для сборщика мусора (garbage collector).
- Размер заголовка зависит от JVM, но обычно составляет 8–16 байт (например, 12 байт в 64-битной HotSpot JVM с сжатыми указателями).

### Данные элементов
- Элементы массива хранятся последовательно в памяти сразу после заголовка.
- Для примитивных типов хранятся сами значения:
  - byte[]: 1 байт на элемент.
  - int[]: 4 байта на элемент.
  - double[]: 8 байт на элемент.
- Для ссылочных типов (String[], Object[]) хранятся ссылки (указатели) на объекты в куче, обычно 4 или 8 байт в зависимости от архитектуры JVM.

### Выравнивание памяти
JVM выравнивает массивы в памяти (обычно по 8 байт), чтобы оптимизировать доступ. Это может добавить "padding" (дополнительные байты) в конец массива.

[К оглавлению](#оглавление)

---

## Расскажи почему доступ к элементам массива O(1)?

Доступ к элементу массива по индексу (arr[i]) выполняется за O(1) благодаря непрерывному хранению:
- JVM вычисляет адрес элемента как: адрес_начала_массива + (индекс × размер_элемента).
- Например, для int[] с размером элемента 4 байта, адрес arr[2] будет адрес_начала + 2 × 4.

### Проверка границ
- JVM автоматически проверяет, находится ли индекс в пределах [0, length - 1].
- Если индекс выходит за границы, выбрасывается ArrayIndexOutOfBoundsException.
- Эта проверка выполняется на уровне байт-кода и добавляет небольшие накладные расходы.

[К оглавлению](#оглавление)

---

## Расскажи про многомерный массив?

Многомерные массивы в Java реализованы как массивы указателей на другие массивы, а не как единый непрерывный блок памяти. Это ключевая особенность их реализации.

### Хранение в памяти
**Основной массив**: Многомерный массив (например, int[][]) — это объект в куче (heap), содержащий:
- Заголовок объекта: Содержит метаданные (тип массива, например, [[I для int[][], и поле length) и данные для сборщика мусора.
- Массив указателей: Каждый элемент основного массива — это ссылка (указатель) на другой массив (например, int[]).

**Подмассивы**: Каждый подмассив (например, int[] в int[][]) — это отдельный объект в куче с собственным заголовком и данными.

### Размер в памяти
- Основной массив: заголовок (обычно 12 байт в HotSpot JVM) + N × размер_указателя (4 или 8 байт, в зависимости от архитектуры).
- Подмассивы: для каждого подмассива — заголовок + данные элементов (например, 4 байта на int).

### Jagged arrays (неровные массивы)
- Подмассивы могут иметь разную длину, так как каждый подмассив — отдельный объект.
- Это позволяет создавать гибкие структуры, но увеличивает фрагментацию памяти, так как подмассивы не обязательно хранятся рядом.

### Преимущества
- Доступ к элементам по индексу — O(1) для каждого уровня (но требует нескольких операций для многомерных массивов).
- Компактное хранение примитивов в подмассивах.

### Недостатки
- Подмассивы хранятся отдельно, что может привести к фрагментации памяти и снижению локальности данных (хуже кэширование).
- Многомерные массивы менее эффективны, чем одномерные, из-за дополнительных указателей и заголовков объектов.
- Проверка границ на каждом уровне добавляет накладные расходы.

[К оглавлению](#оглавление)

---

## Что такое ArrayList?

ArrayList в Java — это динамическая структура данных, реализующая интерфейс List из пакета java.util. Она представляет собой обёртку над массивом, которая позволяет динамически изменять размер, добавлять и удалять элементы.

### Основные поля ArrayList (на основе исходного кода OpenJDK):
```java
public class ArrayList<E> extends AbstractList<E> implements List<E>, RandomAccess, Cloneable, Serializable {
    private static final int DEFAULT_CAPACITY = 10; // Начальная ёмкость по умолчанию
    private transient Object[] elementData; // Внутренний массив для хранения элементов
    private int size; // Текущее количество элементов (не путать с длиной массива)
    // ... другие поля и методы
}
```
- **elementData**: Массив типа Object[], который хранит элементы. Он объявлен как transient, чтобы исключить его из стандартной сериализации.
- **size**: Хранит текущее количество элементов в списке, а не длину массива (elementData.length).
- **DEFAULT_CAPACITY**: Начальная ёмкость массива (10), если она не указана при создании.

[К оглавлению](#оглавление)

---

## Как происходит расширение ArrayList?

Когда size достигает elementData.length, ArrayList увеличивает ёмкость массива:

### Алгоритм
- Новый массив создаётся с увеличенной ёмкостью (обычно в 1.5 раза больше текущей).
- Элементы копируются из старого массива в новый с помощью System.arraycopy.
- Ссылка elementData обновляется на новый массив.

[К оглавлению](#оглавление)

---

## Что такое LinkedList?

LinkedList в Java — это реализация двусвязного списка. Она реализует интерфейсы List, Deque и Queue, что делает её универсальной структурой данных для различных сценариев. В отличие от ArrayList, который основан на массиве, LinkedList использует узлы, связанные указателями, что обеспечивает высокую эффективность для операций вставки и удаления в начале и конце списка.

LinkedList состоит из узлов, каждый из которых представлен внутренним классом Node<E>:
```java
private static class Node<E> {
    E item; // Данные элемента
    Node<E> next; // Ссылка на следующий узел
    Node<E> prev; // Ссылка на предыдущий узел
    Node(Node<E> prev, E element, Node<E> next) {
        this.item = element;
        this.next = next;
        this.prev = prev;
    }
}
```
- **item**: Хранит сам элемент (объект или null).
- **next**: Указатель на следующий узел.
- **prev**: Указатель на предыдущий узел.

### Основные поля LinkedList (на основе исходного кода OpenJDK):
```java
public class LinkedList<E> extends AbstractSequentialList<E> implements List<E>, Deque<E>, Cloneable, Serializable {
    transient int size = 0; // Количество элементов в списке
    transient Node<E> first; // Ссылка на первый узел
    transient Node<E> last; // Ссылка на последний узел
    // ... другие поля и методы
}
```
- **size**: Хранит текущее количество элементов.
- **first**: Указатель на первый узел списка (или null, если список пуст).
- **last**: Указатель на последний узел списка (или null, если список пуст).
- Поля помечены как transient, чтобы исключить их из стандартной сериализации (сериализация обрабатывается вручную).

[К оглавлению](#оглавление)

---

## Чем отличается ArrayList от Vector?

- Методы класса Vector синхронизированы, а ArrayList - нет;
- По умолчанию, Vector удваивает свой размер, когда заканчивается выделенная под элементы память. ArrayList же увеличивает свой размер только на половину.

Vector это устаревший класс и его использование не рекомендовано.

[К оглавлению](#оглавление)

---

## Чем отличается ArrayList от LinkedList? В каких случаях лучше использовать первый, а в каких второй?

ArrayList это список, реализованный на основе массива, а LinkedList — это классический двусвязный список, основанный на объектах с ссылками между ними.

### ArrayList
- доступ к произвольному элементу по индексу за константное время O(1);
- доступ к элементам по значению за линейное время O(N);
- вставка в конец в среднем производится за константное время O(1);
- удаление произвольного элемента из списка занимает значительное время т.к. при этом все элементы, находящиеся «правее» смещаются на одну ячейку влево (реальный размер массива (capacity) не изменяется);
- вставка элемента в произвольное место списка занимает значительное время т.к. при этом все элементы, находящиеся «правее» смещаются на одну ячейку вправо;
- минимум накладных расходов при хранении.

### LinkedList
- на получение элемента по индексу или значению потребуется линейное время O(N);
- на добавление и удаление в начало или конец списка потребуется константное O(1);
- вставка или удаление в/из произвольного место константное O(1);
- требует больше памяти для хранения такого же количества элементов, потому что кроме самого элемента хранятся еще указатели на следующий и предыдущий элементы списка.

В целом, LinkedList в абсолютных величинах проигрывает ArrayList и по потребляемой памяти, и по скорости выполнения операций. LinkedList предпочтительно применять, когда нужны частые операции вставки/удаления или в случаях, когда необходимо гарантированное время добавления элемента в список.

[К оглавлению](#оглавление)

---

## Что работает быстрее ArrayList или LinkedList?

Смотря какие действия будут выполняться над структурой.

[К оглавлению](#оглавление)

---

## Какое худшее время работы метода contains() для элемента, который есть в LinkedList?

O(N). Время поиска элемента линейно пропорционально количеству элементов в списке.

[К оглавлению](#оглавление)

---

## Какое худшее время работы метода contains() для элемента, который есть в ArrayList?

O(N). Время поиска элемента линейно пропорционально количеству элементов с списке.

[К оглавлению](#оглавление)

---

## Какое худшее время работы метода add() для LinkedList?

O(N). Добавление в начало/конец списка осуществляется за время O(1).

[К оглавлению](#оглавление)

---

## Какое худшее время работы метода add() для ArrayList?

O(N). Вставка элемента в конец списка осуществляется за время O(1), но если вместимость массива недостаточна, то происходит создание нового массива с увеличенным размером и копирование всех элементов из старого массива в новый.

### Метод add(E e)
- Проверяет, достаточно ли ёмкости (size < elementData.length).
- Если нет, вызывает grow() для увеличения массива.
- Добавляет элемент: elementData[size++] = e.
- Сложность: O(1) в среднем, но O(n) при увеличении массива.

### Метод add(int index, E e)
- Сдвигает элементы вправо от index с помощью System.arraycopy.
- Вставляет элемент: elementData[index] = e.
- Сложность: O(n) из-за сдвига.

[К оглавлению](#оглавление)

---

## Необходимо добавить 1 млн. элементов, какую структуру вы используете?

Однозначный ответ можно дать только исходя из информации о том в какую часть списка происходит добавление элементов, что потом будет происходить с элементами списка, существуют ли какие-то ограничения по памяти или скорости выполнения.

[К оглавлению](#оглавление)

---

## Как происходит удаление элементов из ArrayList? Как меняется в этом случае размер ArrayList?

При удалении произвольного элемента из списка, все элементы, находящиеся «правее» смещаются на одну ячейку влево и реальный размер массива (его емкость, capacity) не изменяется никак. Механизм автоматического «расширения» массива существует, а вот автоматического «сжатия» нет, можно только явно выполнить «сжатие» командой trimToSize().

### Метод remove(int index)
- Проверяется, что 0 <= index < size. Если индекс вне диапазона, выбрасывается ArrayIndexOutOfBoundsException.
- Сдвигает элементы влево, начиная с index + 1, используя System.arraycopy.
- Устанавливает последний элемент в null для помощи сборщику мусора.
- Уменьшает size.
- Счётчик модификаций (modCount) увеличивается, чтобы отслеживать изменения структуры для итераторов (это предотвращает ошибки при параллельной модификации).
- Сложность: O(n).

### Метод remove(Object o)
- Ищет первый элемент, равный o, и удаляет его.
- Сложность: O(n) из-за поиска и сдвига.

[К оглавлению](#оглавление)

---

## Предложите эффективный алгоритм удаления нескольких рядом стоящих элементов из середины списка, реализуемого ArrayList

Для удаления нескольких рядом стоящих элементов из середины ArrayList можно использовать один вызов System.arraycopy, чтобы сдвинуть элементы после удаляемого диапазона влево, и затем обновить размер списка. Это уменьшает сложность до O(n) для одного сдвига вместо O(k * n).

### Алгоритм
1. **Проверка входных данных**:
  - Убедитесь, что индексы start и end валидны: 0 <= start <= end <= size.
  - Если диапазон пуст (start == end), ничего не делать.
2. **Вычисление количества удаляемых элементов**:
  - Количество элементов для удаления: count = end - start.
3. **Сдвиг элементов**:
  - Используйте System.arraycopy для сдвига элементов, начиная с end, в позицию start, чтобы закрыть пробел.
4. **Очистка хвоста**:
  - Установите элементы в конце списка (от size - count до size - 1) в null, чтобы разорвать ссылки для сборщика мусора.
5. **Обновление размера**:
  - Уменьшите поле size на count.
6. **Обновление modCount**:
  - Увеличьте счётчик модификаций (modCount), чтобы итераторы могли обнаружить изменение структуры.

[К оглавлению](#оглавление)

---

## Сколько необходимо дополнительной памяти при вызове ArrayList.add()?

Если в массиве достаточно места для размещения нового элемента, то дополнительной памяти не требуется.
- 0 байт для самого ArrayList, так как используется существующий массив.
- Однако, если добавляемый элемент — объект (например, String), память выделяется для этого объекта отдельно в куче. Размер зависит от типа объекта:
  - Например, для String память зависит от длины строки (примерно 40 байт для пустой строки + 2 байта на символ в UTF-16).
  - Ссылка на объект в elementData занимает 8 байт (или 4 байта при сжатых указателях в 64-битной JVM).

Иначе происходит создание нового массива размером в 1,5 раза превышающим существующий (это верно для JDK выше 1.7, в более ранних версиях размер увеличения иной).
1. **Новый массив**:
  - Размер: заголовок массива (~12 байт в HotSpot JVM) + newCapacity * sizeof(указатель).
  - Указатель занимает 8 байт (или 4 байта при сжатых указателях).
2. **Старый массив**: Временно сохраняется в памяти, пока не будет собран сборщиком мусора.
3. **Добавляемый объект**: Как и в первом случае, память для самого объекта (например, String).

[К оглавлению](#оглавление)

---

## Сколько выделяется дополнительно памяти при вызове LinkedList.add()?

Создается один новый экземпляр вложенного класса Node.

[К оглавлению](#оглавление)

---

## Оцените количество памяти на хранение одного примитива типа byte в LinkedList?

Каждый элемент LinkedList хранит ссылку на предыдущий элемент, следующий элемент и ссылку на данные.
```java
private static class Node<E> {
    E item;
    Node<E> next;
    Node<E> prev;
    //...
}
```
Для 32-битных систем каждая ссылка занимает 32 бита (4 байта). Сам объект (заголовок) вложенного класса Node занимает 8 байт. 4 + 4 + 4 + 8 = 20 байт, а т.к. размер каждого объекта в Java кратен 8, соответственно получаем 24 байта. Примитив типа byte занимает 1 байт памяти, но в JCF примитивы упаковываются: объект типа Byte занимает в памяти 16 байт (8 байт на заголовок объекта, 1 байт на поле типа byte и 7 байт для кратности 8). Также напомню, что значения от -128 до 127 кэшируются и для них новые объекты каждый раз не создаются. Таким образом, в x32 JVM 24 байта тратятся на хранение одного элемента в списке и 16 байт - на хранение упакованного объекта типа Byte. Итого 40 байт.
Для 64-битной JVM каждая ссылка занимает 64 бита (8 байт), размер заголовка каждого объекта составляет 16 байт (два машинных слова). Вычисления аналогичны: 8 + 8 + 8 + 16 = 40 байт и 24 байта. Итого 64 байта.

[К оглавлению](#оглавление)

---

## Оцените количество памяти на хранение одного примитива типа byte в ArrayList?

ArrayList основан на массиве, для примитивных типов данных осуществляется автоматическая упаковка значения, поэтому 16 байт тратится на хранение упакованного объекта и 4 байта (8 для x64) - на хранение ссылки на этот объект в самой структуре данных. Таким образом, в x32 JVM 4 байта используются на хранение одного элемента и 16 байт - на хранение упакованного объекта типа Byte. Для x64 - 8 байт и 24 байта соответственно.

[К оглавлению](#оглавление)

---

## Для ArrayList или для LinkedList операция добавления элемента в середину медленнее?

### Для ArrayList
- проверка массива на вместимость. Если вместимости недостаточно, то увеличение размера массива и копирование всех элементов в новый массив (O(N));
- копирование всех элементов, расположенных правее от позиции вставки, на одну позицию вправо (O(N));
- вставка элемента (O(1)).

### Для LinkedList
- поиск позиции вставки (O(N));
- вставка элемента (O(1)).

В худшем случае вставка в середину списка эффективнее для LinkedList. В остальных - скорее всего, для ArrayList, поскольку копирование элементов осуществляется за счет вызова быстрого системного метода System.arraycopy().

[К оглавлению](#оглавление)

---

## В реализации класса ArrayList есть следующие поля: Object[] elementData, int size. Объясните, зачем хранить отдельно size, если всегда можно взять elementData.length?

Размер массива elementData.length представляет собой вместимость (capacity) ArrayList, которая всегда больше переменной size - реального количества хранимых элементов. При необходимости вместимость автоматически возрастает.

[К оглавлению](#оглавление)

---

## Кто кого расширяет: Queue расширяет Deque, или Deque расширяет Queue?

Queue - это очередь, которая обычно (но необязательно) строится по принципу FIFO (First-In-First-Out) - соответственно извлечение элемента осуществляется с начала очереди, вставка элемента - в конец очереди. Хотя этот принцип нарушает, к примеру, PriorityQueue, использующая «natural ordering» или переданный Comparator при вставке нового элемента. Deque (Double Ended Queue) расширяет Queue и согласно документации, это линейная коллекция, поддерживающая вставку/извлечение элементов с обоих концов. Помимо этого, реализации интерфейса Deque могут строится по принципу FIFO, либо LIFO. Реализации и Deque, и Queue обычно не переопределяют методы equals() и hashCode(), вместо этого используются унаследованные методы класса Object, основанные на сравнении ссылок.

[К оглавлению](#оглавление)

---

## Почему LinkedList реализует и List, и Deque?

LinkedList позволяет добавлять элементы в начало и конец списка за константное время, что хорошо согласуется с поведением интерфейса Deque.

[К оглавлению](#оглавление)

---

## LinkedList — это односвязный, двусвязный или четырехсвязный список?

Двусвязный: каждый элемент LinkedList хранит ссылку на предыдущий и следующий элементы.

[К оглавлению](#оглавление)

---

## Как перебрать элементы LinkedList в обратном порядке, не используя медленный get(index)?

Для этого в LinkedList есть обратный итератор, который можно получить вызва метод descendingIterator().

[К оглавлению](#оглавление)

---

## Какие FIFO-очереди есть в java?

1. **Обычная FIFO-очередь**:
  - **ArrayDeque** (лучшая производительность)
  - **LinkedList** (если нужен List функционал)
2. **Приоритетная очередь**:
  - **PriorityQueue**
  - **PriorityBlockingQueue** (потокобезопасная)
3. **Многопоточные сценарии**:
  - **ConcurrentLinkedQueue** (неблокирующая)
  - **ArrayBlockingQueue/LinkedBlockingQueue** (блокирующие)
4. **Специальные случаи**:
  - **DelayQueue** для отложенных элементов
  - **TransferQueue (LinkedTransferQueue)** Поддерживает передачу элементов между потоками

[К оглавлению](#оглавление)

---

## Расскажи как изнутри работает ArrayDeque?

ArrayDeque — это реализация двусторонней очереди (Deque) на основе циклического массива, которая обеспечивает эффективное добавление и удаление элементов с обоих концов. Рассмотрим его внутреннее устройство и ключевые механизмы работы.

### Внутренняя структура
#### Хранение данных
ArrayDeque использует массив (Object[]) для хранения элементов и два указателя:
- **head** — индекс первого элемента (начало очереди).
- **tail** — индекс, куда будет вставлен следующий элемент (конец очереди).
```java
transient Object[] elements; // Массив элементов
transient int head;          // Указатель на начало
transient int tail;          // Указатель на конец
```

#### Циклическая организация
Массив работает по принципу кольцевого буфера:
- Когда head или tail достигают конца массива, они "переходят" в начало (0).
- Это позволяет эффективно использовать память без постоянного копирования данных.

Пример:
```java
Исходный массив: [A, B, C, D, E, F, G, H]
head = 2 (начало на "C")
tail = 6 (конец на "G")

Добавление элемента "X":
elements[tail] = X → elements[6] = X
tail = (tail + 1) % capacity → 7
```

### Динамическое расширение
#### Когда происходит расширение?
Массив увеличивается, если:
- Добавление в конец (addLast) и tail + 1 == head (массив заполнен).
- Добавление в начало (addFirst) и head - 1 == tail (массив заполнен).

#### Как увеличивается массив?
- Новый размер = старый размер × 2 (если capacity < 64, иначе +50%).
- Элементы копируются в новый массив с перерасчетом индексов:
  - Если head < tail, копируется как обычный массив.
  - Если head > tail (данные "закольцованы"), копируется в два этапа:
    - От head до конца старого массива.
    - От 0 до tail.
```java
// Исходный массив (capacity=4):
[A, B, C, D]  // head=0, tail=0 (пустая очередь)

// Добавляем 4 элемента:
addLast(1) → [1, B, C, D]  // tail=1
addLast(2) → [1, 2, C, D]  // tail=2
addLast(3) → [1, 2, 3, D]  // tail=3
addLast(4) → [1, 2, 3, 4]  // tail=0 (переход в начало)

// При добавлении 5-го элемента:
1. Новый capacity = 8
2. Копирование: [1, 2, 3, 4, null, null, null, null]
3. tail = 4, head = 0
```

[К оглавлению](#оглавление)

---

## Расскажи как изнутри работает PriorityQueue?

PriorityQueue в Java — это структура данных, реализующая очередь с приоритетами, которая хранит элементы в порядке, определённом их естественным сравнением или пользовательским компаратором. Она входит в состав Java Collections Framework (java.util.PriorityQueue) и основана на бинарной куче (binary heap), что обеспечивает эффективное управление элементами с приоритетами. В этом ответе я подробно разберу, как PriorityQueue работает внутри, включая её реализацию, ключевые операции, использование памяти и особенности.

### Внутренняя реализация
#### Бинарная куча
PriorityQueue использует минимальную бинарную кучу (min-heap), реализованную в виде массива Object[] queue. Бинарная куча — это полное бинарное дерево, где:
- Значение каждого узла меньше или равно значениям его потомков (для min-heap).
- Дерево заполняется слева направо, обеспечивая компактное представление в массиве.

**Свойства кучи**:
- Корень: Элемент с наименьшим приоритетом находится в queue[0].
- Родитель и потомки:
  - Для узла с индексом i:
    - Левый потомок: 2 * i + 1.
    - Правый потомок: 2 * i + 2.
    - Родитель: (i - 1) / 2 (целочисленное деление).
- Компактность: Элементы хранятся в массиве последовательно, без пропусков, пока не достигнут текущий размер (size).

#### Поля класса
Основные поля PriorityQueue (на основе исходного кода OpenJDK):
```java
public class PriorityQueue<E> extends AbstractQueue<E> implements Serializable {
    private transient Object[] queue; // Массив для хранения кучи
    private int size = 0; // Текущее количество элементов
    private transient Comparator<? super E> comparator; // Компаратор (null для естественного порядка)
    private transient int modCount; // Счётчик модификаций для итераторов
    private static final int DEFAULT_INITIAL_CAPACITY = 11; // Начальная ёмкость по умолчанию
    // ... другие поля и методы
}
```
- **queue**: Массив Object[], хранящий элементы кучи.
- **size**: Текущее количество элементов в куче (не путать с queue.length, которое является ёмкостью).
- **comparator**: Если не null, определяет порядок элементов; иначе используется естественный порядок (Comparable).
- **modCount**: Используется для отслеживания структурных изменений (для итераторов).

### Основные операции
#### Добавление элемента (offer(e))
- **Проверка емкости**:
  - Если массив заполнен, увеличивается в 1.5 раза (аналогично ArrayList).
- **Добавление в конец**:
  - Элемент помещается в первую свободную позицию (queue[size+1]).
- **Восстановление кучи (siftUp)**:
  - Элемент "поднимается" по куче, пока не найдет правильное место.
  - Сравнение идет через Comparator или compareTo() (если Comparable).
```java
Пример добавления 5:
Исходная куча: [3, 8, 10]
1. Добавляем 5 в конец: [3, 8, 10, 5]
2. Сравниваем 5 с родителем (10):
   5 < 10 → меняем местами.
3. Новая куча: [3, 5, 8, 10]
```

#### Извлечение элемента (poll())
- **Извлечение корня**:
  - Возвращается queue[1] (минимальный элемент).
- **Замена корня последним элементом**:
  - queue[1] = queue[size], затем size--.
- **Восстановление кучи (siftDown)**:
  - Новый корень "опускается" вниз, пока куча не упорядочится.
  - На каждом шаге выбирается меньший из двух потомков.
```java
Пример удаления корня (3):
Исходная куча: [3, 8, 5, 10]
1. Удаляем 3, заменяем его на 10: [10, 8, 5]
2. Сравниваем 10 с потомками (8 и 5):
   - 5 < 8 → меняем 10 и 5.
3. Новая куча: [5, 8, 10]
```

[К оглавлению](#оглавление)

---

## Какие наследники интерфейса Map есть в Java?

| Класс               | Особенности                                                                 | Порядок элементов                                      | Потокобезопасность       |
|---------------------|-----------------------------------------------------------------------------|-------------------------------------------------------|--------------------------|
| HashMap             | Хэш-таблица, разрешение коллизий через цепочки/деревья (Java 8+)            | Не гарантируется                                       | Нет                      |
| LinkedHashMap       | Сохраняет порядок вставки/доступа                                          | В порядке вставки или доступа (LRU)                    | Нет                      |
| TreeMap             | Красно-черное дерево, сортировка по ключам                                  | В порядке сортировки (natural ordering/comparator)    | Нет                      |
| Hashtable           | Устаревший synchronized аналог HashMap                                      | Не гарантируется                                       | Да (блокировка на весь экземпляр) |
| IdentityHashMap     | Сравнение ключей через == вместо equals()                                   | Не гарантируется                                       | Нет                      |
| WeakHashMap         | WeakReference для ключей (GC может удалять записи)                          | Не гарантируется                                       | Нет                      |

[К оглавлению](#оглавление)

---

## Расскажи как работает HashMap?

`HashMap` в Java — это структура данных из Java Collections Framework (`java.util.HashMap`), реализующая интерфейс `Map`. Она представляет собой хэш-таблицу, которая хранит пары ключ-значение и обеспечивает быстрый доступ, добавление и удаление элементов за среднее время O(1).

### Внутренняя реализация
#### Основные поля
Основные поля `HashMap` (на основе исходного кода OpenJDK):
```java
public class HashMap<K,V> extends AbstractMap<K,V> implements Map<K,V>, Cloneable, Serializable {
    transient Node<K,V>[] table; // Массив бакетов
    transient Set<Map.Entry<K,V>> entrySet; // Кэш для набора записей
    transient int size; // Количество пар ключ-значение
    transient int modCount; // Счётчик модификаций для итераторов
    int threshold; // Порог для увеличения размера (capacity * loadFactor)
    final float loadFactor; // Коэффициент загрузки
    static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // 16
    static final float DEFAULT_LOAD_FACTOR = 0.75f;
    static final int TREEIFY_THRESHOLD = 8; // Порог для преобразования в дерево
    static final int UNTREEIFY_THRESHOLD = 6; // Порог для обратного преобразования
    static final int MIN_TREEIFY_CAPACITY = 64; // Минимальная ёмкость для использования деревьев
}
```
- **table**: Массив бакетов, где каждый бакет хранит связный список (`Node`) или красно-чёрное дерево (`TreeNode`).
- **size**: Количество пар ключ-значение.
- **threshold**: Порог, при котором массив увеличивается (`capacity * loadFactor`).
- **loadFactor**: Коэффициент загрузки (по умолчанию 0.75), определяет, когда нужно увеличивать массив.
- **modCount**: Отслеживает изменения структуры для предотвращения ошибок итерации.

#### Структура узла
Каждый элемент хранится в узле типа `Node<K,V>` (или `TreeNode<K,V>` для деревьев):
```java
static class Node<K,V> implements Map.Entry<K,V> {
    final int hash; // Хэш-код ключа
    final K key; // Ключ
    V value; // Значение
    Node<K,V> next; // Ссылка на следующий узел в бакете (для коллизий)
}
```
- Для `TreeNode` (красно-чёрное дерево) добавляются поля: `parent`, `left`, `right`, `red` (ещё ~20 байт).

#### Хэш-таблица
- **Массив бакетов (`table`)**: Хранит элементы в виде связных списков или деревьев.
- **Хэширование**: Ключ преобразуется в индекс бакета с помощью хэш-функции:
```java
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```
- `key.hashCode()` вычисляет хэш-код.
- Сдвиг и XOR (`h >>> 16`) улучшают распределение, уменьшая коллизии для больших хэш-кодов.
- Индекс: `index = hash & (table.length - 1)` (использует битовую операцию вместо деления, так как `table.length` — степень двойки).
- **Размер массива**: Всегда степень двойки (например, 16, 32, 64), чтобы оптимизировать вычисление индекса.

#### Обработка коллизий
Когда несколько ключей попадают в один бакет (из-за одинаковых хэш-кодов или индексов):
- **До Java 8**: Коллизии обрабатывались только связным списком (`Node`).
- **С Java 8**: Если в бакете становится больше `TREEIFY_THRESHOLD` (8) элементов и общая ёмкость таблицы ≥ `MIN_TREEIFY_CAPACITY` (64), связный список преобразуется в **красно-чёрное дерево** (`TreeNode`).
- **Обратное преобразование**: Если количество элементов в бакете уменьшается до `UNTREEIFY_THRESHOLD` (6), дерево преобразуется обратно в связный список.
- **Почему деревья?**:
  - Связный список: O(n) для поиска/вставки в бакете.
  - Красно-чёрное дерево: O(log n), что лучше при большом количестве коллизий (например, если `hashCode` плохо распределён).

### Основные операции
#### Добавление элемента (`put(K key, V value)`)
- **Процесс**:
  1. **Вычисление индекса**:
    - Вычисляется `hash(key)` и индекс: `hash & (table.length - 1)`.
  2. **Проверка таблицы**:
    - Если `table == null`, инициализируется с начальной ёмкостью (по умолчанию 16).
  3. **Добавление в бакет**:
    - Если бакет пуст, создаётся новый узел `Node`.
    - Если бакет занят:
      - **Связный список**: Проверяется ключ (`equals`), если совпадает — обновляется значение; иначе добавляется новый узел в конец.
      - **Дерево**: Выполняется вставка в красно-чёрное дерево.
  4. **Увеличение размера**: `size++`.
  5. **Проверка порога**:
    - Если `size > threshold` (обычно `capacity * 0.75`), вызывается `resize()` для увеличения массива.
- **Сложность**:
  - Средняя: O(1) (при хорошем хэш-коде).
  - Худшая: O(log n) (для деревьев) или O(n) (для длинных списков при плохом `hashCode`).
- **Память**: Новый узел (~40 байт) + память для ключа и значения.

**Пример**:
```java
HashMap<String, Integer> map = new HashMap<>();
map.put("A", 1); // Новый узел в бакете
map.put("B", 2); // Ещё один узел
```

#### Получение элемента (`get(Object key)`)
- **Процесс**:
  1. Вычисляется `hash(key)` и индекс.
  2. В бакете ищется узел:
    - **Связный список**: Линейный поиск с помощью `equals`.
    - **Дерево**: Поиск в красно-чёрном дереве.
  3. Возвращается значение или `null`, если ключ не найден.
- **Сложность**: O(1) в среднем, O(log n) для деревьев, O(n) в худшем случае.

#### Удаление элемента (`remove(Object key)`)
- **Процесс**:
  1. Находит узел по хэшу и ключу.
  2. Удаляет узел:
    - **Связный список**: Обновляет ссылки `next`.
    - **Дерево**: Выполняет удаление из красно-чёрного дерева.
  3. Уменьшает `size`.
- **Сложность**: O(1) в среднем, O(log n) для деревьев, O(n) в худшем случае.

#### Изменение размера (`resize()`)
- **Процесс**:
  1. Новая ёмкость: Обычно удваивается (например, с 16 до 32).
  2. Создаётся новый массив `Node[]`.
  3. Все элементы перераспределяются:
    - Для связных списков: Элементы либо остаются в том же бакете, либо перемещаются в новый (индекс = `hash & (newCapacity - 1)`).
    - Для деревьев: Дерево разделяется на два (для старого и нового индексов).
  4. Старый массив становится доступным для сборки мусора.
- **Сложность**: O(n).
- **Память**: Новый массив (12 + `newCapacity * 8` байт) + временное хранение старого массива.

### Особенности
- **Null-обработка**:
  - Один `null`-ключ хранится в `table[0]` (так как `hash(null) = 0`).
  - Значения могут быть `null`.
- **Итерация**:
  - Итераторы (`entrySet`, `keySet`, `values`) проходят по бакетам и узлам.
  - Изменение структуры во время итерации вызывает ConcurrentModificationException (fail-fast).

[К оглавлению](#оглавление)

---

## Как работает красно черное дерево?

Красно-чёрное дерево — это бинарное дерево поиска с дополнительным атрибутом цвета (красный или чёрный) для каждого узла, которое обеспечивает балансировку через соблюдение определённых правил.
Эти правила гарантируют, что дерево остаётся сбалансированным, а высота дерева ограничена O(log n), что делает операции эффективными.

### Свойства красно-чёрного дерева
1. **Цвет узла**: Каждый узел либо **красный**, либо **чёрный**.
2. **Корень чёрный**: Корень дерева всегда чёрный.
3. **Листы (NIL)**: Все листья (внешние null-узлы) считаются чёрными.
4. **Красные узлы**: Если узел красный, оба его потомка должны быть чёрными (запрещены два последовательных красных узла).
5. **Чёрная высота**: Для каждого узла все пути от него до листьев (NIL) содержат одинаковое количество чёрных узлов.

Эти свойства гарантируют, что самый длинный путь от корня до листа не более чем в два раза длиннее самого короткого пути, что обеспечивает балансировку.


### 1. **Реализация в Java**
В Java красно-чёрные деревья используются в:
- **`TreeMap` и `TreeSet`**: Основная структура данных для хранения элементов.
- **`HashMap`**: С Java 8 для обработки коллизий в бакетах, когда их длина превышает `TREEIFY_THRESHOLD` (8).

#### a) **Внутренняя структура**
В `HashMap` красно-чёрное дерево реализовано через внутренний класс `TreeNode<K,V>`, который расширяет `Node<K,V>`:
```java
static final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V> {
    TreeNode<K,V> parent; // Ссылка на родителя
    TreeNode<K,V> left;   // Левый потомок
    TreeNode<K,V> right;  // Правый потомок
    TreeNode<K,V> prev;   // Для сохранения порядка в LinkedHashMap
    boolean red;          // Цвет узла (true = красный, false = чёрный)
}
```
- **Поля**:
  - `parent`, `left`, `right`: Ссылки для структуры дерева.
  - `red`: Булево поле для цвета (1 байт, но из-за выравнивания может занимать больше).
  - Наследует от `Node`: `hash`, `key`, `value`, `next` (для совместимости с цепочкой коллизий).

#### b) **Хранение в `HashMap`**
- В `HashMap` красно-чёрное дерево используется в бакетах вместо связного списка, если:
  - Количество узлов в бакете ≥ `TREEIFY_THRESHOLD` (8).
  - Размер таблицы ≥ `MIN_TREEIFY_CAPACITY` (64).
- Преобразование из списка в дерево (`treeify`):
  - Узлы `Node` заменяются на `TreeNode`, и структура перестраивается в красно-чёрное дерево.
- Обратное преобразование (`untreeify`):
  - Если узлов становится ≤ `UNTREEIFY_THRESHOLD` (6), дерево преобразуется обратно в связный список.


### 2. **Основные операции**

#### a) **Поиск (`get` в `HashMap`)**
- **Процесс**:
  1. Вычисляется хэш ключа и индекс бакета.
  2. Если бакет — дерево, выполняется поиск в красно-чёрном дереве:
  - Сравнивается ключ с корневым узлом (через `compareTo` или `Comparator`).
  - Переход в левое или правое поддерево в зависимости от сравнения.
  - Для равных ключей (по `compareTo`) проверяется `equals` и хэш-код.
  3. Возвращается значение или `null`, если ключ не найден.
- **Сложность**: O(log n), где `n` — количество узлов в бакете.
- **Особенность**: В `HashMap` сравнение ключей учитывает не только `compareTo` (или компаратор), но и `hashCode` и `equals` для корректной обработки равных ключей с разными хэшами.

#### b) **Вставка (`put` в `HashMap`)**
- **Процесс**:
  1. Если бакет — связный список, проверяется порог `TREEIFY_THRESHOLD`. При превышении вызывается `treeifyBin` для преобразования в дерево.
  2. Вставка в дерево:
  - Новый узел `TreeNode` создаётся и добавляется как в обычное бинарное дерево поиска.
  - После вставки проверяются свойства красно-чёрного дерева:
    - Если новый узел красный и нарушает свойство (например, два красных узла подряд), выполняются **ротации** и/или **перекрашивание**.
  3. **Балансировка**:
  - **Ротации**: Левый или правый поворот для восстановления баланса.
  - **Перекрашивание**: Изменение цветов узлов для соблюдения свойств (например, красный родитель и красный ребёнок).
  4. Корень бакета становится чёрным.

- **Сложность**: O(log n) для вставки и балансировки.
- **Память**: Новый узел `TreeNode` (~60 байт) + память для ключа и значения.

#### c) **Удаление (`remove` в `HashMap`)**
- **Процесс**:
  1. Находит узел по ключу (O(log n)).
  2. Удаляет узел, как в бинарном дереве поиска:
  - Если узел — лист, он просто удаляется.
  - Если у узла один ребёнок, ребёнок заменяет узел.
  - Если два ребёнка, узел заменяется минимальным элементом из правого поддерева.
  3. Выполняется балансировка:
  - Перекрашивание и ротации для восстановления свойств.
  - Проверяется чёрная высота путей.
  4. Если узлов в бакете становится ≤ `UNTREEIFY_THRESHOLD` (6), дерево преобразуется в связный список.
- **Сложность**: O(log n).
- **Память**: Удалённый узел становится доступным для сборки мусора.

#### d) **Перестройка при изменении размера `HashMap` (`resize`)**
- При увеличении размера таблицы (`table`) бакеты перераспределяются:
  - Дерево в бакете может разделиться на два поддерева (для старого и нового индексов).
  - Если поддерево становится маленьким, оно преобразуется в связный список.
- **Сложность**: O(n) для всей таблицы, O(log n) для обработки одного дерева.


### 3. **Особенности в `HashMap`**
- **Преобразование в дерево**:
  - Происходит, только если `table.length ≥ 64` и бакет содержит ≥ 8 узлов.
  - Это предотвращает ненужное усложнение для маленьких таблиц.
- **Сравнение ключей**:
  - Используется `Comparable` (или `Comparator`), но также учитываются `hashCode` и `equals` для корректной обработки коллизий.
  - Пример:
    ```java
    if (p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k))))
    ```
- **Балансировка**:
  - Ротации и перекрашивание минимизируют высоту дерева.
  - Чёрная высота гарантирует, что дерево не вырождается в список.
- **Обратное преобразование**:
  - Если узлов в бакете ≤ 6, дерево превращается в связный список для экономии памяти.

### 4. **Ограничения**
- **Память**: `TreeNode` требует больше памяти, чем `Node` (~60 байт против ~40 байт).
- **Сложность преобразования**: Переход от списка к дереву (O(n log n)) и обратно (O(n)) может быть дорогим для маленьких бакетов.
- **Сравнение ключей**: Требуется реализация `Comparable` или предоставление `Comparator`, иначе выбросится `ClassCastException`.

[К оглавлению](#оглавление)

---

## Расскажи как работает LinkedHashMap?

`LinkedHashMap` в Java — это структура данных из пакета `java.util`, которая является расширением `HashMap` и сочетает в себе хэш-таблицу с двусвязным списком для сохранения порядка элементов.
Она реализует интерфейс `Map` и предоставляет функциональность хэш-таблицы с быстрым доступом по ключу (O(1) в среднем), одновременно поддерживая либо **порядок вставки**, либо **порядок доступа** (LRU — Least Recently Used).

### 1. **Внутренняя реализация**

#### a) **Основные поля**
`LinkedHashMap` наследуется от `HashMap` и добавляет поля для поддержки двусвязного списка:
```java
public class LinkedHashMap<K,V> extends HashMap<K,V> implements Map<K,V> {
    // Двусвязный список
    transient LinkedHashMap.Entry<K,V> head; // Голова списка
    transient LinkedHashMap.Entry<K,V> tail; // Хвост списка
    // Режим порядка: true = порядок доступа, false = порядок вставки
    final boolean accessOrder;
    // Поля, унаследованные от HashMap:
    // transient Node<K,V>[] table; // Массив бакетов
    // transient int size; // Количество пар ключ-значение
    // int threshold; // Порог для увеличения размера
    // final float loadFactor; // Коэффициент загрузки
}
```
- `head`, `tail`: Указатели на начало и конец двусвязного списка, связывающего все записи.
- `accessOrder`: Определяет порядок:
  - `false` (по умолчанию): Порядок вставки (элементы в порядке добавления).
  - `true`: Порядок доступа (элементы переупорядочиваются при `get` или `put`, помещая недавно использованные в конец).
- Унаследованные поля от `HashMap`: `table` (массив бакетов), `size`, `threshold`, `loadFactor`.

#### b) **Структура узла**
`LinkedHashMap` использует специализированный класс `Entry<K,V>`, который расширяет `HashMap.Node<K,V>`:
```java
static class Entry<K,V> extends HashMap.Node<K,V> {
    Entry<K,V> before, after; // Ссылки на предыдущий и следующий узлы в двусвязном списке
    Entry(int hash, K key, V value, Node<K,V> next) {
        super(hash, key, value, next);
        this.before = null;
        this.after = null;
    }
}
```
#### c) **Хэш-таблица + двусвязный список**
- **Хэш-таблица**: Как в `HashMap`, элементы хранятся в массиве `table`, где каждый бакет может содержать связный список или красно-чёрное дерево (с Java 8, если узлов ≥ 8 и таблица ≥ 64).
- **Двусвязный список**:
  - Все узлы `Entry` связаны через поля `before` и `after` в единый список, охватывающий все пары ключ-значение.
  - Список поддерживает порядок вставки или доступа, независимо от расположения узлов в бакетах.
  - `head` указывает на первый элемент, `tail` — на последний.
- **Хэширование**: Используется та же хэш-функция, что в `HashMap`:
  ```java
  static final int hash(Object key) {
      int h;
      return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
  }
  ```
  - Индекс бакета: `hash & (table.length - 1)`.

#### d) **Порядок элементов**
- **Порядок вставки** (`accessOrder = false`):
  - Элементы добавляются в конец двусвязного списка (`tail`) при вызове `put`.
  - Порядок сохраняется даже при удалении и повторной вставке.
- **Порядок доступа** (`accessOrder = true`):
  - При вызове `get`, `getOrDefault`, `put`, `compute` или других операций, затрагивающих ключ, соответствующий узел перемещается в конец списка (`tail`).
  - Это реализует поведение LRU: недавно использованные элементы находятся в конце, а наименее использованные — в начале.
  - Используется для кэшей, где можно удалять элементы из `head` (наименее используемые).

### 2. **Основные операции**

#### a) **Добавление элемента (`put(K key, V value)`)**
- **Процесс**:
  1. Вычисляется хэш-код и индекс бакета (как в `HashMap`).
  2. Если `table == null`, инициализируется с начальной ёмкостью (по умолчанию 16).
  3. Добавление в бакет:
  - Если бакет пуст, создаётся новый узел `Entry`.
  - Если бакет занят, проверяется ключ (`equals`):
    - Если ключ существует, обновляется значение, и узел может быть перемещён (если `accessOrder = true`).
    - Если ключа нет, создаётся новый `Entry`, добавляется в бакет и в конец двусвязного списка.
  4. Узел связывается в двусвязном списке:
  - Новый узел становится `tail`, обновляются `before` и `after`.
  - Если список был пуст, узел становится `head` и `tail`.
  5. Увеличивается `size`.
  6. Проверяется порог (`size > threshold`); если превышен, вызывается `resize()`.
- **Сложность**: O(1) в среднем (как в `HashMap`), плюс O(1) для обновления двусвязного списка.
- **Память**: Новый узел `Entry` (~56 байт) + память для ключа и значения.

#### b) **Получение элемента (`get(Object key)`)**
- **Процесс**:
  1. Находит узел в бакете (как в `HashMap`).
  2. Если `accessOrder = true`, узел перемещается в конец двусвязного списка (`afterNodeAccess`):
  3. Возвращает значение или `null`.
- **Сложность**: O(1) в среднем, плюс O(1) для перемещения в списке (если `accessOrder = true`).

#### c) **Удаление элемента (`remove(Object key)`)**
- **Процесс**:
  1. Находит узел в бакете.
  2. Удаляет узел из бакета (как в `HashMap`).
  3. Удаляет узел из двусвязного списка:
  - Обновляются ссылки `before` и `after`.
  - Если узел был `head` или `tail`, обновляются соответствующие указатели.
  4. Уменьшает `size`.
- **Сложность**: O(1) в среднем, плюс O(1) для обновления списка.

#### d) **Изменение размера (`resize`)**
- Аналогично `HashMap`, но узлы `Entry` сохраняют порядок в двусвязном списке.
- **Процесс**:
  1. Создаётся новый массив с удвоенной ёмкостью.
  2. Узлы перераспределяются по новым бакетам.
  3. Двусвязный список остаётся неизменным (ссылки `before` и `after` не затрагиваются).
- **Сложность**: O(n).
- **Память**: Новый массив + временное хранение старого.


[К оглавлению](#оглавление)

---

### Расскажи как работает TreeMap?

`TreeMap` в Java — это структура данных из пакета `java.util`, реализующая интерфейс `NavigableMap` (расширяющий `SortedMap` и `Map`). Она основана на **красно-чёрном дереве**, что обеспечивает упорядоченное хранение пар ключ-значение и гарантированную производительность операций (`get`, `put`, `remove`) на уровне O(log n). `TreeMap` хранит ключи в отсортированном порядке, что делает её подходящей для задач, требующих естественного порядка или пользовательской сортировки.

### 1. **Внутренняя реализация**

#### a) **Основные поля**
Основные поля `TreeMap` (на основе исходного кода OpenJDK):
```java
public class TreeMap<K,V> extends AbstractMap<K,V> implements NavigableMap<K,V>, Cloneable, Serializable {
    private final Comparator<? super K> comparator; // Компаратор для сортировки ключей
    private transient Entry<K,V> root; // Корень красно-чёрного дерева
    private transient int size = 0; // Количество пар ключ-значение
    private transient int modCount = 0; // Счётчик модификаций для итераторов
}
```
- `comparator`: Если `null`, используется естественный порядок ключей (через `Comparable`); иначе — заданный компаратор.
- `root`: Указатель на корневой узел дерева (`null`, если дерево пусто).
- `size`: Количество элементов.
- `modCount`: Отслеживает структурные изменения для предотвращения ошибок при итерации.

#### b) **Структура узла**
Каждый элемент хранится в узле типа `Entry<K,V>`:
```java
static final class Entry<K,V> implements Map.Entry<K,V> {
    K key; // Ключ
    V value; // Значение
    Entry<K,V> left; // Левый потомок
    Entry<K,V> right; // Правый потомок
    Entry<K,V> parent; // Родитель
    boolean color; // Цвет узла (true = красный, false = чёрный)
}
```
- **Поля**:
  - `key`, `value`: Ссылки на ключ и значение.
  - `left`, `right`, `parent`: Ссылки для структуры бинарного дерева.
  - `color`: Булево поле для цвета (1 байт, выравнивается до 4 байт).

#### c) **Красно-чёрное дерево**
`TreeMap` использует **красно-чёрное дерево** — сбалансированное бинарное дерево поиска с дополнительным атрибутом цвета для каждого узла. Свойства красно-чёрного дерева:
1. Каждый узел либо красный, либо чёрный.
2. Корень всегда чёрный.
3. Все листья (NIL, представленные `null`) — чёрные.
4. Если узел красный, оба его потомка — чёрные (запрещены два красных узла подряд).
5. Для каждого узла все пути от него до листьев содержат одинаковое количество чёрных узлов (чёрная высота).

Эти свойства гарантируют, что высота дерева ограничена O(log n), так как самый длинный путь (чередующийся красно-чёрный) не более чем в два раза длиннее самого короткого (только чёрные узлы).


### 2. **Основные операции**

#### a) **Добавление элемента (`put(K key, V value)`)**
- **Процесс**:
  1. **Проверка ключа**:
  - Если `comparator == null`, ключ должен реализовать `Comparable`, иначе выбрасывается `ClassCastException`.
  - Если ключ `null` и используется естественный порядок, выбрасывается `NullPointerException`.
  2. **Поиск позиции**:
  - Начинается с корня, сравнивается ключ с текущим узлом (через `compareTo` или компаратор).
  - Переход в левое поддерево, если ключ меньше, или в правое, если больше.
  - Если ключ найден, обновляется значение.
  3. **Вставка нового узла**:
  - Новый узел создаётся как красный и вставляется в найденную позицию.
  - Обновляются ссылки `parent`, `left`, `right`.
  4. **Балансировка**:
  - Проверяются свойства красно-чёрного дерева.
  - Если нарушаются (например, два красных узла подряд), выполняются:
    - **Ротации** (левый или правый поворот):
    - **Перекрашивание**: Изменение цвета узлов (например, красный родитель становится чёрным).
  - Корень всегда перекрашивается в чёрный.
  5. Увеличивается `size` и `modCount`.
- **Сложность**: O(log n) (поиск + балансировка).
- **Память**: Новый узел (~120 байт для `String` → `Integer`).

#### b) **Получение элемента (`get(Object key)`)**
- **Процесс**:
  1. Начинается с корня, сравнивается ключ с текущим узлом.
  2. Переход в левое или правое поддерево в зависимости от результата сравнения.
  3. Если ключ найден, возвращается значение; иначе — `null`.
- **Сложность**: O(log n).
- **Память**: Не требует дополнительной памяти.

#### c) **Удаление элемента (`remove(Object key)`)**
- **Процесс**:
  1. Находит узел по ключу (O(log n)).
  2. Удаление:
  - Если узел — лист, он просто удаляется.
  - Если у узла один ребёнок, ребёнок заменяет узел.
  - Если два ребёнка, узел заменяется минимальным элементом из правого поддерева (`successor`).
  3. Балансировка:
  - Проверяется чёрная высота путей.
  - Выполняются ротации и перекрашивание для восстановления свойств.
  - Пример метода балансировки:
  4. Уменьшается `size` и увеличивается `modCount`.
- **Сложность**: O(log n).
- **Память**: Удалённый узел становится доступным для сборки мусора.

[К оглавлению](#оглавление)

---

###  Расскажи как работает IdentityHashMap?
`IdentityHashMap` в Java — это специализированная реализация интерфейса `Map` из пакета `java.util`, которая использует **сравнение по ссылочной идентичности** (==) вместо логического равенства (`equals`) для ключей. Это отличает её от других реализаций, таких как `HashMap`, `LinkedHashMap` или `TreeMap`, которые полагаются на методы `equals` и `hashCode`. `IdentityHashMap` оптимизирована для случаев, когда важно учитывать физическое равенство объектов (их адреса в памяти), а не их логическое содержимое.

### 1. **Внутренняя реализация**

#### a) **Основные поля**
Основные поля `IdentityHashMap` (на основе исходного кода OpenJDK):
```java
public class IdentityHashMap<K,V> extends AbstractMap<K,V> implements Map<K,V>, Serializable, Cloneable {
    private transient Object[] table; // Массив для хранения ключей и значений
    private int size; // Количество пар ключ-значение
    private transient int modCount; // Счётчик модификаций для итераторов
    private static final int DEFAULT_CAPACITY = 32; // Начальная ёмкость (2^5)
    private static final int MINIMUM_CAPACITY = 4; // Минимальная ёмкость (2^2)
    private static final int MAXIMUM_CAPACITY = 1 << 29; // Максимальная ёмкость (2^29)
}
```
- `table`: Массив `Object[]`, где хранятся ключи и значения в чередующемся порядке (ключ в `table[2*i]`, значение в `table[2*i+1]`).
- `size`: Количество пар ключ-значение.
- `modCount`: Отслеживает изменения структуры для итераторов.
- **Отсутствие `loadFactor`**: В отличие от `HashMap`, `IdentityHashMap` не использует коэффициент загрузки; вместо этого массив увеличивается, когда заполняется примерно на 2/3.

#### b) **Структура хранения**
- **Массив `table`**:
  - Размер массива всегда является степенью двойки (например, 4, 8, 16, ..., 2²⁹).
  - Каждая пара ключ-значение занимает **две смежные ячейки**: ключ в `table[2*i]`, значение в `table[2*i+1]`.
  - Это упрощает доступ, так как ключ и значение хранятся рядом, улучшая локальность данных.
- **Линейное зондирование**:
  - Коллизии (когда несколько ключей претендуют на один индекс) обрабатываются путём поиска следующей свободной пары ячеек в массиве.
  - Зондирование продолжается, пока не найдётся свободная пара или ключ не будет найден/подтверждён отсутствующим.

#### c) **Хэш-функция**
`IdentityHashMap` использует `System.identityHashCode` вместо пользовательского `hashCode`:
```java
int hash = System.identityHashCode(key);
```
- **Особенности**:
  - `System.identityHashCode(obj)` возвращает хэш-код, основанный на адресе объекта в памяти, даже если класс переопределяет `hashCode`.
  - Для `null` возвращается 0.
- **Преобразование в индекс**:
  - Хэш-код преобразуется в индекс с помощью функции `nextKeyIndex`:
    ```java
    static int nextKeyIndex(int i, int len) {
        return (i + 2 < len ? i + 2 : 0);
    }
    ```
  - Начальный индекс: `hash & (table.length - 2)` (гарантирует чётный индекс для ключа).
  - Если ячейка занята, поиск продолжается с шагом +2 (линейное зондирование).
- **Оптимизация хэш-кода**:
  - Для улучшения распределения используется дополнительное смешивание:
    ```java
    static int hash(Object x, int length) {
        int h = System.identityHashCode(x);
        h += ~(h << 9);
        h ^= (h >>> 14);
        h += (h << 4);
        h ^= (h >>> 10);
        return h & (length - 2);
    }
    ```
  - Это уменьшает вероятность коллизий, смешивая биты хэш-кода.

#### d) **Обработка коллизий**
- **Линейное зондирование**:
  - Если индекс `i` занят, проверяется следующий чётный индекс (`i + 2`, затем `i + 4`, и так далее, с обёртыванием в начало массива при `i + 2 ≥ table.length`).
  - Поиск останавливается, когда:
    - Найден ключ (сравнение через `==`).
    - Найдена свободная ячейка (`table[i] == null`).
    - Пройден весь массив (гарантирует отсутствие ключа).
- **Преимущества**:
  - Простота реализации.
  - Хорошая локальность данных, так как ключи и значения хранятся рядом.
- **Недостатки**:
  - При высокой загрузке (близкой к 2/3) зондирование может стать длинным, увеличивая сложность до O(n).

### 2. **Основные операции**

#### a) **Добавление элемента (`put(K key, V value)`)**
- **Процесс**:
  1. **Вычисление индекса**:
  - `h = System.identityHashCode(key)`.
  - Индекс: `hash(key, table.length) & (table.length - 2)`.
  2. **Поиск позиции**:
  - Проверяется ячейка `table[i]`:
    - Если `table[i] == key` (по ссылке), обновляется значение в `table[i+1]`.
    - Если `table[i] == null`, вставляется новая пара (`table[i] = key`, `table[i+1] = value`).
    - Иначе выполняется зондирование до свободной ячейки или совпадения.
  3. **Проверка размера**:
  - Если `size >= threshold` (где `threshold = table.length * 2 / 3`), вызывается `resize` для удвоения массива.
  4. Увеличивается `size` и `modCount`.
- **Сложность**:
  - Средняя: O(1) при низкой загрузке.
  - Худшая: O(n) при длинном зондировании.ё
#### b) **Получение элемента (`get(Object key)`)**
- **Процесс**:
  1. Вычисляется индекс через `hash(key, table.length)`.
  2. Проверяется `table[i]`:
  - Если `table[i] == key` (по ссылке), возвращается `table[i+1]`.
  - Если `table[i] == null`, возвращается `null`.
  - Иначе продолжается зондирование.
- **Сложность**: O(1) в среднем, O(n) в худшем случае.

#### c) **Удаление элемента (`remove(Object key)`)**
- **Процесс**:
  1. Находит индекс ключа через `hash` и зондирование.
  2. Если ключ найден, удаляет пару:
  - Устанавливает `table[i] = table[i+1] = null`.
  - Перестраивает последующие элементы, чтобы устранить пробел (для корректного зондирования):
  3. Уменьшает `size` и увеличивает `modCount`.
- **Сложность**: O(1) в среднем, O(n) в худшем случае из-за перестройки.

#### d) **Изменение размера (`resize`)**
- **Процесс**:
  1. Новая ёмкость: Удваивается (например, с 32 до 64) или устанавливается в `MINIMUM_CAPACITY` (4) при первой инициализации.
  2. Создаётся новый массив `Object[]`.
  3. Все пары ключ-значение перераспределяются в новый массив с использованием нового хэш-вычисления.
  4. Старый массив становится доступным для сборки мусора.
- **Сложность**: O(n).

[К оглавлению](#оглавление)

---

##  Расскажи как работает WeakHashMap?

`WeakHashMap` в Java — это специализированная реализация интерфейса `Map` из пакета `java.util`, которая использует **слабые ссылки** (`WeakReference`) для ключей, позволяя сборщику мусора (Garbage Collector) автоматически удалять записи, если на ключ больше нет сильных ссылок. Это делает `WeakHashMap` полезной для реализации кэшей, где записи должны автоматически очищаться, когда ключи становятся недоступными. В отличие от `HashMap`, `WeakHashMap` не предотвращает сборку мусора ключей, что существенно влияет на её поведение.

### 1. **Внутренняя реализация**

#### a) **Основные поля**
Основные поля `WeakHashMap` (на основе исходного кода OpenJDK):
```java
public class WeakHashMap<K,V> extends AbstractMap<K,V> implements Map<K,V> {
    private transient Entry<K,V>[] table; // Массив бакетов
    private transient int size; // Количество пар ключ-значение
    private int threshold; // Порог для увеличения размера (capacity * loadFactor)
    private final float loadFactor; // Коэффициент загрузки
    private final ReferenceQueue<Object> queue = new ReferenceQueue<>(); // Очередь для удалённых ключей
    transient int modCount; // Счётчик модификаций для итераторов
    private static final int DEFAULT_INITIAL_CAPACITY = 16;
    private static final float DEFAULT_LOAD_FACTOR = 0.75f;
}
```
- `table`: Массив бакетов, где каждый бакет содержит связный список узлов `Entry`.
- `size`: Количество активных пар ключ-значение.
- `threshold`: Порог, при котором массив увеличивается (`capacity * loadFactor`).
- `loadFactor`: Коэффициент загрузки (по умолчанию 0.75).
- `queue`: `ReferenceQueue` для хранения `WeakReference`, чьи ключи были собраны сборщиком мусора.
- `modCount`: Отслеживает изменения структуры для итераторов.

#### b) **Структура узла**
Каждый элемент хранится в узле типа `Entry<K,V>`, который расширяет `WeakReference`:
```java
private static class Entry<K,V> extends WeakReference<Object> implements Map.Entry<K,V> {
    V value; // Значение
    int hash; // Хэш-код ключа
    Entry<K,V> next; // Ссылка на следующий узел в бакете
}
```
- **Поля**:
  - `WeakReference<Object>`: Хранит ключ как слабую ссылку, связанную с `queue`.
  - `value`: Ссылка на значение.
  - `hash`: Хэш-код ключа, вычисленный на момент вставки.
  - `next`: Ссылка на следующий узел в бакете для обработки коллизий.

#### c) **Хэш-таблица**
- **Массив бакетов (`table`)**:
  - Как в `HashMap`, размер массива — степень двойки (16, 32, 64, ...).
  - Каждый бакет содержит связный список узлов `Entry` или `null`.
- **Хэширование**:
  - Используется та же хэш-функция, что в `HashMap`:
  - Индекс бакета: `hash & (table.length - 1)`.
- **Обработка коллизий**:
  - Коллизии разрешаются через связные списки (в отличие от `HashMap`, где могут использоваться красно-чёрные деревья при большом количестве узлов).
  - Это упрощает реализацию, но может привести к O(n) при большом количестве коллизий.

#### d) **Слабые ссылки и `ReferenceQueue`**
- **Слабые ссылки**:
  - Ключи обёрнуты в `WeakReference`, что позволяет сборщику мусора удалять их, если на них нет сильных или мягких ссылок.
  - Когда ключ собирается, объект `WeakReference` помещается в `queue`.
- **Очистка записей**:
  - Перед каждой операцией (`get`, `put`, `remove`, `size`, и т.д.) вызывается метод `expungeStaleEntries`:
  - Удаляет записи, чьи ключи были собраны, из `table` и уменьшает `size`.
  - Синхронизация на `queue` предотвращает проблемы при многопоточном доступе к очереди.

### 2. **Основные операции**

#### a) **Добавление элемента (`put(K key, V value)`)**
- **Процесс**:
  1. Вызывается `expungeStaleEntries` для очистки удалённых ключей.
  2. Вычисляется хэш-код и индекс бакета:
  - `h = hash(key)`.
  - Индекс: `h & (table.length - 1)`.
  3. Проверяется бакет:
  - Если ключ уже существует (по `equals`), обновляется значение.
  - Иначе создаётся новый узел `Entry`:
  - Узел добавляется в начало связного списка бакета.
  4. Увеличивается `size`.
  5. Если `size > threshold`, вызывается `resize` для удвоения массива.
- **Сложность**:
  - Средняя: O(1) для вставки, плюс O(n) в худшем случае для очистки `queue`.
  - Худшая: O(n) при большом количестве коллизий или записей в `queue`.

#### b) **Получение элемента (`get(Object key)`)**
- **Процесс**:
  1. Вызывается `expungeStaleEntries`.
  2. Вычисляется индекс бакета.
  3. Проверяется связный список в бакете:
  - Для каждого узла сравнивается ключ через `equals` (или `==` для `null`).
  - Если ключ найден, возвращается значение; иначе — `null`.
- **Сложность**: O(1) в среднем, O(n) в худшем случае (коллизии или очистка).

#### c) **Удаление элемента (`remove(Object key)`)**
- **Процесс**:
  1. Вызывается `expungeStaleEntries`.
  2. Находит узел в бакете по ключу.
  3. Удаляет узел из связного списка, обновляя ссылки.
  4. Уменьшает `size` и увеличивает `modCount`.
- **Сложность**: O(1) в среднем, O(n) в худшем случае.

#### d) **Изменение размера (`resize`)**
- **Процесс**:
  1. Новая ёмкость: Удваивается (например, с 16 до 32).
  2. Создаётся новый массив `Entry[]`.
  3. Все активные узлы перераспределяются в новый массив.
  4. Старый массив становится доступным для сборки мусора.
- **Сложность**: O(n).
- **Память**: Новый массив (12 + `newCapacity * 8` байт) + временное хранение старого.

#### e) **Очистка (`expungeStaleEntries`)**
- Вызывается перед большинством операций.
- Проверяет `queue` на наличие `WeakReference`, чьи ключи были собраны.
- Удаляет соответствующие записи из `table`.
- **Сложность**: Зависит от количества элементов в `queue`; в худшем случае O(n).

[К оглавлению](#оглавление)

---

## Stack считается «устаревшим». Чем его рекомендуют заменять? Почему?

Stack был добавлен в Java 1.0 как реализация стека LIFO (last-in-first-out) и является расширением коллекции Vector, хотя это несколько нарушает понятие стека (например, класс Vector предоставляет возможность обращаться к любому элементу по индексу). Является частично синхронизированной коллекцией (кроме метода добавления push()) с вытекающими отсюда последствиями в виде негативного воздействия на производительность. После добавления в Java 1.6 интерфейса Deque, рекомендуется использовать реализации именно этого интерфейса, например, ArrayDeque.

[К оглавлению](#оглавление)

---

## Зачем нужен HashMap, если есть Hashtable?

- Методы класса Hashtable синхронизированы, что приводит к снижению производительности, а HashMap - нет;
- HashTable не может содержать элементы null, тогда как HashMap может содержать один ключ null и любое количество значений null;
- Iterator у HashMap, в отличие от Enumeration у HashTable, работает по принципу «fail-fast» (выдает исключение при любой несогласованности данных).

Hashtable это устаревший класс и его использование не рекомендовано.

[К оглавлению](#оглавление)

---

## В чем разница между HashMap и IdentityHashMap?

#### **HashMap**
- Использует методы `equals()` и `hashCode()` для сравнения ключей и определения их хэш-кодов.
- Два разных объекта, которые считаются равными по `equals()`, **не могут быть разными ключами**.
- Стандартная реализация ассоциативного массива.

```java
Map<String, Integer> map = new HashMap<>();
map.put(new String("a"), 1);
map.put(new String("a"), 2); // перезапишет значение
```

#### **IdentityHashMap**
- Сравнивает **ключи по ссылке (==)**, игнорируя метод `equals()`.
- Вычисляет хэш-код с помощью **`System.identityHashCode()`**, а не метода `hashCode()` объекта.
- Подходит для случаев, когда нужно гарантировать уникальность **именно объектов по ссылке**.

```java
Map<String, Integer> map = new IdentityHashMap<>();
map.put(new String("a"), 1);
map.put(new String("a"), 2); // добавит новый элемент — это разные объекты
```

#### 📌 Ключевая разница:

| Критерий                  | `HashMap`                        | `IdentityHashMap`               |
|---------------------------|----------------------------------|----------------------------------|
| Сравнение ключей          | через `equals()`                 | через `==` (по ссылке)           |
| Хэширование               | через `hashCode()`               | через `System.identityHashCode()`|
| Когда использовать       | обычное использование            | когда важна идентичность ссылок   |

[К оглавлению](#оглавление)

---

## В чем разница между HashMap и WeakHashMap?

#### **HashMap**
- Ключи в `HashMap` **предотвращают удаление объектов сборщиком мусора (GC)**.
- Обычная реализация ассоциативного массива "ключ-значение".
- Объекты остаются в памяти, пока они есть в карте.

#### **WeakHashMap**
- Использует **слабые ссылки (WeakReference)** на ключи.
- Если на ключ **нет других сильных ссылок**, он автоматически удаляется из карты при следующей работе GC.
- Полезен, когда нужно связать данные с объектами, **не мешая их удалению**.

```java
Map<Key, Value> map = new WeakHashMap<>();
map.put(new Key(), new Value()); // после GC: если нет других ссылок — запись исчезнет
```

## 📋 Таблица сравнения:

| Характеристика           | `HashMap`                        | `WeakHashMap`                      |
|--------------------------|----------------------------------|------------------------------------|
| Тип ссылок               | Сильные (strong)                 | Слабые (weak) для ключей           |
| Удаление неиспользуемых  | Нет                              | Да (автоматически через GC)        |
| Потенциальная утечка     | Может быть                       | Минимизирована                     |
| Использование            | Общее хранение данных            | Кэши, временные маппинги            |

[К оглавлению](#оглавление)

---

## В WeakHashMap используются WeakReferences. А почему бы не создать SoftHashMap на SoftReferences или PhantomHashMap на PhantomReferences?

- **WeakReference**:
  - Объект, на который ссылается `WeakReference`, собирается сборщиком мусора (Garbage Collector, GC), как только на него **не остаётся сильных ссылок**. Очистка происходит довольно агрессивно, обычно в следующем цикле GC.
  - Используется в `WeakHashMap` для автоматического удаления записей, когда ключи становятся недоступными.
  - Подходит для временных кэшей, где записи не должны задерживаться в памяти.
  - Доступ к объекту возможен через `get()`, пока он не собран.

- **SoftReference**:
  - Объект, на который ссылается `SoftReference`, сохраняется дольше и собирается только при **нехватке памяти**, обычно перед `OutOfMemoryError`. JVM старается удерживать такие объекты как можно дольше, в зависимости от реализации и настроек (например, `-XX:SoftRefLRUPolicyMSPerMB`).
  - Подходит для кэшей, где данные желательно сохранять, пока память позволяет.
  - Доступ к объекту возможен через `get()`.

- **PhantomReference**:
  - Объект, на который ссылается `PhantomReference`, становится **финализируемым** и может быть собран GC, когда на него нет сильных, мягких или слабых ссылок. Метод `get()` **всегда возвращает `null`**, что делает объект недоступным.
  - Используется для уведомлений о том, что объект стал финализируемым, через `ReferenceQueue`, чтобы выполнить очистку ресурсов (например, закрытие файлов) **до** полной сборки.
  - Подходит для низкоуровневого управления ресурсами, а не для хранения данных.

**Ключевые отличия**:
- `WeakReference` и `SoftReference` позволяют получать объект через `get()`, что делает их подходящими для кэшей.
- `SoftReference` удерживает объекты дольше, чем `WeakReference`, что полезно для кэшей с долгосрочным хранением.
- `PhantomReference` не даёт доступа к объекту и предназначена для финализации, а не для хранения данных.

### 2. **Почему нет `SoftHashMap` в стандартной библиотеке Java?**

#### a) **Ограниченная универсальность и недетерминированность**
- **Поведение `SoftReference`**:
  - Время жизни объектов, на которые ссылается `SoftReference`, зависит от состояния памяти и реализации JVM. Например, параметр `-XX:SoftRefLRUPolicyMSPerMB` в HotSpot JVM влияет на то, как долго объекты сохраняются. Это делает поведение `SoftHashMap` менее предсказуемым по сравнению с `WeakHashMap`, где очистка происходит сразу после потери сильных ссылок.
  - Недетерминированность затрудняет использование `SoftHashMap` в приложениях, где требуется точное управление содержимым кэша.
- **Сравнение с `WeakHashMap`**:
  - `WeakHashMap` обеспечивает чёткое поведение: записи удаляются, как только ключ становится недоступным. Это подходит для задач, таких как канонизация объектов или временные кэши.
  - `SoftHashMap` была бы полезна для кэшей с более долгим удержанием данных, но её поведение слишком зависит от внешних факторов (память, JVM), что снижает её универсальность.

#### b) **Сложность управления `SoftReference`**
- Управление `SoftReference` требует учёта состояния памяти, что усложняет реализацию. JVM может очищать `SoftReference` в разное время в зависимости от нагрузки, что делает тестирование и отладку сложнее.
- В `WeakHashMap` используется `ReferenceQueue` для отслеживания удалённых ключей, что уже добавляет накладные расходы. Для `SoftHashMap` пришлось бы реализовать аналогичную логику, но с учётом менее агрессивной очистки, что увеличило бы сложность.

### 3. **Почему нет `PhantomHashMap` в стандартной библиотеке Java?**

`PhantomHashMap`, использующая `PhantomReference` для ключей, ещё менее вероятна, чем `SoftHashMap`, из-за фундаментальных ограничений `PhantomReference`:

#### a) **Недоступность ключей**
- `PhantomReference.get()` всегда возвращает `null`, что делает невозможным доступ к ключу для операций `get`, `put` или `remove`. Без ключа нельзя выполнить сравнение (`equals`) или вычислить хэш-код, что ломает основную функциональность карты.
- В `WeakHashMap` ключи, обёрнутые в `WeakReference`, доступны через `get()`, что позволяет использовать их для поиска. `PhantomReference` этого не предоставляет, делая реализацию полноценной карты невозможной без хранения копий ключей.

#### b) **Назначение `PhantomReference`**
- `PhantomReference` предназначена для **финализации** и уведомлений о том, что объект стал финализируемым (готов к сборке после финализации). Её используют для выполнения очистки ресурсов (например, закрытия файлов или освобождения нативных ресурсов) через `ReferenceQueue`.
- В контексте `Map` это означало бы, что `PhantomHashMap` могла бы только отслеживать момент удаления ключей, но не предоставлять доступ к значениям по ключам, что противоречит назначению структуры `Map`.

[К оглавлению](#оглавление)

---

## LinkedHashMap - что в нем от LinkedList, а что от HashMap?

Реализация LinkedHashMap отличается от HashMap поддержкой двухсвязанного списка, определяющего порядок итерации по элементам структуры данных. По умолчанию элементы списка упорядочены согласно их порядку добавления в LinkedHashMap (insertion-order). Однако порядок итерации можно изменить, установив параметр конструктора accessOrder в значение true. В этом случае доступ осуществляется по порядку последнего обращения к элементу (access-order). Это означает, что при вызове методов get() или put() элемент, к которому обращаемся, перемещается в конец списка.
При добавлении элемента, который уже присутствует в LinkedHashMap (т.е. с одинаковым ключом), порядок итерации по элементам не изменяется.

[К оглавлению](#оглавление)

---

## Что такое SortedMap?

SortedMap — это интерфейс , а TreeMap — его наиболее популярная реализация в стандартной библиотеке Java.

[К оглавлению](#оглавление)

---

## Согласно Кнуту и Кормену существует две основных реализации хэш-таблицы

**`HashMap` в Java реализована на основе метода цепочек (chaining).**

Начиная с Java 8, если в одной "цепочке" накапливается много элементов (по умолчанию — 8), то **связный список заменяется на красно-черное дерево**, чтобы улучшить производительность поиска.

### Причины выбора:
1. **Устойчивость к коллизиям:** позволяет эффективно обрабатывать ситуации, когда разные ключи попадают в один индекс.
2. **Простая реализация:** проще управлять списками/деревьями, чем перераспределять элементы при изменении размера таблицы.
3. **Гибкость:** легко масштабируется под разные типы данных и распределения хэшей.
4. **Производительность на практике:** для большинства реальных сценариев дает хорошие результаты без излишней сложности.

### Еще существует Метод открытой адресации

Это способ разрешения коллизий в хэш-таблицах, при котором **все элементы хранятся непосредственно в массиве таблицы**, а не в отдельных структурах (например, списках или деревьях), как в методе цепочек.
Когда происходит коллизия (два ключа хэшируются в один и тот же индекс), метод открытой адресации использует **функцию пробирования (probing)**, чтобы найти **следующую свободную ячейку** в массиве.
1. **Линейное пробирование**
   ```java
   index = (hash(key) + i) % capacity;
   ```
   Где `i` — шаг пробирования (обычно 1). Просто, но может приводить к **кластеризации**.

2. **Квадратичное пробирование**
   ```java
   index = (hash(key) + i^2) % capacity;
   ```
   Уменьшает кластеризацию, но всё равно возможны **вторичные кластеры**.

3. **Двойное хэширование**  
   Используется вторая хэш-функция для определения шага:
   ```java
   index = (hash1(key) + i * hash2(key)) % capacity;
   ```
   Самый эффективный из этих методов, минимизирует кластеры.

### Плюсы открытой адресации:

- **Экономия памяти:** не нужны дополнительные структуры (списки/деревья).
- **Хорошая локальность данных:** все элементы находятся в одном массиве → лучше использование CPU-кеша.
- **Простота сериализации:** проще сохранить/загрузить всю таблицу.

### Минусы открытой адресации:

- **Сложность удаления:** нельзя просто удалить элемент, т.к. это может нарушить последовательность поиска → требуется маркировка "удалённых" записей.
- **Ухудшение производительности при высокой загрузке:** чем больше элементов, тем больше коллизий и длиннее пробирование.
- **Риск переполнения:** если таблица заполнена, операции становятся очень медленными.

Метод открытой адресации — это **экономичный по памяти и быстрый по доступу** способ реализации хэш-таблиц, особенно полезный при хорошем хэшировании и невысокой нагрузке. Однако он сложнее в управлении (особенно при удалении элементов) и менее устойчив к высокому числу коллизий, чем метод цепочек.

## 🧠 Вывод:

> **`HashMap` реализована через метод цепочек**, потому что он:
> - лучше справляется с коллизиями,
> - проще в реализации,
> - обеспечивает хорошую производительность в реальных условиях.

[К оглавлению](#оглавление)

---

## Как работает HashMap при попытке сохранить в него два элемента по ключам с одинаковым hashCode(), но для которых equals() == false?

По значению hashCode() вычисляется индекс ячейки массива, в список которой этот элемент будет добавлен. Перед добавлением осуществляется проверка на наличие элементов в этой ячейке. Если элементы с таким hashCode() уже присутствует, но их equals() методы не равны, то элемент будет добавлен в конец списка.

[К оглавлению](#оглавление)

---

## Какое начальное количество корзин в HashMap?

В конструкторе по умолчанию - 16, используя конструкторы с параметрами можно задавать произвольное начальное количество корзин.

[К оглавлению](#оглавление)

---

## Какова оценка временной сложности операций над элементами из HashMap? Гарантирует ли HashMap указанную сложность выборки элемента?

В общем случае операции добавления, поиска и удаления элементов занимают константное время.
Данная сложность не гарантируется, т.к. если хэш-функция распределяет элементы по корзинам равномерно, временная сложность станет не хуже Логарифмического времени O(log(N)), а в случае, когда хэш-функция постоянно возвращает одно и то же значение, HashMap превратится в связный список со сложностью О(n).

[К оглавлению](#оглавление)

---

## Возможна ли ситуация, когда HashMap выродится в список даже с ключами имеющими разные hashCode()?

Это возможно в случае, если метод, определяющий номер корзины будет возвращать одинаковые значения.

[К оглавлению](#оглавление)

---

## В каком случае может быть потерян элемент в HashMap?

Допустим, в качестве ключа используется не примитив, а объект с несколькими полями. После добавления элемента в HashMap у объекта, который выступает в качестве ключа, изменяют одно поле, которое участвует в вычислении хэш-кода. В результате при попытке найти данный элемент по исходному ключу, будет происходить обращение к правильной корзине, а вот equals уже не найдет указанный ключ в списке элементов. Тем не менее, даже если equals реализован таким образом, что изменение данного поля объекта не влияет на результат, то после увеличения размера корзин и пересчета хэш-кодов элементов, указанный элемент, с измененным значением поля, с большой долей вероятности попадет в совершенно другую корзину и тогда уже потеряется совсем.

[К оглавлению](#оглавление)

---

## Почему нельзя использовать byte[] в качестве ключа в HashMap?

Хэш-код массива не зависит от хранимых в нем элементов, а присваивается при создании массива (метод вычисления хэш-кода массива не переопределен и вычисляется по стандартному Object.hashCode() на основании адреса массива). Так же у массивов не переопределен equals и выполняется сравнение указателей. Это приводит к тому, что обратиться к сохраненному с ключом-массивом элементу не получится при использовании другого массива такого же размера и с такими же элементами, доступ можно осуществить лишь в одном случае — при использовании той же самой ссылки на массив, что использовалась для сохранения элемента.

[К оглавлению](#оглавление)

---

## Какова роль equals() и hashCode() в HashMap?

hashCode позволяет определить корзину для поиска элемента, а equals используется для сравнения ключей элементов в списке корзины и искомого ключа.

[К оглавлению](#оглавление)

---

## Каково максимальное число значений hashCode()?

Число значений следует из сигнатуры int hashCode() и равно диапазону типа int — 2^32.

[К оглавлению](#оглавление)

---

## Какое худшее время работы метода get(key) для ключа, которого нет в HashMap?

O(N). Худший случай - это поиск ключа в HashMap, вырожденного в список по причине совпадения ключей по hashCode() и для выяснения хранится ли элемент с определённым ключом может потребоваться перебор всего списка.

[К оглавлению](#оглавление)

---

## Сколько переходов происходит в момент вызова HashMap.get(key) по ключу, который есть в таблице?

- ключ равен null: 1 - выполняется единственный метод getForNullKey().
- любой ключ отличный от null: 4 - вычисление хэш-кода ключа; определение номера корзины; поиск значения; возврат значения.

[К оглавлению](#оглавление)

---

## Сколько создается новых объектов, когда вы добавляете новый элемент в HashMap?

Один новый объект статического вложенного класса Entry<K,V>.

[К оглавлению](#оглавление)

---

## Как и когда происходит увеличение количества корзин в HashMap?

Помимо capacity у HashMap есть еще поле loadFactor, на основании которого, вычисляется предельное количество занятых корзин capacity * loadFactor. По умолчанию loadFactor = 0.75. По достижению предельного значения, число корзин увеличивается в 2 раза и для всех хранимых элементов вычисляется новое «местоположение» с учетом нового числа корзин.

[К оглавлению](#оглавление)

---

## Объясните смысл параметров в конструкторе HashMap(int initialCapacity, float loadFactor).

- initialCapacity - исходный размер HashMap, количество корзин в хэш-таблице в момент её создания.
- loadFactor - коэффициент заполнения HashMap, при превышении которого происходит увеличение количества корзин и автоматическое перехэширование. Равен отношению числа уже хранимых элементов в таблице к её размеру.

[К оглавлению](#оглавление)

---

## Будет ли работать HashMap, если все добавляемые ключи будут иметь одинаковый hashCode()?

Да, будет, но в этом случае HashMap вырождается в связный список и теряет свои преимущества.

[К оглавлению](#оглавление)

---

## Как перебрать все ключи Map?

Использовать метод keySet(), который возвращает множество Set<K> ключей.

[К оглавлению](#оглавление)

---

## Как перебрать все значения Map?

Использовать метод values(), который возвращает коллекцию Collection<V> значений.

[К оглавлению](#оглавление)

---

## Как перебрать все пары «ключ-значение» в Map?

Использовать метод entrySet(), который возвращает множество Set<Map.Entry<K, V> пар «ключ-значение».

[К оглавлению](#оглавление)

---

## Что такое Entry, какие в нем поля, и для чего они используются

Интерфейс Map.Entry в Java позволяет работать с записями Map.
Метод entrySet(), объявленный интерфейсом Map, возвращает Set, содержащий записи Map. Каждый из этих элементов является объектом Map.Entry.
В следующей таблице приведены методы, объявленные этим интерфейсом:

| Метод                | Описание                                                                 |
|----------------------|--------------------------------------------------------------------------|
| Object getKey()      | Возвращает ключ для этой записи в Map.                                   |
| Object getValue()    | Возвращает значение для этой записи в Map.                               |

[К оглавлению](#оглавление)

---

## Реализации Set в Java?

Вот список реализаций интерфейса `Set` в Java:

### **Реализации `Set` в Java**

1. **`HashSet`**
  - Основан на хэш-таблице.
  - Не сохраняет порядок элементов.
  - Операции `add`, `remove`, `contains` — `O(1)` в среднем.
  - Не потокобезопасен.

2. **`LinkedHashSet`**
  - Наследует `HashSet`, но сохраняет порядок вставки.
  - Немного медленнее `HashSet` из-за поддержки связанного списка.
  - Операции — `O(1)`.

3. **`TreeSet`**
  - Основан на красно-черном дереве (`NavigableSet`).
  - Хранит элементы в отсортированном порядке.
  - Операции — `O(log n)`.
  - Можно задать `Comparator`.

4. **`CopyOnWriteArraySet`** (`java.util.concurrent`)
  - Потокобезопасная реализация.
  - Медленный при частых изменениях.
  - Итераторы не поддерживают `remove()`.

5. **`ConcurrentSkipListSet`** (`java.util.concurrent`)
  - Потокобезопасный аналог `TreeSet`.
  - Элементы хранятся в отсортированном порядке.
  - Операции — `O(log n)`.

6. **`EnumSet`**
  - Оптимизирован для `enum`.
  - Крайне эффективен (битовая маска).
  - Быстрее `HashSet` для перечислений.

### **Специальные обертки**
- **`Collections.synchronizedSet(Set)`** – синхронизированная версия любого `Set`.
- **`ImmutableSet`** (из Guava) – неизменяемый `Set`.

Если нужна **потокобезопасность** → `ConcurrentSkipListSet`, `CopyOnWriteArraySet`.  
Если нужен **порядок** → `LinkedHashSet` (вставка) или `TreeSet` (сортировка).  
Если важна **производительность** → `HashSet`.  
Если работаете с **`enum`** → `EnumSet`.

[К оглавлению](#оглавление)

---

## Внутренняя реализация и как внутри работают основные операции HashSet?

`HashSet` — это реализация интерфейса `Set`, основанная на **хэш-таблице**. Внутри он использует `HashMap` для хранения элементов.

#### **1. Базовая структура данных**
- `HashSet` хранит элементы в виде **ключей `HashMap`**, а значения (`values`) заполняются "заглушкой" (`PRESENT`).
- По умолчанию начальная ёмкость (`capacity`) = **16**, а коэффициент загрузки (`loadFactor`) = **0.75**.

```java
// Внутри HashSet
private transient HashMap<E, Object> map;

// Заглушка для значений в HashMap
private static final Object PRESENT = new Object();

// Конструктор
public HashSet() {
    map = new HashMap<>(); // Внутри используется HashMap
}
```

### **2. Как работают основные операции?**

#### **✔ `add(E e)` – добавление элемента**
1. Вычисляется **хэш-код** элемента (`e.hashCode()`).
2. На основе хэш-кода определяется **индекс корзины (bucket)** в хэш-таблице:
   ```java
   index = hash(key) & (capacity - 1);
   ```
3. Если корзина пуста, элемент добавляется.
4. Если в корзине уже есть элементы (`коллизия`), то:
  - Для **`LinkedList`** (Java 7) – элемент добавляется в конец списка.
  - Для **`TreeNode`** (Java 8+) – если корзина становится слишком большой, список преобразуется в **красно-черное дерево** (при `TREEIFY_THRESHOLD = 8`).

```java
public boolean add(E e) {
  return map.put(e, PRESENT) == null; // Кладёт ключ в HashMap
}
```

#### **✔ `remove(Object o)` – удаление элемента**
1. Вычисляется хэш-код объекта.
2. Находится корзина по индексу.
3. Если элемент найден (через `equals()`), он удаляется.

```java
public boolean remove(Object o) {
  return map.remove(o) == PRESENT;
}
```

#### **✔ `contains(Object o)` – проверка наличия элемента**
1. Вычисляется хэш-код.
2. Находится корзина.
3. Проверяется наличие элемента через `equals()`.

```java
public boolean contains(Object o) {
  return map.containsKey(o);
}
```

[К оглавлению](#оглавление)

---

## Внутренняя реализация и как внутри работают основные операции LinkedHashSet?

`LinkedHashSet` — это наследник `HashSet`, который сохраняет **порядок добавления элементов** за счёт использования **связанного списка**. Внутри он основан на `LinkedHashMap`.

#### **1. Базовая структура данных**
- `LinkedHashSet` использует `LinkedHashMap` для хранения элементов.
- Каждый элемент связан с предыдущим и следующим через **двусвязный список**.
- Как и в `HashSet`, значения (`values`) заполняются заглушкой `PRESENT`.

```java
// Внутри LinkedHashSet
public class LinkedHashSet<E> extends HashSet<E> {
  public LinkedHashSet() {
    super(16, 0.75f, true); // вызывает конструктор HashSet с accessOrder = false
  }
}

// В HashSet есть специальный конструктор для LinkedHashSet
HashSet(int initialCapacity, float loadFactor, boolean dummy) {
  map = new LinkedHashMap<>(initialCapacity, loadFactor); // Здесь используется LinkedHashMap!
}
```

### **2. Как работают основные операции?**

#### **✔ `add(E e)` – добавление элемента**
1. Элемент добавляется в `LinkedHashMap` (как ключ).
2. Если элемент уже есть, метод возвращает `false`.
3. Новый элемент **добавляется в конец двусвязного списка** (поддерживается порядок вставки).

```java
public boolean add(E e) {
  return map.put(e, PRESENT) == null; // Используется LinkedHashMap.put()
}
```

#### **✔ `remove(Object o)` – удаление элемента**
1. Элемент удаляется из `LinkedHashMap`.
2. Соответствующая нода **удаляется из двусвязного списка**.

```java
public boolean remove(Object o) {
  return map.remove(o) == PRESENT; // Используется LinkedHashMap.remove()
}
```

#### **✔ `contains(Object o)` – проверка наличия элемента**
1. Проверка происходит через `LinkedHashMap.containsKey()`.
2. **Не влияет на порядок** (если бы использовался `accessOrder = true`, как в `LRU-кеше`, то влиял бы).

```java
public boolean contains(Object o) {
  return map.containsKey(o);
}
```

[К оглавлению](#оглавление)

---

## Внутренняя реализация и как внутри работают основные операции TreeSet?

`TreeSet` — это реализация интерфейса `NavigableSet`, основанная на **красно-черном дереве (Red-Black Tree)**. В отличие от `HashSet` и `LinkedHashSet`, элементы в `TreeSet` хранятся **в отсортированном порядке** (по умолчанию — natural ordering, либо через `Comparator`).

### **1. Базовая структура данных**
- Внутри `TreeSet` использует `TreeMap` для хранения элементов.
- Каждый элемент является **ключом (`key`)** в `TreeMap`, а значение (`value`) — это заглушка `PRESENT`.

```java
// Внутри TreeSet
private transient NavigableMap<E, Object> map; // TreeMap по умолчанию
private static final Object PRESENT = new Object();

// Конструктор
public TreeSet() {
  this(new TreeMap<>()); // Использует TreeMap внутри
}
```

### **2. Как работают основные операции?**

#### **✔ `add(E e)` – добавление элемента**
1. Элемент вставляется в `TreeMap` как ключ.
2. Если элемент уже есть, метод возвращает `false`.
3. Дерево **автоматически балансируется** (по правилам красно-черного дерева).

```java
public boolean add(E e) {
  return map.put(e, PRESENT) == null; // TreeMap.put()
}
```

#### **✔ `remove(Object o)` – удаление элемента**
1. Элемент удаляется из `TreeMap`.
2. Дерево **перебалансируется** для сохранения свойств.

```java
public boolean remove(Object o) {
  return map.remove(o) == PRESENT; // TreeMap.remove()
}
```

#### **✔ `contains(Object o)` – проверка наличия элемента**
1. Используется `TreeMap.containsKey()`.
2. Поиск происходит за `O(log n)` благодаря двоичному поиску в дереве.

```java
public boolean contains(Object o) {
  return map.containsKey(o);
}
```

### **3. Как поддерживается сортировка?**
- Если `Comparator` не задан, используется **natural ordering** (`Comparable`).
- Если задан `Comparator`, порядок определяется им.

[К оглавлению](#оглавление)

---

## В чем отличия TreeSet и HashSet?

Начнем с того, что Set — это множество (так же называют «набором»). Set не допускает хранение двух одинаковых элементов. Формально говоря, термин «множество» и так обозначает совокупность различных элементов, очень важно, что именно различных элементов, так как это главное свойство Set. С учетом такого определения, пояснение про хранение одинаковых элементом не требуется, но в обиходе, понятие «множество» потеряло свой строгий смысл касательно уникальности элементов, входящих в него, поэтому все же уточняйте отдельно данное свойство множества.

TreeSet обеспечивает упорядоченно хранение элементов в виде красно-черного дерева. Сложность выполнения основных операций не хуже O(log(N)) (Логарифмическое время).
HashSet использует для хранения элементов такой же подход, что и HashMap, за тем отличием, что в HashSet в качестве ключа и значения выступает сам элемент, кроме того, HashSet не поддерживает упорядоченное хранение элементов и обеспечивает временную сложность выполнения операций аналогично HashMap.

[К оглавлению](#оглавление)

---

## Что будет, если добавлять элементы в TreeSet по возрастанию?

В основе TreeSet лежит красно-черное дерево, которое умеет само себя балансировать. В итоге, TreeSet все равно в каком порядке вы добавляете в него элементы, преимущества этой структуры данных будут сохраняться.

[К оглавлению](#оглавление)

---

## Чем LinkedHashSet отличается от HashSet?

LinkedHashSet отличается от HashSet только тем, что в его основе лежит LinkedHashMap вместо HashMap. Благодаря этому порядок элементов при обходе коллекции является идентичным порядку добавления элементов (insertion-order). При добавлении элемента, который уже присутствует в LinkedHashSet (т.е. с одинаковым ключом), порядок обхода элементов не изменяется.

[К оглавлению](#оглавление)

---

## Для Enum есть специальный класс java.util.EnumSet. Зачем? Чем авторов не устраивал HashSet или TreeSet?

EnumSet - это реализация интерфейса Set для использования с перечислениями (Enum). В структуре данных хранятся объекты только одного типа Enum, указываемого при создании. Для хранения значений EnumSet использует массив битов (bit vector), - это позволяет получить высокую компактность и эффективность. Проход по EnumSet осуществляется согласно порядку объявления элементов перечисления.
Все основные операции выполняются за O(1) и обычно (но негарантированно) быстрей аналогов из HashSet, а пакетные операции (bulk operations), такие как containsAll() и retainAll() выполняются даже горазда быстрей.
Помимо всего EnumSet предоставляет множество статических методов инициализации для упрощенного и удобного создания экземпляров.

[К оглавлению](#оглавление)

---

## Каким образом можно получить синхронизированные объекты стандартных коллекций?

С помощью статических методов synchronizedMap() и synchronizedList() класса Collections. Данные методы возвращают синхронизированный декоратор переданной коллекции. При этом все равно в случае обхода по коллекции требуется ручная синхронизация.
```java
Map m = Collections.synchronizedMap(new HashMap());
List l = Collections.synchronizedList(new ArrayList());
```
Начиная с Java 6 JCF был расширен специальными коллекциями, поддерживающими многопоточный доступ, такими как CopyOnWriteArrayList и ConcurrentHashMap.

[К оглавлению](#оглавление)

---

## Как получить коллекцию только для чтения?

При помощи:
```java
Collections.unmodifiableList(list);
Collections.unmodifiableSet(set);
Collections.unmodifiableMap(map);
```
Эти методы принимают коллекцию в качестве параметра, и возвращают коллекцию только для чтения с теми же элементами внутри.

[К оглавлению](#оглавление)

---

## Напишите однопоточную программу, которая заставляет коллекцию выбросить ConcurrentModificationException.

```java
public static void main(String[] args) {
    List<Integer> list = new ArrayList<>();
    list.add(1);
    list.add(2);
    list.add(3);
    for (Integer integer : list) {
        list.remove(1);
    }
}
```

[К оглавлению](#оглавление)

---

## Приведите пример, когда какая-либо коллекция выбрасывает UnsupportedOperationException.

```java
public static void main(String[] args) {
    List<Integer> list = Collections.emptyList();
    list.add(0);
}
```

[К оглавлению](#оглавление)

---

## Реализуйте симметрическую разность двух коллекций используя методы Collection (addAll(...), removeAll(...), retainAll(...)).

Симметрическая разность двух коллекций - это множество элементов, одновременно не принадлежащих обоим исходным коллекциям.
```java
<T> Collection<T> symmetricDifference(Collection<T> a, Collection<T> b) {
    // Объединяем коллекции.
    Collection<T> result = new ArrayList<>(a);
    result.addAll(b);
    // Получаем пересечение коллекций.
    Collection<T> intersection = new ArrayList<>(a);
    intersection.retainAll(b);
    // Удаляем элементы, расположенные в обоих коллекциях.
    result.removeAll(intersection);
    return result;
}
```

[К оглавлению](#оглавление)

---

## Как, используя LinkedHashMap, сделать кэш c «invalidation policy»?

Необходимо использовать LRU-алгоритм (Least Recently Used algorithm) и LinkedHashMap с access-order. В этом случае при обращении к элементу он будет перемещаться в конец списка, а наименее используемые элементы будут постепенно группироваться в начале списка. Так же в стандартной реализации LinkedHashMap есть метод removeEldestEntry(), который возвращает true, если текущий объект LinkedHashMap должен удалить наименее используемый элемент из коллекции при использовании методов put() и putAll().

```java
public class LRUCache<K, V> extends LinkedHashMap<K, V> {
    private static final int MAX_ENTRIES = 10;
    public LRUCache(int initialCapacity) {
        super(initialCapacity, 0.85f, true);
    }
    @Override
    protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
        return size() > MAX_ENTRIES;
    }
}
```

Стоит заметить, что LinkedHashMap не позволяет полностью реализовать LRU-алгоритм, поскольку при вставке уже имеющегося в коллекции элемента порядок итерации по элементам не меняется.

[К оглавлению](#оглавление)

---

## Чем отличается ArrayList от HashSet?

Если ArrayList и LinkedList можно было сравнить по операциям — где кто лучше — то с ArrayList с HashSet сравнить уже не так просто, ведь это совершенно разные коллекции.
Можно сравнить одно сладкое блюдо с другим, но с мясным уже получится — больно уж они разные. Тем не менее, я попробую привести их некоторые различия:

- ArrayList реализует интерфейс List, в то время как HashSet реализует интерфейс Set;
- В ArrayList возможен доступ по индексу элемента: операция get имеет алгоритмическую сложность O(1), а в HashSet необходимый элемент можно получить лишь путём перебора, а это у нас от O(1) до O(n);
- ArrayList допускает присутствие дубликатов элементов. В HashSet все элементы уникальны: добавить в HashSet элемент, аналог которого уже присутствует в коллекции, не получится (проверка дубликатов ведется по hashcode, отсюда и название этой коллекции);
- ArrayList реализован с помощью внутреннего массива, а HashSet реализован с помощью внутренней HashMap;
- ArrayList поддерживает порядок вставки элементов, в то время как HashSet — это неупорядоченное множество и не поддерживает порядок элементов;
- ArrayList допускает любое количество пустых значений (null), в HashSet можно вставить лишь одно значение null (как-никак, уникальность элементов).

[К оглавлению](#оглавление)

---

## Зачем в Java такое разнообразие имплементации динамического массива?

Ну, это скорее философский вопрос. Ну а зачем придумывают такое количество новых разнообразных технологий? Для удобства. Собственно, так же и с большим количеством имплементаций динамического массива. Ни одну из них нельзя назвать лучшей или идеальной. У каждой есть преимущество в какой-то конкретной ситуации. И наша задача — знать их различия, их сильные/слабые стороны: чтобы суметь в нужной ситуации использовать самую подходящую из них.

[К оглавлению](#оглавление)

---

## Как отсортировать коллекцию элементов?

Первое, что нужно сказать, — класс элемента коллекции должен имплементировать интерфейс Comparable и его метод compareTo. Или же нужен класс, который имплементирует Comparator с его методом comparator.
Оба способа указывают, каким образом нужно сравнивать объекты данного типа. При сортировке это критически важно, ведь нужно понимать принцип, по которому элементы можно сравнить. В основном используется способ через имплементацию Comparable, реализуемый непосредственно в классе, который вы хотите сортировать. В то же время применение Comparator-а более редко. Скажем, вы используете класс с какой-то библиотеки, у которого нет реализации Comparable, но вам как-то нужно будет его сортировать. Не имея возможности изменить код данного класса (кроме как расширить его), вы можете написать реализацию Comparator-а, в котором укажете, по какому принципу нужно сравнивать объекты данного класса. И еще один пример. Допустим, вам нужны разные принципы сортировки объектов одного и того же типа, поэтому вы пишете несколько Comparator-ов которые используете в разных ситуациях. Как правило, многие классы из коробки уже реализуют интерфейс Comparable — тот же String. Собственно, при их использовании вам не нужно париться, как их сравнить. Вы просто берете и используете их.

Первый и самый очевидный способ — использовать коллекцию типа TreeSet или TreeMap, которые хранят элементы в ужеотсортированном порядке, согласно компаратору класса элементов. Не забывайте, что TreeMap сортирует ключи, но не значения. Если вы используете имплементацию Comparator вместо Comparable, вам нужно будет передать его объект в конструктор коллекции при создании:
```java
TreeSet treeSet = new TreeSet(customComparator);
```
А что если у вас коллекция другого типа? Как её отсортировать?

В этом случае подходит второй способ утилитного класса Collections — метод sort(). Он статический, поэтому всё, что вам нужно — имя класса и метод, в который передается необходимый список. Например:
```java
Collections.sort(someList);
```
Если вы используете не Comparable, а реализацию Comparator, его нужно передать вторым параметром:
```java
Collections.sort(someList, customComparator);
```
В итоге внутренний порядок элементов переданного списка изменится: он будет отсортирован согласно компаратору элементов. Отмечу, что передаваемый список элементов должен быть мутабельным, т.е. изменяемым, иначе метод не сработает и будет выброшено UnsupportedOperationException.

В качестве третьего способа можно использовать Stream операцию sort, которая сортирует элементы коллекции, если используется имплементация Comparable:
```java
someList = someList.stream().sorted().collect(Collectors.toList());
```
если Comparator:
```java
someList = someList.stream().sorted(customComparator).collect(Collectors.toList());
```
Подробнее о Stream можно почитать в этой статье.

Четвертый способ — ручная реализация сортировки, например, сортировки пузырьком или сортировки слиянием.

[К оглавлению](#оглавление)

---

## В чем разница между HashMap, TreeMap, и Hashtable

- **Порядок элементов.** HashMap и Hashtable не гарантируют, что элементы будут храниться в порядке добавления. Кроме того, они не гарантируют, что порядок элементов не будет меняться со временем. В свою очередь, TreeMap гарантирует хранение элементов в порядке добавления или же в соответствии с заданным компаратором.
- **Допустимые значения.** HashMap позволяет иметь ключ и значение null, HashTable — нет. TreeMap может использовать значения null только если это позволяет компаратор. Без использования компаратора (при хранении пар в порядке добавления) значение null не допускается.
- **Синхронизация.** Только HashTable синхронизирована, остальные — нет. Если к мапе не будут обращаться разные потоки, рекомендуется использовать HashMap вместо HashTable.

[К оглавлению](#оглавление)

---

## HashMap one optimization?

Когда TREEIFY_THRESHOLD = 8 (Количество объектов в односвязном списке) становится слишком большой (в настоящее время: TREEIFY_THRESHOLD = 8 ), HashMap динамически заменяет ее специальной реализацией древовидной карты. Таким образом, вместо пессимистического O (n) мы получаем намного лучше O (logn). Как это работает? Что ж, ранее записи с конфликтующими ключами просто добавлялись в связанный список, который позже нужно было просмотреть. Теперь HashMap преобразует список в двоичное дерево, используя хеш-код в качестве переменной ветвления. Если два хэша различны, но попали в одно и то же ведро, один считается больше и идет вправо. Если хэши равны (как в нашем случае), HashMap надеется, что ключи Comparable , чтобы он мог установить некоторый порядок. Это не требование ключей HashMap , но, видимо, хорошая практика. Если ключи несопоставимы, не ожидайте каких-либо улучшений производительности в случае сильных коллизий хешей.

[К оглавлению](#оглавление)

---

## Как создать двунаправленную мапу

Иногда появляется необходимость использовать структуру данных, в которой и ключи, и значения будут уникальными, то есть мапа будет содержать пары "ключ-ключ".
Такая структура данных позволяет создать "инвертированный просмотр/поиск" по мапе. То есть, мы можем найти ключ по его значению.Эту структуру данных называют двунаправленной мапой, которая, к сожалению, не поддерживается JDK. Но, к счастью, ее реализацию можно найти в библиотеках Apache Common Collections или Guava. Там она называется BidiMap и BiMap соответственно. Эти реализации вводят ограничения на уникальность ключей и значений. Таким образом получаются отношения one-to-one.

[К оглавлению](#оглавление)

---

## Как конвертировать Map в List

У интерфейса Map существует 3 метода, которые возвращают перечень элементов:

- keySet() — возвращает множество(Set) ключей;
- values() — возвращает коллекцию(Collection) значений;
- entrySet() — возвращает множество(Set) наборов "ключ-значение".

Если заглянуть в конструкторы класса ArrayList, можно заметить, что существует конструктор с аргументом типа Collection. Так как Set является наследником Collection, результаты всех вышеупомянутых методов можно передать в конструктор класса ArrayList. Таким образом, мы создадим новые списки и заполним их значениями из Map:
```java
// key list
List<Integer> keyList = new ArrayList<>(map.keySet());
// value list
List<String> valueList = new ArrayList<>(map.values());
// key-value list
List<Map.Entry<Integer, String>> entryList = new ArrayList<>(map.entrySet());
```

[К оглавлению](#оглавление)

---

## Расскажите про реализации деревьев.

- **TreeMap** - Упорядоченная по ключам. Основана на красно-черных деревьях. Может использовать компаратов в конструкторе. Красно-черные деревья это самобалансирующееся дерево которое гарантирует логарифмический рост высоты дерева от числа узлов.
- **TreeSet** - основан на сбалансированном двоичном дереве, в результате элементы упорядочены по возрастанию hashCode()'ов. Можно управлять порядком при помощи компаратора.

[К оглавлению](#оглавление)

---

## Какие существуют методы для разрешения коллизий?

### Метод цепочек
Метод цепочек является наиболее простым методом разрешения коллизий. В ячейке массива мы будем хранить не элементы, а связанный список данных элементов. Потому как добавление в начало списка (а нам все равно в какую часть списка добавлять элемент) обладает асимптотикой О(1), мы не испортим общую асимптотику, и она останется равной О(1).У данной реализации есть проблема: если списки будут очень сильно вырастать (в качестве крайнего случая можно рассмотреть хеш-функцию, которая возвращает константу для любого объекта), то мы получим асимптотику O(m), где m — число элементов во множестве, если размер массива фиксирован. Для избежания таких неприятностей вводится понятие коэффициент заполнения(он может быть равен, например, 1.5). Если при добавлении элемента оказывается, что доля числа элементов, находящихся в структуре данных по отношению к размеру массива, превосходит коэффициент заполнения, то происходит следующее: выделяется новый массив, размер которого превосходит размер старого массива (например в 2 раза), и структура данных перестраивается на новом массиве.Данный метод разрешения коллизий и применяется в Java, а структура данных называется HashSet.

### Метод открытой адресации
В данном методе в ячейках хранятся сами элементы, а в случае коллизии происходит последовательность проб, то есть мы начинаем по некоторому алгоритму перебирать ячейки в надежде найти свободную. Это можно делать разными алгоритмами (линейная / квадратичная последовательности проб,двойное хеширование), каждый из которых обладает своими проблемами (например, возникновение первичных или вторичных кластеров).

[К оглавлению](#оглавление)