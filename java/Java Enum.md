Дайте краткую характеристику Enum в Java

Enum — перечисление, набор строковых констант, объединенных общим типом. Объявляется через ключевое слово — enum. Вот пример с enum — допустимые роли в некоторой школе:

public enum Role { STUDENT, TEACHER, DIRECTOR, SECURITY_GUARD }

Слова, написанные большими буквами, и есть те самые константы перечисления, которые объявляются упрощенно, без использования оператора new. Использование перечислений заметно упрощает жизнь, так как они помогают избежать ошибок и путаницы в наименованиях (так как может быть только определенный перечень значений).

--------------------------------------------------------------------------------------------------------------------
Может Enum реализовывать (implements) интерфейсы?

Да. Ведь перечисления должны представлять не просто пассивные наборы (как например, роли). В Java они могут представлять более сложные объекты с некоторым функционалом, поэтому вам, возможно, понадобится добавить к ним дополнительный функционал. Также это позволит использовать возможности полиморфизма, подставляя значение enum в места, где необходим тип имплементируемого интерфейса.

--------------------------------------------------------------------------------------------------------------------
Может Enum расширять (extends) класс?

Нет, не может, так как перечисление — это подкласс по умолчанию универсального класса Enum <T>, где T представляет универсальный тип перечисления. Это не что иное, как общий базовый класс для всех типов перечисления языка Java. Преобразование enum в класс выполняется компилятором Java во время компиляции. Это расширение явно в коде не указывается, но всегда незримо присутствует.

--------------------------------------------------------------------------------------------------------------------
Можно ли создать Enum без экземпляров объектов?

Как по мне, вопрос немного странный, ну или я его не до конца понял. У меня есть две интерпретации:
1. Может ли быть enum без значений — да, конечно, это будет что-то вроде пустого класса — бессмысленно:
   public enum Role { }
   И вызвав:
   var s = Role.values(); System.out.println(s);
   Мы получим в консоли:
   [Lflyweight.Role;@9f70c54
   (пустой массив значений Role)
2. Можно ли создать enum без оператора new — да, конечно. Как я выше уже сказал, для значений (перечислений) enum не нужно использовать оператор new, так как это — статические значения.

--------------------------------------------------------------------------------------------------------------------
Можно ли мы переопределить метод toString() для Enum?

Да, конечно вы можете переопределить метод toString(), чтобы определить конкретный способ отображения вашего enum при вызове метода toString (при переводе enum в обычную строку, например, для вывод в консоль или логи).

--------------------------------------------------------------------------------------------------------------------
Что будет, если мы не будем переопределять метод toString() для Enum?

Предположим, у нас есть следующий enum:
public enum Role { STUDENT, TEACHER, DIRECTOR, SECURITY_GUARD; }
Выведем в консоли студента, вызвав у него toString():
System.out.println(Role.STUDENT.toString());
Результат в консоли:
STUDENT
То есть по умолчанию toString() для enum-а — название самой константы.

--------------------------------------------------------------------------------------------------------------------
Можно ли указывать конструктор внутри Enum?

Да, конечно. Именно через конструктор и задаются значения внутренних переменных enum. В качестве примера к предыдущему enum добавим два поля — ageFrom и ageTo — чтобы обозначить возрастные рамки для каждой роли:

public enum Role {
STUDENT(5,18),
TEACHER(20,60),
DIRECTOR(40,70),
SECURITY_GUARD(18,50);
int ageFrom;
int ageTo;
Role(int ageFrom, int ageTo)
{ this.ageFrom = ageFrom;
this.ageTo = ageTo; }
}

--------------------------------------------------------------------------------------------------------------------
Что делает метод ordinal() в Enum?

При вызове метода int ordinal() на элементе enum-а мы получим порядковый номер с нуля этого значения в общем ряде перечислений. Давайте используем данный метод на одном элементе из предыдущего рассмотренного enum-а — Role:
System.out.println(Role.DIRECTOR.ordinal());
Соответственно, в консоли выведется:
2

--------------------------------------------------------------------------------------------------------------------
Можно ли использовать Enum c TreeSet или TreeMap в Java?

Использование enum типов в TreeSet и TreeMap допустимо. И мы можем написать:
TreeSet<Role> treeSet = new TreeSet<>(); treeSet.add(Role.SECURITY_GUARD); treeSet.add(Role.DIRECTOR); treeSet.add(Role.TEACHER); treeSet.add(Role.STUDENT); treeSet.forEach(System.out::println);
И в консоли будет выведено:
STUDENT TEACHER DIRECTOR SECURITY_GUARD
Мы получили вывод не по алфавиту. Дело в том, что если мы используем элементы enum-а для значений TreeSet или как ключи для TreeMap, элементы сортируются по их естественному порядку (по порядку, в котором они и заданы в enum). Понимание этих особенностей помогает нам писать код качественнее.

--------------------------------------------------------------------------------------------------------------------
Как связаны методы ordinal() и compareTo() в Enum?

Как было сказано ранее, ordinal() возвращает порядковый номер значения в общем списке перечислений. Также в разборе предыдущего вопроса вы увидели, что элементы перечислений, попав, например, в TreeSet (отсортированное множество) принимают порядок, в котором они объявлены в enum. И как мы знаем, TreeSet и TreeMap сортируют элементы посредством вызова у них метода compareTo() интерфейса Comparable. Из этого можно сделать предположение, что класс Enum имплементирует интерфейс Comparable, реализуя его в метод compareTo(), внутри которого и используется ordinal() для задания порядка сортировки.

--------------------------------------------------------------------------------------------------------------------
Можно ли использовать Enum в switch case?

Можно и нужно! Оглядываясь на свою практику, отмечу, что одним из наиболее частых мест применения enum являются логические конструкции типа switch. В таком случае вы можете предусмотреть все возможные вариации case, и после прописания логики для всех значений enum-а использование оператора default может даже не понадобиться! Ведь если вы используете String или числовое значение, например, типа int, вам может прийти не предусмотренное значение, что в свою очередь невозможно с использованием enum-а.

--------------------------------------------------------------------------------------------------------------------
Как получить все имеющиеся значения в экземпляре Enum?

Если нужно получить все экземпляры перечисления, есть метод values(), который возвращает массив всех доступных значений определенного enum-а в естественно порядке (в порядке задания в enum).

--------------------------------------------------------------------------------------------------------------------