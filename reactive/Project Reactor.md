
### 1. Основы реактивного программирования

**1.1. Project Reactor**
Это Java-библиотека для создания асинхронных, неблокирующих приложений. Она реализует спецификацию **Reactive Streams** и является основой для Spring WebFlux.

**1.2. Реактивные потоки (Reactive Streams)**
Это стандарт для асинхронной обработки потоков данных с поддержкой **backpressure**. Основные интерфейсы:
- **Publisher**: Источник данных (`Mono`, `Flux`).
- **Subscriber**: Потребитель данных, который подписывается на `Publisher`.
- **Subscription**: Связь между `Publisher` и `Subscriber`, через которую запрашиваются данные (`request(n)`).
- **Processor**: Компонент, который одновременно является `Publisher` и `Subscriber` (для промежуточной обработки).

**1.3. Асинхронность и неблокирующий код**
Вместо блокировки потоков в ожидании завершения операции (например, запроса к БД), Reactor использует событийно-ориентированный подход. Поток освобождается для других задач, а результат обрабатывается по мере готовности через колбэки или операторы. Это позволяет эффективно использовать ресурсы.

**1.4. Backpressure**
Это механизм, который позволяет `Subscriber` (потребителю) контролировать скорость поступления данных от `Publisher` (производителя), чтобы избежать перегрузки.
- **Как работает**: `Subscriber` запрашивает у `Publisher` определенное количество элементов с помощью `subscription.request(n)`.
- **Стратегии обработки избытка**:
  - **Buffer**: Накапливать данные.
  - **Drop**: Отбрасывать новые данные.
  - **Error**: Выдавать ошибку.
  - **Latest**: Сохранять только последний элемент.

### 2. Основные компоненты Reactor

**2.1. Mono и Flux**
Это два основных типа `Publisher` в Reactor:
- **Mono**: Поток, содержащий **0 или 1 элемент**. Используется для операций, возвращающих один результат (например, HTTP-запрос, поиск записи по ID).
  ```java
  Mono.just("Hello, Reactor!").subscribe(System.out::println);
  ```
- **Flux**: Поток, содержащий **0 или много элементов**. Используется для последовательностей данных (например, список записей из БД, поток событий).
  ```java
  Flux.fromIterable(List.of(1, 2, 3)).subscribe(System.out::println);
  ```
**Выбор**: `Mono` для единичного результата, `Flux` для последовательности.

**2.2. Операторы**
Это методы для трансформации, фильтрации и комбинирования потоков. Они ленивы (выполняются только по подписке) и не изменяют исходный поток, а создают новый.
- **`map`**: Преобразует каждый элемент (1 к 1).
- **`flatMap`**: Преобразует каждый элемент в новый поток (`Mono` или `Flux`) и объединяет результаты. Используется для асинхронных вызовов.
- **`filter`**: Фильтрует элементы по условию.
- **`zip`**: Объединяет элементы из нескольких потоков в кортежи.
- **`merge`**: Объединяет потоки в порядке поступления элементов.
- **`concat`**: Объединяет потоки последовательно (один за другим).
- **`retry`**: Повторяет поток при ошибке.
- **`onErrorResume`**: В случае ошибки переключается на запасной поток.

**2.3. Холодные и горячие потоки**
- **Холодные (Cold)**: Генерируют данные заново для каждого подписчика. Каждый получает свою последовательность с самого начала. Большинство операторов (`just`, `fromIterable`) создают холодные потоки.
- **Горячие (Hot)**: Транслируют данные всем подписчикам в реальном времени. Подписчики получают только те данные, которые появились после подписки. Используются для живых событий (UI, WebSocket). Создаются через операторы `publish()` или `share()`.

### 3. Планировщики (Schedulers)

**3.1. Типы планировщиков (Schedulers)**
Планировщики определяют, в каком потоке выполняется код.
- **`Schedulers.immediate()`**: В текущем потоке.
- **`Schedulers.single()`**: В одном выделенном, общем потоке.
- **`Schedulers.parallel()`**: В пуле потоков, равном числу ядер CPU. **Для CPU-интенсивных задач.**
- **`Schedulers.boundedElastic()`**: В эластичном пуле потоков с ограничением. **Для блокирующих I/O-операций** (сеть, БД).

**3.2. Управление потоками: `publishOn` и `subscribeOn`**
- **`subscribeOn`**: Определяет поток для **источника данных** (upstream). Влияет на всю цепочку, начиная с самого начала. Обычно используется один раз.
- **`publishOn`**: Определяет поток для **последующих операторов** (downstream). Может использоваться несколько раз для переключения контекста.

**3.3. Оптимизация производительности**
- Для **I/O-задач** (запросы к БД, HTTP) используйте `Schedulers.boundedElastic()`.
- Для **CPU-задач** (вычисления) используйте `Schedulers.parallel()`.
- Избегайте блокировки в неблокирующих потоках (например, в `parallel`).
- Минимизируйте количество `publishOn` для снижения накладных расходов.

### 4. Обработка ошибок

**4.1. Механизмы обработки ошибок**
- **`onErrorReturn(value)`**: В случае ошибки возвращает значение по умолчанию и завершает поток.
- **`onErrorResume(fallbackPublisher)`**: В случае ошибки переключается на запасной поток (`Mono` или `Flux`).
- **`onErrorMap(exceptionMapper)`**: Трансформирует один тип исключения в другой.
- **`retry(n)`**: Повторяет подписку `n` раз в случае ошибки.
- **`timeout(duration)`**: Генерирует ошибку, если поток не выдает сигнал в течение заданного времени.

**4.2. Передача ошибок по цепочке**
Ошибка, возникшая в потоке, прерывает его и передается вниз по цепочке в `onError` подписчика, если не будет перехвачена оператором вроде `onErrorResume`.

**4.3. Использование `doOnError`**
Выполняет побочное действие (например, **логирование**) при ошибке, но **не перехватывает** ее. Ошибка продолжает передаваться дальше по цепочке.
```java
.doOnError(e -> log.error("Error occurred: {}", e.getMessage()))
.onErrorReturn("Default Value");
```

### 5. Контекст и управление состоянием

**5.1. Reactor Context**
Это механизм, похожий на `ThreadLocal`, для передачи метаданных (ключ-значение) в реактивном потоке. Полезен для хранения ID запроса, токенов аутентификации и т.д.
- **Как работает**: Контекст привязан к подписке и "виден" **снизу вверх** по цепочке вызовов.
- **Методы**:
  - `contextWrite(Context)`: Записывает данные в контекст в конце цепочки.
  - `Mono.deferContextual(contextView -> ...)`: Позволяет читать данные из контекста внутри операторов.

**5.2. Управление состоянием**
- **Reactor Context**: Лучший способ для передачи метаданных.
- **Данные потока**: Состояние можно передавать как часть данных (например, в `Tuple`).
- **Операторы**: `scan` для накопления состояния или `handle` для более сложной логики.
- **Внешние хранилища**: Атомарные переменные (`AtomicReference`) или кэши (использовать с осторожностью из-за многопоточности).

### 6. Тестирование реактивного кода

**6.1. Библиотека `reactor-test`**
Предоставляет инструменты для тестирования `Mono` и `Flux`, главным из которых является `StepVerifier`.

**6.2. `StepVerifier`**
Декларативный инструмент для проверки последовательности событий в потоке.
- **Создание**: `StepVerifier.create(myFlux)`
- **Основные методы**:
  - `expectNext(values...)`: Ожидает определенные элементы.
  - `expectNextCount(n)`: Ожидает `n` элементов.
  - `expectComplete()`: Ожидает успешного завершения.
  - `expectError(Exception.class)`: Ожидает ошибку определенного типа.
  - `verify()`: Запускает проверку.

**6.3. Тестирование асинхронных сценариев**
- **`withVirtualTime`**: Позволяет тестировать операции с задержками (`delayElements`) без реального ожидания, управляя "виртуальным временем".
- **`thenRequest(n)`**: Позволяет тестировать **backpressure**, запрашивая определенное количество элементов.
- **`verify(Duration)`**: Запускает проверку с таймаутом, чтобы тест не "завис".

### 8. Производительность и оптимизация

**8.1. Оптимизация потоков данных**
- **Минимизируйте операторы**: Объединяйте несколько `map` в один, чтобы снизить накладные расходы.
- **Выбирайте правильный оператор**: Используйте `map` для синхронных операций вместо `flatMap`, где это возможно.
- **Ограничивайте буферы**: В операторах `buffer` или `onBackpressureBuffer` задавайте явный размер, чтобы избежать переполнения памяти.
- **Минимизируйте переключения потоков**: Используйте `publishOn` только при необходимости.
- **Кэшируйте результаты**: Используйте `cache()` для дорогих или повторяющихся операций в холодных потоках.
- **Используйте профилировщики**: Анализируйте поведение приложения с помощью VisualVM или аналогов для поиска узких мест.