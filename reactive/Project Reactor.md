1)Что такое Project Reactor?

Project Reactor — это библиотека Java 8, которая реализует модель реактивного программирования. Он построен на основе спецификации реактивных потоков, стандарта для создания реактивных приложений.
Reactor — это полностью неблокирующая основа реактивного программирования для JVM с эффективным управлением требованиями (в форме управления «противодавлением»). Он напрямую интегрируется с функциональными API-интерфейсами Java 8, в частности, Completable Future , Stream и Duration. Он предлагает составные API-интерфейсы асинхронной последовательности — Flux (для элементов[N]) и Mono (для элементов[1]) — и широко реализует спецификацию Reactive Streams.

--------------------------------------------------------------------------------------------------------------------

2)Что такое реактивные типы и зачем их использовать ?

Реактивные типы не предназначены для обработки запросов или данных быстрее.
Их сила заключается в их способности одновременно обслуживать больше запросов и более эффективно обрабатывать операции с задержкой, такие как запрос данных с удаленного сервера.
Они позволяют обеспечить лучшее качество обслуживания и предсказуемое планирование пропускной способности, изначально имея дело со временем и задержкой, не затрачивая больше ресурсов.
В отличие от традиционной обработки, которая блокирует текущий поток во время ожидания результата, Reactive API запрашивает только тот объем данных, который он способен обработать и предоставляет новые возможности, поскольку он имеет дело с потоком данных, а не с отдельными элементами (объектами).

--------------------------------------------------------------------------------------------------------------------

3)Зачем мне вообще использовать RxJava или Reactor, если то же самое можно сделать с Streams, CompletableFutures и Optionals?

Проблема, по сути, заключается в том, что большую часть времени вы имеете дело с простыми задачами и вам действительно не нужны эти библиотеки. Но когда все усложняется, вы должны писать некрасивый кусок кода. Затем этот кусок кода становится все более сложным и сложным в поддержке.
RxJava и Reactor имеют множество удобных функций, которые будут удовлетворять ваши потребности на долгие годы.

--------------------------------------------------------------------------------------------------------------------

4)Основные классы для работы в реактивном режиме?

- Mono
  Класс Mono нужен для работы с единственным объектом.Mono также может использоваться как какая-то асинхронная задача в стиле "выполнил и забыл", без возвращаемого результата (очень похож на Runnable).
- Flux
  Данный класс схож с Mono, но предоставляет возможность асинхронной работы со множеством объектов.Flux — это Publisher, способный выпустить от 0 до N событий (элементов), в том числе и бесконечное их число.
Flux и Mono реализуют Publisher интерфейс из спецификации Reactive Streams.
Разделение на Flux и Mono помогает улучшить семантику реактивного API, делая его достаточно выразительным.
Flux и Mono — lazy.Для того чтобы запустить какую-то обработку и воспользоваться данными, лежащими в Mono и Flux, нужно на них подписаться с помощью subscribe().Методы subscribe() используют "лямбда-выражения" из Java 8 в качестве параметров.

--------------------------------------------------------------------------------------------------------------------

5)Основные операторы?

КАТЕГОРИЯ ОПЕРАТОРА -> ПРИМЕРЫ
Создание новой последовательности -> just, fromArray, fromIterable, fromStream
Преобразование существующей последовательности -> map, flatMap, startWith, concatWith
Заглядывать в последовательность -> doOnNext, doOnComplete, doOnError, doOnCancel
Фильтрация последовательности -> filter, ignoreElements, distinct, elementAt, takeLast
Обработка ошибок -> onErrorReturn, onErrorResume, retry
Работаем со временем -> elapsed, interval, timestamp, timeout
Расщепление потока -> buffer, groupBy, window
Возвращаясь к синхронному миру -> block, blockFirst, blockLast, toIterable, toStream
Многоадресная рассылка потока нескольким подписчикам -> publish, cache, replay

--------------------------------------------------------------------------------------------------------------------

6)Как работает subscribe()?

1) Вызывается метод subscribe()
2) Затем создается Subscription объект
3) После этого Subscriber вызовет request() метод в Subscription классе, чтобы указать количество объектов, которые он может обработать (если этот метод не вызывается явно, запрашивается неограниченное количество объектов).
4) Subscriber может получать объекты с помощью метода onNext().Если подписчик получает все запрошенные им объекты, он может запросить дополнительные объекты или отменить подписку, вызвав onComplete(). Если в какой-то момент возникает ошибка, издатель вызывает метод onError() на подписчике.
Flux.just(1, 2, 3, 4).subscribe(System.out::println);
Данные не начнут поступать, пока мы не подпишемся — метод subscribe().
Когда мы вызываем подписку, под капотом вызывается Subscription, который запрашивает элементы из потока (это означает, что он запрашивает каждый доступный элемент).
Этот поток описывается в интерфейсе Subscriber как часть спецификации реактивных потоков, и фактически это то, что было реализовано за кулисами в нашем вызове метода onSubscribe().

--------------------------------------------------------------------------------------------------------------------

7)Как выполнять операторы в новом потоке?

Reactor не применяет модель параллелизма. Вместо этого выполнение большинства операторов будет продолжено в том же потоке, оставляя выбор за разработчиком. Модель выполнения определяется тем Scheduler, что используется.
Есть два способа переключения контекста выполнения в реактивной цепочке: publishOn и subscribeOn. Отличается следующее:
publishOn(Scheduler scheduler) влияет на выполнение всех последующих операторов (если не указано иное)
subscribeOn(Scheduler scheduler) изменяет поток, из которого подписывается вся цепочка операторов, на основе самого раннего вызова subscribeOn в цепочке. Это не влияет на поведение последующих вызовов publishOn
Класс Schedulers содержит статические методы, чтобы обеспечить контекст выполнения, например:
parallel() - Фиксированный пул воркеров, настроенный для параллельной работы, создавая столько воркеров, сколько ядер ЦП.
single() - Одиночная многоразовая нить. Этот метод повторно использует один и тот же поток для всех вызывающих, пока Планировщик не будет удален. Если вместо этого вам нужен выделенный поток для каждого вызова, вы можете использовать Schedulers.newSingle () для каждого вызова.
boundedElastic() - Динамически создает ограниченное количество рабочих. Он имеет ограничение на количество поддерживающих потоков, которые он может создать, и может ставить задачи в очередь для перепланирования, когда поток становится доступным. Это хороший выбор для обертывания синхронных, блокирующих вызовов.
immediate() - немедленно запускается в исполняемом потоке, не переключая контекст выполнения
fromExecutorService(ExecutorService) - может использоваться для создания Планировщика из любого существующего ExecutorService

--------------------------------------------------------------------------------------------------------------------

8)Чем отличается map от flatMap?

map — преобразует элементы, испускаемые этим потоком, применяя синхронную функцию к каждому элементу.
Flux.just(1, 2, 3).map(s -> s + 1)
.subscribe(System.out::println);
Output:234
Такие операции, как map или flatMap, не работают с результатом Mono, они создают новый Mono, который добавляет другое преобразование к выполнению исходного Mono.
flatMap — асинхронно преобразует элементы, испускаемые этим потоком, в Publisher-ы, а затем объединяет эти внутренние Publisher-ы в единый поток посредством слияния
flatMap не гарантирует порядок элементов!

--------------------------------------------------------------------------------------------------------------------

9)Разница между flatMap(), concatMap() и switchMap()?

flatMap: не сохраняет порядок элементов, работает асинхронно
switchMap — он похож на flatMap, за исключением того, что он сохраняет результат только последней подписки, отбрасывая предыдущие.
Пример: обработка новых данных (например, список сообщений в ленте). Предположим, что где-то в приложении есть Observable, который периодически генерирует список объектов. Это может быть список сообщений на временной шкале, который обновляется каждый раз, когда пользователь взаимодействует с ним. В этом случае лучшим оператором для использования будет switchMap, потому что нас не волнует предыдущий результат, если у нас есть новый набор элементов. От него можно отказаться и подписаться на новейшие данные. Это может сэкономить нам время, если пропустить обработку предыдущего (старого) ответа.
concatMap — работает почти так же, как flatMap, но сохраняет порядок элементов.
Например: сделать что-то для каждого элемента в отсортированном списке: FlatMap или switchMap не должны использоваться в этом случае. Из-за синхронных вызовов в concatMap необходимо учитывать увеличение времени обработки (что не всегда благоприятно).

--------------------------------------------------------------------------------------------------------------------

10)Холодные и горячие Publisher

Доступны два типа Publisher - cold и hot (холодные и горячие). Пока что мы сосредоточились на холодных Publisher. Как мы заявляли ранее, ничего не происходит, пока мы не подпишемся - но на самом деле это верно только для холодных издателей.
Холодный Publisher генерирует новые данные для каждой подписки. Если подписки нет, данные никогда не генерируются. Напротив, hot издатель не зависит от подписчиков. Он может начать публикацию данных без подписчиков. Если подписчик подписывается после того, как издатель начал передавать значения, он получит только значения, выпущенные после его подписки.
Publisher в Reactor по умолчанию не работают. Один из способов создания горячего Publisher - это вызвать publish() метод в Flux. Это вернет ConnectableFlux<T>, у которого есть метод connect() для запуска передачи значений. Подписчики должны затем подписаться на этот ConnectableFlux вместо исходного Flux.

--------------------------------------------------------------------------------------------------------------------

11)Что такое Reactor IPC ?

Reactor IPC — это расширение Reactor, которое позволяет интегрироваться с различными платформами и системами, поддерживающими неблокирующий ввод / вывод (например, Netty, Kafka).
Когда запрос поступает в Netty, он немедленно обрабатывается с использованием класса ChannelOperations . Далее вызывается цепочка вызовов и, наконец, запрос достигает DispatcherHandler (он направляет входящие запросы другим контроллерам).
Затем запрос достигает контроллера.
Дело в том, что по умолчанию все Mono и Flux холодные (ниже мы рассмотрим более подробно, что это означает).
Затем на основе Publisher начал выстраиваться поток, достигший класса ChannelOperations, и только здесь, в ChannelOperations, был вызван метод subscribe(), и только в этот момент этот поток начал работать (начали происходить HTTP-вызовы).

--------------------------------------------------------------------------------------------------------------------