### 1. Основы Netty

#### 1.1. Что такое Netty?
**Netty** — это высокопроизводительный, асинхронный, событийно-ориентированный фреймворк на Java для разработки сетевых приложений. Он абстрагирует и упрощает низкоуровневую работу с сокетами и протоколами, позволяя разработчикам сосредоточиться на бизнес-логике.

**Проблема, которую решает Netty**: Традиционная модель "один поток на одно соединение" плохо масштабируется. Netty использует **неблокирующий ввод-вывод (NIO)**, позволяя одному потоку эффективно управлять тысячами одновременных соединений.

#### 1.2. Ключевые особенности
- **Асинхронность и событийно-ориентированность**: Операции (например, подключение, запись данных) не блокируют вызывающий поток. Вместо этого они возвращают объект `ChannelFuture`, который уведомляет о завершении операции.
- **Унифицированный API**: Предоставляет единый API для различных транспортных протоколов (TCP и UDP).
- **Гибкая модель потоков**: Мощный `EventLoop` позволяет полностью контролировать потоки и легко интегрироваться с другими фреймворками.
- **Модульная архитектура**: Логика обработки данных строится из цепочки повторно используемых обработчиков (`ChannelPipeline`).
- **Эффективное управление памятью**: Использует собственный буфер `ByteBuf`, который минимизирует копирование данных и снижает нагрузку на сборщик мусора.
- **Готовая поддержка протоколов**: Включает кодеки для HTTP, HTTP/2, WebSocket, SSL/TLS, Protobuf и многих других.

---

### 2. Архитектура Netty

#### 2.1. EventLoop и EventLoopGroup
- **Что это?**
  - `EventLoop` — это, по сути, **один поток**, который работает в бесконечном цикле. Он проверяет наличие новых событий (входящие данные, новые соединения, таймеры) и передает их на обработку соответствующим `ChannelHandler`-ам.
  - `EventLoopGroup` — это группа (пул) из нескольких `EventLoop`.
- **Как это работает?**
  В типичном серверном приложении используются две группы:
  1.  **Boss Group**: Принимает входящие соединения. Обычно для этой задачи достаточно одного потока (`new NioEventLoopGroup(1)`). Как только соединение принято, `boss` передает его `worker`-у.
  2.  **Worker Group**: Обрабатывает все I/O операции (чтение, запись) для принятых соединений. Каждое новое соединение (`Channel`) регистрируется в одном из `EventLoop` из `worker` группы и остается привязанным к этому потоку на все время своей жизни.
- **Почему это важно?**
  - **Производительность**: Поскольку все события для одного канала обрабатываются в одном и том же потоке, это полностью устраняет необходимость в синхронизации ( `synchronized`, `locks`) в бизнес-логике, что значительно повышает производительность.
  - **Опасность**: **Никогда не выполняйте долгие, блокирующие операции** (например, запросы к БД, сложные вычисления, `Thread.sleep()`) в потоке `EventLoop`. Это "заморозит" не только текущий канал, но и все остальные каналы, обслуживаемые этим же потоком.

```java
// Boss group принимает новые соединения
EventLoopGroup bossGroup = new NioEventLoopGroup(1);
// Worker group обрабатывает данные для каждого соединения
EventLoopGroup workerGroup = new NioEventLoopGroup(); // По умолчанию = CPU cores * 2
try {
    ServerBootstrap b = new ServerBootstrap();
    b.group(bossGroup, workerGroup)
     /* ... остальная настройка ... */
} finally {
    bossGroup.shutdownGracefully();
    workerGroup.shutdownGracefully();
}
```

#### 2.2. Channel
- **Что это?** `Channel` — это абстракция над сетевым соединением (сокетом), через которое происходят операции ввода-вывода.
- **Как это работает?** Netty предоставляет разные реализации `Channel` для разных протоколов и транспортов:
  - `NioServerSocketChannel`: Для TCP-сервера, принимает соединения.
  - `NioSocketChannel`: Для TCP-клиента или для соединения, принятого сервером.
  - `NioDatagramChannel`: Для UDP.
- **Жизненный цикл**: У канала есть четкий жизненный цикл, который генерирует события, перехватываемые в `ChannelHandler`:
  - `channelRegistered`: Канал зарегистрирован в `EventLoop`.
  - `channelActive`: Канал активен и готов к обмену данными (соединение установлено).
  - `channelRead`: Из канала прочитаны данные.
  - `channelInactive`: Канал больше не активен (соединение разорвано).
- **Почему это важно?** Понимание жизненного цикла позволяет выполнять действия в нужный момент (например, отправить приветственное сообщение при `channelActive` или очистить ресурсы при `channelInactive`).

#### 2.3. ChannelPipeline
- **Что это?** `ChannelPipeline` — это цепочка обработчиков (`ChannelHandler`), которая обрабатывает или перехватывает все события ввода-вывода для конкретного `Channel`. Это ключевой компонент для построения модульной логики.
- **Как это работает?**
  - **`ChannelInboundHandler`**: Обрабатывает входящие события (снизу вверх по потоку данных): `channelActive`, `channelRead`, `exceptionCaught`.
  - **`ChannelOutboundHandler`**: Обрабатывает исходящие операции (сверху вниз): `write`, `flush`, `connect`.
  - Данные проходят по конвейеру, и каждый обработчик может их модифицировать, передать дальше, проигнорировать или прервать обработку.
- **Почему это важно?** Позволяет реализовать принцип разделения ответственности. Например, типичный pipeline для HTTP-сервера может выглядеть так:
  1.  `ByteToMessageDecoder` (декодер байтов в HTTP-запросы).
  2.  `HttpObjectAggregator` (собирает фрагменты HTTP-сообщения в одно целое).
  3.  `HttpServerCodec` (кодек для HTTP).
  4.  Ваш кастомный обработчик с бизнес-логикой.

```java
// Пример инициализации Pipeline
.childHandler(new ChannelInitializer<SocketChannel>() {
    @Override
    public void initChannel(SocketChannel ch) {
        ChannelPipeline p = ch.pipeline();
        p.addLast(new HttpRequestDecoder());
        p.addLast(new HttpResponseEncoder());
        p.addLast(new MyBusinessLogicHandler());
    }
});
```

#### 2.4. ByteBuf
- **Что это?** `ByteBuf` — это собственный буфер Netty для работы с байтами, превосходящий стандартный `java.nio.ByteBuffer`.
- **Как это работает?**
  - **Два индекса**: Имеет отдельные индексы для чтения (`readerIndex`) и записи (`writerIndex`), что избавляет от необходимости вызывать `flip()`.
  - **Динамический размер**: Автоматически расширяется при необходимости.
  - **Пул памяти (Pooling)**: Netty может переиспользовать буферы, чтобы снизить нагрузку на GC.
  - **Heap vs. Direct**: `ByteBuf` может быть размещен в куче JVM (heap) или в нативной памяти (direct). Direct-буферы предпочтительнее для сетевых операций, так как избегают копирования данных из кучи в нативную память перед отправкой.
- **Почему это важно? (Критически!)**
  - `ByteBuf` использует **подсчет ссылок** для управления памятью. Когда буфер больше не нужен, вы **обязаны** вызвать `buf.release()` для его освобождения.
  - **Утечка памяти** — самая частая ошибка в Netty-приложениях, и она почти всегда связана с тем, что `release()` не был вызван.

```java
// Безопасная работа с ByteBuf
ByteBuf buf = ctx.alloc().buffer();
try {
    // ... запись данных в буфер ...
    ctx.writeAndFlush(buf);
} finally {
    // Неправильно! writeAndFlush сам освободит буфер после записи.
    // Освобождать нужно только если вы не передаете буфер дальше по pipeline.
    // Если бы мы просто прочитали данные и обработали их, то освобождение было бы нужно.
}
```

#### 2.5. Bootstrap и ServerBootstrap
- **Что это?** Это вспомогательные классы с fluent API для легкой конфигурации и запуска клиента (`Bootstrap`) или сервера (`ServerBootstrap`).
- **Как это работает?** Они связывают воедино все компоненты:
  - `.group(bossGroup, workerGroup)`: Устанавливает группы потоков.
  - `.channel(NioServerSocketChannel.class)`: Задает тип канала.
  - `.childHandler(...)`: Задает `ChannelInitializer` для настройки `Pipeline` каждого нового соединения.
  - `.option(...)` и `.childOption(...)`: Настраивает опции сокета (например, `SO_KEEPALIVE`, `TCP_NODELAY`).
- **Почему это важно?** Упрощает boilerplate-код, делая настройку сетевого приложения декларативной и читаемой.

---

### 3. Асинхронное и реактивное программирование

#### 3.1. ChannelFuture
- **Что это?** `ChannelFuture` — это "заполнитель" (placeholder) для результата асинхронной операции.
- **Как это работает?** Любая I/O операция в Netty (например, `connect()`, `writeAndFlush()`, `close()`) возвращает `ChannelFuture` немедленно. Вместо того чтобы блокировать поток в ожидании завершения (`.sync()`), вы добавляете слушателя (`.addListener()`), который будет вызван, когда операция завершится.

```java
ChannelFuture future = channel.writeAndFlush("some data");
future.addListener(f -> {
    if (f.isSuccess()) {
        System.out.println("Данные успешно отправлены.");
    } else {
        System.err.println("Ошибка отправки: " + f.cause());
    }
});
```
- **Почему это важно?** Использование `addListener()` вместо `.sync()` является ключом к сохранению неблокирующей природы приложения и достижению высокой производительности.

#### 3.2. Backpressure
- **Что это?** Механизм, позволяющий потребителю данных (ваше приложение) сигнализировать производителю (удаленной стороне), чтобы тот замедлил отправку, если потребитель не успевает обрабатывать входящий поток.
- **Как это работает?**
  - **Исходящий поток (Write)**: Перед записью в канал проверяйте `channel.isWritable()`. Если `false`, значит, буфер переполнен. Можно дождаться, пока он освободится.
  - **Входящий поток (Read)**: Если ваше приложение не успевает обрабатывать данные, можно временно остановить их чтение из сокета: `ctx.channel().config().setAutoRead(false);`. После обработки накопленных данных чтение возобновляется: `...setAutoRead(true);`.
- **Почему это важно?** Без backpressure быстро отправляющий клиент может легко вызвать `OutOfMemoryError` на сервере, забив его память неотправленными или необработанными данными.

#### 3.3. Обработка ошибок
- **Как это работает?**
  1.  **Исключения в Pipeline**: Если в `ChannelInboundHandler` возникает исключение, оно передается дальше по цепочке до тех пор, пока не встретит обработчик, переопределяющий метод `exceptionCaught()`.
  2.  **Ошибки в Future**: Если асинхронная операция завершилась неудачно, `ChannelFuture` будет содержать информацию об ошибке, доступную через `future.cause()`.
- **Почему это важно?** Централизованная обработка ошибок (обычно в последнем обработчике pipeline) позволяет корректно логировать проблемы и закрывать сбойные соединения, предотвращая утечки ресурсов.

```java
// Рекомендуется добавлять последним в pipeline
public class FinalErrorHandler extends ChannelInboundHandlerAdapter {
    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
        // Логируем ошибку
        cause.printStackTrace();
        // Закрываем соединение
        ctx.close();
    }
}
```

---

### 4. Протоколы и кодеки

#### 4.1. Кодеки (Codec)
- **Что это?** Кодеки — это специальные `ChannelHandler`-ы, которые занимаются преобразованием данных между их байтовым представлением (для передачи по сети) и удобными Java-объектами (POJO).
- **Как это работает?**
  - **`Encoder`** (`MessageToByteEncoder`): Кодирует Java-объект в `ByteBuf`.
  - **`Decoder`** (`ByteToMessageDecoder`): Декодирует `ByteBuf` в один или несколько Java-объектов.
- **Почему это важно?** Кодеки позволяют полностью отделить логику протокола от бизнес-логики. Ваши основные обработчики работают с готовыми объектами (`MyMessage`), а не с сырыми байтами.

#### 4.2. Встроенные и кастомные кодеки
- **Кастомные**: Вы можете легко создать свой протокол. Например, простой протокол "длина + данные": энкодер сначала записывает `int` с длиной сообщения, а затем само сообщение в байтах; декодер сначала читает `int`, а затем ждет, пока придет нужное количество байт для сборки полного сообщения.
- **Встроенные**: Netty предлагает богатую библиотеку готовых кодеков:
  - **`HttpServerCodec`, `HttpClientCodec`**: Для HTTP/1.1.
  - **`WebSocketServerProtocolHandler`**: Для полной обработки WebSocket хендшейка и фреймов.
  - **`SslHandler`**: Для шифрования (SSL/TLS).
  - **`LengthFieldBasedFrameDecoder`**: Мощный декодер для протоколов, где длина сообщения указана в заголовке.
  - **`DelimiterBasedFrameDecoder`**: Декодер, который разделяет сообщения по специальному символу-разделителю (например, `\n`).
  