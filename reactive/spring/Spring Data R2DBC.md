### 1. Спецификация R2DBC (Reactive Relational Database Connectivity)

Представьте, что вы строите дом. Вам нужны чертежи, которые описывают, где должны быть стены, окна, двери. Сами чертежи не являются ни
стенами, ни окнами. R2DBC — это и есть такой **чертеж (спецификация)** для реактивного взаимодействия с реляционными базами данных.

#### Что это такое? Простая аналогия с JDBC

*   **Мир JDBC (Блокирующий):**
    *   У вас есть стандартный API — `java.sql.Connection`, `java.sql.Statement`, `java.sql.ResultSet`. Это интерфейсы, тот самый "чертеж".
    *   Когда вы вызываете `statement.executeQuery()`, ваш поток **блокируется** и ждет, пока база данных не вернет все результаты. Он не
        может делать ничего другого в это время.

*   **Мир R2DBC (Реактивный/Неблокирующий):**
    *   Здесь тоже есть стандартный API — `io.r2dbc.spi.Connection`, `io.r2dbc.spi.Statement`, `io.r2dbc.spi.Result`. Это тоже интерфейсы, "
        реактивный чертеж".
    *   Ключевое отличие: когда вы вызываете метод для выполнения запроса, он **немедленно возвращает** вам "обещание" результата в
        виде `Publisher<T>` (`Mono` или `Flux` в мире Project Reactor).
    *   Ваш поток не ждет. Он говорит: "Окей, база, когда у тебя будут данные, отправь их вот по этому каналу (`Publisher`)". И тут же
        освобождается, чтобы обрабатывать другие запросы.

**Углубление:** Спецификация R2DBC была создана с нуля, а не как обертка над JDBC. Это было сделано потому, что сам JDBC по своей природе
блокирующий, и попытка сделать его "реактивным" привела бы к запуску блокирующих операций в отдельном пуле потоков, что не решает проблему
эффективного использования ресурсов, а лишь маскирует ее. R2DBC нацелен на использование неблокирующих сетевых протоколов, которые
предоставляют сами драйверы баз данных.

#### Драйверы: Конкретные строители для вашего чертежа

Продолжая аналогию со строительством: у вас есть чертеж (R2DBC API), но вам нужны конкретные исполнители, которые умеют работать с разными
материалами (разными СУБД).

*   **Драйвер JDBC:** Библиотека `mysql-connector-java.jar` — это "строитель", который реализует интерфейсы JDBC и умеет общаться с MySQL по
    ее протоколу.
*   **Драйвер R2DBC:** Библиотека `r2dbc-postgresql` — это "реактивный строитель", который реализует интерфейсы R2DBC SPI и умеет общаться с
    PostgreSQL по ее протоколу **неблокирующим** способом.

Для каждой базы данных (PostgreSQL, MS SQL, MySQL, H2, MariaDB и т.д.) нужен свой собственный R2DBC-драйвер. Если для вашей СУБД нет
R2DBC-драйвера, вы не сможете использовать ее с Spring Data R2DBC "из коробки".

---

### 2. Ключевые Абстракции Spring Data R2DBC

Spring не заставляет вас работать напрямую с "чертежами" R2DBC. Вместо этого он предоставляет удобные инструменты разного уровня, как набор
профессиональных электроинструментов для строителя. Вы выбираете инструмент в зависимости от сложности задачи.

Давайте рассмотрим их по порядку, от самого низкого уровня к самому высокому.

#### `ConnectionFactory` (Фабрика подключений)

*   **Аналог:** `DataSource` в мире JDBC.
*   **Что это?** Это основной бин, который Spring Boot конфигурирует за вас. Его единственная задача — предоставлять реактивные подключения к
    базе данных (`Mono<Connection>`).
*   **Углубление:** На самом деле, `ConnectionFactory` обычно обернута в пул соединений (`r2dbc-pool`). Это означает, что когда вы
    запрашиваете новое подключение, вы, скорее всего, получаете уже существующее, готовое к использованию соединение из пула, что значительно
    ускоряет работу. Настройки пула (минимальное/максимальное количество соединений, таймауты) можно задавать в `application.properties`.

#### `DatabaseClient` (Низкоуровневый клиент)

*   **Аналог:** `JdbcTemplate` в мире Spring JDBC.
*   **Что это?** Ваш швейцарский нож для работы с базой. Он дает полный контроль над SQL-запросом, но избавляет от рутинной работы с
    открытием/закрытием соединений и обработкой низкоуровневых исключений. Идеален для сложных, кастомных или динамически генерируемых
    запросов.
*   **Как использовать (Fluent API):**

```java
// Пример: найти всех пользователей старше определенного возраста
Flux<User> findUsersOlderThan(int age) {
  return databaseClient.sql("SELECT id, name, age FROM users WHERE age > :user_age") // 1. SQL с именованным параметром
      .bind("user_age", age) // 2. Безопасно подставляем значение параметра
      .map((row, rowMetadata) -> new User( // 3. Маппим каждую строку результата
          row.get("id", Long.class),
          row.get("name", String.class),
          row.get("age", Integer.class)
      ))
      .all(); // 4. Говорим, что ожидаем много записей (Flux)
  // .one() для одной записи (Mono)
  // .fetch().rowsUpdated() для количества измененных строк (Mono<Integer>)
}
```

#### `R2dbcEntityTemplate` (Шаблон для сущностей)

*   **Аналог:** Нечто среднее между `JdbcTemplate` и возможностями `EntityManager` из JPA.
*   **Что это?** Уровень повыше. Он уже знает о ваших Java-классах-сущностях (тех, что с аннотациями `@Table`, `@Id`). Он позволяет выполнять
    операции (`insert`, `update`, `select`, `delete`), оперируя объектами, а не только сырыми строками `Row`.
*   **Как использовать:**

```java
// Пример: вставить пользователя и получить его обратно
Mono<User> insertUser(User user) {
  return entityTemplate.insert(user);
}

// Пример: найти пользователя по ID
Mono<User> findById(long id) {
  return entityTemplate.selectOne(query(where("id").is(id)), User.class);
}
```

*   **Углубление:** Этот инструмент полезен, когда вам нужно программно строить запросы (например, добавлять условия `WHERE` в зависимости от
    входных параметров), но вы хотите, чтобы Spring сам занимался маппингом результата на ваши объекты-сущности.

#### Репозитории (`R2dbcRepository`, `ReactiveCrudRepository`)

*   **Аналог:** Spring Data JPA репозитории.
*   **Что это?** Самый высокий и самый удобный уровень абстракции. Вы просто объявляете интерфейс, а Spring волшебным образом создает его
    реализацию во время запуска приложения. Идеально для 90% стандартных CRUD-операций.

```java
public interface UserRepository extends ReactiveCrudRepository<User, Long> {

  // Просто объявляем метод, Spring сам генерирует SQL!
  // SQL: SELECT * FROM users WHERE name = ?
  Flux<User> findByName(String name);

  // Можно писать и свои, более сложные запросы
  @Query("SELECT * FROM users WHERE age >= :minAge AND age <= :maxAge")
  Flux<User> findUsersInAgeRange(int minAge, int maxAge);
}
```

*   **Производные методы (Derived Methods):** "Магия" Spring Data. Он парсит название вашего метода (`findBy...`, `countBy...`, `deleteBy...`)
    и генерирует соответствующий SQL. `findByNameAndAgeOrderByNameDesc` — все это будет разобрано и превращено в корректный запрос.
*   **Аннотация `@Query`:** Когда магии имен недостаточно (например, нужен `JOIN` или сложная логика), вы просто пишете SQL-запрос вручную в
    аннотации `@Query`.

---

### 3. Маппинг Сущностей (Entities)

Это клей, который связывает ваш объектно-ориентированный мир (Java классы) с реляционным миром (таблицы в БД). Spring Data R2DBC использует
простой набор аннотаций для этой цели.

*   `@Table("table_name")`: Указывает, с какой таблицей в базе данных связан этот класс. Если имя класса `User`, а таблицы — `app_users`, вы
    напишете `@Table("app_users")`. Если опустить, Spring будет использовать имя класса, преобразованное в snake_case (
    например, `UserAccount` -> `user_account`).
*   `@Id`: Обязательная аннотация. Помечает поле, которое является первичным ключом (`PRIMARY KEY`) в таблице. Это критически важно для таких
    операций, как `findById()` или `save()` (чтобы `save` мог понять, делать ему `INSERT` для нового объекта или `UPDATE` для существующего).
*   `@Column("column_name")`: Связывает поле класса с колонкой в таблице. Необходимо, если имя поля в Java (например, `firstName`) не
    совпадает с именем колонки в БД (например, `first_name`).
*   `@Transient`: "Не сохранять в базу". Помечает поле, которое Spring Data должен полностью игнорировать. Оно не будет ни читаться из базы,
    ни записываться в нее. Полезно для вычисляемых полей, временного состояния и т.д.

#### Пример сущности со всеми аннотациями:

```java
import org.springframework.data.annotation.Id;
import org.springframework.data.annotation.Transient;
import org.springframework.data.relational.core.mapping.Column;
import org.springframework.data.relational.core.mapping.Table;

@Table("employees") // Этот класс соответствует таблице 'employees'
public class Employee {

  @Id // Это поле - первичный ключ
  private Long id;

  @Column("first_name") // Это поле соответствует колонке 'first_name'
  private String firstName;

  @Column("last_name") // Это поле соответствует колонке 'last_name'
  private String lastName;

  private int age; // Имя поля совпадает с именем колонки 'age', @Column не нужен

  @Transient // Это поле не будет сохранено в БД
  private String fullName;

  // Конструкторы, геттеры, сеттеры...

  public String getFullName() {
    // Пример вычисляемого поля
    return firstName + " " + lastName;
  }
}
```

### 4. Реактивные Транзакции

В блокирующем мире (JDBC) транзакция привязана к потоку (`ThreadLocal`). В реактивном мире один и тот же запрос может обрабатываться разными
потоками, поэтому нужен другой механизм.

#### `@Transactional`

*   **Простое объяснение:** Представьте, что вы отправляете посылку со сложным маршрутом (это ваш реактивный пайплайн `Mono`/`Flux`).
    Аннотация `@Transactional` — это как специальная наклейка "ХРУПКОЕ: ОБРАБОТАТЬ КАК ЕДИНОЕ ЦЕЛОЕ" на этой посылке.
    *   Если посылка успешно доходит до конца маршрута (сигнал `onComplete`), ее содержимое принимается (транзакция **коммитится**).
    *   Если на любом этапе маршрута посылка повреждается (сигнал `onError`), вся отправка отменяется, и она возвращается на склад (транзакция
        **откатывается**).

*   **Углубленное объяснение:** Когда вы помечаете метод `@Transactional`, Spring AOP создает прокси вокруг вашего метода.
    1.  **Начало:** Перед вызовом вашего кода прокси запрашивает соединение у `ConnectionFactory` и выполняет команду `BEGIN TRANSACTION`.
    2.  **Распространение:** Это соединение **не кладется в `ThreadLocal`**. Вместо этого оно помещается в **`Subscriber Context`** (контекст
        подписчика). Это как невидимый рюкзак, который путешествует вместе с вашим `Mono` или `Flux` по всей цепочке вызовов.
    3.  **Использование:** Любая последующая операция с базой данных (например, вызов `repository.save()`) внутри этой цепочки сначала
        проверяет `Subscriber Context`. Если она находит там транзакционное соединение, она использует его, а не запрашивает новое. Это
        гарантирует, что все операции выполняются в рамках одной и той же транзакции.
    4.  **Завершение:** Прокси "подписывается" на `Mono`/`Flux`, который возвращает ваш метод. Он добавляет операторы `doOnComplete()` (чтобы
        выполнить `COMMIT`) и `doOnError()` (чтобы выполнить `ROLLBACK`). Судьба транзакции полностью зависит от итогового сигнала вашего
        реактивного потока.

#### `TransactionalOperator`

*   **Простое объяснение:** Если `@Transactional` — это автоматическая "наклейка" на весь метод, то `TransactionalOperator` — это ручной набор
    для упаковки. Он позволяет вам самим определить, какой именно участок кода должен быть обернут в транзакционную "коробку".
*   **Углубленное объяснение:** Это программный, функциональный способ управления транзакциями. Он полезен, когда аннотации неудобны или
    невозможны (например, в лямбдах или при композиции сложных потоков).

```java

@Service
public class MyService {

  private final UserRepository userRepository;
  private final AuditRepository auditRepository;
  private final TransactionalOperator transactionalOperator; // Инжектится Spring

  // ... конструктор

  public Mono<User> createUserWithAudit(User user) {
    // Мы явно определяем границы транзакции
    return transactionalOperator.execute(status -> { // status - это TransactionStatus
      // Весь код внутри этой лямбды будет в одной транзакции
      return userRepository.save(user)
          .flatMap(savedUser -> auditRepository.log("CREATED", savedUser.getId()))
          .thenReturn(savedUser); // Возвращаем сохраненного пользователя
    }).single(); // execute возвращает Flux, мы берем один элемент
  }
}
```

Здесь мы явно говорим: "Выполни этот блок кода (`userRepository.save().flatMap(...)`) в транзакции".

#### Контекст Подписчика (Subscriber Context)

Это фундаментальная концепция, заменяющая `ThreadLocal`. Это неизменяемый `Map`, который живет внутри подписки на реактивный поток. Он
позволяет передавать состояние (например, транзакционное соединение или данные трассировки) "вниз" по цепочке операторов.

---

### 5. Управление Пулом Соединений

*   **Простое объяснение:** Создавать новое подключение к базе данных каждый раз — это дорого и медленно, как каждый раз собирать и разбирать
    удочку, чтобы поймать одну рыбу. Пул соединений — это стойка с уже готовыми, настроенными удочками. Вы просто берете одну, используете и
    возвращаете на место.
*   **Углубленное объяснение:**
    *   **Библиотека:** Для R2DBC существует отдельная библиотека `r2dbc-pool`. Spring Boot автоматически подключит и настроит ее, если она
        есть в зависимостях.
    *   **Принцип работы:** Пул оборачивает вашу настоящую `ConnectionFactory`. Когда вы запрашиваете соединение, пул:
        1.  Проверяет, есть ли свободное, валидное соединение в пуле.
        2.  Если есть, он отдает его вам.
        3.  Если нет, и лимит пула (`maxSize`) не достигнут, он создает новое соединение.
        4.  Если лимит достигнут, запрос будет ждать освобождения соединения в течение таймаута (`maxAcquireTime`).
    *   **Настройка:** Это критически важно для производительности. В `application.properties`:
      ```properties
      # Включить пул
      spring.r2dbc.pool.enabled=true
      # Начальное количество соединений
      spring.r2dbc.pool.initial-size=5
      # Максимальное количество соединений
      spring.r2dbc.pool.max-size=20
      # Максимальное время ожидания свободного соединения
      spring.r2dbc.pool.max-acquire-time=2s
      # Как долго соединение может простаивать, прежде чем будет закрыто
      spring.r2dbc.pool.max-idle-time=30m
      ```

---

### 6. Backpressure (Противодавление)

*   **Простое объяснение:** Представьте конвейерную ленту на заводе. `Backpressure` — это когда рабочий в конце ленты (`Subscriber`) сам
    контролирует скорость ленты. Если он занят, он замедляет ленту или останавливает ее. Он кричит машине в начале ленты (`Publisher` / База
    данных): "Пришли мне 5 деталей!". Обработав их, он кричит: "Окей, готов, давай еще 5!". База данных не может "завалить" приложение
    данными, потому что приложение само запрашивает их порциями, которые готово обработать.
*   **Углубленное объяснение:** Это ключевая часть спецификации Reactive Streams.
    1.  Когда `Subscriber` подписывается на `Publisher`, он получает объект `Subscription`.
    2.  Поток данных **не начнется**, пока `Subscriber` не вызовет `subscription.request(n)`, где `n` — количество элементов, которое он
        готов принять.
    3.  `Publisher` (драйвер R2DBC) отправит не более `n` элементов через `onNext()`, а затем остановится, ожидая следующего
        вызова `request(n)`.
        Это фундаментально решает проблему `OutOfMemoryError` при чтении больших объемов данных из базы. Ваше приложение потребляет данные в
        том темпе, в котором может их обработать, а не в том, в котором их отдает база.

---

### 7. Интеграция со Spring WebFlux

*   **Простое объяснение:** Это создание полностью "реактивного шоссе" от начала до конца. Запрос от пользователя въезжает на это шоссе (
    WebFlux), мчится без остановок через сервисный слой до базы данных (R2DBC), забирает данные и так же без остановок возвращается к
    пользователю. Ни на одном участке пути поток не стоит в "пробке", ожидая ответа.
*   **Углубленное объяснение:** Полный неблокирующий стек выглядит так:

```java
// 1. Controller (WebFlux) - точка входа. Неблокирующий.
@RestController
public class UserController {

  private final UserService userService;

  // ...
  @GetMapping("/users")
  public Flux<User> getAllUsers() {
    // Просто возвращает "обещание" потока пользователей.
    // Поток выполнения не блокируется здесь.
    return userService.findAll();
  }
}

// 2. Service - бизнес-логика. Неблокирующий.
@Service
public class UserService {

  private final UserRepository userRepository;

  // ...
  public Flux<User> findAll() {
    // Делегирует вызов репозиторию. Никаких блокировок.
    return userRepository.findAll();
  }
}

// 3. Repository (R2DBC) - слой данных. Неблокирующий.
public interface UserRepository extends ReactiveCrudRepository<User, Long> {
  // Spring Data R2DBC реализует этот метод неблокирующим образом.
}
```

Когда поступает HTTP-запрос, один из рабочих потоков Netty (сервер, используемый WebFlux) начинает обрабатывать его. Он проходит по цепочке
до `userRepository.findAll()`. В этот момент **поток не ждет ответа от базы**. Он освобождается и может пойти обрабатывать другой
HTTP-запрос. Когда данные от базы начнут поступать, один из свободных потоков "подхватит" их и продолжит обработку (отправку пользователю).
Это позволяет очень малому числу потоков обслуживать огромное количество одновременных запросов.

---

### 8. Тестирование

Тестирование реактивного кода требует специальных инструментов.

*   **`@DataR2dbcTest`**:
    *   **Простое объяснение:** Это как специальная лаборатория для тестирования вашего кода работы с базой. Она автоматически настраивает все
        необходимое (подключение к тестовой БД, репозитории) и, что самое главное, после каждого теста "убирает за собой", откатывая все
        изменения в базе.
    *   **Углубленное объяснение:** Эта аннотация автоматически:
        *   Настраивает `DatabaseClient`, `R2dbcEntityTemplate` и другие бины для R2DBC.
        *   Сканирует и подключает ваши `@Repository` интерфейсы.
        *   Оборачивает каждый тестовый метод в транзакцию и выполняет `ROLLBACK` после его завершения, обеспечивая изоляцию тестов.
        *   Часто используется вместе с `@AutoConfigureTestDatabase` для контроля над тем, используется ли встроенная (H2) или реальная (
            Testcontainers) база данных.

*   **`TestDatabaseClient`**: Просто версия `DatabaseClient`, автоматически настроенная для использования в тестах с `@DataR2dbcTest`.

*   **`StepVerifier`**:
    *   **Простое объяснение:** Если `Mono` и `Flux` — это "посылки", которые придут в будущем, то `StepVerifier` — это эксперт на таможне. Вы
        даете ему "посылку" (`Flux`) и говорите: "Проверь, что внутри сначала лежит яблоко, потом апельсин, а потом посылка заканчивается.
        Если что-то не так — подними тревогу".
    *   **Углубленное объяснение:** Это главный инструмент из библиотеки `reactor-test`. Он подписывается на ваш `Publisher` и позволяет
        декларативно описывать ожидаемую последовательность событий.

  ```java
  @Test
  void shouldFindUserByName() {
      // Подготовительный этап: сохраняем тестового пользователя
      repository.save(new User("Alice", 30)).block();

      // Тестируемый вызов
      Flux<User> userFlux = repository.findByName("Alice");

      // Проверка с помощью StepVerifier
      StepVerifier.create(userFlux)
              .assertNext(user -> { // Ожидаем один элемент и проверяем его
                  assertThat(user.getName()).isEqualTo("Alice");
                  assertThat(user.getAge()).isEqualTo(30);
              })
              .expectComplete() // Ожидаем, что поток успешно завершится
              .verify(); // Запускаем проверку!
  }
  ```

---

### 9. Сравнение с Spring Data JPA/JDBC

*   **Когда использовать R2DBC (и весь реактивный стек):**
    *   **Высоконагруженные I/O-bound приложения:** Системы, которые постоянно ждут чего-то по сети: микросервисы, общающиеся друг с другом,
        API-шлюзы, приложения, интенсивно работающие с базами данных или внешними API.
    *   **Стриминг данных:** Когда вам нужно обрабатывать или отдавать большие объемы данных по частям (например, выгрузка большого отчета).
    *   **Максимальная масштабируемость и утилизация ресурсов:** Когда вы хотите обслуживать максимум запросов на минимальном железе, экономя
        потоки и память.

*   **Когда НЕ использовать R2DBC (и лучше остаться на JPA/JDBC):**
    *   **CPU-bound приложения:** Если ваше приложение в основном занимается вычислениями (математика, криптография, сложная обработка данных
        в памяти), а не ожиданием, выгода от неблокирующего I/O будет минимальной.
    *   **Команда не готова:** Реактивное программирование — это серьезный сдвиг парадигмы. Отладка сложнее, стек-трейсы менее информативны.
        Если команда не имеет опыта, это может замедлить разработку.
    *   **Зрелость экосистемы JPA:** Вы сильно зависите от "плюшек" JPA, которых нет или они менее развиты в R2DBC:
        *   **Ленивая загрузка (Lazy Loading):** В R2DBC ее нет по определению, так как она подразумевает блокирующий вызов.
        *   **Кэш второго уровня (L2 Cache):** Нет встроенной поддержки.
        *   **Богатый маппинг:** JPA/Hibernate умеет мапить очень сложные отношения между сущностями. R2DBC в этом плане проще.
        *   **Инструменты миграции:** Flyway и Liquibase лучше интегрированы с блокирующим стеком JDBC.