<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Вопросы по собеседованию</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .question-block {
            cursor: pointer;
            transition: background-color 0.3s ease;
            word-break: break-word;
        }
        .question-block:hover {
            background-color: #f3f4f6;
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen">

<!-- Контейнер с вопросом -->
<div id="question-container" class="bg-white shadow-lg rounded-lg p-6 w-[800px] h-[750px] flex items-center justify-center text-center relative">
    <div id="question-block" class="question-block p-4 border-b w-full h-full flex items-center justify-center text-center relative" onclick="toggleAnswer()">
        <strong class="text-lg block" id="question-text"></strong>
        <div id="answer-text" class="text-gray-700 hidden" onclick="toggleAnswer()"></div>
    </div>
</div>

<!-- Навигация -->
<div class="absolute bottom-10 flex justify-center gap-4">
    <button onclick="prevQuestion()" class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600">Назад</button>
    <button onclick="location.href='main.html'" class="bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600">На главную</button>
    <button onclick="nextQuestion()" class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600">Вперед</button>
</div>

<!-- Модальное окно -->
<div id="modal" class="fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 hidden">
    <div class="bg-white p-6 rounded-lg shadow-lg w-[900px] h-[800px] overflow-y-auto">
        <h2 class="text-lg font-semibold mb-4">Ответ</h2>
        <p id="modal-answer" class="text-gray-700"></p>
        <button onclick="closeModal()" class="mt-4 bg-red-500 text-white px-4 py-2 rounded hover:bg-red-600 w-full">Закрыть</button>
    </div>
</div>

<script>
    let currentQuestionIndex = 0;
    const MAX_ANSWER_LENGTH = 2000; // Максимальная длина ответа для отображения без модального окна

    const questions = [
        {
  question: "P.S Spring WebFlux == Spring Reactive Web",
  answer: ""
}
,{
  question: "1)Что такое WebFlux?",
  answer: "Spring 5 представил платформу WebFlux, которая представляет собой полностью асинхронный и неблокирующий реактивный веб-стек, который позволяет обрабатывать огромное количество одновременных соединений.Модуль WebFlux является альтернативой Spring MVC и представляет собой реактивный подход для написания веб-сервисов.<br>WebFlux позиционирует себя как микрофреймворк.Этот новый микрофреймворк поддерживает аннотированные контроллеры, функциональные конечные точки, WebClient (аналог RestTemplate в Spring Web MVC), WebSockets и многое другое."
}
,{
  question: "2)В чем отличие Spring WebFlux от RxJava ?",
  answer: "Spring WebFlux и RxJava2+ являются реализациями реактивных потоков.<br>Т.е. теперь начинает складываться более детальная картина:Project Reactor — это библиотека, которая лежит в основе WebFlux.Она исправляет недостатки в RxJava и больше подходит для бэкэнд-разработки. RxJava имеет некоторые проблемы, которые могут вызвать нехватку памяти.<br>Если можно сказать простыми словами, то 'Реактивное программирование' — это программирование с асинхронными потоками (streams) данных.<br>Т.е. можно слушать поток и реагировать на события в нем. Можем фильтровать поток как нам вздумается, объединять потоки, кроме того потоки могут быть входными параметрами других потоков.Даже множественный поток может быть использован как входной аргумент другого потока. Вы можете объединять несколько потоков. Вы можете фильтровать один поток, чтобы потом получить другой, который содержит только актуальные данные. Вы можете объединять данные с одного потока с данными другого, чтобы получить еще один.<br>Поток — это некая последовательность, состоящая из постоянных событий, отсортированных по времени. В нем может быть три типа сообщений: значения (данные некоторого типа), ошибки и сигнал о завершении работы.Нам лишь надо подписаться на поток.Наблюдатель (observers) подписывается на поток.<br>Данные же будут получены тогда, когда они будут готовы — произойти это может в этом же самом либо другом потоке. Publisher их сам отдаст, когда они придут. Это push-модель. Отдача готового элемента — это event. Реактивная модель основана на событиях (event-driven)."
}
,{
  question: "3)Каковы цели WebClient и WebTestClient в Spring?",
  answer: "WebClient — это функция новой среды Web Reactive, которая позволяет не блокировать HTTP-запросы в качестве реактивного клиента. Будучи реактивным, он может эффективно обрабатывать<br>реактивные потоки и имеет возможность использовать лямбда-выражения Java 8. Он может управлять обоими<br>синхронные и асинхронные сценарии, а также поддерживает обратное давление.<br>С другой стороны, WebTestClient — это сопоставимый класс, специально разработанный<br>для использования в тестировании. Он служит тонким слоем над WebClient и может подключаться к<br>любой сервер через HTTP-соединение. Кроме того, он может напрямую взаимодействовать с<br>Приложения WebFlux, использующие фиктивные объекты запросов и ответов, не требующие HTTP-сервер"
}
,{
  question: "4)Можем ли мы использовать как Web MVC, так и WebFlux в одном приложении?",
  answer: "Да, в одном приложении Spring можно использовать как Web MVC, так и WebFlux.<br>Spring предоставляет гибридную конфигурацию, в которой можно использовать обе платформы.<br>вместе. Это полезно при переносе существующего приложения на WebFlux, так как<br>позволяет постепенно внедрять реактивное программирование в приложение.<br>Чтобы использовать Web MVC и WebFlux вместе, вы можете использовать @EnableWebMvc и<br>Аннотации @EnableWebFlux в отдельных классах конфигурации."
}
,{
  question: "5)Какими интерфейсами были заменены ServletHttpResponse/Request?",
  answer: "ServerHttpRequest/Response."
}
,{
  question: "6)Почему при передаче типов в Spring WebFlux, они обрабатываются?",
  answer: "Всё потому что, Spring Web Flux сам является subscriber и при обработке response, запускает обработку."
}
,{
  question: "7)Как работает Spring WebFlux?",
  answer: "<div style='display: flex; justify-content: center; margin: 10px 0;'><br><img src='../../image/img_2.png' alt='Photo' style='max-width: 100%;'><br></div><br>Пояснения к диаграмме.<br>1. Входящий запрос, обрабатываемый серверным движком. Как видите, список серверных движков не ограничивается серверами с Servlet API и теперь<br>   включает такие движки, как Netty и Undertow. Здесь для каждого серверного движка имеется свой реактивный адаптер, который отображает внутреннее представление HTTP-запросов и  HTTP-ответов в  ServerHttpRequest<br>   и ServerHttpResponse.<br>2. Этап выполнения HttpHandler, который объединяет ServerHttpRequest,<br>   ServerHttpResponse пользовательский сеанс и прочую сопутствующую информацию в экземпляр ServerWebExchage.<br>3. Этап выполнения WebFilterChain, который добавляет в цепочку заданный<br>   WebFilter. Затем WebFilterChain вызывает метод WebFilter#filter каждого экземпляра WebFilter в этой цепочке, чтобы отфильтровать входящие<br>   ServerWebExchange.<br>4. Если все условия, определяемые фильтрами, соблюдены, WebFilterChain<br>   вызывает экземпляр WebHandler.<br>5. Следующий шаг  – поиск экземпляров HandlerMapping и  вызов первого подходящего. В  этом примере мы изобразили несколько экземпляров HandlerMapping, таких как RouterFunctionMapping, RequestMapping<br>   HandlerMapping и  HandlerMapping. Здесь присутствует пока незнакомый<br>   экземпляр HandlerMapping  – RouterFunctionMapping, который появился<br>   в модуле WebFlux и выходит за рамки чисто функциональной обработки запросов. Поближе познакомимся с этим типом в следующем разделе.<br>6. Этап выполнения RequestMappingHandlerAdapter, который сохранил прежние функциональные обязанности, но теперь использует реактивные потоки для управления реактивными взаимодействиями<br>"
}
,{
  question: "",
  answer: "8)Как работает традиционное веб-приложения Spring MVC?Контейнер сервлетов имеет выделенный пул потоков для обработки HTTP-запросов, где каждому входящему запросу будет назначен поток, и этот поток будет обрабатывать весь жизненный цикл запроса (модель «поток на запрос»). Это означает, что приложение сможет обрабатывать количество одновременных запросов, равное размеру пула потоков. Можно настроить размер пула потоков, но поскольку каждый поток резервирует некоторую память (обычно 1 МБ), чем больший размер пула потоков мы настраиваем, тем выше потребление памяти.<br>Если приложение разработано в соответствии с архитектурой на основе микросервисов, у нас есть лучшие возможности для масштабирования в зависимости от нагрузки, но за высокое использование памяти по-прежнему приходится платить. Таким образом, модель потока на запрос может стать довольно дорогостоящей для приложений с большим количеством одновременных запросов.<br>Важной характеристикой архитектур на основе микросервисов является то, что приложение распределено, выполняется большое количество отдельных процессов, обычно на нескольких серверах. Использование традиционного императивного программирования с синхронными вызовами запроса/ответа для взаимодействия между службами означает, что потоки часто блокируются в ожидании ответа от другой службы, что приводит к огромной трате ресурсов."
}
,{
  question: "",
  answer: "9)Можно ли описывать конечные точки, не так как в Spring Web?Да, это возможно с помощью статических методов RouterFunctions.nest, RouterFunctions.route.<br>Примерно выглядит так:<br>nest(path('/orders'),<br>    nest(accept(APPLICATION_JSON), <br>    route(GET('/{id}'), handler::get) <br>    .andRoute(method(HttpMethod.GET), handler::list)<br>))"
}
,{
  question: "",
  answer: "10)Можете рассказать о реактивном WebSocket?В качестве центрального интерфейса для обработки соединений WebSocket модуль WebFlux предлагает WebSocketHandler. Этот интерфейс имеет метод handle,<br>принимающий экземпляр WebSocketSession. Класс WebSocketSession представляет успешно установленное соединение между клиентом и сервером и обеспечивает доступ к  информации, включая информацию о  соединении, атрибуты<br>сеанса и входящий поток данных."
}
,{
  question: "",
  answer: "11)Можете назвать сходства Spring Web и Spring WebFlux(Spring Reactive Web)Spring Web и Spring WebFlux очень похожи в построении логики.<br>Многие аннотации, как в Spring Web, так и в Spring WebFlux выполняют одну и туже логику.<br>Схема(структура) приложений одинакова, но в Spring WebFlux присутствует описание конечных точек с помощью функционального стиля.<br>и т.д"
}
,{
  question: "",
  answer: "12)Расскажите об обработке http запросов в Spring WebFlux.Модуль WebFlux, напротив, построен на основе неблокирующего API. То есть рабочему потоку выполнения не требуется выполнять никаких блокирующих операций ввода/вывода. Этот эффективный подход к обработке запросов изображен<br>на рис. 6.11.<br><div style='display: flex; justify-content: center; margin: 10px 0;'><br><img src='../../image/img.png' alt='Photo' style='max-width: 100%;'><br></div>"
}
,
    ];

    const questionText = document.getElementById('question-text');
    const answerText = document.getElementById('answer-text');
    const modal = document.getElementById('modal');
    const modalAnswer = document.getElementById('modal-answer');

    function toggleAnswer() {
        const answer = questions[currentQuestionIndex].answer;
        if (answer.length > MAX_ANSWER_LENGTH) {
            showModal(answer);
        } else {
            if (answerText.classList.contains('hidden')) {
                answerText.innerHTML = answer;
                answerText.classList.remove('hidden');
                questionText.classList.add('hidden');
            } else {
                answerText.classList.add('hidden');
                questionText.classList.remove('hidden');
            }
        }
    }

    function showModal(answer) {
        modalAnswer.innerHTML = answer;
        modal.classList.remove('hidden');
    }

    function showQuestion(index) {
        questionText.textContent = questions[index].question;
        answerText.innerHTML = ""; // Скрываем ответ при смене вопроса
        questionText.classList.remove('hidden');
        answerText.classList.add('hidden');
    }

    function nextQuestion() {
        if (currentQuestionIndex < questions.length - 1) {
            currentQuestionIndex++;
            showQuestion(currentQuestionIndex);
        }
    }

    function prevQuestion() {
        if (currentQuestionIndex > 0) {
            currentQuestionIndex--;
            showQuestion(currentQuestionIndex);
        }
    }

    function closeModal() {
        modal.classList.add('hidden');
    }

    showQuestion(currentQuestionIndex);
</script>

</body>
</html>
