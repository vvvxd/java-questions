1)Что такое Reactive Streams?

В конце 2013 года собралась группа гениальных инженеров из компаний Lightbend,
Netflix и Pivotal, чтобы обсудить описанную проблему и представить решение сообществу JVM. После года напряженной работы мир увидел первый проект стандарта Reactive Streams. В нем не содержалось ничего необычного – основная идея
заключалась в стандартизации уже знакомых шаблонов реактивного программирования.

--------------------------------------------------------------------------------------------------------------------
2)Назовите основные интерфейсы.

Publisher:
Он представляет производителя данных/источник данных и имеет один метод, который позволяет подписчику зарегистрироваться на издателе.

public interface Publisher<T> {
public void subscribe(Subscriber<? super T> s);
}

Subscriber:
Он представляет потребителя и имеет следующие методы:

public interface Subscriber<T> {
public void onSubscribe(Subscription s);
public void onNext(T t);
public void onError(Throwable t);
public void onComplete();
}

onSubscribe должны вызываться Publisher перед началом обработки и использоватся для передачи на Subscription объекта от Publisher до Subscriber

onNext используется для того, чтобы сигнализировать о том, что был отправлен новый элемент

onError используется для того, чтобы сигнализировать о том, что произошел сбой Publisher и больше никаких элементов не будет

onComplete используется для того, чтобы сигнализировать, что все элементы были успешно отправлены

Subscription:
Subscription содержат методы, которые позволяют клиенту управлять выдачей элементов Publisher (т.е. обеспечивать поддержку противодавления).

public interface Subscription {
public void request(long n);
public void cancel();
}

request позволяет Subscriber сообщить, Publisher сколько дополнительных элементов будет опубликовано

cancel позволяет подписчику отменить дальнейшую отправку элементов Publisher

Processor:
Если объект должен преобразовывать входящие элементы, а затем передавать их другому Subscriber, требуется реализация интерфейса Processor. Он действует и как Subscriber ,и как Publisher.
public interface Processor<T, R> extends Subscriber<T>, Publisher<R> { }

--------------------------------------------------------------------------------------------------------------------
3)Что такое Back-pressure ?

Мы возвращаем не объект, а "обещание" объекта — Publisher, который будет отдавать объекты, как только они появятся. Отдавать мы их будем Subscriber-у — тому, кто подписывается на Publisher.Подписчик может быть как один, так и много. Subscriber и получает объекты. Причем подписчик может регулировать скорость потока, это и называется Back-pressure.
Как уже говорилось выше, основная концепция реактивного программирования — это неблокирующий ввод/вывод.
Слушать поток означает подписаться на него. Т.е. функции, которые мы определили — это наблюдатели (Observers). А поток является субъектом, который наблюдают. Этот подход называется Observer Design Pattern.
Если у нас есть Publisher, который отправляет события потребителю быстрее, чем он может их обработать, то, в конце концов, потребитель будет перегружен событиями, которые истощают системные ресурсы. Backpressure означает, что наш клиент должен иметь возможность сообщить производителю, сколько данных отправлять, чтобы предотвратить это, и это указано в самой спецификации.

--------------------------------------------------------------------------------------------------------------------
4)Что такое TCK?

Reactive Streams Technology Compatibility Kit - это набор тестов TestNG, которые должны адаптироваться и  подготавливаться для проверки конкретной реализации Publisher или Subscriber. TCK включает полный список тестовых классов, призванных охватить все правила, описанные в  стандарте Reactive Streams.

--------------------------------------------------------------------------------------------------------------------
5)Какие способы есть подписаться на паблишер?

1) Подписаться (слушать поток):
subscribe();
2) Сделать что-то с каждым полученным значением
   subscribe(Consumer<? super T> consumer);
3) Сделать что-то в случае исключения
   subscribe(Consumer<? super T> consumer, Consumer<? super Throwable> errorConsumer);
4) Сделать что-то по завершению
   subscribe(Consumer<? super T> consumer,Consumer<? super Throwable> errorConsumer,Runnable completeConsumer);

--------------------------------------------------------------------------------------------------------------------