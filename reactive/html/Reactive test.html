<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Вопросы по собеседованию</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .question-block {
            cursor: pointer;
            transition: background-color 0.3s ease;
            word-break: break-word;
        }
        .question-block:hover {
            background-color: #f3f4f6;
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen">

<!-- Контейнер с вопросом -->
<div id="question-container" class="bg-white shadow-lg rounded-lg p-6 w-[800px] h-[750px] flex items-center justify-center text-center relative">
    <div id="question-block" class="question-block p-4 border-b w-full h-full flex items-center justify-center text-center relative" onclick="toggleAnswer()">
        <strong class="text-lg block" id="question-text"></strong>
        <div id="answer-text" class="text-gray-700 hidden" onclick="toggleAnswer()"></div>
    </div>
</div>

<!-- Навигация -->
<div class="absolute bottom-10 flex justify-center gap-4">
    <button onclick="prevQuestion()" class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600">Назад</button>
    <button onclick="location.href='main.html'" class="bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600">На главную</button>
    <button onclick="nextQuestion()" class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600">Вперед</button>
</div>

<!-- Модальное окно -->
<div id="modal" class="fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 hidden">
    <div class="bg-white p-6 rounded-lg shadow-lg w-[900px] h-[800px] overflow-y-auto">
        <h2 class="text-lg font-semibold mb-4">Ответ</h2>
        <p id="modal-answer" class="text-gray-700"></p>
        <button onclick="closeModal()" class="mt-4 bg-red-500 text-white px-4 py-2 rounded hover:bg-red-600 w-full">Закрыть</button>
    </div>
</div>

<script>
    let currentQuestionIndex = 0;
    const MAX_ANSWER_LENGTH = 2000; // Максимальная длина ответа для отображения без модального окна

    const questions = [
        {
  question: "1)Что такое StepVerifier?",
  answer: "StepVerifier  – текучий (fluent) API для построения конвейера тестирования любого издателя Publisher"
}
,{
  question: "2)Напишите легкий тест на StepVerifier.",
  answer: "StepVerifier<br>    .create(Flux.just('foo', 'bar'))<br>    .expectSubscription()<br>    .expectNext('foo')<br>    .expectNext('bar')<br>    .expectComplete()<br>    .verify()"
}
,{
  question: "3)Назовите основные методы в StepVerifier.",
  answer: "create(Publisher<? extends T> publisher): Создает новый экземпляр StepVerifier, который будет использоваться для тестирования реактивного потока данных, предоставленного Publisher.expectNext(T... values): Ожидает получение следующих значений в потоке данных. Можно указать несколько значений через запятую.expectNextMatches(Predicate<? super T> predicate): Ожидает получение следующего значения, которое соответствует заданному предикату. Можно использовать лямбда-выражения или ссылки на методы для определения предиката.expectNextCount(long count): Ожидает получение указанного количества следующих значений в потоке данных.expectComplete(): Ожидает успешное завершение потока данных без дополнительных значений.expectError(): Ожидает ошибку в потоке данных. Этот метод не проверяет конкретный тип ошибки.expectError(Class<? extends Throwable> exceptionType): Ожидает ошибку указанного типа в потоке данных.verify(): Запускает выполнение теста и проверяет, соответствует ли реальное поведение потока данных ожидаемым значениям, ошибкам и завершению."
}
,{
  question: "4)Что такое WebTestClient?WebTestClient - это класс из модуля Spring WebFlux, который предоставляет возможность выполнения интеграционных тестов для реактивных веб-приложений. Он предоставляет удобный API для отправки HTTP-запросов к приложению и проверки полученных HTTP-ответов.",
  answer: "WebTestClient основан на клиентской стороне WebClient из Spring WebFlux, который сам по себе представляет реактивный клиент для выполнения HTTP-запросов. Однако, в отличие от WebClient, WebTestClient предназначен специально для написания тестов и предлагает дополнительные функции для проверки и верификации HTTP-ответов."
}
,{
  question: "5)Напишите основные методы для работы с WebTestClient.",
  answer: "Основные методы для написания тестов с WebTestClient в Spring Reactive Web:- get(), post(), put(), delete(), patch(), options(): Методы для отправки соответствующих HTTP-запросов. Вы можете указать путь, параметры, заголовки и тело запроса при необходимости.    Пример:<br>    webTestClient.get().uri('/api/users')<br>        .exchange()<br>        .expectStatus().isOk()<br>        .expectBody().json('[{\'id\':1,\'name\':\'John\'},{\'id\':2,\'name\':\'Jane\'}]');- uri(String uriTemplate, Object... uriVariables): Метод для указания пути запроса с возможностью использования шаблона URI и переменных пути.    Пример:<br>    webTestClient.get().uri('/api/users/{id}', 1)<br>        .exchange()<br>        .expectStatus().isOk()<br>        .expectBody().json('{\'id\':1,\'name\':\'John\'}');- header(String name, String value): Метод для добавления заголовка к запросу.    Пример:<br>    webTestClient.post().uri('/api/users')<br>        .header('Content-Type', 'application/json')<br>        .body(BodyInserters.fromValue(user))<br>        .exchange()<br>        .expectStatus().isCreated();- body(BodyInserter<?, ? super ClientHttpRequest> inserter): Метод для установки тела запроса. BodyInserter может быть создан с помощью статических методов BodyInserters.    Пример:<br>    User user = new User('John');<br>    webTestClient.post().uri('/api/users')<br>        .body(BodyInserters.fromValue(user))<br>        .exchange()<br>        .expectStatus().isCreated();- exchange(): Метод, который отправляет HTTP-запрос и возвращает WebClient.ResponseSpec для проверки и верификации HTTP-ответа.    Пример:<br>    webTestClient.get().uri('/api/users')<br>        .exchange()<br>        .expectStatus().isOk()<br>        .expectBody().json('[{\'id\':1,\'name\':\'John\'},{\'id\':2,\'name\':\'Jane\'}]');- expectStatus(): Метод для проверки статуса HTTP-ответа.    Пример:<br>    webTestClient.get().uri('/api/users')<br>        .exchange()<br>        .expectStatus().isOk();- expectBody(): Метод для проверки тела HTTP-ответа. Вы можете использовать методы, такие как json(), jsonPath(), xml(), xpath() и другие для проверки содержимого тела ответа.    Пример:<br>    webTestClient.get().uri('/api/users')<br>        .exchange()<br>        .expectBody().json('[{\'id\':1,\'name\':\'John\'},{\'id\':2,\'name\':\'Jane\'}]');- expectHeader(): Метод для проверки заголовков HTTP-ответа.    Пример:    webTestClient.get().uri('/api/users')<br>        .exchange()<br>        .expectHeader().contentType(MediaType.APPLICATION_JSON)<br>        .expectHeader().valueEquals('Cache-Control', 'no-cache');"
}
,
    ];

    const questionText = document.getElementById('question-text');
    const answerText = document.getElementById('answer-text');
    const modal = document.getElementById('modal');
    const modalAnswer = document.getElementById('modal-answer');

    function toggleAnswer() {
        const answer = questions[currentQuestionIndex].answer;
        if (answer.length > MAX_ANSWER_LENGTH) {
            showModal(answer);
        } else {
            if (answerText.classList.contains('hidden')) {
                answerText.innerHTML = answer;
                answerText.classList.remove('hidden');
                questionText.classList.add('hidden');
            } else {
                answerText.classList.add('hidden');
                questionText.classList.remove('hidden');
            }
        }
    }

    function showModal(answer) {
        modalAnswer.innerHTML = answer;
        modal.classList.remove('hidden');
    }

    function showQuestion(index) {
        questionText.textContent = questions[index].question;
        answerText.innerHTML = ""; // Скрываем ответ при смене вопроса
        questionText.classList.remove('hidden');
        answerText.classList.add('hidden');
    }

    function nextQuestion() {
        if (currentQuestionIndex < questions.length - 1) {
            currentQuestionIndex++;
            showQuestion(currentQuestionIndex);
        }
    }

    function prevQuestion() {
        if (currentQuestionIndex > 0) {
            currentQuestionIndex--;
            showQuestion(currentQuestionIndex);
        }
    }

    function closeModal() {
        modal.classList.add('hidden');
    }

    showQuestion(currentQuestionIndex);
</script>

</body>
</html>
