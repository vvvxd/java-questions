
# Часы Лэмпорта

Давайте рассмотрим, что такое часы Лэмпорта и как они работают.

Лесли Лэмпорт изобрел один из первых и простейших типов логических часов, названных **часами Лэмпорта**.

В этом типе логических часов каждый узел в системе поддерживает логические часы в виде числового счетчика, который начинается с нуля при
запуске узла.

## Правила протокола

* **(R1)** Перед выполнением события (отправка, получение или локальное событие) узел увеличивает счетчик своих логических часов на
  единицу: `Cᵢ = Cᵢ + 1`.
* **(R2)** Каждое отправленное сообщение несет с собой значение часов отправителя на момент отправки. Когда узел `nᵢ` получает сообщение с
  временной меткой `C_msg`, он выполняет следующие действия:
    * Обновляет свои часы, принимая максимум из своих часов и полученных часов: `Cᵢ = max(Cᵢ, C_msg)`
    * Выполняет R1
    * Доставляет сообщение

## Условие согласованности часов

Часы Лэмпорта удовлетворяют так называемому **условию согласованности часов**.

Если одно событие `e₁` причинно предшествует другому событию `e₂`, то `C(e₁) < C(e₂)`. Однако обратное, то есть **условие строгой
согласованности**, часами Лэмпорта не удовлетворяется. Это означает, что если `C(e₁) < C(e₂)`, то это не обязательно означает, что
событие `e₁` причинно предшествует `e₂`. В результате это означает, что часы Лэмпорта не могут быть использованы для вывода **частичных
порядков**, которые являются причинно согласованными.

> Однако их все еще можно использовать для других целей, например, для создания (не причинно согласованных) **полных порядков**.

## Работа часов Лэмпорта

Чтобы лучше понять, как работают часы Лэмпорта, давайте рассмотрим пример на следующей иллюстрации. У нас есть распределенная система,
состоящая из трех узлов A, B и C, которые выполняют события локально и обмениваются сообщениями для распространения необходимой информации
по всей системе. Мы можем попробовать применить описанные выше правила и увидеть, что часы каждого узла обновляются, как показано на
иллюстрации.

**Пошаговый пример работы:**

Вот перевод предоставленного текста с описанием шагов:

1) Система из трех узлов. Изначально на каждом узле значение логических часов C установлено в ноль.
   ![Image 1](img/image_a8452201-ff2f-4160-820f-47771f2fea65.svg)

2) Узел A отправляет сообщение узлу B.
   ![Image 2](img/image_677a1388-a502-4b6a-ba37-691e4eaa822f.svg)

3) Узел B получает сообщение.
   ![Image 3](img/image_43981ea6-389f-497c-8adb-05bd351a4718.svg)

4) Временная метка B1 равна max (clock(B), timestamp(A1)) + 1, то есть 2.
   ![Image 4](img/image_f264f18d-bce8-4c99-a317-9a5443e4d87e.svg)

5) Часы B1 становятся 2.
   ![Image 5](img/image_f7be0f6f-7e19-42a2-8c49-b3512774798d.svg)

6) В то же время B отправляет сообщение C. Оно еще не получено.
   ![Image 6](img/image_c8237719-da9a-4611-9db0-a4c6bb195913.svg)

7) Происходит C1, часы C становятся 1.
   ![Image 7](img/image_f5db59cf-a908-4ec5-98d8-cdca81bc2653.svg)

8) Происходит C2, часы C становятся 2.
   ![Image 8](img/image_0e673fbd-3328-4ac0-880f-c27d1a44194f.svg)

9) Происходит B2. Часы B становятся 3.
   ![Image 9](img/image_e4c23e16-0923-42d0-9f6f-86196046bcc9.svg)

10) Происходит A2, часы A становятся 2.
    ![Image 10](img/image_b7a51bab-68ab-4d83-86fb-6144cfc597b4.svg)

11) Происходит C3, часы C становятся 3.
    ![Image 11](img/image_e1133121-4c82-4aa7-b353-43326efd079e.svg)

12) Сообщение от B наконец приходит к C.
    ![Image 12](img/image_ab56dc54-78a5-453a-b3b5-93adf00a2065.svg)

13) Временная метка C равна max(clock(C), timestamp(B1)) + 1, то есть 4.
    ![Image 13](img/image_ab94b4da-5058-46bd-b785-5976351a96d9.svg)

14) Часы C становятся 4.
    ![Image 14](img/image_270457fa-d1d3-45f4-bf3b-71d5b3945699.svg)

15) Узел C отправляет сообщение узлу A.
    ![Image 15](img/image_8fd32171-7705-4045-b1a9-431cb5d3f95e.svg)

16) Узел A получает сообщение.
    ![Image 16](img/image_67d1329c-0462-434b-9830-f469ec4f11a3.svg)

17) Временная метка A3 равна max (clock(A), timestamp(C5)) + 1, то есть 6.
    ![Image 17](img/image_d93fc2dd-ae7f-4c2c-9446-c644b05a880f.svg)

18) Часы A становятся 6.
    ![Image 18](img/image_7892dcdb-51b1-4225-a674-596b9da0159d.svg)
По сути, каждый узел «тикает» своими часами при локальных событиях и «подгоняет» их вперед, если обнаруживает, что у другого узла значение
часов больше, чем у него.

Теперь давайте обсудим представленные ранее условия более подробно.

Любые два события, которые причинно связаны, будут отражать эту связь в значении часов. Например, `A₁` причинно предшествует `B₁`, и мы
видим, что `C(A₁) = 1 < 2 = C(B₁)` (условие согласованности часов).

Мы также можем видеть, что *условие строгой согласованности* не выполняется. Например, `C(C₂) < C(B₂)` (так как `2 < 3`), но эти два события
не являются причинно зависимыми. Событие `B₂` могло произойти как до, так и после `C₂` с тем же значением часов.

## Использование часов Лэмпорта

Часы Лэмпорта могут быть использованы для создания **полного упорядочивания** событий в распределенной системе с использованием некоторого
произвольного механизма для разрешения «ничьих» в случае, если часы разных узлов имеют одинаковое значение (например, по идентификатору
узла).

Особенность заключается в том, что это **полное упорядочивание** в некоторой степени произвольно и не может выявлять причинно-следственные
связи. Это ограничивает количество практических применений часов Лэмпорта. В статье Лэмпорта демонстрируется, как их потенциально можно
использовать для решения проблем синхронизации, таких как взаимное исключение.