
# Целостность

Давайте разберем, что такое целостность и как мы можем ее обеспечить.


**Целостность** — это процесс сохранения точности и полноты данных на протяжении всего их жизненного цикла, чтобы они не могли быть изменены несанкционированным или незаметным образом. Это изменение может произойти злонамеренно (например, посредником в сети) или случайно (например, из-за сбоя программного или аппаратного обеспечения).

## Обеспечение целостности

> **Примечание:** В предыдущей главе мы обсуждали некоторые методы защиты от случайных изменений, такие как **контрольные суммы** и **циклические избыточные проверки**, поэтому здесь мы сосредоточимся на злонамеренных изменениях, которые более актуальны в контексте безопасности.

### Хеш-значение

Простой подход к защите *целостности* данных заключается в вычислении хеш-значения для фрагмента данных и отправке как данных, так и хеша, как показано на следующей иллюстрации:

1) Система, в которой есть отправитель, получатель и сеть связи.
   ![Изображение 1](img/image_f8a63d64-b17a-406a-8777-a7de3fe79f33.svg)


2) У отправителя есть некоторые данные в виде открытого текста
   ![Изображение 2](img/image_9da0ee8f-d964-4de9-be47-729401171df3.svg)


3) Отправитель вычисляет хэш данных с помощью хэш-функции.
   ![Изображение 3](img/image_f7a160a3-5c35-411f-b49f-5fb180e17e36.svg)


4) Отправитель помещает данные и соответствующий хэш в сообщение и отправляет сообщение по сети
   ![Изображение 4](img/image_d0ffec19-5d83-4db1-8b0f-f9278f83f1a9.svg)


5) Сообщение будет отправлено получателю.
   ![Изображение 5](img/image_e01b81e6-74c4-469a-b0d8-46c74b60c84f.svg)


6) Получатель получает сообщение
   ![Изображение 6](img/image_725cb006-a490-4d11-be00-5bc6625b12ef.svg)


7) Получает и вычисляет хэш данных в сообщении, используя хэш-функцию
   ![Изображение 7](img/image_efd50bec-f46d-4bd8-badc-27664e1e8dd1.svg)


8) Получатель сравнивает хэш данных, который он вычислил локально, с сохраненным хэшем в сообщении
   ![Изображение 8](img/image_a349aad0-8774-43c1-977f-c5e68d94c21c.svg)


9) Получатель сохраняет сообщение, поскольку значения хэша совпадают, поскольку данные не были изменены каким-либо вредоносным объектом в сети.
   ![Изображение 9](img/image_44698113-be19-462f-a535-ea08533354c8.svg)

Любой злоумышленник может изменить данные, но мы можем обнаружить некоторые атаки, если злоумышленник не сможет подобрать правильную хеш-функцию, как показано на следующей иллюстрации.

1) Система, в которой есть отправитель, получатель и сеть связи
   ![Изображение 1](img/image_3afb28fc-f084-45cd-86ce-25b18eaced1a.svg)


2) У отправителя есть некоторые данные в виде открытого текста
   ![Изображение 2](img/image_ca36485b-bfd6-4014-8f2a-851ffc7dba00.svg)


3) Отправитель вычисляет хэш данных, используя хэш-функцию
   ![Изображение 3](img/image_3cd248d9-0279-471f-8204-855ba9181116.svg)


4) Отправитель помещает данные и соответствующий хэш в сообщение и отправляет сообщение по сети
   ![Изображение 4](img/image_b302173a-2aa7-4a37-9400-e5827100d371.svg)


5) В сеть проникает вредоносный объект.
   ![Изображение 5](img/image_5b5c8ba4-1b60-426f-8bd7-bd6fa108c79c.svg)


6) Вредоносный объект обновляет данные в сообщении, которое пересылается получателю
   ![Изображение 6](img/image_2eba32a0-9944-45b0-b4f7-9f6a9ca994ad.svg)


7) Получатель получает сообщение
   ![Изображение 7](img/image_3b822630-f114-45d6-a333-03e8c2c38f54.svg)


8) Получает и вычисляет хэш данных в сообщении, используя хэш-функцию
   ![Изображение 8](img/image_f5df0989-04eb-453c-9321-178df8f9daf4.svg)


9) Получатель сравнивает хэш данных, который он вычислил локально, с сохраненным хэшем в сообщении
   ![Изображение 9](img/image_60ba0aeb-7940-4af2-a694-97309753f031.svg)


10) Получатель отклоняет сообщение из-за несоответствия значений хэша, поскольку данные были изменены вредоносным объектом в сети.
    ![Изображение 10](img/image_0235dcbe-4439-4ead-a62d-5c65c256f215.svg)

Однако этот подход имеет очевидную проблему:
*   Предположим, если мы отправляем хеш вместе с данными, любой злоумышленник, который может изменить данные, сможет выяснить используемую хеш-функцию и соответствующим образом скорректировать хеш. В результате мы не сможем обнаружить измененные данные.

Следовательно, нам обычно нужна комбинация *целостности* и *аутентификации*, то есть уверенность в том, что хеш соответствует данным и что хеш был вычислен отправителем, а не кем-то другим.

Мы можем достичь этого с помощью техник, аналогичных описанным ранее. Ниже приведены некоторые методы, обеспечивающие как *целостность*, так и *аутентификацию*.

## Методы, обеспечивающие как целостность, так и аутентификацию

Мы рассмотрим два метода для обеспечения целостности и аутентификации.

### Коды аутентификации сообщений (MAC)

**Коды аутентификации сообщений** используют **общий секретный ключ** для генерации тега для сообщения, который затем может быть проверен по данным с использованием этого общего ключа. Это показано на следующей иллюстрации.

1) Отправитель запрашивает у генератора ключей секретный ключ
   ![Изображение 1](img/image_5f0ba4e3-5c66-46e6-bdc3-687e8d4c44e4.svg)


2) В системе связи есть отправитель, получатель и сеть связи
   ![Изображение 2](img/image_6308bc9b-89b5-4da4-891b-936680c20847.svg)


3) У отправителя есть сообщение, и он хочет отправить это сообщение получателю
   ![Изображение 3](img/image_ae33e4a5-57b0-40b5-9961-84c7288c07de.svg)


4) На стороне отправителя сначала отправляется сообщение для создания тега для этого сообщения
   ![Изображение 4](img/image_4599c8bc-b172-45cc-85d8-3914dc287fe6.svg)


5) Отправитель генерирует тег для сообщения, используя общий секретный ключ, затем помеченное сообщение отправляется по сети
   ![Изображение 5](img/image_69c83073-e891-41d6-8a31-5b640f316442.svg)


6) На стороне получателя тег сначала проверяется
   ![Изображение 6](img/image_ed4a4857-ca7e-45a6-9329-9be53f047388.svg)


7) Получатель сверяет метку с сообщением, используя общий секретный ключ, удаляет метку и сохраняет сообщение
   ![Изображение 7](img/image_131e1e7e-07b5-4f72-b800-e3aa655643f3.svg)

Этот метод страдает от тех же проблем, что и симметричное шифрование (требуется безопасный обмен ключом).

### Цифровая подпись

Цифровые подписи используют **асимметричную криптографию**, где алгоритм генерирует открытый и закрытый ключ.

Закрытый ключ известен только отправителю сообщения, который может использовать его для подписи сообщения, создавая цифровую подпись.

Получатели затем могут использовать общий открытый ключ, чтобы убедиться, что цифровая подпись действительна и была сгенерирована отправителем.

Это показано на следующей иллюстрации.

1) Отправитель запрашивает генератор ключей для генерации закрытого и открытого ключей
   ![Изображение 1](img/image_a4bee428-86e7-4e99-81c3-33226f516854.svg)


2) В системе связи есть отправитель, получатель и сеть связи
   ![Изображение 2](img/image_ad7cd4b1-96c6-4751-bbe7-0cc639fbbfae.svg)


3) У отправителя есть сообщение, и он хочет отправить его получателю.
   ![Изображение 3](img/image_b72c9fe4-e77e-44f7-9a0b-a47cd581c146.svg)


4) Со стороны отправителя сообщение сначала отправляется на подпись
   ![Изображение 4](img/image_e73b97c9-938b-4dfb-b51e-25b2f4f7f386.svg)


5) Отправитель использует закрытый ключ для создания цифровой подписи для сообщения, после чего подписанное сообщение отправляется по сети.
   ![Изображение 5](img/image_789843f1-9540-4ff3-8470-04193087bb5c.svg)


6) На стороне получателя цифровая подпись подтверждена
   ![Изображение 6](img/image_35391b3f-8577-41d1-8658-f98928e6fe38.svg)


7) Получатель проверяет цифровую подпись с помощью открытого ключа, удаляет подпись и сохраняет сообщение, если подпись действительна
   ![Изображение 7](img/image_b3d32951-3714-4660-967f-5b496cf44eab.svg)

Подобно асимметричному шифрованию, цифровые подписи могут использоваться для защиты *целостности* и *подлинности* данных, передаваемых по сети или хранящихся в системе.

