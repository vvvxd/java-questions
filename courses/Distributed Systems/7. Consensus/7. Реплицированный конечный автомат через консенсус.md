# Реплицированный конечный автомат через консенсус

В этом уроке мы объясним, как можно использовать алгоритм консенсуса для создания реплицированного конечного автомата.


В начале этой главы мы кратко описали, как алгоритм консенсуса может быть использован для решения широкого круга задач.

Это не случайно, поскольку все эти проблемы имеют общую, фундаментальную характеристику. Она заключается в том, что все они могут быть в некоторой степени смоделированы как **конечный автомат**. Это также является причиной, почему их легче решать в **централизованной** среде, но гораздо сложнее, когда мы хотим решить их в **распределённой** среде для повышения **доступности**.

## Создание реплицированного конечного автомата с использованием алгоритма консенсуса

Используя алгоритм консенсуса, мы можем создать реплицированный конечный автомат. Это набор узлов, каждый из которых получает команды и выполняет их, переходя между состояниями.

Если все узлы используют один и тот же конечный автомат, всё, что нам нужно, — это обеспечить, чтобы все узлы получали одни и те же входные данные в одном и том же порядке, и тогда мы можем гарантировать, что все узлы будут совершать одинаковые переходы. Это будет означать, что распределённая система будет выглядеть извне как единый сервер.

В результате можно получить все преимущества распределённой системы, сохраняя при этом простую модель программирования.

Следующая иллюстрация содержит высокоуровневый обзор такой системы.

![img_6.png](img/img_6.png)

Верхний уровень получает запросы от клиентов. Он создаёт предложения для уровня консенсуса, который осуществляет необходимую координацию между другими узлами системы и распространяет выбранные значения на нижний уровень, который получает эти значения в качестве входных данных и выполняет необходимые переходы состояний.

### Использование Paxos на уровне консенсуса

Давайте немного подробнее остановимся на том, что это повлечёт за собой, если предположить, что в качестве уровня консенсуса системы используется Paxos.

По сути, клиенты будут отправлять обычные запросы в систему, в зависимости от её предметной области. Эти запросы могут быть либо командами для системы, либо запросами на проверку её внутреннего состояния.

Эти запросы будут отправляться текущему лидеру системы, который будет определён на основе предыдущих экземпляров консенсуса.

Если узел, не являющийся лидером, получает запрос, он может вернуть адрес лидера, чтобы клиент мог перенаправить его.

> При начальной загрузке системы, когда экземпляры консенсуса ещё не выполнялись, лидер может быть определён из конфигурационного файла, или узлы могут конкурировать друг с другом за роль лидера.

Каждый раз, когда узел-лидер получает новую команду, он пытается выполнить новый экземпляр консенсуса, каждый раз увеличивая номер экземпляра.

1.  Три клиента и пять узлов, работающих по протоколу Paxos, где узел D выступает в роли лидера.
    ![Image 1](img/image_b4e24a8f-7dd7-48a1-9ef4-335b98574864.svg)

2.  Клиент 1 отправляет запрос R1 узлу C, который не является лидером.
    ![Image 2](img/image_51fdda81-d6b9-4e68-9db5-94dbb5dcb1a1.svg)

3.  Узел C отвечает клиенту 1, сообщая идентификатор лидера.
    ![Image 3](img/image_837bae55-2644-499e-9ea9-343bb76f5f7d.svg)

4.  Клиент 1 повторно отправляет запрос R1 лидеру.
    ![Image 4](img/image_6d6956b6-6ddd-4621-bb2a-ef085f0b0fcd.svg)

5.  Лидер запускает экземпляр Paxos 1.
    ![Image 5](img/image_7df132b7-a9c9-4afe-9413-33729883a188.svg)

6.  Лидер завершает экземпляр Paxos для R1.
    ![Image 6](img/image_56627364-8fdb-48d5-b7a3-0b560665b064.svg)

7.  Лидер отправляет подтверждение клиенту 1.
    ![Image 7](img/image_3d483f27-6913-4957-b20b-77a58b8c888d.svg)

8.  Клиент 2 отправляет запрос R2 лидеру.
    ![Image 8](img/image_cb3a6261-9845-456c-b726-80a02ba2264b.svg)

9.  Лидер запускает экземпляр Paxos 2.
    ![Image 9](img/image_3aa622c7-09b6-4317-a5df-2c9fbeb1d7e8.svg)

10. Клиент 3 отправляет еще один запрос R3 до того, как лидер завершит экземпляр Paxos для R2.
    ![Image 10](img/image_22c8621a-a70d-4215-bf71-f645e2ae9a58.svg)

11. Лидер запускает экземпляр Paxos 3.
    ![Image 11](img/image_f496e7f7-bc19-4d09-aaa0-b3b71df4cd17.svg)

12. Экземпляр 3 завершается.
    ![Image 12](img/image_e3e051a6-980d-4d5c-be33-59c539ef0e70.svg)

13. Поскольку экземпляр 2 еще не завершен, мы не можем отправить клиенту 2 подтверждение. Итак, экземпляр 2 завершается.
    ![Image 13](img/image_f778832d-6868-42e5-8677-3609cb117766.svg)

14. Лидер отправляет подтверждение клиенту 2 для R2.
    ![Image 14](img/image_a1e4a1ad-3661-43fd-a0b2-f3ec9494eb16.svg)

15. Лидер отправляет подтверждение клиенту 3 для R3.
    ![Image 15](img/image_80614309-6626-430e-9c4b-5c3297c33381.svg)

Для достижения удовлетворительной производительности несколько экземпляров консенсуса могут выполняться параллельно. Однако в некоторых местах для обеспечения корректности необходимо выполнять сериализацию.

Например, нижний уровень должен обрабатывать решение экземпляра консенсуса только тогда, когда он обработал все предыдущие экземпляры, чтобы гарантировать, что все конечные автоматы выполняют одинаковые переходы.

Аналогично, лидер должен дождаться завершения экземпляра и ответить соответствующему клиенту только после завершения всех предыдущих экземпляров.

Когда текущий лидер нестабилен и другие узлы начинают делать предложения, может возникнуть повышенная конкуренция, что, например, создаст значительные задержки для любых последующих экземпляров, которые могли бы быть завершены.

> В этих случаях узлы могут предлагать фиктивное значение, которое по сути представляет собой пустую операцию (no-op), отклоняя операцию клиента.

Эта абстракция реплицированного конечного автомата довольно мощна и потенциально может быть использована для реализации решений многих распространённых проблем в области распределённых систем.