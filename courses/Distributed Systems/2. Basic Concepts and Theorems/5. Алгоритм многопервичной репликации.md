# Алгоритм многопервичной репликации
Рассмотрим многопервичный алгоритм репликации.

Как мы видели в предыдущем уроке, репликация первично-резервного копирования — это метод, который легко реализовать и эксплуатировать. Он может легко поддерживать транзакции и скрывать распределенную природу базовой системы, т. е. при использовании синхронной репликации.

Однако первично-резервная репликация имеет некоторые ограничения с точки зрения производительности, масштабируемости и доступности.

Как мы уже обсуждали, существует множество приложений, где доступность и производительность гораздо важнее согласованности данных или транзакционной семантики.

Часто цитируемый пример — это корзина покупок в электронной коммерции, где самое важное для клиентов — иметь доступ к своей корзине в любое время и быстро и легко добавлять товары. Для достижения этого приемлемо пойти на компромисс с согласованностью, если в какой-то момент происходит согласование данных. Например, если две реплики расходятся из-за периодических сбоев, клиент все равно может разрешить конфликты во время процесса оформления заказа.

# Многопервичная репликация
Многопервичная репликация — это альтернативный метод репликации, при котором предпочтение отдается более высокой доступности и производительности, чем согласованности данных.

> Этот метод также известен как репликация с несколькими мастерами .

В этой технике все реплики равны и могут принимать запросы на запись. Они также отвечают за распространение изменений данных на остальную часть группы.

Многопервичная репликация имеет существенное отличие от первично-резервной репликации. В многопервичной репликации нет единого узла-лидера, который сериализует запросы и устанавливает единый порядок, поскольку запросы на запись обрабатываются всеми узлами одновременно. Это означает, что узлы могут не согласиться с тем, какой порядок является правильным для некоторых запросов. Обычно мы называем это конфликтом .

Чтобы система оставалась работоспособной, узлам необходимо разрешать этот конфликт, когда он возникает, согласовывая один заказ из доступных.

В случае конфликта последующий запрос на чтение может получить разные результаты в зависимости от узла, который обрабатывает запрос, если только мы не разрешим конфликт так, чтобы все узлы снова сошлись к одному значению.

# Разрешение конфликта
Существует множество различных способов разрешения конфликтов в зависимости от гарантий, которые хочет предоставить система.

Важным аспектом различных подходов к разрешению конфликтов является то, делают ли они это с энтузиазмом или лениво .

1) В крайнем случае конфликт разрешается во время операции записи. 
2) В ленивом случае операция записи продолжает поддерживать несколько альтернативных версий записи данных, которые в конечном итоге разрешаются в одну версию позже, т. е. во время последующей операции чтения.

# Подходы к разрешению конфликтов
Вот несколько распространенных подходов к разрешению конфликтов:

## Представление клиентам разрешения конфликтов
При возникновении конфликта несколько доступных версий возвращаются клиенту. Затем клиент выбирает нужную версию и возвращает ее системе. Это разрешает конфликт.

Примером этого является приложение «Корзина покупок», где клиент выбирает нужную версию своей корзины.

## Разрешение конфликта «победитель — последний, кто написал»
Каждый узел в системе помечает каждую версию временной меткой, используя локальные часы. Во время конфликта выбирается версия с последней временной меткой.

Однако эта техника может привести к некоторым неожиданным поведениям, поскольку нет глобального понятия времени. Например, запись A может переопределить запись B, даже если B произошло «в результате» A.

## Алгоритмы отслеживания причинно-следственных связей
Система использует алгоритм, который отслеживает причинно-следственные связи между различными запросами. Когда возникает конфликт между двумя записями (A, B) и одна из них определяется как причина другой (предположим, A является причиной B), то результирующая запись (B) сохраняется.

Однако все еще могут быть записи, которые не связаны причинно, т. е. запросы фактически параллельны. В таких случаях система не может принять простое решение.

> Мы более подробно рассмотрим некоторые из этих подходов далее в главах, посвященных времени и порядку.