Что такое IoC?

Инверсия управления (Inversion of Control, IoC) — важный принцип объектно-ориентированного программирования, используемый для уменьшения зацепления (связанности) в коде. Также архитектурное решение интеграции, упрощающее расширение возможностей системы, при котором поток управления программы контролируется фреймворком.

В обычной программе программист сам решает, в какой последовательности делать вызовы процедур. Но если используется фреймворк, программист может разместить свой код в определенных точках выполнения (используя callback или другие механизмы), затем запустить «главную функцию» фреймворка, которая обеспечит все выполнение и вызовет код программиста тогда, когда это будет необходимо. Как следствие, происходит утеря контроля над выполнением кода — это и называется инверсией управления (фреймворк управляет кодом программиста, а не программист управляет фреймворком).

Одной из реализаций инверсии управления в применении к управлению зависимостями является внедрение зависимостей (dependency injection).

--------------------------------------------------------------------------------------------------------------------
Что такое DI?

Внедрение зависимости (Dependency injection, DI) — процесс предоставления внешней зависимости программному компоненту. Является специфичной формой «инверсии управления» Inversion of control, IoC), когда она применяется к управлению зависимостями. В полном соответствии с принципом единственной ответственности объект отдаёт заботу о построении требуемых ему зависимостей внешнему, специально предназначенному для этого общему механизму.

Внедрение зависимости для Spring это и есть инициализация полей бинов другими бинами (зависимостями).

Ведь помимо создания объектов, Spring-контейнер внедряет эти объекты в другие объекты, то есть делает их полями других объектов. Иногда это выглядит магически - например, контейнер способен внедрить зависимость в поле с модификатором private, для которого нет сеттера. Как же код Spring может это сделать? Дело в том, что под капотом он использует рефлексию, так что это реально. Но эти детали для нас как разработчиков не важны, главное знать, как объяснить фреймворку, какие объекты вы хотите отдать под его управление, и в какие поля других объектов вы хотите их внедрить.

Кстати, шаблон Dependency Injection не привязан к Spring, это всего лишь инициализация поля класса. Это такая обычная вещь и так часто встречается в коде (через конструктор либо сеттер), что даже странно выделять ее в отдельный шаблон. В связи со Spring это название мелькает часто наверно потому, что внедрение выполняет Spring, и у программиста тут много возни с конфигурацией зависимостей. Но с другой стороны, создание и внедрение Spring-ом — это уже другой шаблон — инверсия контроля (IoC).

--------------------------------------------------------------------------------------------------------------------
Что такое IoC-контейнер?

Внедрение зависимости используется во многих фреймворках, которые называются IoC-контейнерами.
Если сравнить с более низкоуровневыми технологиями, IoC-контейнер — это компоновщик, который собирает не объектные файлы, а объекты ООП (экземпляры класса) во время исполнения программы. Очевидно, для реализации подобной идеи было необходимо создать не только сам компоновщик, но и фабрику, производящую объекты. Предоставление программисту инструментов внедрения зависимостей дало значительно бо́льшую гибкость в разработке и удобство в тестировании кода.

--------------------------------------------------------------------------------------------------------------------
Что такое Spring IoC?

Центральной частью Spring является подход Inversion of Control, который позволяет конфигурировать и управлять объектами Java с помощью рефлексии. Вместо ручного внедрения зависимостей, фреймворк забирает ответственность за это посредством контейнера. Контейнер отвечает за управление жизненным циклом объекта: создание объектов, вызов методов инициализации и конфигурирование объектов путём связывания их между собой.
Объекты, создаваемые контейнером, также называются управляемыми объектами (beans). Обычно, конфигурирование контейнера, осуществляется путём внедрения аннотаций (начиная с 5 версии J2SE), но также, есть возможность, по старинке, загрузить XML-файлы, содержащие определение bean'ов и предоставляющие информацию, необходимую для создания bean'ов.
Плюсы такого подхода:
отделение выполнения задачи от ее реализации;
легкое переключение между различными реализациями;
большая модульность программы;
более легкое тестирование программы путем изоляции компонента или проверки его зависимостей и обеспечения взаимодействия компонентов через контракты.
Объекты могут быть получены одним из двух способов:
Dependency Lookup Поиск зависимости — шаблон проектирования, в котором вызывающий объект запрашивает у объекта-контейнера экземпляр объекта с определённым именем или определённого типа.
Dependency Injection Внедрение зависимости — шаблон проектирования, в котором контейнер передает экземпляры объектов по их имени другим объектам с помощью конструктора, свойства или фабричного метода.

--------------------------------------------------------------------------------------------------------------------
Какие преимущества применения Dependency Injection (DI)?

К преимуществам DI можно отнести:

Сокращение объема связующего кода. Одним из самых больших плюсов DI является возможность значительного сокращения объема кода, который должен быть написан для связывания вместе различных компонентов приложения. Зачастую этот код очень прост - при создании зависимости должен создаваться новый экземпляр соответствующего объекта.

Упрощенная конфигурация приложения. За счет применения DI процесс конфигурирования приложения значительно упрощается. Для конфигурирования классов, которые могут быть внедрены в другие классы, можно использовать аннотации или XML-файлы.

Возможность управления общими зависимостями в единственном репозитории. При традиционном подходе к управлению зависимостями в общих службах, к которым относятся, например, подключение к источнику данных, транзакция, удаленные службы и т.п., вы создаете экземпляры (или получаете их из определенных фабричных классов) зависимостей там, где они нужны - внутри зависимого класса. Это приводит к распространению зависимостей по множеству классов в приложении, что может затруднить их изменение. В случае использования DI вся информация об общих зависимостях содержится в единственном репозитории (в Spring есть возможность хранить эту информацию в XML-файлах или Java классах).

Улучшенная возможность тестирования. Когда классы проектируются для DI, становится возможной простая замена зависимостей. Это особенно полезно при тестировании приложения.

Стимулирование качественных проектных решений для приложений. Вообще говоря, проектирование для DI означает проектирование с использованием интерфейсов. Используя Spring, вы получаете в свое распоряжение целый ряд средств DI и можете сосредоточиться на построении логики приложения, а не на поддерживающей DI платформе.

--------------------------------------------------------------------------------------------------------------------
Какие IoC контейнеры вы знаете?

Spring является IoC контейнером. Помимо него существуют HiveMind, Avalon, PicoContainer и т.д.

--------------------------------------------------------------------------------------------------------------------
Как реализуется DI в Spring Framework?

Внедрение зависимостей (DI) - это концепция, которая определяет, как должно быть связано несколько классов. Это один из примеров Инверсии контроля. Вам не нужно явно подключать службы и компоненты в коде при использовании внедрения зависимостей. Вместо этого вы описываете службы, необходимые каждому компоненту, в файле конфигурации XML и разрешаете контейнеру IOC автоматически подключать их.
Реализация DI в Spring основана на двух ключевых концепциях Java - компонентах JavaBean и интерфейсах. При использовании Spring в качестве поставщика DI вы получаете гибкость определения конфигурации зависимостей внутри своих приложений разнообразными путями (т.е. внешне в XML-файлах, с помощью конфигурационных Java классов Spring или посредством аннотаций Java в коде). Компоненты JavaBean (также называемые POJO (Plain Old Java Object — простой старый объект Java)) предоставляют стандартный механизм для создания ресурсов Java, которые являются конфигурируемыми множеством способов. За счет применения DI объем кода, который необходим при проектировании приложения на основе интерфейсов, снижается почти до нуля. Кроме того, с помощью интерфейсов можно получить максимальную отдачу от DI, потому что бины могут использовать любую реализацию интерфейса для удовлетворения их зависимости.ff

--------------------------------------------------------------------------------------------------------------------
Какие существуют виды DI?

DI можно делать через:
Поля класса
Сеттеры
Конструкторы

--------------------------------------------------------------------------------------------------------------------
Назовите некоторые из шаблонов проектирования, используемых в Spring Framework?

Вот некоторые известные паттерны, используемые в Spring Framework:

Chain of Responsibility - это поведенческий паттерн проектирования, который позволяет передавать запросы последовательно по цепочке обработчиков. Каждый последующий обработчик решает, может ли он обработать запрос сам и стоит ли передавать запрос дальше по цепи. Ему Spring Security

Singleton (Одиночка) - Паттерн Singleton гарантирует, что в памяти будет существовать только один экземпляр объекта, который будет предоставлять сервисы. Spring область видимости бина (scope) по умолчанию равна singleton и IoC-контейнер создаёт ровно один экземпляр объекта на Spring IoC-контейнер. Spring-контейнер будет хранить этот единственный экземпляр в кэше синглтон-бинов, и все последующие запросы и ссылки для этого бина получат кэшированный объект. Рекомендуется использовать область видимости singleton для бинов без состояния. Область видимости бина можно определить как singleton или как prototype (создаётся новый экземпляр при каждом запросе бина).

Model View Controller (Модель-Представление-Контроллер) - Преимущество Spring MVC в том, что ваши контроллеры являются POJO, а не сервлетами. Это облегчает тестирование контроллеров. Стоит отметить, что от контроллеров требуется только вернуть логическое имя представления, а выбор представления остаётся за ViewResolver. Это облегчает повторное использование контроллеров при различных вариантах представления.

Front Controller (Контроллер запросов) - Spring предоставляет DispatcherServlet, чтобы гарантировать, что входящий запрос будет отправлен вашим контроллерам.Паттерн Front Controller используется для обеспечения централизованного механизма обработки запросов, так что все запросы обрабатываются одним обработчиком. Этот обработчик может выполнить аутентификацию, авторизацию, регистрацию или отслеживание запроса, а затем передать запрос соответствующему контроллеру. View Helper отделяет статическое содержимое в представлении, такое как JSP, от обработки бизнес-логики.

Dependency injection и Inversion of control (IoC) (Внедрение зависимостей и инверсия управления) - IoC-контейнер в Spring, отвечает за создание объекта, связывание объектов вместе, конфигурирование объектов и обработку всего их жизненного цикла от создания до полного уничтожения. В контейнере Spring используется инъекция зависимостей (Dependency Injection, DI) для управления компонентами приложения. Эти компоненты называются "Spring-бины" (Spring Beans).

Service Locator (Локатор служб) - ServiceLocatorFactoryBean сохраняет информацию обо всех бинах в контексте. Когда клиентский код запрашивает сервис (бин) по имени, он просто находит этот компонент в контексте и возвращает его. Клиентскому коду не нужно писать код, связанный со Spring, чтобы найти бин. Паттерн Service Locator используется, когда мы хотим найти различные сервисы, используя JNDI. Учитывая высокую стоимость поиска сервисов в JNDI, Service Locator использует кеширование. При запросе сервиса первый раз Service Locator ищет его в JNDI и кэширует объект. Дальнейший поиск этого же сервиса через Service Locator выполняется в кэше, что значительно улучшает производительность приложения.

Observer-Observable (Наблюдатель) - Используется в механизме событий ApplicationContext. Определяет зависимость "один-ко-многим" между объектами, чтобы при изменении состояния одного объекта все его подписчики уведомлялись и обновлялись автоматически.

Context Object (Контекстный объект) - Паттерн Context Object, инкапсулирует системные данные в объекте-контексте для совместного использования другими частями приложения без привязки приложения к конкретному протоколу. ApplicationContext является центральным интерфейсом в приложении Spring для предоставления информации о конфигурации приложения.

Proxy (Заместитель) - позволяет подставлять вместо реальных объектов специальные объекты-заменители. Эти объекты перехватывают вызовы к оригинальному объекту, позволяя сделать что-то до или после передачи вызова оригиналу.

Factory (Фабрика) - определяет общий интерфейс для создания объектов в суперклассе, позволяя подклассам изменять тип создаваемых объектов.

Template (Шаблон) - Этот паттерн широко используется для работы с повторяющимся бойлерплейт кодом (таким как, закрытие соединений и т. п.).

--------------------------------------------------------------------------------------------------------------------
Что такое контейнер?

Container создаёт объекты, связывает их вместе, настраивает и управляет ими от создания до момента уничтожения. Spring Container получает инструкции какие объекты инстанциировать и как их конфигурировать через метаданные: XML, Аннотации или Java код .

Spring BeanFactory Container Это самый простой контейнер, который обеспечивает базовую поддержку DI и который основан на интерфейсе org.springframework.beans.factory.BeanFactory. Такие интерфейсы, как BeanFactoryAware и DisposableBean всё ещё присутствуют в Spring для обеспечения обратной совместимости.

Бины создаются при вызове метода getBean().

Наиболее часто используемая реализация интерфейса BeanFactory - XmlBeanFactory. XmlBeanFactory получает метаданные из конфигурационного XML файла и использует его для создания настроенного приложения или системы. BeanFactory обычно используется тогда, когда ресурсы ограничены (мобильные устройства). Поэтому, если ресурсы не сильно ограничены, то лучше использовать ApplicationContext.

Spring ApplicationContext Container ApplicationContext является более сложным и более продвинутым Spring Container-ом. Наследует BeanFactory и так же загружает бины, связывает их вместе и конфигурирует их определённым образом. Но кроме этого, ApplicationContext обладает дополнительной функциональностью: общий механизм работы с ресурсами, распознание текстовых сообщений из файлов настройки и отображение событий, которые происходят в приложении различными способами. Этот контейнер определяется интерфейсом org.springframework.context.ApplicationContext.

--------------------------------------------------------------------------------------------------------------------
Что такое Spring бин?

Термин бин (англ. Bean) - в Spring используется для ссылки на любой компонент, управляемый контейнером. Обычно бины на определенном уровне придерживаются спецификации JavaBean, но это не обязательно особенно если для связывания бинов друг с другом планируется применять Constructor Injection. Для получения экземпляра бина используется ApplicationContext. IoC контейнер управляет жизненным циклом спринг бина, областью видимости и внедрением.

--------------------------------------------------------------------------------------------------------------------
Какое значение имеет конфигурационный файл Spring Bean?

Конфигурационный файл спринг определяет все бины, которые будут инициализированы в Spring Context. При создании экземпляра Spring ApplicationContext будет прочитан конфигурационный xml файл и выполнены указанные в нем необходимые инициализации. Отдельно от базовой конфигурации, в файле могут содержаться описание перехватчиков (interceptors), view resolvers, настройки локализации и др...

--------------------------------------------------------------------------------------------------------------------
Каковы различные способы настроить класс как Spring Bean?

Существует несколько способов работы с классами в Spring: XML конфигурация:

Java based конфигурация. Все настройки и указания бинов прописываются в java коде:

Annotation based конфигурация. Можно использовать внутри кода аннотации @Component, @Service, @Repository, @Controller для указания классов в качестве спринг бинов. Для их поиска и управления контейнером прописывается настройка в xml файле:

--------------------------------------------------------------------------------------------------------------------
Какие вы знаете различные scope у Spring Bean?

В Spring предусмотрены различные области времени действия бинов:
Singleton
Prototype
Request
Session
Application
WebSocket - жизненный цикл WebSocket

--------------------------------------------------------------------------------------------------------------------
Что знаете про scope Singleton

Может быть создан только один экземпляр бина. Этот тип используется спрингом по умолчанию, если не указано другое. Следует осторожно использовать публичные свойства класса, т.к. они не будут потокобезопасными.

Spring создает Singleton бины при загрузке контекста и присваивает им имена (иначе, ID бина). Эта область видимости называется Singleton, поскольку при обращении к конкретному бину мы всегда получаем один и тот же экземпляр.

Но будьте внимательны! В контексте Spring может существовать несколько экземпляров одного типа, но с разными именами. Я особенно акцентирую этот момент. Вероятно, для обозначения шаблонов проектирования вам уже встречалось слово «одиночка» (синглтон). Если нет, то вы не спутаете его с одиночной областью видимости бинов — можете пропустить следующий абзац.

--------------------------------------------------------------------------------------------------------------------
Что знаете про scope Prototype

Каждый раз, когда запрашивается ссылка на прототипный бин, Spring создает новый экземпляр объекта. В случае прототипных бинов Spring не создает сам объект и не управляет им. Фреймворк управляет только типом объекта и создает новый экземпляр всякий раз, когда какой-либо объект запрашивает ссылку на этот бин..

--------------------------------------------------------------------------------------------------------------------
Что знаете про scope Request

Spring создает отдельный экземпляр класса бина для каждого HTTP-запроса. Конкретный экземпляр существует только для конкретного HTTP-запроса. Для каждого следующего HTTP-запроса (от того же или другого клиента) создается и используется новый бин

--------------------------------------------------------------------------------------------------------------------
Что знаете про scope Session

Spring создает экземпляр и хранит его в памяти сервера в течение всей HTTP-сессии. Фреймворк связывает этот экземпляр в контексте с сессией данного клиента.

Бин с областью видимости в рамках сессии — это управляемый Spring объект, для которого фреймворк создает экземпляр, привязанный к текущей HTTP-сессии. Когда клиент посылает запрос на сервер, сервер выделяет в памяти место для этого запроса на все время сессии, к которой данный запрос относится. Spring создает экземпляр бина с областью видимости в рамках сессии в начале HTTP-сессии для данного клиента. Этот экземпляр может многократно использоваться одним и тем же клиентом, пока HTTP-сессия остается активной. Данные в атрибутах бина с областью видимости в рамках сессии доступны для всех запросов клиента в рамках сессии. Такой способ хранения данных позволяет не потерять информацию о том, что делает пользователь, пока переходит по страницам приложения.
При всех запросах, передаваемых в рамках одной HTTP-сессии, клиент получает доступ к одному и тому же экземпляру бина. У каждого пользователя есть своя сессия, поэтому они получают доступ к собственным бинам, имеющим область видимости в рамках сессии.
Потратим некоторое время на анализ

--------------------------------------------------------------------------------------------------------------------
Что знаете про scope Application

Экземпляр является уникальным в контексте приложения и доступен все время работы приложения.

Бин с областью видимости Application доступен для всех запросов от всех клиентов . Он похож на Singleton. Различие состоит в том, что в данном случае нельзя создать в контексте несколько экземпляров. Кроме того, когда мы говорим о жизненном цикле бинов Application (включая область видимости в рамках всего веб-приложения), отправной точкой всегда являются HTTP-запросы. В случае бинов с областью видимости в рамках приложения возникают те же проблемы конкурентности, которые были описаны для Singleton бинов. Желательно, чтобы атрибуты Singleton бинов были неизменяемыми. Тот же совет касается и бинов с областью видимости Application. Но если сделать атрибуты неизменяемыми, вместо бина с областью видимости Application можно просто использовать Singleton.

--------------------------------------------------------------------------------------------------------------------
Как связаны различные скоупы и многопоточность?

Prototype Scope не потокбезопасный, т.к. он не гарантирует что один и тот же экземпляр будет вызываться только в 1 потоке.
Singleton Scope же наоборот потокобезопасный.

--------------------------------------------------------------------------------------------------------------------
Как создаются бины: сразу или лениво? Как изменить это поведение?

Singleton-бины обычно создаются сразу при сканировании.Prototype-бины обычно создаются только после запроса.
Чтобы указать способ инициализации, можно использовать аннотацию @Lazy. Она ставится на @Bean-методы, на @Configuration-классы, или на @Component-классы.В зависимости от параметра(true или false), который принимает аннотация, инициализация будет или ленивая, или произойдет сразу. По умолчанию(т.е. без указания параметра) используется true.

--------------------------------------------------------------------------------------------------------------------
Что будет если бин с одним скоупом внедрить в бин с другим скоупом?

Singleton bean можно внедрять в любой другой бин.
В сам singleton можно внедрить только prototype или singleton.Если внедрять prototype, то для каждого singleton будет создан уникальный prototype.
Prototype может быть зависимостью для любого бина.Внедрять можно только singleton или prototype.

--------------------------------------------------------------------------------------------------------------------
Как работает инъекция прототипа в синглтон?

1) В аннотации @Scope кроме самого scopeName доступен второй параметр - proxyMode. По умолчанию его значение NO - прокси не создается. Но если указать INTERFACES или TARGET_CLASS, то под @Autowired будет внедряться не сам объект, а сгенерированный фреймворком прокси. И когда проксируемый бин имеет скоуп prototype, то объект внутри прокси будет пересоздаваться при каждом обращении.

2) Spring предоставляет интерфейс ObjectFactory<T> для создания объектов по требованию заданного типа:

public class SingletonObjectFactoryBean {

@Autowired
private ObjectFactory<PrototypeBean> prototypeBeanObjectFactory;

public PrototypeBean getPrototypeInstance() {
return prototypeBeanObjectFactory.getObject()
}

}

Давайте посмотрим на метод getPrototypeInstance(); GetObject() возвращает совершенно новый экземпляр PrototypeBean для каждого запроса. Здесь у нас больше контроля над инициализацией прототипа.
Кроме того, ObjectFactory является частью фреймворка; это означает, что для использования этой опции не требуется дополнительной настройки.

ObjectProvider, расширение существующего интерфейса ObjectFactory с удобными сигнатурами, такими как getIfAvailable и getIfUnique, для извлечения компонента, только если он существует или если может быть определен один кандидат (в частности: основной кандидат в случае нескольких совпадающих компонентов).

--------------------------------------------------------------------------------------------------------------------
Объясните работу BeanFactory в Spring.

BeanFactory - это реализация паттерна Фабрика, его функицональность покрывает создание бинов. Так как эта фабрика знает многие об объектах приложения, то она может создавать связи между объектами на этапе создания экземпляра. Существует несколько реализаций BeanFactory, самая используемся - "org.springframework.beans.factory.xml.XmlBeanFactory". Она загружает бины на основе конфигурационного XML-файла. Чтобы создать XmlBeanFactory передайте конструктору InputStream, например:

BeanFactory factory = new XmlBeanFactory(new FileInputStream("myBean.xml"));

После этой строки фабрика знает о бинах, но их экземпляры еще не созданы. Чтобы инстанцировать бин нужно вызвать метод getBean(). Например:
myBean bean1 = (myBean)factory.getBean("myBean");

--------------------------------------------------------------------------------------------------------------------
В чем разница между BeanFactory и ApplicationContext?

BeanFactory - это базовый, компактный контейнер с ограниченной функциональностью. Его лучше всего использовать для простых задач или при использовании машин с низким ресурсом.
ApplicationContext - это расширенный, более интенсивный контейнер с расширенным интерфейсом и дополнительными возможностями, такими как AOP.

ApplicationContext загружает все бины при запуске, а BeanFactory - по требованию.

ApplicationContext расширяет BeanFactory и предоставляет функции, которые подходят для корпоративных приложений: a. поддержка внедрения зависимостей на основе аннотаций; b. удобный доступ к MessageSource (для использования в интернационализации); c. публикация ApplicationEvent - для бинов, реализующих интерфейс ApplicationListener, с помощью интерфейса ApplicationEventPublisher; d. простая интеграция с функциями Spring AOP.

ApplicationContext поддерживает автоматическую регистрацию BeanPostProcessor и BeanFactoryPostProcessor. Поэтому всегда желательно использовать ApplicationContext, потому что Spring 2.0 (и выше) интенсивно использует BeanPostProcessor.

ApplicationContext поддерживает практически все типы scope для бинов, а BeanFactory поддерживает только два - Singleton и Prototype.

В BeanFactory не будут работать транзакции и Spring AOP. Это может привести к путанице, потому что конфигурация с виду будет корректной

--------------------------------------------------------------------------------------------------------------------
В чем роль ApplicationContext в Spring?

В то время, как BeanFactory используется в простых приложениях, Application Context - это более сложный контейнер. Как и BeanFactory он может быть использован для загрузки и связывания бинов, но еще он предоставляет:

возможность получения текстовых сообщений, в том числе поддержку интернационализации;

общий механизм работы с ресурсами;

события для бинов, которые зарегестрированы как слушатели.

Из-за большей функциональности рекомендуется использование Application Context вместо BeanFactory. Последний используется только в случаях нехватки ресурсов, например при разработке для мобильных устройств

--------------------------------------------------------------------------------------------------------------------
Как получить ApplicationContext в интеграционном тесте?

Если вы используете JUnit 5, то вам нужно указать 2 аннотации:
@ExtendWith(TestClass.class) — используется для указания тестового класса
@ContextConfoguration(classes = JavaConfig.class) — загружает java/xml конфигурацию для создания контекста в тесте
Можно использовать аннотацию @SpringJUnitConfig, которая сочетает обе эти аннотации.Для теста веб-слоя можно использовать аннотацию @SpringJUnitWebConfig.

--------------------------------------------------------------------------------------------------------------------
Как завершить работу контекста в приложении?

Если это не веб-приложение, то есть 2 способа:
Регистрация shutdown-hook с помощью вызова метода registerShutdownHook(), он также реализован в классе AbstractApplicationContext. Это предпочтительный способ.
Можно вызвать метод close() из класса AbstractApplicationContext.
В Spring Boot приложении:
Spring Boot самостоятельно зарегистрирует shutdown-hook за вас.

--------------------------------------------------------------------------------------------------------------------
Для чего нужен Component Scan?

Если вы понимаете как работает Component Scan, то вы понимаете Spring
Первый шаг для описания Spring Beans это добавление аннотации — @Component, или @Service, или @Repository.
Однако, Spring ничего не знает об этих бинах, если он не знает где искать их. То, что скажет Spring где искать эти бины и называется Component Scan. В @ComponentScan вы указываете пакеты, которые должны сканироваться.
Spring будет искать бины не только в пакетах для сканирования, но и в их подпакетах.

--------------------------------------------------------------------------------------------------------------------
Различия @Component, @Service, @Repository, @Controller

Они все служат для обозначения класса как Бин.
@Component - Spring определяет этот класс как кандидата для создания bean.
@Service - класс содержит бизнес-логику и вызывает методы на уровне хранилища. Ничем не отличается от классов с @Component.
@Repository - указывает, что класс выполняет роль хранилища (объект доступа к DAO). При этом отлавливает определенные исключения персистентности и пробрасывает их как одно непроверенное исключение Spring Framework. Для этого Spring оборачивает эти классы в прокси, и в контекст должен быть добавлен класс PersistenceExceptionTranslationPostProcessor
@Controller - указывает, что класс выполняет роль контроллера MVC. Диспетчер сервлетов просматривает такие классы для поиска @RequestMapping.

--------------------------------------------------------------------------------------------------------------------
Как вы добавите Component Scan в Spring Boot?

@SpringBootApplication public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } }
@SpringBootApplication определяет автоматическое сканирование пакета, где находится класс Application
Всё будет в порядке, ваш код целиком находится в указанном пакете или его подпакетах.
Однако, если необходимый вам компонент находится в другом пакете, вы должны использовать дополнительно аннотацию @ComponentScan, где перечислите все дополнительные пакеты для сканирования

--------------------------------------------------------------------------------------------------------------------
Для чего используется аннотация @Bean?

В классах конфигурации Spring, @Bean используется для определения компонентов с кастомной логикой.

--------------------------------------------------------------------------------------------------------------------
Почему для создания Spring beans рекомендуются интерфейсы?

Улучшенное тестирование. В тестах бин может быть заменен специальным объектом(mock или stub), который реализует интерфейс бина.
Позволяет использовать механизм динамических прокси из JDK(например, при создании репозитория через Spring Data)
Позволяет скрывать реализацию

--------------------------------------------------------------------------------------------------------------------
Как внедряется singleton-бин?

Если в контейнере нет экземпляра бина, то вызывается @Bean-метод. Если экземпляр бина есть, то возвращается уже созданный бин.

--------------------------------------------------------------------------------------------------------------------
В чём разница между @Bean и @Component?

@Bean используется в конфигурационных классах Spring. Он используется для непосредственного создания бина.
@Component используется со всеми классами, которыми должен управлять Spring. Когда Spring видит класс с @Component, Spring определяет этот класс как кандидата для создания bean.

--------------------------------------------------------------------------------------------------------------------
Можем ли мы применить @Autowired с не сеттерами и не конструкторами методами?

Да, конечно.
@Autowired может использоваться вместе с конструкторами, сеттерами или любым другими методами. Когда Spring находит @Autowired на методе, Spring автоматически вызовет этот метод, после создания экземпляра бина. В качестве аргументов, будут подобраны подходящие объекты из контекста Spring.

--------------------------------------------------------------------------------------------------------------------
Как внедрить простые значения в свойства в Spring?

Для этого можно использовать аннотацию @Value.Такие значения можно получать из property файлов, из бинов, и т.п.
@Value("$some.key") public String stringWithDefaultValue;
В эту переменную будет внедрена строка, например из property или из view.

--------------------------------------------------------------------------------------------------------------------
Как вы решаете какой бин инжектить, если у вас несколько подходящих бинов. Расскажите о @Primary и @Qualifier?

Если есть бин, который вы предпочитаете большую часть времени по сравнению с другими, то используйте @Primary, и используйте @Qualifier для нестандартных сценариев.
Если все бины имеют одинаковый приоритет, мы всегда будем использовать @Qualifier
Если бин надо выбрать во время исполнения программы, то эти аннотации вам не подойдут. Вам надо в конфигурационном классе создать метод, пометить его аннотацией @Bean, и вернуть им требуемый бин.

--------------------------------------------------------------------------------------------------------------------
Что такое связывание в Spring и расскажите об аннотации @Autowired?

Процесс внедрения зависимостей в бины при инициализации называется Spring Bean Wiring. Считается хорошей практикой задавать явные связи между зависимостями, но в Spring предусмотрен дополнительный механизм связывания @Autowired. Аннотация может использоваться над полем или методом для связывания по типу. Чтобы аннотация заработала, необходимо указать небольшие настройки в конфигурационном файле спринг с помощью элемента context:annotation-config.

--------------------------------------------------------------------------------------------------------------------
Опишите поведение аннотации @Autowired

1) Контейнер определяет тип объекта для внедрения
2) Контейнер ищет бины в контексте(он же контейнер), которые соответствуют нужному типу
3) Если есть несколько кандидатов, и один из них помечен как @Primary, то внедряется он
4) Если используется аннотации @Autowire + Qualifier, то контейнер будет использовать информацию из @Qualifier, чтобы понять, какой компонент внедрять
5) В противном случае контейнер попытается внедрить компонент, основываясь на его имени или ID
6) Если ни один из способов не сработал, то будет выброшено исключение

Контейнер обрабатывает DI с помощью AutowiredAnnotationBeanPostProcessor. В связи с этим, аннотация не может быть использована ни в одном BeanFactoryPP или BeanPP.

Если внедряемый объект массив, коллекция, или map с дженериком, то Spring внедрит все бины подходящие по типу в этот массив(или другую структуру данных). В случае с map ключом будет имя бина.
//параметр указывает, требуется ли DI @Authowired(required = true/false)

--------------------------------------------------------------------------------------------------------------------
Аннотация Qualifier

Данная аннотация позволяет несколько специфицировать бин, который необходим для @Autowired. @Qualifier принимает один входной параметр — имя бина.

@Autowired@Qualifier("specialTestBean")
private TestBean bean;
* This source code was highlighted with Source Code Highlighter.

Эта конструкция будет искать в контексте бин с именем specialTestBean и в нашем примере мы соответственно получим исключение, так как TestBean объявлен с именем 'testBean' (@Service(«testBean»)).На основе @Qualifier можно создавать свои признаки бинов, об этом достаточно хорошо написано (и, что немаловажно, с огромным количеством примеров) в Spring Reference Manual.

--------------------------------------------------------------------------------------------------------------------
Каковы различные типы автоматического связывания в Spring?

Существует четыре вида связывания в спринг:
autowire byName,
autowire byType,
autowire by constructor,
autowiring by @Autowired and @Qualifier annotations

--------------------------------------------------------------------------------------------------------------------
Приведите пример часто используемых аннотаций Spring.

@Controller - класс фронт контроллера в проекте Spring MVC.
@RequestMapping - позволяет задать шаблон маппинга URI в методе обработчике контроллера.
@ResponseBody - позволяет отправлять Object в ответе. Обычно используется для отправки данных формата XML или JSON.
@PathVariable - задает динамический маппинг значений из URI внутри аргументов метода обработчика.
@Autowired - используется для автоматического связывания зависимостей в spring beans.
@Qualifier - используется совместно с @Autowired для уточнения данных связывания, когда возможны коллизии (например одинаковых имен\типов).
@Service - указывает что класс осуществляет сервисные функции.
@Scope - указывает scope у spring bean.
@Configuration, @ComponentScan и @Bean - для java based configurations.
AspectJ аннотации для настройки aspects и advices, @Aspect, @Before, @After,@Around, @Pointcut и др.

--------------------------------------------------------------------------------------------------------------------
Что такое профили? Какие у них причины использования?

Используя аннотацию @Profile - мы сопоставляем bean-компонент с этим конкретным профилем; аннотация просто берет имена одного (или нескольких) профилей. Отвечает за то - какие бины буду создаваться, в зависимости от профайла. Фактически реализована с помощью гораздо более гибкой аннотации @Conditional.
Рассмотрим базовый сценарий - у нас есть компонент, который должен быть активным только во время разработки, но не должен использоваться в производстве. Мы аннотируем этот компонент с профилем «dev», и он будет присутствовать в контейнере только во время разработки - в производственном процессе dev просто не будет активен.
Или можно задать @Profile("postgres") и @Profile("mysql"), а в application.properties указать, бин с каким профилем использовать = spring.profiles.active = mysql
По умолчанию, если профиль бина не определен, то он относится к профилю "default". Spring также предоставляет способ установить профиль по умолчанию, когда другой профиль не активен, используя свойство «spring.profiles.default»

--------------------------------------------------------------------------------------------------------------------
Что делает @LookUp

Используется для внедрения prototype bean в singleton bean.
ПРИМЕР - Обычно бины в приложении Spring являтся синглтонами, и для внедрения зависимостей мы используем конструктор или сеттер. Но бывает и другая ситуация: имеется бин Car - синглтон (singleton bean), и ему требуется каждый раз новый экземпляр бина Passenger. То есть Car - синглтон, а Passenger - так называемый прототипный бин (prototype bean). Жизненные циклы бинов разные. Бин Car создается контейнером только раз, а бин Passenger создается каждый раз новый - допустим, это происходит каждый раз при вызове какого-то метода бина Car.Вот здесь то и пригодится внедрение бина с помощью Lookup метода. Оно происходит не при инициализации контейнера, а позднее: каждый раз, когда вызывается метод.

@Component
public class Car {

@Lookup
public Passenger createPassenger() {
return null;
}

public String drive(String name) {
Passenger passenger = createPassenger(); passenger.setName(name);
return "car with " + passenger.getName();
}
}

Суть в том, что вы создаете метод-заглушку в бине Car и помечаете его специальным образом - аннотацией @Lookup. Этот метод должен возвращать бин Passenger, каждый раз новый. Контейнер Spring под капотом создаст подкласс и переопределит этот метод и будет вам выдавать новый экземпляр бина Passenger при каждом вызове аннотированного метода. Даже если в вашей заглушке он возвращает null (а так и надо делать, все равно этот метод будет переопределен).

@Component
@Scope("prototype")
public class Passenger {
private String name;
public String getName() {
return name; }
public void setName(String name) {
this.name = name;
}
}

Теперь при вызове метода drive() мы можем везти каждый раз нового пассажира. Имя его передаётся в аргументе метода drive(), и затем задается сеттером во вновь созданном экземпляре пассажира.

--------------------------------------------------------------------------------------------------------------------
Что такое @Resource

Java-аннотация @Resource может применяться к классам, полям и методам. Она пытается получить зависимость: сначала по имени, затем по типу, затем по описанию (Qualifier). Имя извлекается из имени аннотируемого сеттера или поля, либо берется из параметра name. При аннотировании классов имя не извлекается из имени класса по умолчанию, поэтому оно должно быть указано явно.
Указав данную аннотацию у полей или методов с аргументом name, в контейнере будет произведен поиск компонентов с данным именем, и в контейнере должен быть бин с таким именем:

@Resource(name="namedFile")
private File defaultFile;

Если указать её без аргументов, то Spring Framework поможет найти бин по типу. Если в контейнере несколько бинов-кандидатов на внедрение, то нужно использовать аннотацию @Qualifier:

@Resource
@Qualifier("defaultFile")
private File dependency1;

@Resource
@Qualifier("namedFile")
private File dependency2;

Разница с @Autowired:
ищет бин сначала по имени, а потом по типу;
не нужна дополнительная аннотация для указания имени конкретного бина;
@Autowired позволяет отметить место вставки бина как необязательное @Autowired(required = false);
при замене Spring Framework на другой фреймворк, менять аннотацию @Resource не нужно

--------------------------------------------------------------------------------------------------------------------
Что делает @Inject

Размещается над полями, методами, и конструкторами с аргументами. @Inject как и @Autowired в первую очередь пытается подключить зависимость по типу, затем по описанию и только потом по имени. Это означает, что даже если имя переменной ссылки на класс отличается от имени компонента, но они одинакового типа, зависимость все равно будет разрешена:

@Inject
private ArbitraryDependency fieldInjectDependency; //fieldInjectDependency - отличается от имени компонента, настроенного в контексте приложения:

@Bean
public ArbitraryDependency injectDependency() { ArbitraryDependency injectDependency = new ArbitraryDependency();
return injectDependency;
}

Разность имён injectDependency и fieldInjectDependency не имеет значения, зависимость будет подобрана по типу ArbitraryDependency. Если в контейнере несколько бинов-кандидатов на внедрение, то нужно использовать аннотацию @Qualifier:

@Inject
@Qualifier("defaultFile")
private ArbitraryDependency defaultDependency;

@Inject
@Qualifier("namedFile")
private ArbitraryDependency namedDependency;

//При использовании конкретного имени (Id) бина используем @Named:

@Inject
@Named("yetAnotherFieldInjectDependency")
private ArbitraryDependency yetAnotherFieldInjectDependency

--------------------------------------------------------------------------------------------------------------------
@Autowired vs @Resource vs @Inject

Аннотации для внедрения зависимостей.
@Resource (java) пытается получить зависимость: по имени, по типу, затем по описанию. Имя извлекается из имени аннотируемого сеттера или поля, либо берется из параметра name.
@Inject (java) или @Autowired (spring) в первую очередь пытается подключить зависимость по типу, затем по описанию и только потом по имени.

--------------------------------------------------------------------------------------------------------------------
Можем ли мы послать объект как ответ метода обработчика контроллера?

Да, это возможно. Для этого используется аннотация @ResponseBody. Так можно отправлять ответы в виде JSON, XML в restful веб сервисах.

--------------------------------------------------------------------------------------------------------------------
Является ли Spring bean потокобезопасным?

По умолчанию бин задается как синглтон в Spring. Таким образом все публичные переменные класса могут быть изменены одновременно из разных мест. Так что - нет, не является. Однако поменяв область действия бина на request, prototype, session он станет потокобезопасным, но это скажется на производительности.

--------------------------------------------------------------------------------------------------------------------
Как создать ApplicationContext в программе Java?

В независимой Java программе ApplicationContext можно создать следующим образом:

FileSystemXmlApplicationContext - Загружает данные о бине из XML файла. При использовании этой реализации в конструкторе необходимо указать полный адрес конфигурационного файла.

ClassPathXmlApplicationContext - Этот контейнер также получает данные о бине из XML файла. Но в отличие от FileSystemApplicationContext, в этом случае необходимо указать относительный адрес конфигурационного файла (CLASSPATH).

AnnotationConfigApplicationContext — метаданные конфигурируются с помощью аннотаций прямо на классах.

WebApplicationContext — для веб-приложений

GenericGroovyApplicationContext - эта конфигурация работает по сути так же, как и Xml, только с Groovy-файлами. К тому же, GroovyApplicationContext нормально работает и с Xml-файлом. Принимает на в

--------------------------------------------------------------------------------------------------------------------
Можем ли мы иметь несколько файлов конфигурации Spring?

С помощью указания contextConfigLocation можно задать несколько файлов конфигурации Spring. Параметры указываются через запятую или пробел:

Поддерживается возможность указания нескольких корневых файлов конфигурации Spring:

Файл конфигурации можно импортировать:

--------------------------------------------------------------------------------------------------------------------
Как внедрить java.util.Properties в Spring Bean?

Для возможности использования Spring EL для внедрения свойств (properties) в различные бины необходимо определить propertyConfigure bean, который будет загружать файл свойств.
Или через аннотации @Value

--------------------------------------------------------------------------------------------------------------------
Что делает @PostConstruct

Spring вызывает методы, аннотированные @PostConstruct, только один раз, сразу после инициализации свойств компонента. За данную аннотацию отвечает один из BeanPostProcessor-ов.
Метод, аннотированный @PostConstruct, может иметь любой уровень доступа, может иметь любой тип возвращаемого значения (хотя тип возвращаемого значения игнорируется Spring-ом), метод не должен принимать аргументы. Он также может быть статическим, но преимуществ такого использования метода нет, т.к. доступ у него будет только к статическим полям/методам бина, и в таком случае смысл его использования для настройки бина пропадает.
Одним из примеров использования @PostConstruct является заполнение базы данных. Например, во время разработки нам может потребоваться создать пользователей по умолчанию.

--------------------------------------------------------------------------------------------------------------------
Что делает @PreDestroy

Метод, аннотированный @PreDestroy, запускается только один раз, непосредственно перед тем, как Spring удаляет наш компонент из контекста приложения.
Как и в случае с @PostConstruct, методы, аннотированные @PreDestroy, могут иметь любой уровень доступа, но не могут быть статическими.

Целью этого метода может быть освобождение ресурсов или выполнение любых других задач очистки до уничтожения бина, например, закрытие соединения с базой данных.

Обратите внимание, что аннотации @PostConstruct и @PreDestroy являются частью Java EE, а именно пакета javax.annotation модуля java.xml.ws.annotation. И поскольку Java EE устарела в Java 9, то с этой версии пакет считается устаревшим (Deprecated). С Java 11 данный пакет вообще удален, поэтому мы должны добавить дополнительную зависимость для использования этих аннотаций:

<dependency> 
<groupId>javax.annotation</groupId> <artifactId>javax.annotation-api</artifactId> <version>1.3.2</version> 
</dependency>

--------------------------------------------------------------------------------------------------------------------
Этапы инициализации контекста Spring

1. Парсирование конфигурации и создание BeanDefinition
2. Настройка созданных BeanDefinition
3. Создание кастомных FactoryBean (только для XML-конфигурации)
4. Создание экземпляров бинов
5. Настройка созданных бинов
6. Бины готовы к использованию
7. Закрытие контекста

--------------------------------------------------------------------------------------------------------------------
Этап Парсирование конфигурации и создание BeanDefinition

Цель первого этапа — это создание всех BeanDefinition. Объекты BeanDefinition — это набор метаданных будущего бина, макет, по которому нужно будет создавать бин в случае необходимости. То есть для каждого бина создается свой объект BeanDefinition, в котором хранится описание того, как создавать и управлять этим конкретным бином. Проще говоря, сколько бинов в программе - столько и объектов BeanDefinition, их описывающих.

BeanDefinition содержат (среди прочего) следующие метаданные:

Имя класса с указанием пакета: обычно это фактический класс бина.

Элементы поведенческой конфигурации бина, которые определяют, как бин должен вести себя в контейнере (scope, обратные вызовы жизненного цикла и т.д.).

Ссылки на другие bean-компоненты, которые необходимы для его работы. Эти ссылки также называются зависимостями.

Другие параметры конфигурации для установки во вновь созданном объекте - например, ограничение размера пула или количество соединений, используемых в бине, который управляет пулом соединений.

Эти метаданные преобразуются в набор свойств, которые составляют каждое BeanDefinition.

При конфигурации через аннотации с указанием пакета для сканирования или JavaConfig используется класс AnnotationConfigApplicationContext.

Если заглянуть во внутрь AnnotationConfigApplicationContext, то можно увидеть два поля.
private final AnnotatedBeanDefinitionReader reader; private final ClassPathBeanDefinitionScanner scanner;

ClassPathBeanDefinitionScanner сканирует указанный пакет на наличие классов помеченных аннотацией @Component (или любой другой аннотацией которая включает в себя @Component). Найденные классы парсируются и для них создаются BeanDefinition.Чтобы сканирование было запущено, в конфигурации должен быть указан пакет для сканирования.
@ComponentScan({"package.name"})

AnnotatedBeanDefinitionReader работает в несколько этапов.
Первый этап — это регистрация всех @Configuration для дальнейшего парсирования. Если в конфигурации используются Conditional, то будут зарегистрированы только те конфигурации, для которых Condition вернет true. Аннотация Conditional появилась в четвертой версии спринга. Она используется в случае, когда на момент поднятия контекста нужно решить, создавать бин/конфигурацию или нет. Причем решение принимает специальный класс, который обязан реализовать интерфейс Condition.

Второй этап — это регистрация специального BeanFactoryPostProcessor, а именно BeanDefinitionRegistryPostProcessor, который при помощи класса ConfigurationClassParser парсирует JavaConfig и создает BeanDefinition, создаёт граф зависимостей (между бинами) и создаёт:

Map<String, BeanDefinition> beanDefinitionMap = new ConcurrentHashMap<>(256);

в которой хранятся все описания бинов, обнаруженных в ходе парсинга конфигурации.

--------------------------------------------------------------------------------------------------------------------
Этап Настройка созданных BeanDefinition

После первого этапа у нас имеется Map, в котором хранятся BeanDefinition. Архитектура спринга построена таким образом, что у нас есть возможность повлиять на то, какими будут наши бины еще до их фактического создания, иначе говоря мы имеем доступ к метаданным класса. Для этого существует специальный интерфейс BeanFactoryPostProcessor, реализовав который, мы получаем доступ к созданным BeanDefinition и можем их изменять. В этом интерфейсе всего один метод.

public interface BeanFactoryPostProcessor { void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException; }

Метод postProcessBeanFactory принимает параметром ConfigurableListableBeanFactory. Данная фабрика содержит много полезных методов, в том числе getBeanDefinitionNames, через который мы можем получить все BeanDefinitionNames, а уже потом по конкретному имени получить BeanDefinition для дальнейшей обработки метаданных.

Давайте разберем одну из родных реализаций интерфейса BeanFactoryPostProcessor. Обычно, настройки подключения к базе данных выносятся в отдельный property файл, потом при помощи PropertySourcesPlaceholderConfigurer они загружаются и делается inject этих значений в нужное поле. Так как inject делается по ключу, то до создания экземпляра бина нужно заменить этот ключ на само значение из property файла. Эта замена происходит в классе, который реализует интерфейс BeanFactoryPostProcessor. Название этого класса — PropertySourcesPlaceholderConfigurer. Весь этот процесс можно увидеть на рисунке ниже.Давайте еще раз разберем что же у нас тут происходит. У нас имеется BeanDefinition для класса ClassName. Код класса приведен ниже.

@Component
public class ClassName {
@Value("${host}")
private String host;
@Value("${user}")
private String user;
@Value("${password}")
private String password;
@Value("${port}")
private Integer port;
}

Если PropertySourcesPlaceholderConfigurer не обработает этот BeanDefinition, то после создания экземпляра ClassName, в поле host проинжектится значение — "${host}" (в остальные поля проинжектятся соответсвующие значения). Если PropertySourcesPlaceholderConfigurer все таки обработает этот BeanDefinition, то после обработки, метаданные этого класса будут выглядеть следующим образом.

@Component
public class ClassName {
@Value("127.0.0.1")
private String host;
@Value("root")
private String user;
@Value("root")
private String password;
@Value("27017")
private Integer port;
}

Соответственно в эти поля проинжектятся правильные значения.Для того что бы PropertySourcesPlaceholderConfigurer был добавлен в цикл настройки созданных BeanDefinition, нужно сделать одно из следующих действий.

@Configuration @PropertySource("classpath:property.properties")
public class DevConfig {
@Bean public static PropertySourcesPlaceholderConfigurer configurer() { return new PropertySourcesPlaceholderConfigurer();
}
}

PropertySourcesPlaceholderConfigurer обязательно должен быть объявлен как static. Без static у вас все будет работать до тех пор, пока вы не попробуете использовать @Value внутри класса @Configuration.

--------------------------------------------------------------------------------------------------------------------
Этап Создание экземпляров бинов

Сначала BeanFactory из коллекции Map с объектами BeanDefinition вначале достает определения этих BeanPostProcessor-ов, создает их и кладет в сторону, т.е. в первую очередь он создаст те бины, которые имплементируют интерфейс BeanPostProcessor и с их помощью будет потом настраивать все остальные бины. Создаются экземпляры бинов через BeanFactory на основе ранее созданных BeanDefinition

--------------------------------------------------------------------------------------------------------------------
Этап Настройка созданных бинов

На данном этапе бины уже созданы, мы можем лишь их донастроить.

Интерфейс BeanPostProcessor позволяет вклиниться в процесс настройки наших бинов до того, как они попадут в контейнер. ApplicationContext автоматически обнаруживает любые бины с реализацией BeanPostProcessor и помечает их как "post-processors" для того, чтобы создать их определенным способом. Например, в Spring есть реализации BeanPostProcessor-ов, которые обрабатывают аннотации @Autowired, @Inject, @Value и @Resource.

Интерфейс несет в себе несколько методов.

public interface BeanPostProcessor {
Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException;
Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;
}
Оба метода вызываются для каждого бина. У обоих методов параметры абсолютно одинаковые. Разница только в порядке их вызова. Первый вызывается до init-метода, воторой, после. Важно понимать, что на данном этапе экземпляр бина уже создан и идет его донастройка.

Тут есть два важных момента:
1) Оба метода в итоге должны вернуть бин. Если в методе вы вернете null, то при получении этого бина из контекста вы получите null, а поскольку через бинпостпроцессор проходят все бины, после поднятия контекста, при запросе любого бина вы будете получать фиг, в смысле null.
2) Если вы хотите сделать прокси над вашим объектом (аспекты, транзакции, и т.д. — некая бизнес логика), то имейте ввиду, что это принято делать после вызова init метода, иначе говоря это нужно делать в методе postProcessAfterInitialization.
3) Если нужно заполнить бины через маркерные интерфейсы или настраивает объект, реализовывают метод postProcessBeforeInitialization (Object bean, String beanName),

Прокси — это класс-декорация над бином. Например, мы хотим добавить логику нашему бину, но джава-код уже скомпилирован, поэтому нам нужно на лету сгенерировать новый класс. Этим классом мы должны заменить оригинальный класс так, чтобы никто не заметил подмены.

Есть два варианта создания этого класса:

либо он должен наследоваться от оригинального класса (CGLIB) и переопределять его методы, добавляя нужную логику;

либо он должен имплементировать те же самые интерфейсы, что и первый класс(Dynamic Proxy).

По конвенции спринга, если какой-то из BeanPostProcessor-ов меняет что-то в классе, то он должен это делать на этапе postProcessAfterInitialization(). Таким образом мы уверены, что initMethod у данного бина, работает на оригинальный метод, до того, как на него накрутился прокси.

Хронология событий:

Сначала сработает метод postProcessBeforeInitialization() всех имеющихся BeanPostProcessor-ов.

Затем, при наличии, будет вызван метод, аннотированный @PostConstruct.

Если бин имплементирует InitializingBean, то Spring вызовет метод afterPropertiesSet() - не рекомендуется к использованию как устаревший.

При наличии, будет вызван метод, указанный в параметре initMethod аннотации @Bean.

В конце бины пройдут через postProcessAfterInitialization (Object bean, String beanName). Именно на данном этапе создаются прокси стандартными BeanPostProcessor-ами. Затем отработают наши кастомные BeanPostProcessor-ы и применят нашу логику к прокси-объектам. После чего все бины окажутся в контейнере, который будет обязательно обновлен методом refresh().

Но даже после этого мы можем донастроить наши бины ApplicationListener-ами.

Теперь всё

Пример:
Порядок в котором будут вызваны BeanPostProcessor не известен, но мы точно знаем что выполнены они будут последовательно.
Для того, что бы лучше понять для чего это нужно, давайте разберемся на каком-нибудь примере.
При разработке больших проектов, как правило, команда делится на несколько групп. Например первая группа разработчиков занимается написанием инфраструктуры проекта, а вторая группа, используя наработки первой группы, занимается написанием бизнес логики. Допустим второй группе понадобился функционал, который позволит в их бины инжектить некоторые значения, например случайные числа.На первом этапе будет создана аннотация, которой будут помечаться поля класса, в которые нужно проинжектить значение.

@Retention(RetentionPolicy.RUNTIME) @Target(ElementType.FIELD)
public @interface InjectRandomInt {
int min() default 0;
int max() default 10;
}

По умолчанию, диапазон случайных числе будет от 0 до 10.
Затем, нужно создать обработчик этой аннотации, а именно реализацию BeanPostProcessor для обработки аннотации InjectRandomInt.

@Component
public class InjectRandomIntBeanPostProcessor implements BeanPostProcessor {

@Override
public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {

Field[] fields = bean.getClass().getDeclaredFields();

for (Field field : fields) {
if (field.isAnnotationPresent(InjectRandomInt.class)) {

field.setAccessible(true);
InjectRandomInt annotation = field.getAnnotation(InjectRandomInt.class);
ReflectionUtils.setField(field, bean, getRandomIntInRange(annotation.min(),annotation.max()));
}
}
return bean;
}
@Override
public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
return bean;
}

private int getRandomIntInRange(int min, int max) { return min + (int)(Math.random() * ((max - min) + 1)); }
}

Код данного BeanPostProcessor достаточно прозрачен, поэтому мы не будем на нем останавливаться, но тут есть один важный момент.
BeanPostProcessor обязательно должен быть бином, поэтому мы его либо помечаем аннотацией @Component, либо регестрируем его в xml конфигурации как обычный бин.Первая группа разработчиков свою задачу выполнила. Теперь вторая группа может использовать эти наработки.

@Component @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)
public class MyBean {
@InjectRandomInt
private int value1;

@InjectRandomInt(min = 100, max = 200)
private int value2;
private int value3;

@Override
public String toString() {
return "MyBean{" + "value1=" + value1 + ", value2=" + value2 + ", value3=" + value3 + '}';
}
}
В итоге, все бины типа MyBean, получаемые из контекста, будут создаваться с уже проинициализированными полями value1 и value2. Также тут стоить отметить, этап на котором будет происходить инжект значений в эти поля будет зависеть от того какой @ Scope у вашего бина. SCOPE_SINGLETON — инициализация произойдет один раз на этапе поднятия контекста. SCOPE_PROTOTYPE — инициализация будет выполняться каждый раз по запросу. Причем во втором случае ваш бин будет проходить через все BeanPostProcessor-ы что может значительно ударить по производительности.

--------------------------------------------------------------------------------------------------------------------
Этап Бины готовы к использованию

Их можно получить с помощью метода ApplicationContext#getBean().

--------------------------------------------------------------------------------------------------------------------
Этап Закрытие контекста

Когда контекст закрывается (метод close() из ApplicationContext), бин уничтожается.
Если в бине есть метод, аннотированный @PreDestroy, то перед уничтожением вызовется этот метод.
Если бин имплементирует DisposibleBean, то Spring вызовет метод destroy() - не рекомендуется к использованию как устаревший.
Если в аннотации @Bean определен метод destroyMethod, то будет вызван и он.

--------------------------------------------------------------------------------------------------------------------
Что такое BeanDefinitions ?

Что такое BeanDefinitions ? В первую очередь это интерфейс.Можно представить его в виде map, который в качестве ключа хранит id бина, а в качестве значения — его декларацию.Что такое декларация ? Это то, из какого класса надо создавать бин, есть ли у него init() метод и как он называется, какие у него проперти и все остальные подробности бина, которые мы прописываем в XML. Другими словами это интерфейс, через который можно получить доступ к метаданным будущего бина.

--------------------------------------------------------------------------------------------------------------------
BeanDefinitions имплементаций.

У интерфейса BeanDefinitions есть много имплементаций.Основные из них, это:
— AbstractBeanDefinition
— AnnotatedBeanDefinition — если используем аннотацию @Component
— ConfigurationClassBeanDefinition — с помощью него мы можем узнать то, что нам нужно (какого типа и из какого класса создался бин).
— GenericBeanDefinition
— ScannedGenericBeanDefinition

--------------------------------------------------------------------------------------------------------------------
Что такое BeanFactory

BeanFactory — важный элемент структуры, т.к. он отвечает за создание и хранение всех объектов (занимается созданием экземпляров бинов, которые создаются на основе ранее созданных BeanDefinition). Это generic интерфейс. Он изначально был сделан для того, чтобы у разработчика была возможность управлять процессом создания бинов.После создания BeanDefinition, BeanFactory начинает по ним работать, создает из классов объекты и все бины складывает в контейнер.

--------------------------------------------------------------------------------------------------------------------
Что такое BeanPostProcessor

BeanPostProcessor — это интерфейс. Он позволяет настраивать бины прежде чем они попадут в контейнер. Здесь задействован паттерн "Change Of Responsibility" ("цепочка обязанностей"").

У этого интерфейса обязательно нужно переопределить 2 метода, если вы собираетесь его имплементировать:— postProcessBeforeInitialization() — вызывается до init() метода.— postProcessAfterInitialization() — вызывается после init() метода.

--------------------------------------------------------------------------------------------------------------------
Зачем нужен ApplicationContextAware

ApplicationContextAware - это интерфейс, и, если верить документации Spring (лучше верить) он должен реализовываться всеми объектами, которые хотят знать в каком ApplicationContext они запущены. Вроде бы звучит просто. Интерфейс определяет единственный метод setApplicationContext(AppicationContext applicationContext).

Приступим к его реалиации!
@Service("BeanUtil")
public class BeanUtil implements ApplicationContextAware {
private static ApplicationContext context;
@Override
public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
context = applicationContext;
}
public static <T> T getBean(Class<T> beanClass) {
return context.getBean(beanClass);
}
public static <T> Object getBean(String className) {
return context.getBean(className);
}
}
Создали класс BeanUtil, в нём - статическая переменная для хранения ссылки на текущий контекст. Переопределили метод setApplicationContext и создали свой метод getBean, который по имени класса возвращает бин из текущего контекста. Все и вправду легко.
Само собой, чтобы дать Spring корректно внедрить все зависимости, те классы-компоненты контекста, в которых вызывается getBean, должны собираться после того, как собран сам BeanUtil, иначе на старте контекста можем поймать самый настоящий NullPointerException (это, кстати, самое популярное исключение в мире Java). Для этого на зависимых классах можем указать аннотацию @DependsOn:
@Bean
@DependsOn("BeanUtil")
public DbClient clusterClient() {
return new DBClient();
}

--------------------------------------------------------------------------------------------------------------------
Что такое ApplicationListener

ApplicationListener - Он умеет слушать контекст Spring, все "events", которые с ним происходят. Работает на этапе, когда все уже создано. Также он имеет дженерики <>, в которых мы можем указать что конкретно мы хотим слушать. Обозначается аннотацией @EventListener.
— contextStartedEvent — контекст начал свое построение (не построился, а только начал)
— contextRefreshedEvent — когда контекст заканчивает свое построение, он всегда делает refresh.
— contextStoppedEvent
— contextClosedEvent

--------------------------------------------------------------------------------------------------------------------
CommandLineRunner и ApplicationRunner

Эти интрефейсы используются для запуска логики при запуске приложения, после создания экземпляра контекста приложения Spring.
ApplicationRunner.run() и CommandLineRunner.run() выполнятся сразу после создания applicationcontext и до запуска приложения. Оба они обеспечивают одинаковую функциональность, и единственное различие между CommandLineRunner и ApplicationRunner состоит в том, что CommandLineRunner.run() принимает String array[], тогда как ApplicationRunner.run() принимает ApplicationArguments в качестве аргумента.

@Component public class CommandLineAppStartupRunner implements CommandLineRunner {

private static final Logger LOG = LoggerFactory.getLogger(CommandLineAppStartupRunner.class);

public static int counter;

@Override
public void run(String...args) throws Exception { LOG.info("Increment counter");
counter++;
}
}
Можно запускать несколько CommandLineRunner одновременно, например чтобы распаралелить сложную логику. Управлять их порядком через @Order. Каждый Runner может иметь свои собственные зависимости

--------------------------------------------------------------------------------------------------------------------