Какой жизненный цикл у запроса?

Запрос приходит в DispatcherServlet

DispatcherServlet отправляет запрос на один из контроллеров, основываясь на URL из запроса

Контроллер обрабатывает запрос, делегирует выполнение бизнес-логике бизнес-слою (как правило это классы с аннотацией @Service), и создает модель с данными, которую и отправляет обратно в DispatcherServlet

DispatcherServlet отправляет модель на фронт для вью, основываясь на интерфейсе ViewResolver(подробнее об этом ниже)

--------------------------------------------------------------------------------------------------------------------

Что такое платформа Spring Model-View-Controller (MVC)?

Spring имеет собственную MVC-платформу веб-приложений, которая не была первоначально запланирована. Spring MVC является фреймворком, ориентированным на запросы. В нем определены стратегические интерфейсы для всех функций современной запросно-ориентированной системы.
Цель каждого интерфейса — быть простым и ясным, чтобы пользователям было легко его заново имплементировать, если они того пожелают. MVC прокладывает путь к более чистому front-end-коду. Все интерфейсы тесно связаны с Servlet API. Эта связь рассматривается некоторыми как неспособность разработчиков Spring предложить для веб-приложений абстракцию более высокого уровня. Однако эта связь оставляет особенности Servlet API доступными для разработчиков, облегчая все же работу с ним.

--------------------------------------------------------------------------------------------------------------------

Наиболее важные интерфейсы, определенные Spring MVC

HandlerMapping: выбор класса и его метода, которые должны обработать данный входящий запрос на основе любого внутреннего или внешнего для этого запроса атрибута или состояния.

HandlerAdapter: вызов и выполнение выбранного метода обработки входящего запроса.

Controller: включен между Моделью (Model) и Представлением (View). Управляет процессом преобразования входящих запросов в адекватные ответы. Действует как ворота, направляющие всю поступающую информацию. Переключает поток информации из модели в представление и обратно.
Класс DispatcherServlet является главным контроллером, которые получает запросы и распределяет их между другими контроллерами. @RequestsMapping указывает, какие именно запросы будут обрабатываться в конкретном контроллере. Может быть несколько экземпляров DispatcherServlet, отвечающих за разные задачи (обработка запросов пользовательского интерфейса, REST служб и т.д.). Каждый экземпляр DispatcherServlet имеет собственную конфигурацию WebApplicationContext, которая определяет характеристики уровня сервлета, такие как контроллеры, поддерживающие сервлет, отображение обработчиков, распознавание представлений, интернационализация, оформление темами, проверка достоверности, преобразование типов и форматирование и т.п.
ContextLoaderListener - слушатель при старте и завершении корневого класса Spring WebApplicationContext. Основным назначением является связывание жизненного цикла ApplicationContext и ServletContext, а так же автоматического создания ApplicationContext. Можно использовать этот класс для доступа к бинам из различных контекстов спринг. Настраивается в web.xml

Model: Этот блок инкапсулирует (объединяет) данные приложения. На практике это POJO-классы.

View: ответственно за возвращение ответа клиенту в виде текстов и изображений. Некоторые запросы могут идти прямо во View, не заходя в Model; другие проходят через все три слоя.

ViewResolver: выбор, какое именно View должно быть показано клиенту. Поддерживает распознавание представлений на основе логического имени, возвращаемого контроллером. Для поддержки различных механизмов распознавания представлений предусмотрено множество классов реализации. Например, класс UrlBasedViewResolver поддерживает прямое преобразование логических имен в URL.
Класс ContentNegotiatingViewResolver поддерживает динамическое распознавание представлений в зависимости от типа медиа, поддерживаемого клиентом (XML, PDF, JSON и т.д.). Существует также несколько реализаций для интеграции с различными технологиями представлений, такими как FreeMarker (FreeMarkerViewResolver), Velocity (VelocityViewResolver) и JasperReports (JasperReportsViewResolver).

HandlerInterceptor: перехват входящих запросов. Сопоставим, но не эквивалентен сервлет-фильтрам (использование не является обязательным и не контролируется DispatcherServlet-ом).

LocaleResolver: получение и, возможно, сохранение локальных настроек (язык, страна, часовой пояс) пользователя.

MultipartResolver: обеспечивает Upload — загрузку на сервер локальных файлов клиента. По умолчанию этот интерфейс не включается в приложении и необходимо указывать его в файле конфигурации. После настройки любой запрос о загрузке будет отправляться этому интерфейсу.

--------------------------------------------------------------------------------------------------------------------

Какие возможности предоставляет Spring MVC

Spring MVC предоставляет разработчику следующие возможности:

Ясное и прозрачное разделение между слоями в MVC и запросах.

Стратегия интерфейсов — каждый интерфейс делает только свою часть работы.

Интерфейс всегда может быть заменен альтернативной реализацией.

Интерфейсы тесно связаны с Servlet API.

Высокий уровень абстракции для веб-приложений.

В веб-приложениях можно использовать различные
части Spring, а не только Spring MVC.

--------------------------------------------------------------------------------------------------------------------

Как использовать JavaEE сервлет в Spring Framework?

Web-приложение на Spring MVC технически само по себе работает на сервлетах: всю обработку запросов берет на себя единый DispatcherServlet. С его помощью реализуется паттерн Front Controller.
Если вам нужно определить в программе полностью независимый от Spring-контекста сервлет или фильтр, ничего особенного для этого делать не нужно. Как обычно в Servlet API, нужно объявить класс, добавить его в web.xml как сервлет, добавить для сервлета маппинг.
Сервлет живет вне Spring-контекста, внедрение зависимостей в нём просто так не заработает. Чтобы использовать autowiring, на этапе инициализации сервлета вызывается статический SpringBeanAutowiringSupport.processInjectionBasedOnServletContext, с текущим сервлетом и его контекстом в аргументах. В этом же утилитарном классе есть ряд других средств для работы с контекстом извне.
Если программа построена на Spring Boot, создание бина типа ServletRegistrationBean поможет добавить сервлеты в рантайме. А для декларативного добавления на этапе компиляции, к классу конфигурации применяется @ServletComponentScan. С этой аннотацией стартер приложения просканирует и добавит в контекст все web-компоненты в стиле Servlet 3.0: классы с аннотациями @WebFilter, @WebListener и @WebServlet.

--------------------------------------------------------------------------------------------------------------------

Что такое контроллер в Spring MVC?

Ключевым интерфейсом в Spring MVC является Controller. Контроллер обрабатывает запросы к действиям, осуществляемые пользователями в пользовательском интерфейсе, взаимодействуя с уровнем обслуживания, обновляя модель и направляя пользователей на соответствующие представления в зависимости от результатов выполнения. Controller - управление, связь между моделью и видом.

Основным контроллером в Spring MVC является org.springframework.web.servlet.DispatcherServlet. Задается аннотацией @Controller и часто используется с аннотацией @RequestMapping, которая указывает какие запросы будут обрабатываться этим контроллером.

--------------------------------------------------------------------------------------------------------------------

Какая разница между аннотациями @Component, @Repository и @Service в Spring?

@Component - используется для указания класса в качестве компонента spring. При использовании поиска аннотаций, такой класс будет сконфигурирован как spring bean.
@Controller - специальный тип класса, применяемый в MVC приложениях. Обрабатывает запросы и часто используется с аннотацией @RequestMapping.
@Repository - указывает, что класс используется для работы с поиском, получением и хранением данных. Аннотация может использоваться для реализации шаблона DAO.
@Service - указывает, что класс является сервисом для реализации бизнес логики (на самом деле не отличается от Component, но просто помогает разработчику указать смысловую нагрузку класса).
Для указания контейнеру на класс-бин можно использовать любую из этих аннотаций. Но различные имена позволяют различать назначение того или иного класса.
Например, бины, получившиеся при помощи @Repository, дополнительно имеют обработку для JDBC Exception

--------------------------------------------------------------------------------------------------------------------

Можем ли мы использовать @Component вместо @Service для бизнес логики?

Да. конечно.
Если @Component является универсальным стереотипом для любого Spring компонента, то @Service в настоящее время является его псевдонимом. Однако, в официальной документации Spring рекомендуется использовать именно @Service для бизнес логики. Вполне возможно, что в будущих версиях фреймворка, для данного стереотипа добавится дополнительная семантика, и его бины станут обладать дополнительной логикой.

--------------------------------------------------------------------------------------------------------------------

Шаблон проектирования Front Controller

Паттерн Front Controller обеспечивает единую точку входа для всех входящих запросов. Все запросы обрабатываются одним фрагментом кода, который затем может делегировать ответственность за обработку запроса другим объектам приложения. Он также обеспечивает интерфейс для общего поведения, такого как безопасность, интернационализация и передача определенных представлений определенным пользователям.

В Spring в качестве Front Controller выступает DispatcherServlet, все действия проходят через него. Как правило в приложении задаётся только один DispatcherServlet с маппингом "/", который перехватывает все запросы. Это и есть реализация паттерна Front Controller.

Однако иногда необходимо определить два и более DispatcherServlet-а, которые будут отвечать за свой собственный функционал. Например, чтобы один обрабатывал REST-запросы с маппингом "/api", а другой обычные запросы с маппингом "/default". Spring предоставляет нам такую возможность, и для начала нужно понять, что:

Spring может иметь несколько контекстов одновременно. Одним из них будет корневой контекст, а все остальные контексты будут дочерними.

Все дочерние контексты могут получить доступ к бинам, определенным в корневом контексте, но не наоборот. Корневой контекст не может получить доступ к бинам дочерних контекстов.

Каждый дочерний контекст внутри себя может переопределить бины из корневого контекста.

Каждый DispatcherServlet имеет свой дочерний контекст приложения. DispatcherServlet по сути является сервлетом(он расширяет HttpServlet), основной целью которого является обработка входящих веб запросов, соответствующих настроенному шаблону URL. Он принимает входящий URI и находит правильную комбинацию контроллера и вида. Веб-приложение может определять любое количество DispatcherServlet-ов. Каждый из них будет работать в своем собственном пространстве имен, загружая свой собственный дочерний WebApplicationContext (на рисунке - Servlet WebApplicationContext) с вьюшками, контроллерами и т.д. Например, когда нам нужно в одном Servlet WebApplicationContext определить обычные контроллеры, а в другом REST-контроллеры.

--------------------------------------------------------------------------------------------------------------------

Расскажите, что вы знаете о DispatcherServlet.

DispatcherServlet - сервлет диспатчер. Этот сервлет анализирует запросы и направляет их соответствующему контроллеру для обработки. В Spring MVC класс DispatcherServlet является центральным сервлетом, который получает запросы и направляет их соответствующим контроллерам. В приложении Spring MVC может существовать произвольное количество экземпляров DispatcherServlet, предназначенных для разных целей (например, для обработки запросов пользовательского интерфейса, запросов веб-служб REST и т.д.). Каждый экземпляр DispatcherServlet имеет собственную конфигурацию WebApplicationContext расширяет ApplicationContext (создаёт и управляет бинами и т.д.), но помимо этого он имеет дополнительный метод getServletContext(), через который у него есть возможность получать доступ к ServletContext-у которая определяет характеристики уровня сервлета, такие как контроллеры, поддерживающие сервлет, отображение обработчиков, распознавание представлений, интернационализация, оформление темами, проверка достоверности, преобразование типов и форматирование и т.п.

--------------------------------------------------------------------------------------------------------------------

Расскажите, что вы знаете о ContextLoaderListener.

ContextLoaderListener - слушатель при старте и завершении корневого класса Spring WebApplicationContext. Основным назначением является связывание жизненного цикла term-54ApplicationContext и ServletContext, а так же автоматического создания ApplicationContext. Можно использовать этот класс для доступа к бинам из различных контекстов спринг.
Настраивается в web.xml

ContextLoaderListener создает корневой контекст приложения (Root WebApplicationContext) и будет использоваться всеми дочерними контекстами, созданными всеми DispatcherServlet. Напомню, что корневой контекст приложения будет общим и может быть только один. Root WebApplicationContext содержит компоненты, которые видны всем дочерним контекстам, такие как сервисы, репозитории, компоненты инфраструктуры и т.д. После создания корневого контекста приложения он сохраняется в ServletContext как атрибут, имя которого:

WebApplicationContext.class.getName() + ".ROOT"

Чтобы из контроллера любого дочернего контекста обратиться к корневому контексту приложения, мы можем использовать класс WebApplicationContextUtils, содержащий статические методы:

@Autowired
ServletContext context;
ApplicationContext ac =WebApplicationContextUtils.getWebApplicationContext(context);
if(ac == null){ return "root application context is null"; }

--------------------------------------------------------------------------------------------------------------------

ContextLoaderListener vs DispatcherServlet

ContextLoaderListener создает корневой контекст приложения.

Каждый DispatcherServlet создаёт себе один дочерний контекст.

Дочерние контексты могут обращаться к бинам, определенным в корневом контексте.

Бины в корневом контексте не могут получить доступ к бинам в дочерних контекстах (напрямую).

Все контексты добавляются в ServletContext.

Мы можем получить доступ к корневому контексту, используя класс WebApplicationContextUtils.

--------------------------------------------------------------------------------------------------------------------

DispatcherServlet Создан ли экземпляр в контексте приложения?

Нет, DispatcherServlet экземпляр создается сервлет-контейнерами, такими как Tomcat или Jetty. Вы должны определить DispatcherServlet в файл web.xml, как показано ниже.
Вы можете видеть, что тег загрузки при запуске имеет значение 1, что означает, что DispatcherServlet он создается при развертывании приложения Spring MVC в Tomcat или любом другом контейнере сервлетов. Во время создания он ищет файл servlet-name-context.xml и затем инициализирует bean-компоненты, определенные в этом файле.

--------------------------------------------------------------------------------------------------------------------

Что такое корневой контекст приложения в Spring MVC? Как это загружается?

В Spring MVC контекст, загружаемый с использованием ContextLoaderListener , называется «корневым» контекстом приложения, который принадлежит всему приложению, в то время как тот, который инициализирован с использованием DispatcherServlet , фактически специфичен для этого сервлета.
Технически Spring MVC допускает множественное использование DispatcherServlet в веб-приложении Spring MVC, поэтому каждый контекст является специфическим для соответствующего сервлета. Но, имея тот же корневой контекст, может существовать.

--------------------------------------------------------------------------------------------------------------------

Что такое ContextLoaderListener и для чего это нужно?

Это ContextLoaderListener слушатель, который помогает загрузить Spring MVC. Как следует из названия, он загружается и создает ApplicationContext, так что вам не нужно писать явный код для его создания.
Контекст приложения — это то, куда уходит Spring bean. Для веб-приложения существует подкласс WebAppliationContext.
ContextLoaderListener Также связывает жизненный цикл ApplicationContext для жизненного цикла ServletContext. Вы можете получить ServletContext с WebApplicationContext помощью getServletContext() метода.

--------------------------------------------------------------------------------------------------------------------

Что вы собираетесь делать в web.xml? Где вы это разместите?

Он ContextLoaderListener настроен в web.xml как слушатель, и вы помещаете его в тег, как показано ниже:

<listener> 
<listener-class> org.springframework.web.context.ContextLoaderListener 
</listener-class> 
</listener>

При развертывании веб-приложения Spring MVC контейнер сервлетов создал экземпляр ContextLoaderListener класса, который загружает Spring WebApplicationContext. Вы также можете увидеть Spring MVC для начинающих, чтобы узнать больше об ContextLoaderListener и WebApplicationContext и их роли в Spring MVC.

--------------------------------------------------------------------------------------------------------------------

Каковы части фреймворка Spring MVC?

Тремя основными частями MVC являются:
· DispatcherServlet: Эта часть MVC управляет всеми HTTP-запросами и ответами, которые взаимодействуют с программой. DispatcherServlet сначала получает соответствующее сопоставление обработчика из файла конфигурации, а затем передает запрос контроллеру. DispatcherServlet является наиболее важной частью платформы Spring Web MVC.
· WebApplicationContext: Это действует как расширение обычного ApplicationContext с дополнительными функциями, необходимыми для веб-приложений. Он может однозначно разрешать темы и автоматически определять, с каким сервлетом он связан.
· Контроллеры: Это компоненты в DispatcherServlet, которые действуют как фильтры между вводом данных пользователем и ответом приложения. Контроллеры принимают ввод пользователя, решают, следует ли преобразовать его в Представление или Модель, и, наконец, возвращают преобразованный ввод в Распознаватель представлений для просмотра.

--------------------------------------------------------------------------------------------------------------------

Как входящий запрос сопоставляется с контроллером и сопоставляется с методом?

Иногда также задают этот вопрос: как DispatcherServlet узнать, какой контроллер должен обработать запрос? Ну, ответ лежит в том, что называется отображением обработчика.
Spring использует сопоставления обработчиков для связи контроллеров с запросами. Два из наиболее часто используемых отображений обработчиков — это BeanNameUrlHandlerMapping и SimpleUrlHandlerMapping.
Если BeanNameUrlHandlerMappingURL-адрес запроса совпадает с именем компонента, класс в определении компонента является контроллером, который будет обрабатывать запрос.
С другой стороны SimpleUrlHandlerMapping, отображение более явное. Вы можете указать количество URL, и каждый URL может быть явно связан с контроллером.
Если вы используете аннотации для настройки Spring MVC, что необходимо, тогда @RequestMapping аннотации используются для сопоставления входящего запроса с контроллером и методом-обработчиком.
Вы также можете настроить @RequestMapping аннотацию по пути URI, параметрам запроса, HTTP-методам запроса и HTTP-заголовкам, присутствующим в запросе.

--------------------------------------------------------------------------------------------------------------------

В чём разница между @Controller и @RestController?

Controller - это один из стереотипов Spring Framework. Компоненты такого типа обычно занимаются обработкой сетевых запросов. Контроллер состоит из набора методов-обработчиков, помеченных аннотацией @RequestMapping.Ответ на запрос можно сформировать разными способами: например просто вернуть из обработчика строку с именем jsp-файла, или же вернуть ResponseBodyEmitter, который будет асинхронно заполняться данными позже. Все возможные варианты перечислены в документации.Большинство современных API реализуется по архитектуре REST. В ней каждая сущность доступна под собственным URI. В методе-обработчике возвращается экземпляр класса этой сущности, который преобразуется в ответ сервера одним из HttpMessageConverter-ов. Например, в JSON его превратит MappingJackson2HttpMessageConverter. Чтобы использовать этот способ ответа, метод, или весь контроллер, должен иметь аннотацию @ResponseBody.
@RestController - это просто сокращенная запись для @Controller + @ResponseBody.

--------------------------------------------------------------------------------------------------------------------

Что такое ViewResolver в Spring?

ViewResolver - распознаватель представлений. Интерфейс ViewResolver в Spring MVC (из пакета org.springframework.web.servlet) поддерживает распознавание представлений на основе логического имени, возвращаемого контроллером. Для поддержки различных механизмов распознавания представлений предусмотрено множество классов реализации. Например, класс UrlBasedViewResolver поддерживает прямое преобразование логических имен в URL. Класс ContentNegotiatingViewResolver поддерживает динамическое распознавание представлений в зависимости от типа медиа, поддерживаемого клиентом (XML, PDF, JSON и т.д.). Существует также несколько реализаций для интеграции с различными технологиями представлений, такими как FreeMarker (FreeMarkerViewResolver), Velocity (VelocityViewResolver) и JasperReports (JasperReportsViewResolver).
InternalResourceViewResolver - реализация ViewResolver, которая позволяет находить представления, которые возвращает контроллер для последующего перехода к нему. Ищет по заданному пути, префиксу, суффиксу и имени.

--------------------------------------------------------------------------------------------------------------------

Что такое MultipartResolver и когда его использовать?

Интерфейс MultipartResolver используется для загрузки файлов. Существуют две реализации: CommonsMultipartResolver и StandardServletMultipartResolver, которые позволяют фреймворку загружать файлы. По умолчанию этот интерфейс не включается в приложении и необходимо указывать его в файле конфигурации. После настройки любой запрос о загрузке будет отправляться этому интерфейсу.

--------------------------------------------------------------------------------------------------------------------

Для чего @RequestParam используется?

Это @RequestParam аннотация Spring MVC, которая используется для извлечения параметра запроса или параметров запроса из URL-адреса в методе обработчика контроллера, как показано ниже:

public String personDetail(@RequestParam("id") long id)
{
.... return "personDetails";
}

@RequestParam Аннотаций также поддерживает преобразование типов данных, например , вы можете увидеть здесь строка преобразуется в автоматический вход в систему , но она также может привести к исключению , если параметр запроса нет , или в случае несоответствия типа. Вы также можете сделать параметр необязательным, используя требуемый = false, например @RequestParam (value = «id», required = false)

--------------------------------------------------------------------------------------------------------------------

Каковы различия между @RequestParam и @PathVariable ?

Несмотря на то, что оба @RequestParam и @PathVariable аннотации используются для извлечения некоторых данных из URL, между ними есть ключевое различие.
@RequestParam Используется для параметров экстракта запросов, например , что — нибудь после «?» в URL, в то время @PathVariable как используется для извлечения части самого URI. Например, если задан URL-адрес http: // localhost: 8080 / SpringMVC / books / 3232233 /? Format = json, то вы можете получить доступ к параметру запроса «format» с помощью @RequestParam аннотации и / books / {id} с помощью @PathVariable, который даст вам 3232233.
Вот еще один пример @PathVariable:
@RequestMapping("/persons/{id}" )
public String personDetail (@PathVariable ("id" ) long id) {...}

Этот код может извлечь лицо id = 123 из / персон / 123. Он особенно используется в веб-службах RESTful, поскольку их идентификатор обычно является частью пути URI или URL-адреса.

--------------------------------------------------------------------------------------------------------------------

Расскажите про аннотацию @RequestMapping

Это аннотация в основном используется для указания URI для класс-контроллера. Раньше ее использовали методов класса, чтобы указать URI, http-метод, тип отправляемых данных, и т.п. В более новых версиях Spring ее заменили на аннотации @GetMapping, @PostMapping, и т.п. Теперь она используется только для указания URI до класса-контроллера.

--------------------------------------------------------------------------------------------------------------------

Что за аннотации @GetMapping, @PostMapping, @DeleteMapping и прочие?

Это более узкие аннотации для маппинга http-методов.
@GetMapping — Обрабатывает get-запросы
@PostMapping — Обрабатывает post-запросы
@DeleteMapping — Обрабатывает delete-запросы
@PutMapping — Обрабатывает put-запросы
@PatchMapping — Обрабатывает patch-запросы
Все написанное ниже характерно также и для других аннотаций.
Аннотация @GetMapping — это просто аннотация которая содержит @RequestMapping(method = RequestMethod.GET).Она также позволяет более глубоко настроить метод-обработчик.Ее параметры(они конвертируются в аналогичные параметры @RequestMapping):
path — URI
headers — заголовки
name — имя обработчика
params — параметры
produces — тип возвращаемых данных(JSON, XML, текст). Используется в REST
consumes — тип принимаемых данных. Используется в REST
По умолчанию аннотация принимает путь до метода.@GetMapping("managers") = @GetMapping(path = "managers")

--------------------------------------------------------------------------------------------------------------------

Что за аннотация @RequestBody?

Она используется для того чтобы указать что метод оперирует не моделями, а данными. То есть отправляет JSON, XML, текст, и т.п. Обычно она неявно используется в REST-сервисах.

--------------------------------------------------------------------------------------------------------------------

Что такое View и какова идея поддержки различных типов View?

A View — это интерфейс в приложении Spring MVC, реализации которого отвечают за отображение контекста и представление модели. Один вид предоставляет несколько атрибутов модели. Представления в Spring MVC могут быть бобами.
Они могут быть созданы как бобы ViewResolver. Поскольку этот интерфейс не имеет состояния, реализации представлений должны быть поточно-ориентированными. При использовании ViewResolverлогическое имя представления может быть преобразовано в различные типы View реализации, например, JstlView для отображения JSP или других реализаций представления для FreeMarker и Velocity.

--------------------------------------------------------------------------------------------------------------------

Как выбирается View в фазе рендеринга? Как отображается View?

DispatcherServlet содержит список специальных "отображателей" для view, которые основываясь на конфигурации сервлета будут содержать бины реализующие интерфейс ViewResolver.
Процесс отображения view:

Контроллер возвращает имя view в DispactherServlet

Имя сопоставляется с именами во ViewResolver

Если находится подходящий ViewResolver, он возвращает View который должен использоваться при рендеринге.

DS передает модель с данными во View и отображает вывод(html-страницу)

--------------------------------------------------------------------------------------------------------------------

Что такое Model?

Model является ссылкой для инкапсуляции данных или вывода для визуализации. Model всегда создается и передается в представление в Spring MVC. Если метод сопоставленного контроллера имеет Model в качестве параметра метода, model Spring Framework автоматически внедряет в этот метод экземпляр.
Все атрибуты, установленные на внедренной модели, сохраняются и передаются в View. Вот пример использования Model в Spring MVC:

public String personDetail(Model model) { ... model.addAttribute("name", "Joe"); ... }

--------------------------------------------------------------------------------------------------------------------

Почему у вас есть доступ к model вашему View? Откуда это взялось?

У вас должен быть доступ к model вашему представлению, чтобы отобразить вывод. Это тот, model который содержит данные для визуализации. Model Поставляется с контроллером, который обрабатывает их запрос клиента и инкапсулирует выход в Model объект.

--------------------------------------------------------------------------------------------------------------------

Как загрузить файл в Spring MVC?

Внутри спринг предусмотрен интерфейс MultipartResolver для обеспечения загрузки файлов. Фактически нужно настроить файл конфигурации для указания обработчика загрузки файлов, а затем задать необходимый метод в контроллере spring.

--------------------------------------------------------------------------------------------------------------------

Как обрабатывать исключения в Spring MVC Framework?

В Spring MVC интерфейс HandlerExceptionResolver (из пакета org.springframework.web.servlet) предназначен для работы с непредвиденными исключениями, возникающими во время выполнения обработчиков. По умолчанию DispatcherServlet регистрирует класс DefaultHandlerExceptionResolver (из пакета org.springframework.web.servlet.mvc.support). Этот распознаватель обрабатывает определенные стандартные исключения Spring MVC, устанавливая специальный код состояния ответа. Можно также реализовать собственный обработчик исключений, аннотировав метод контроллера с помощью аннотации @ExceptionHandler и передав ей в качестве атрибута тип исключения. В общем случае обработку исключений можно описать таким образом:
Controller Based - указать методы для обработки исключения в классе контроллере. Для этого нужно пометить такие методы аннотацией @ExceptionHandler.
Global Exception Handler - для обработки глобальных исключений spring предоставляет аннотацию @ControllerAdvice.
HandlerExceptionResolver implementation - общие исключений большая часть времени обслуживают статические страницы. Spring Framework предоставляет интерфейс HandlerExceptionResolver, который позволяет задать глобального обработчика исключений. Реализацию этого интерфейса можно использовать для создания собственных глобальных обработчиков исключений в приложении.

--------------------------------------------------------------------------------------------------------------------

Каковы минимальные настройки, чтобы создать приложение Spring MVC?

Для создания простого Spring MVC приложения необходимо пройти следующие шаги:
Добавить зависимости spring-context и spring-webmvc в проект.
Указать DispatcherServlet в web.xml для обработки запросов внутри приложения.
Задать определение spring bean (аннотацией или в xml).
Добавить определение view resolver для представлений.
Настроить класс контроллер для обработки клиентских запросов.

--------------------------------------------------------------------------------------------------------------------

Как бы вы связали Spring MVC Framework и архитектуру MVC?

Модель (Model) - выступает любой Java bean в Spring. Внутри класса могут быть заданы различные атрибуты и свойства для использования в представлении.
Преставление (View) - JSP страница, HTML файл и т.п. служат для отображения необходимой информации пользователю. Представление передает обработку запросов к диспетчеру сервлетов (контроллеру).
DispatcherServlet (Controller) - это главный контроллер в приложении Spring MVC, который обрабатывает все входящие запросы и передает их для обработки в различные методы в контроллеры.

--------------------------------------------------------------------------------------------------------------------

Как добиться локализации в приложениях Spring MVC?

Spring MVC предоставляет очень простую и удобную возможность локализации приложения. Для этого необходимо сделать следующее:
Создать файл resource bundle, в котором будут заданы различные варианты локализированной информации.
Определить messageSource в конфигурации Spring используя классы ResourceBundleMessageSource или ResourceBundleMessageSource.
Определить localceResolver класса CookieLocaleResolver для включения возможности переключения локали.
С помощью элемента spring:message DispatcherServlet будет определять в каком месте необходимо подставлять локализированное сообщение в ответе.

--------------------------------------------------------------------------------------------------------------------

Как мы можем использовать Spring для создания веб-службы RESTful, возвращающей JSON?

Spring Framework позволяет создавать Resful веб сервисы и возвращать данные в формате JSON. Spring обеспечивает интеграцию с Jackson JSON API для возможности отправки JSON ответов в resful web сервисе. Для отправки ответа в формате JSON из Spring MVC приложения необходимо произвести следующие настройки:
Добавить зависимости Jackson JSON. С помощью maven это делается так:

Настроить бин RequestMappingHandlerAdapter в файле конфигурации Spring и задать свойство messageConverters на использование бина MappingJackson2HttpMessageConverter.

В контроллере указать с помощью аннотации @ResponseBody возвращение Object:

--------------------------------------------------------------------------------------------------------------------

Как проверить (валидировать) данные формы в Spring Web MVC Framework?

Spring поддерживает аннотации валидации из JSR-303, а так же возможность создания своих реализаций классов валидаторов. Пример использования аннотаций:

--------------------------------------------------------------------------------------------------------------------

Что такое Filter

Это интерфейс из пакета javax.servlet, имплементации которого выполняют задачи фильтрации либо по пути запроса к ресурсу (сервлету, либо по статическому контенту), либо по пути ответа от ресурса, либо в обоих направлениях.

Фильтры выполняют фильтрацию в методе doFilter. Каждый фильтр имеет доступ к объекту FilterConfig, из которого он может получить параметры инициализации, и ссылку на ServletContext, который он может использовать, например, для загрузки ресурсов, необходимых для задач фильтрации. Фильтры настраиваются в дескрипторе развертывания веб-приложения.

В веб-приложении мы можем написать несколько фильтров, которые вместе называются цепочкой фильтров. Веб-сервер решает, какой фильтр вызывать первым, в соответствии с порядком регистрации фильтров.

Когда вызывается метод doFilter(ServletRequest request, ServletResponse response, FilterChain chain) первого фильтра, веб-сервер создает объект FilterChain, представляющий цепочку фильтров, и передаёт её в метод.

--------------------------------------------------------------------------------------------------------------------

Что вы знаете Spring MVC Interceptor и как он используется?

Это интерфейс из пакета org.aopalliance.intercept, предназначенный для аспектно ориентированного программирования. В Spring, когда запрос отправляется в Controller, перед тем как он в него попадёт, он может пройти через перехватчики Interceptor (0 или более). Это одна из реализаций АОП в Spring. Вы можете использовать Interceptor для выполнения таких задач, как запись в Log, добавление или обновление конфигурации перед тем, как запрос обработается Controller-ом.
Стек перехватчиков: он предназначен для связывания перехватчиков в цепочку в определенном порядке. При доступе к перехваченному методу или полю перехватчик в цепочке перехватчиков вызывается в том порядке, в котором он был определен.

Мы можем использовать Interceptor-ы для выполнения логики до попадания в контроллер, после обработки в контроллере, а также после формирования представления. Также можем запретить выполнение метода контроллера. Мы можем указать любое количество перехватчиков.

Перехватчики работают с HandlerMapping и поэтому должны реализовывать интерфейс HandlerInterceptor или наследоваться от готового класса HandlerInterceptorAdapter. В случае реализации HandlerInterceptor нам нужно переопределить 3 метода, а в случае HandlerInterceptor, только необходимые нам:

public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) - вызывается после того, как HandlerMapping определил соответствующий контроллер, но до того, как HandlerAdapter вызовет метод контроллера. С помощью этого метода каждый перехватчик может решить, прервать цепочку выполнения или направить запрос на испольнение дальше по цепочке перехватчиков до метода контроллера. Если этот метод возвращает true, то запрос отправляется следующему перехватчику или в контроллер. Если метод возвращает false, то исполнение запроса прекращается, обычно отправляя ошибку HTTP или записывая собственный ответ в response.

public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) - отработает после контроллера, но перед формированием представления. Мы можем использовать этот метод для добавления дополнительных атрибутов в ModelAndView или для определения времени, затрачиваемого методом-обработчиком на обработку запроса клиента. Вы можете добавить больше объектов модели в представление, но вы не можете изменить HttpServletResponse, так как он уже зафиксирован.

public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) - отработает после формирования представления. Вызывается только в том случае, если метод preHandle этого перехватчика успешно завершен и вернул true!

--------------------------------------------------------------------------------------------------------------------

Как добавить перехватчики в конфигурацию Spring

Следует знать, что HandlerInterceptor связан с бином DefaultAnnotationHandlerMapping, который отвечает за применение перехватчиков к любому классу, помеченному аннотацией @Controller.
Чтобы добавить наши перехватчики в конфигурацию Spring, нам нужно переопределить метод addInterceptors () внутри класса, который реализует WebMvcConfigurer:

@Override public void addInterceptors(InterceptorRegistry registry) {
// LogInterceptor applies to all URLs. registry.addInterceptor(new LogInterceptor());
// This interceptor applies to URL /admin/oldLogin.
// Using OldURLInterceptor to redirect to new URL. registry.addInterceptor(new OldLoginInterceptor()) .addPathPatterns("/admin/oldLogin");
// This interceptor applies to URLs like /admin/*
// Exclude /admin/oldLogin registry.addInterceptor(new AdminInterceptor())
.addPathPatterns("/admin/*")// .excludePathPatterns("/admin/oldLogin"); }

--------------------------------------------------------------------------------------------------------------------

Что такое Java Listener?

Listener (Слушатель) - это класс, который реализует интерфейс javax.servlet.ServletContextListener. Он инициализируется только один раз при запуске веб�приложения и уничтожается при остановке веб-приложения. Слушатель сидит и ждет, когда произойдет указанное событие, затем «перехватывает» событие и запускает собственное событие. Например, мы хотим инициализировать пул соединений с базой данных до запуска веб-приложения. ServletContextListener - это то, что нам нужно, он будет запускать наш код до запуска веб-приложения.

Все ServletContextListeners уведомляются об инициализации контекста до инициализации любых фильтров или сервлетов в веб-приложении.

Все ServletContextListeners уведомляются об уничтожении контекста после того, как все сервлеты и фильтры уничтожены.

Чтобы создать свой Listener нам достаточно создать класс, имплементирующий интерфейс ServletContextListener и поставить над ним аннотацию @WebListener:

@WebListener
public class MyAppServletContextListener implements ServletContextListener{
//Run this before web application is started

@Override public void contextInitialized(ServletContextEvent arg0) { System.out.println("ServletContextListener started");
}

@Override public void contextDestroyed(ServletContextEvent arg0) { System.out.println("ServletContextListener destroyed");
}
}

--------------------------------------------------------------------------------------------------------------------

Filter vs. Interceptor

Перехватчик основан на механизме Reflection, а фильтр основан на обратном вызове функции.

Фильтр зависит от контейнера сервлета, тогда как перехватчик не зависит от него.

Перехватчики могут работать только с запросами к контроллерам, в то время как фильтры могут работать почти со всеми запросами (например, js, .css и т.д.).

Перехватчики в отличии от фильтров могут обращаться к объектам в контейнере Spring, что даёт им более изощренный функционал.

Порядок работы:
Фильтры до;
Перехватчики до;
Метод контроллера;
Перехватчики после;
Фильтры после.

HandlerInterceptor в основном похож на Servlet Filter, но в отличие от последнего он просто позволяет настраивать предварительную обработку с возможностью запретить выполнение самого обработчика и настраивать постобработку.

Согласно документации Spring, фильтры более мощные, например, они позволяют обмениваться объектами запроса и ответа, которые передаются по цепочке. Это означает, что фильтры работают больше в области запроса/ответа, в то время как HandlerInterceptors являются бинами и могут обращаться к другим компонентам в приложении. Обратите внимание, что фильтр настраивается в web.xml, а HandlerInterceptor в контексте приложения.

--------------------------------------------------------------------------------------------------------------------

В чем разница между Filters, Listeners and Interceptors?

Концептуально всё просто, фильтры сервлетов могут перехватывать только HTTPServlets. Listeners могут перехватывать специфические события. Как перехватить события которые относятся ни к тем не другим?
Фильтры и перехватчики делают по сути одно и тоже: они перехватывают какое-то событие, и делают что-то до или после.
Java EE использует термин Filter, Spring называет их Interceptors.
Именно здесь AOP используется в полную силу, благодаря чему возможно перехватывание вызовов любых объектов

--------------------------------------------------------------------------------------------------------------------

В чем разница между ModelMap и ModelAndView?

Model — интерфейс, ModelMap его реализация..
ModelAndView является контейнером для пары, как ModelMap и View.
Обычно я люблю использовать ModelAndView. Однако есть так же способ когда мы задаем необходимые атрибуты в ModelMap, и возвращаем название View обычной строкой из метода контроллера.

--------------------------------------------------------------------------------------------------------------------

В чем разница между model.put() и model.addAttribute()?

Метод addAttribute отделяет нас от работы с базовой структурой hashmap. По сути addAttribute это обертка над put, где делается дополнительная проверка на null. Метод addAttribute в отличии от put возвращает modelmap.model.addAttribute("attribute1","value1").addAttribute("attribute2","value2");

--------------------------------------------------------------------------------------------------------------------

Что можете рассказать про Form Binding?

Нам это может понадобиться, если мы, например, захотим взять некоторое значение с HTML страницы и сохранить его в БД. Для этого нам надо это значение переместить в контроллер Спринга.
Если мы будем использовать Spring MVC form tags, Spring автоматически свяжет переменные на HTML странице с Бином Спринга.
Если мне придется с этим работать, я обязательно буду смотреть официальную документацию Spring MVC Form Tags.

--------------------------------------------------------------------------------------------------------------------

Для чего был создан REST?

Чтобы понять концепцию REST, нужно разобрать акроним на его составляющие:
Representational — ресурсы в REST могут быть представлены в любой форме — JSON, XML, текст, или даже HTML — зависит от того, какие данные больше подходят потребителю
State — при работе с REST вы должны быть сконцентрированы на состоянии ресурса, а не на действиях с ресурсом
Transfer — REST включает себя передачу ресурсных данных, в любой представленной форме, от одного приложения другому.
REST это передача состояний ресурса между сервером и клиентом.

--------------------------------------------------------------------------------------------------------------------

Что такое ресурс?

Ресурс в REST — это все, что может быть передано между клиентом и сервером.Вот несколько примеров ресурсов:
Новость
Температура в Санкт-Петербурге в понедельник в 4 утра
Зарплата сотрудника
Выборка из базы данных
Результат поиска

--------------------------------------------------------------------------------------------------------------------

Что обозначает CRUD?

Действия в REST определяются http-методами.Get, Post, Put, Delete, Patch, и другие.
Самые часто-используемые обозначаются аббревиатурой CRUD:
Create — POST
Read — GET
Update — PUT
Delete — DELETE

--------------------------------------------------------------------------------------------------------------------

REST безопасен? Как вы можете защитить его?

По умолчанию REST не защищен.
Вы можете настроить безопасность с помощью Basic Auth, JWT, OAuth2

--------------------------------------------------------------------------------------------------------------------

Что такое save operations?

Это операции, которые не модифицируют ресурсы. Вот их список:
GET
HEAD
OPTIONS

--------------------------------------------------------------------------------------------------------------------

Что такое идемпотентая операция? Почему идемпотентность важна?

Идемпотентые методы — это методы, при каждом вызове которых результат будет одинаковый.
То есть, результат после 1 вызова такого метода будет такой же, как и результат после 10 вызовов этого метода.
Это важно для отказоустойчевого API. Предположим, что клиент хочет обновить ресурс с помощью POST-запроса? Если POST не идемпотентный метод, то при многократном вызове возникнут непредвиденные обновления ресурса. Используя идемпотентные методы, вы ограждаете себя от многих ошибок.

--------------------------------------------------------------------------------------------------------------------

REST хорошо масштабируется?

Да. REST хорошо масштабируется потому что он не хранит состояние.
Это значит что он не хранит информацию о пользовательских сессиях на сервере.
Информация о клиенте не должна хранится на стороне сервера, а должна передаваться каждый раз туда, где она нужна. Вот что значит ST в REST, State Transfer. Вы передаете состояние, а не храните его на сервере.
REST также интероперабельный — это значит, что на нем могут взаимодействовать разные программы написанные на разных языках. Это исходит из 2ух факторов:
Интероперабельные HTTP-клиенты. Разные клиенты должны отправлять одинаковые http-запросы.
Интероперабельность на уровне медиа-типов. Различные клиенты должны корректно отправлять и получать одни и те же ресурсы.

--------------------------------------------------------------------------------------------------------------------

Что такое HttpMessageConverter?

HttpMessageConverter конвертирует запрос в объект и наоборот.
Spring имеет несколько реализаций этого интерфейса, а вы можете создать свою.
В этом случае DispatcherServlet не использует Model и View.
В REST вообще не существует Model и View. Есть только данные, поставляемые контроллером, и представление ресурса, когда сообщение конвертируется из медиа-типа(json, xml...) в объект.
Список конвертеров:
BufferedImageHttpMessageConverter — конвертирует BufferedImage в(из) код изображения.
Jaxb2RootElementHttpMessageConverter — конвертирует xml в(из) объект, помеченный jaxb2 аннотациями. Регистрируется, если jaxb2 находится в classpath.
MappingJackson2HttpMessageConverter — конвертирует JSON в(из) объект. Регистрируется, если Jackson 2 находится в classpath.
StringHttpMessageConverter — конвертирует все медиа-файлы в text/plain.

--------------------------------------------------------------------------------------------------------------------

Зачем нужна @ResponseBody?

Аннотация @ResponseBody ставится на методы, которые работают с данными, а не с моделями. Ее не требуется указывать явно, если используется @RestController.
Обычные методы возвращают Model, а методы аннотированные @ResponseBody возвращают объекты, которые конвертируются в медиа-файлы с помощью HttpMessageConverter.

--------------------------------------------------------------------------------------------------------------------

Зачем нужна аннотация @PathVariable?

Эта аннотация получает определенную часть из URI.
URI: http://localhost:8080/getById/23
Следующий код поместит в переменную id значение 23.
@GetMapping("getById/{id}") public User getUserById(@PathVariable("id") String id) { //some logic }

--------------------------------------------------------------------------------------------------------------------

Зачем нужна аннотация @ResponseStatus?

Она позволяет устанавливать код ответа. Обычно Spring сам устанавливает нужный код ответа, но бывают моменты, когда это нужно переопределить.
@PostMapping @ResponseStatus(HttpStatus.CREATED) public void add(...) {...}
Вместо использования аннотации можно возвращать ResponseEntity и вручную устанавливать код ответа.
Не рекомендуется использовать ResponseEntity и @ReponseStatus вместе.

--------------------------------------------------------------------------------------------------------------------

Что такое ResponseEntity?

Это специальный класс, который представляет http-ответ. Он содержит тело ответа, код состояния, заголовки. Мы можем использовать его для более тонкой настройки http-ответа.
Он является универсальным типом, и можно использовать любой объект в качестве тела:
@GetMapping("/hello") ResponseEntity hello() { return new ResponseEntity("Hello World!", HttpStatus.OK); }

--------------------------------------------------------------------------------------------------------------------

Почему иногда мы используем @ResponseBody, а иногда ResponseEntity?

ResponseEntity необходим, только если мы хотим кастомизировать ответ, добавив к нему статус ответа. Во всех остальных случаях будем использовать @ResponseBody.
@GetMapping(value="/resource") @ResponseBody public Resource sayHello() { return resource; }
@PostMapping(value="/resource") public ResponseEntity createResource() { .... return ResponseEntity.created(resource).build(); }
Стандартные HTTP коды статусов ответов, которые можно использовать.
200 — SUCCESS
201 — CREATED
404 — RESOURCE NOT FOUND
400 — BAD REQUEST
401 — UNAUTHORIZED5
00 — SERVER ERROR
Для @ResponseBody единственные состояния статуса это SUCCESS(200), если всё ок и SERVER ERROR(500), если произошла какая-либо ошибка.
Допустим мы что-то создали и хотим отправить статус CREATED(201). В этом случае мы используем ResponseEntity.

--------------------------------------------------------------------------------------------------------------------

Как добавить поддержку Spring в web-приложение

Достаточно просто указать ContextLoaderListener в web.xml файле

--------------------------------------------------------------------------------------------------------------------

В чем различие между web.xml и the Spring Context - servlet.xml?

web.xml — Метаданные и конфигурация любого веб-приложения, совместимого с Java EE. Java EE стандарт для веб-приложений.servlet.xml — файл конфигурации, специфичный для Spring Framework.

--------------------------------------------------------------------------------------------------------------------

Исключения в Spring MVC

В Spring MVC интерфейс HandlerExceptionResolver (из пакета org.springframework.web.servlet) предназначен для работы с непредвиденными исключениями, возникающими во время выполнения обработчиков. По умолчанию DispatcherServlet регистрирует класс DefaultHandlerExceptionResolver (из пакета org.springframework.web.servlet.mvc.support). Этот распознаватель обрабатывает определенные стандартные исключения Spring MVC, устанавливая специальный код состояния ответа. Можно также реализовать собственный обработчик исключений, аннотировав метод контроллера с помощью аннотации @ExceptionHandler и передав ей в качестве атрибута тип исключения.

В общем случае обработку исключений можно описать таким образом:

@ExceptionHandler - указать методы для обработки исключения в классе контроллере. Принимает в себя имя класса обрабатываемого исключения (можно несколько).

@ControllerAdvice - для глобальной обработки ошибок в приложении Spring MVC. Ставится над классом-контроллером, отлавливает все исключения с методов. Он также имеет полный контроль над телом ответа и кодом состояния.

HandlerExceptionResolver implementation - позволяет задать глобального обработчика исключений. Реализацию этого интерфейса можно использовать для создания собственных глобальных обработчиков исключений в приложении.

--------------------------------------------------------------------------------------------------------------------

Локализация в приложениях Spring MVC

Spring MVC предоставляет очень простую и удобную возможность локализации приложения. Для этого необходимо сделать следующее:

Создать файл resource bundle, в котором будут заданы различные варианты локализированной информации.

Определить messageSource в конфигурации Spring используя классы ResourceBundleMessageSource или ResourceBundleMessageSource.

Определить localceResolver класса CookieLocaleResolver для включения возможности переключения локали.

С помощью элемента spring:message DispatcherServlet будет определять в каком месте необходимо подставлять локализированное сообщение в ответе.

--------------------------------------------------------------------------------------------------------------------

Spring Interceptor

Перехватчики в Spring (Spring Interceptor) являются аналогом Servlet Filter и позволяют перехватывать запросы клиента и обрабатывать их. Перехватить запрос клиента можно в трех местах: preHandle, postHandle и afterCompletion.

preHandle — метод используется для обработки запросов, которые еще не были переданы в метода обработчик контроллера. Должен вернуть true для передачи следующему перехватчику или в handler method. False укажет на обработку запроса самим обработчиком и отсутствию необходимости передавать его дальше. Метод имеет возможность выкидывать исключения и пересылать ошибки к представлению.

postHandle — вызывается после handler method, но до обработки DispatcherServlet для передачи представлению. Может использоваться для добавления параметров в объект ModelAndView.

afterCompletion — вызывается после отрисовки представления.

Для создания обработчика необходимо расширить абстрактный класс HandlerInterceptorAdapter или реализовать интерфейс HandlerInterceptor. Так же нужно указать перехватчики в конфигурационном файле Spring.

--------------------------------------------------------------------------------------------------------------------

Что такое RestTemplate

Класс RestTemplate является центральным инструментом для выполнения клиентских HTTP-операций в Spring. Он предоставляет несколько утилитных методов для создания HTTP-запросов и обработки ответов.

--------------------------------------------------------------------------------------------------------------------

Где должны располагаться статические (css, js, html) ресурсы в Spring MVC приложении?

Расположение статических ресурсов можно настроить. В документации Spring Boot рекомендуется использовать /static, или /public, или /resources, или /META-INF/resources

--------------------------------------------------------------------------------------------------------------------

Почему для конфиденциальных данных рекомендуется использовать POST, а не GET запросы?

В случае GET запроса передаваемые параметры являются частью url, и все маршрутизаторы, через которые пройдет наш GET запрос, смогут их прочитать.

В случае POST запроса передаваемые параметры являются частью тела запроса. При использовании HTTPs, тело запроса шифруется. Следовательно, использование POST запросов является более безопасным

--------------------------------------------------------------------------------------------------------------------

Можно ли передать в запросе один и тот же параметр несколько раз?

Пример:http://localhost:8080/login?name=Ranga&name=Ravi&name=Sathish
Да, можно принять все значения, используя массив в методе контроллера
public String method(@RequestParam(value="name") String[] names){ }

--------------------------------------------------------------------------------------------------------------------

Почему мы используем Hibernate Validator?

Hibernate Validator никак не связан с БД. Это просто библиотека для валидации.
Hibernate Validator версии 5.x является эталонной реализацией Bean Validation 1.1
Hibernate Validator является единственным, который сертифицирован.

--------------------------------------------------------------------------------------------------------------------