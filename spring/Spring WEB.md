Шаблон проектирования Front Controller

Паттерн Front Controller обеспечивает единую точку входа для всех входящих запросов. Все запросы обрабатываются одним фрагментом кода, который затем может делегировать ответственность за обработку запроса другим объектам приложения. Он также обеспечивает интерфейс для общего поведения, такого как безопасность, интернационализация и передача определенных представлений определенным пользователям.

В Spring в качестве Front Controller выступает DispatcherServlet, все действия проходят через него. Как правило в приложении задаётся только один DispatcherServlet с маппингом "/", который перехватывает все запросы. Это и есть реализация паттерна Front Controller.

Однако иногда необходимо определить два и более DispatcherServlet-а, которые будут отвечать за свой собственный функционал. Например, чтобы один обрабатывал REST-запросы с маппингом "/api", а другой обычные запросы с маппингом "/default". Spring предоставляет нам такую возможность, и для начала нужно понять, что:

Spring может иметь несколько контекстов одновременно. Одним из них будет корневой контекст, а все остальные контексты будут дочерними.

Все дочерние контексты могут получить доступ к бинам, определенным в корневом контексте, но не наоборот. Корневой контекст не может получить доступ к бинам дочерних контекстов.

Каждый дочерний контекст внутри себя может переопределить бины из корневого контекста.

Каждый DispatcherServlet имеет свой дочерний контекст приложения. DispatcherServlet по сути является сервлетом(он расширяет HttpServlet), основной целью которого является обработка входящих веб запросов, соответствующих настроенному шаблону URL. Он принимает входящий URI и находит правильную комбинацию контроллера и вида. Веб-приложение может определять любое количество DispatcherServlet-ов. Каждый из них будет работать в своем собственном пространстве имен, загружая свой собственный дочерний WebApplicationContext (на рисунке - Servlet WebApplicationContext) с вьюшками, контроллерами и т.д. Например, когда нам нужно в одном Servlet WebApplicationContext определить обычные контроллеры, а в другом REST-контроллеры.

--------------------------------------------------------------------------------------------------------------------
Расскажите, что вы знаете о DispatcherServlet.

DispatcherServlet - сервлет диспатчер. Этот сервлет анализирует запросы и направляет их соответствующему контроллеру для обработки. В Spring MVC класс DispatcherServlet является центральным сервлетом, который получает запросы и направляет их соответствующим контроллерам. В приложении Spring MVC может существовать произвольное количество экземпляров DispatcherServlet, предназначенных для разных целей (например, для обработки запросов пользовательского интерфейса, запросов веб-служб REST и т.д.). Каждый экземпляр DispatcherServlet имеет собственную конфигурацию WebApplicationContext расширяет ApplicationContext (создаёт и управляет бинами и т.д.), но помимо этого он имеет дополнительный метод getServletContext(), через который у него есть возможность получать доступ к ServletContext-у которая определяет характеристики уровня сервлета, такие как контроллеры, поддерживающие сервлет, отображение обработчиков, распознавание представлений, интернационализация, оформление темами, проверка достоверности, преобразование типов и форматирование и т.п.

--------------------------------------------------------------------------------------------------------------------
DispatcherServlet Создан ли экземпляр в контексте приложения?

Нет, DispatcherServlet экземпляр создается сервлет-контейнерами, такими как Tomcat или Jetty. Вы должны определить DispatcherServlet в файл web.xml, как показано ниже.
Вы можете видеть, что тег загрузки при запуске имеет значение 1, что означает, что DispatcherServlet он создается при развертывании приложения Spring MVC в Tomcat или любом другом контейнере сервлетов. Во время создания он ищет файл servlet-name-context.xml и затем инициализирует bean-компоненты, определенные в этом файле.

--------------------------------------------------------------------------------------------------------------------
Как входящий запрос сопоставляется с контроллером и сопоставляется с методом?

Иногда также задают этот вопрос: как DispatcherServlet узнать, какой контроллер должен обработать запрос? Ну, ответ лежит в том, что называется отображением обработчика.
Spring использует сопоставления обработчиков для связи контроллеров с запросами. Два из наиболее часто используемых отображений обработчиков — это BeanNameUrlHandlerMapping и SimpleUrlHandlerMapping.
Если BeanNameUrlHandlerMappingURL-адрес запроса совпадает с именем компонента, класс в определении компонента является контроллером, который будет обрабатывать запрос.
С другой стороны SimpleUrlHandlerMapping, отображение более явное. Вы можете указать количество URL, и каждый URL может быть явно связан с контроллером.
Если вы используете аннотации для настройки Spring MVC, что необходимо, тогда @RequestMapping аннотации используются для сопоставления входящего запроса с контроллером и методом-обработчиком.
Вы также можете настроить @RequestMapping аннотацию по пути URI, параметрам запроса, HTTP-методам запроса и HTTP-заголовкам, присутствующим в запросе.

--------------------------------------------------------------------------------------------------------------------
В чём разница между @Controller и @RestController?

Controller - это один из стереотипов Spring Framework. Компоненты такого типа обычно занимаются обработкой сетевых запросов. Контроллер состоит из набора методов-обработчиков, помеченных аннотацией @RequestMapping.Ответ на запрос можно сформировать разными способами: например просто вернуть из обработчика строку с именем jsp-файла, или же вернуть ResponseBodyEmitter, который будет асинхронно заполняться данными позже. Все возможные варианты перечислены в документации.Большинство современных API реализуется по архитектуре REST. В ней каждая сущность доступна под собственным URI. В методе-обработчике возвращается экземпляр класса этой сущности, который преобразуется в ответ сервера одним из HttpMessageConverter-ов. Например, в JSON его превратит MappingJackson2HttpMessageConverter. Чтобы использовать этот способ ответа, метод, или весь контроллер, должен иметь аннотацию @ResponseBody.
@RestController - это просто сокращенная запись для @Controller + @ResponseBody.

--------------------------------------------------------------------------------------------------------------------
Что такое MultipartResolver и когда его использовать?

Интерфейс MultipartResolver используется для загрузки файлов. Существуют две реализации: CommonsMultipartResolver и StandardServletMultipartResolver, которые позволяют фреймворку загружать файлы. По умолчанию этот интерфейс не включается в приложении и необходимо указывать его в файле конфигурации. После настройки любой запрос о загрузке будет отправляться этому интерфейсу.

--------------------------------------------------------------------------------------------------------------------
Для чего @RequestParam используется?

Это @RequestParam аннотация Spring MVC, которая используется для извлечения параметра запроса или параметров запроса из URL-адреса в методе обработчика контроллера, как показано ниже:

public String personDetail(@RequestParam("id") long id)
{
.... return "personDetails";
}

@RequestParam Аннотаций также поддерживает преобразование типов данных, например , вы можете увидеть здесь строка преобразуется в автоматический вход в систему , но она также может привести к исключению , если параметр запроса нет , или в случае несоответствия типа. Вы также можете сделать параметр необязательным, используя требуемый = false, например @RequestParam (value = «id», required = false)

--------------------------------------------------------------------------------------------------------------------
Каковы различия между @RequestParam и @PathVariable ?

Несмотря на то, что оба @RequestParam и @PathVariable аннотации используются для извлечения некоторых данных из URL, между ними есть ключевое различие.
@RequestParam Используется для параметров экстракта запросов, например , что — нибудь после «?» в URL, в то время @PathVariable как используется для извлечения части самого URI. Например, если задан URL-адрес http: // localhost: 8080 / SpringMVC / books / 3232233 /? Format = json, то вы можете получить доступ к параметру запроса «format» с помощью @RequestParam аннотации и / books / {id} с помощью @PathVariable, который даст вам 3232233.
Вот еще один пример @PathVariable:
@RequestMapping("/persons/{id}" )
public String personDetail (@PathVariable ("id" ) long id) {...}

Этот код может извлечь лицо id = 123 из / персон / 123. Он особенно используется в веб-службах RESTful, поскольку их идентификатор обычно является частью пути URI или URL-адреса.

--------------------------------------------------------------------------------------------------------------------
Расскажите про аннотацию @RequestMapping

Это аннотация в основном используется для указания URI для класс-контроллера. Раньше ее использовали методов класса, чтобы указать URI, http-метод, тип отправляемых данных, и т.п. В более новых версиях Spring ее заменили на аннотации @GetMapping, @PostMapping, и т.п. Теперь она используется только для указания URI до класса-контроллера.

--------------------------------------------------------------------------------------------------------------------
Что за аннотации @GetMapping, @PostMapping, @DeleteMapping и прочие?

Это более узкие аннотации для маппинга http-методов.
@GetMapping — Обрабатывает get-запросы
@PostMapping — Обрабатывает post-запросы
@DeleteMapping — Обрабатывает delete-запросы
@PutMapping — Обрабатывает put-запросы
@PatchMapping — Обрабатывает patch-запросы
Все написанное ниже характерно также и для других аннотаций.
Аннотация @GetMapping — это просто аннотация которая содержит @RequestMapping(method = RequestMethod.GET).Она также позволяет более глубоко настроить метод-обработчик.Ее параметры(они конвертируются в аналогичные параметры @RequestMapping):
path — URI
headers — заголовки
name — имя обработчика
params — параметры
produces — тип возвращаемых данных(JSON, XML, текст). Используется в REST
consumes — тип принимаемых данных. Используется в REST
По умолчанию аннотация принимает путь до метода.@GetMapping("managers") = @GetMapping(path = "managers")

--------------------------------------------------------------------------------------------------------------------
Что за аннотация @RequestBody?

Она используется для того чтобы указать что метод оперирует не моделями, а данными. То есть отправляет JSON, XML, текст, и т.п. Обычно она неявно используется в REST-сервисах.

--------------------------------------------------------------------------------------------------------------------
Как обрабатывать исключения в Spring WEB?

В Spring MVC интерфейс HandlerExceptionResolver (из пакета org.springframework.web.servlet) предназначен для работы с непредвиденными исключениями, возникающими во время выполнения обработчиков. По умолчанию DispatcherServlet регистрирует класс DefaultHandlerExceptionResolver (из пакета org.springframework.web.servlet.mvc.support). Этот распознаватель обрабатывает определенные стандартные исключения Spring MVC, устанавливая специальный код состояния ответа. Можно также реализовать собственный обработчик исключений, аннотировав метод контроллера с помощью аннотации @ExceptionHandler и передав ей в качестве атрибута тип исключения. В общем случае обработку исключений можно описать таким образом:
Controller Based - указать методы для обработки исключения в классе контроллере. Для этого нужно пометить такие методы аннотацией @ExceptionHandler.
Global Exception Handler - для обработки глобальных исключений spring предоставляет аннотацию @ControllerAdvice.
HandlerExceptionResolver implementation - общие исключений большая часть времени обслуживают статические страницы. Spring Framework предоставляет интерфейс HandlerExceptionResolver, который позволяет задать глобального обработчика исключений. Реализацию этого интерфейса можно использовать для создания собственных глобальных обработчиков исключений в приложении.

--------------------------------------------------------------------------------------------------------------------
Как мы можем использовать Spring для создания веб-службы RESTful, возвращающей JSON?

Spring Framework позволяет создавать Resful веб сервисы и возвращать данные в формате JSON. Spring обеспечивает интеграцию с Jackson JSON API для возможности отправки JSON ответов в resful web сервисе. Для отправки ответа в формате JSON из Spring MVC приложения необходимо произвести следующие настройки:
Добавить зависимости Jackson JSON. С помощью maven это делается так:

Настроить бин RequestMappingHandlerAdapter в файле конфигурации Spring и задать свойство messageConverters на использование бина MappingJackson2HttpMessageConverter.

В контроллере указать с помощью аннотации @ResponseBody возвращение Object:

--------------------------------------------------------------------------------------------------------------------
Как проверить (валидировать) данные формы в Spring Web MVC Framework?

Spring поддерживает аннотации валидации из JSR-303, а так же возможность создания своих реализаций классов валидаторов. Пример использования аннотаций:

--------------------------------------------------------------------------------------------------------------------
Что такое Filter

Это интерфейс из пакета javax.servlet, имплементации которого выполняют задачи фильтрации либо по пути запроса к ресурсу (сервлету, либо по статическому контенту), либо по пути ответа от ресурса, либо в обоих направлениях.

Фильтры выполняют фильтрацию в методе doFilter. Каждый фильтр имеет доступ к объекту FilterConfig, из которого он может получить параметры инициализации, и ссылку на ServletContext, который он может использовать, например, для загрузки ресурсов, необходимых для задач фильтрации. Фильтры настраиваются в дескрипторе развертывания веб-приложения.

В веб-приложении мы можем написать несколько фильтров, которые вместе называются цепочкой фильтров. Веб-сервер решает, какой фильтр вызывать первым, в соответствии с порядком регистрации фильтров.

Когда вызывается метод doFilter(ServletRequest request, ServletResponse response, FilterChain chain) первого фильтра, веб-сервер создает объект FilterChain, представляющий цепочку фильтров, и передаёт её в метод.

--------------------------------------------------------------------------------------------------------------------
Что вы знаете Spring MVC Interceptor и как он используется?

Это интерфейс из пакета org.aopalliance.intercept, предназначенный для аспектно ориентированного программирования. В Spring, когда запрос отправляется в Controller, перед тем как он в него попадёт, он может пройти через перехватчики Interceptor (0 или более). Это одна из реализаций АОП в Spring. Вы можете использовать Interceptor для выполнения таких задач, как запись в Log, добавление или обновление конфигурации перед тем, как запрос обработается Controller-ом.
Стек перехватчиков: он предназначен для связывания перехватчиков в цепочку в определенном порядке. При доступе к перехваченному методу или полю перехватчик в цепочке перехватчиков вызывается в том порядке, в котором он был определен.

Мы можем использовать Interceptor-ы для выполнения логики до попадания в контроллер, после обработки в контроллере, а также после формирования представления. Также можем запретить выполнение метода контроллера. Мы можем указать любое количество перехватчиков.

Перехватчики работают с HandlerMapping и поэтому должны реализовывать интерфейс HandlerInterceptor или наследоваться от готового класса HandlerInterceptorAdapter. В случае реализации HandlerInterceptor нам нужно переопределить 3 метода, а в случае HandlerInterceptor, только необходимые нам:

public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) - вызывается после того, как HandlerMapping определил соответствующий контроллер, но до того, как HandlerAdapter вызовет метод контроллера. С помощью этого метода каждый перехватчик может решить, прервать цепочку выполнения или направить запрос на испольнение дальше по цепочке перехватчиков до метода контроллера. Если этот метод возвращает true, то запрос отправляется следующему перехватчику или в контроллер. Если метод возвращает false, то исполнение запроса прекращается, обычно отправляя ошибку HTTP или записывая собственный ответ в response.

public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) - отработает после контроллера, но перед формированием представления. Мы можем использовать этот метод для добавления дополнительных атрибутов в ModelAndView или для определения времени, затрачиваемого методом-обработчиком на обработку запроса клиента. Вы можете добавить больше объектов модели в представление, но вы не можете изменить HttpServletResponse, так как он уже зафиксирован.

public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) - отработает после формирования представления. Вызывается только в том случае, если метод preHandle этого перехватчика успешно завершен и вернул true!

--------------------------------------------------------------------------------------------------------------------
Как добавить перехватчики в конфигурацию Spring

Следует знать, что HandlerInterceptor связан с бином DefaultAnnotationHandlerMapping, который отвечает за применение перехватчиков к любому классу, помеченному аннотацией @Controller.
Чтобы добавить наши перехватчики в конфигурацию Spring, нам нужно переопределить метод addInterceptors () внутри класса, который реализует WebMvcConfigurer:

@Override public void addInterceptors(InterceptorRegistry registry) {
// LogInterceptor applies to all URLs. registry.addInterceptor(new LogInterceptor());
// This interceptor applies to URL /admin/oldLogin.
// Using OldURLInterceptor to redirect to new URL. registry.addInterceptor(new OldLoginInterceptor()) .addPathPatterns("/admin/oldLogin");
// This interceptor applies to URLs like /admin/*
// Exclude /admin/oldLogin registry.addInterceptor(new AdminInterceptor())
.addPathPatterns("/admin/*")// .excludePathPatterns("/admin/oldLogin"); }

--------------------------------------------------------------------------------------------------------------------
Что такое Java Listener?

Listener (Слушатель) - это класс, который реализует интерфейс javax.servlet.ServletContextListener. Он инициализируется только один раз при запуске веб�приложения и уничтожается при остановке веб-приложения. Слушатель сидит и ждет, когда произойдет указанное событие, затем «перехватывает» событие и запускает собственное событие. Например, мы хотим инициализировать пул соединений с базой данных до запуска веб-приложения. ServletContextListener - это то, что нам нужно, он будет запускать наш код до запуска веб-приложения.

Все ServletContextListeners уведомляются об инициализации контекста до инициализации любых фильтров или сервлетов в веб-приложении.

Все ServletContextListeners уведомляются об уничтожении контекста после того, как все сервлеты и фильтры уничтожены.

Чтобы создать свой Listener нам достаточно создать класс, имплементирующий интерфейс ServletContextListener и поставить над ним аннотацию @WebListener:

@WebListener
public class MyAppServletContextListener implements ServletContextListener{
//Run this before web application is started

@Override public void contextInitialized(ServletContextEvent arg0) { System.out.println("ServletContextListener started");
}

@Override public void contextDestroyed(ServletContextEvent arg0) { System.out.println("ServletContextListener destroyed");
}
}

--------------------------------------------------------------------------------------------------------------------
Filter vs. Interceptor

Перехватчик основан на механизме Reflection, а фильтр основан на обратном вызове функции.

Фильтр зависит от контейнера сервлета, тогда как перехватчик не зависит от него.

Перехватчики могут работать только с запросами к контроллерам, в то время как фильтры могут работать почти со всеми запросами (например, js, .css и т.д.).

Перехватчики в отличии от фильтров могут обращаться к объектам в контейнере Spring, что даёт им более изощренный функционал.

Порядок работы:
Фильтры до;
Перехватчики до;
Метод контроллера;
Перехватчики после;
Фильтры после.

HandlerInterceptor в основном похож на Servlet Filter, но в отличие от последнего он просто позволяет настраивать предварительную обработку с возможностью запретить выполнение самого обработчика и настраивать постобработку.

Согласно документации Spring, фильтры более мощные, например, они позволяют обмениваться объектами запроса и ответа, которые передаются по цепочке. Это означает, что фильтры работают больше в области запроса/ответа, в то время как HandlerInterceptors являются бинами и могут обращаться к другим компонентам в приложении. Обратите внимание, что фильтр настраивается в web.xml, а HandlerInterceptor в контексте приложения.

--------------------------------------------------------------------------------------------------------------------
В чем разница между Filters, Listeners and Interceptors?

Концептуально всё просто, фильтры сервлетов могут перехватывать только HTTPServlets. Listeners могут перехватывать специфические события. Как перехватить события которые относятся ни к тем не другим?
Фильтры и перехватчики делают по сути одно и тоже: они перехватывают какое-то событие, и делают что-то до или после.
Java EE использует термин Filter, Spring называет их Interceptors.
Именно здесь AOP используется в полную силу, благодаря чему возможно перехватывание вызовов любых объектов

--------------------------------------------------------------------------------------------------------------------
Для чего был создан REST?

Чтобы понять концепцию REST, нужно разобрать акроним на его составляющие:
Representational — ресурсы в REST могут быть представлены в любой форме — JSON, XML, текст, или даже HTML — зависит от того, какие данные больше подходят потребителю
State — при работе с REST вы должны быть сконцентрированы на состоянии ресурса, а не на действиях с ресурсом
Transfer — REST включает себя передачу ресурсных данных, в любой представленной форме, от одного приложения другому.
REST это передача состояний ресурса между сервером и клиентом.

--------------------------------------------------------------------------------------------------------------------
Что такое ресурс?

Ресурс в REST — это все, что может быть передано между клиентом и сервером.Вот несколько примеров ресурсов:
Новость
Температура в Санкт-Петербурге в понедельник в 4 утра
Зарплата сотрудника
Выборка из базы данных
Результат поиска

--------------------------------------------------------------------------------------------------------------------
Что обозначает CRUD?

Действия в REST определяются http-методами.Get, Post, Put, Delete, Patch, и другие.
Самые часто-используемые обозначаются аббревиатурой CRUD:
Create — POST
Read — GET
Update — PUT
Delete — DELETE

--------------------------------------------------------------------------------------------------------------------
REST безопасен? Как вы можете защитить его?

По умолчанию REST не защищен.
Вы можете настроить безопасность с помощью Basic Auth, JWT, OAuth2

--------------------------------------------------------------------------------------------------------------------
Что такое save operations?

Это операции, которые не модифицируют ресурсы. Вот их список:
GET
HEAD
OPTIONS

--------------------------------------------------------------------------------------------------------------------
Что такое идемпотентая операция? Почему идемпотентность важна?

Идемпотентые методы — это методы, при каждом вызове которых результат будет одинаковый.
То есть, результат после 1 вызова такого метода будет такой же, как и результат после 10 вызовов этого метода.
Это важно для отказоустойчевого API. Предположим, что клиент хочет обновить ресурс с помощью POST-запроса? Если POST не идемпотентный метод, то при многократном вызове возникнут непредвиденные обновления ресурса. Используя идемпотентные методы, вы ограждаете себя от многих ошибок.

--------------------------------------------------------------------------------------------------------------------
REST хорошо масштабируется?

Да. REST хорошо масштабируется потому что он не хранит состояние.
Это значит что он не хранит информацию о пользовательских сессиях на сервере.
Информация о клиенте не должна хранится на стороне сервера, а должна передаваться каждый раз туда, где она нужна. Вот что значит ST в REST, State Transfer. Вы передаете состояние, а не храните его на сервере.
REST также интероперабельный — это значит, что на нем могут взаимодействовать разные программы написанные на разных языках. Это исходит из 2ух факторов:
Интероперабельные HTTP-клиенты. Разные клиенты должны отправлять одинаковые http-запросы.
Интероперабельность на уровне медиа-типов. Различные клиенты должны корректно отправлять и получать одни и те же ресурсы.

--------------------------------------------------------------------------------------------------------------------
Зачем нужна @ResponseBody?

Аннотация @ResponseBody ставится на методы, которые работают с данными, а не с моделями. Ее не требуется указывать явно, если используется @RestController.
Обычные методы возвращают Model, а методы аннотированные @ResponseBody возвращают объекты, которые конвертируются в медиа-файлы с помощью HttpMessageConverter.

--------------------------------------------------------------------------------------------------------------------
Зачем нужна аннотация @ResponseStatus?

Она позволяет устанавливать код ответа. Обычно Spring сам устанавливает нужный код ответа, но бывают моменты, когда это нужно переопределить.
@PostMapping @ResponseStatus(HttpStatus.CREATED) public void add(...) {...}
Вместо использования аннотации можно возвращать ResponseEntity и вручную устанавливать код ответа.
Не рекомендуется использовать ResponseEntity и @ReponseStatus вместе.

--------------------------------------------------------------------------------------------------------------------
Что такое ResponseEntity?

Это специальный класс, который представляет http-ответ. Он содержит тело ответа, код состояния, заголовки. Мы можем использовать его для более тонкой настройки http-ответа.
Он является универсальным типом, и можно использовать любой объект в качестве тела:
@GetMapping("/hello") ResponseEntity hello() { return new ResponseEntity("Hello World!", HttpStatus.OK); }

--------------------------------------------------------------------------------------------------------------------
Почему иногда мы используем @ResponseBody, а иногда ResponseEntity?

ResponseEntity необходим, только если мы хотим кастомизировать ответ, добавив к нему статус ответа. Во всех остальных случаях будем использовать @ResponseBody.
@GetMapping(value="/resource") @ResponseBody public Resource sayHello() { return resource; }
@PostMapping(value="/resource") public ResponseEntity createResource() { .... return ResponseEntity.created(resource).build(); }
Стандартные HTTP коды статусов ответов, которые можно использовать.
200 — SUCCESS
201 — CREATED
404 — RESOURCE NOT FOUND
400 — BAD REQUEST
401 — UNAUTHORIZED5
00 — SERVER ERROR
Для @ResponseBody единственные состояния статуса это SUCCESS(200), если всё ок и SERVER ERROR(500), если произошла какая-либо ошибка.
Допустим мы что-то создали и хотим отправить статус CREATED(201). В этом случае мы используем ResponseEntity.

--------------------------------------------------------------------------------------------------------------------
Что такое RestTemplate

Класс RestTemplate является центральным инструментом для выполнения клиентских HTTP-операций в Spring. Он предоставляет несколько утилитных методов для создания HTTP-запросов и обработки ответов.

--------------------------------------------------------------------------------------------------------------------
Почему для конфиденциальных данных рекомендуется использовать POST, а не GET запросы?

В случае GET запроса передаваемые параметры являются частью url, и все маршрутизаторы, через которые пройдет наш GET запрос, смогут их прочитать.

В случае POST запроса передаваемые параметры являются частью тела запроса. При использовании HTTPs, тело запроса шифруется. Следовательно, использование POST запросов является более безопасным

--------------------------------------------------------------------------------------------------------------------
Можно ли передать в запросе один и тот же параметр несколько раз?

Пример:http://localhost:8080/login?name=Ranga&name=Ravi&name=Sathish
Да, можно принять все значения, используя массив в методе контроллера
public String method(@RequestParam(value="name") String[] names){ }

--------------------------------------------------------------------------------------------------------------------