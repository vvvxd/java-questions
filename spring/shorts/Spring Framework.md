### Расскажите о Spring Framework.

**Spring Framework** — это мощный фреймворк для разработки Java-приложений, построенный на принципах **инверсии управления (IoC)** и **внедрения зависимостей (DI)**. Он упрощает создание модульных, масштабируемых и легко тестируемых систем, предоставляя готовую инфраструктуру для веб-приложений, работы с данными, безопасности и многого другого.

### Из каких частей состоит Spring Framework?

Spring имеет модульную архитектуру, позволяя использовать только необходимые компоненты.

1.  **Core Container (Ядро):**
    *   `spring-core`, `spring-beans`, `spring-context`: Основа фреймворка, реализующая **IoC-контейнер** (`ApplicationContext`) для управления жизненным циклом объектов (бинов).
    *   `spring-expression`: Язык выражений (SpEL) для работы с объектами во время выполнения.
2.  **AOP (Аспектно-ориентированное программирование):**
    *   `spring-aop`, `spring-aspects`: Позволяет выносить сквозную функциональность (логирование, транзакции, безопасность) в отдельные модули (аспекты).
3.  **Data Access/Integration (Работа с данными):**
    *   `spring-jdbc`, `spring-orm`, `spring-tx`: Упрощает работу с базами данных, ORM (Hibernate/JPA) и декларативное управление транзакциями (`@Transactional`).
4.  **Web (Веб-разработка):**
    *   `spring-webmvc`: Классический фреймворк для создания веб-приложений и REST API на основе паттерна MVC (`DispatcherServlet`).
    *   `spring-webflux`: Современный реактивный веб-фреймворк для построения асинхронных, неблокирующих приложений.
5.  **Test (Тестирование):**
    *   `spring-test`: Инструменты для интеграционного и модульного тестирования Spring-приложений.
6.  **Security (Безопасность):**
    *   `spring-security`: Мощный модуль для аутентификации, авторизации и защиты приложений.

### Какие ключевые особенности и преимущества Spring Framework?

**Особенности:**

*   **Инверсия управления (IoC) и Внедрение зависимостей (DI):** Контейнер управляет объектами (бинами), а не они сами. Это снижает связанность и упрощает тестирование.
*   **Аспектно-ориентированное программирование (AOP):** Позволяет отделить бизнес-логику от технических задач (транзакции, логирование).
*   **Декларативное управление транзакциями:** Простая и надежная работа с транзакциями через аннотацию `@Transactional`.
*   **Модульность:** Вы используете только те части фреймворка, которые вам нужны.
*   **Интеграция:** Легко интегрируется с огромным количеством технологий (Hibernate, Kafka, Redis и др.).
*   **Spring Boot:** Надстройка, которая радикально упрощает настройку и запуск приложений благодаря автоконфигурации.

**Преимущества:**

*   **Снижение связанности кода (Loose Coupling):** Компоненты легко заменять и тестировать.
*   **Ускорение разработки:** Spring берет на себя рутинные задачи.
*   **Повышение тестируемости:** Зависимости легко подменять моками в тестах.
*   **Огромная экосистема:** Spring Data, Spring Cloud, Spring Batch и др. решают широкий спектр задач.

### Что такое IoC и DI?

*   **Инверсия управления (Inversion of Control, IoC)** — это **принцип** проектирования, при котором управление жизненным циклом объектов (создание, конфигурация) передается от самого кода внешнему контейнеру (фреймворку). Ваш код не создает зависимости, а получает их извне.

*   **Внедрение зависимостей (Dependency Injection, DI)** — это **конкретная реализация** принципа IoC. Это процесс, при котором контейнер "внедряет" (предоставляет) объекту его зависимости через конструктор, сеттер или поле.

> **Простая аналогия:** IoC — это принцип "не звоните нам, мы позвоним вам". DI — это то, *как именно* вам "звонят" (передают зависимость).

### Какие существуют виды DI и какой из них лучше?

Существует три основных способа внедрения зависимостей:

1.  **Через конструктор (Constructor Injection):**
    ```java
    @Service
    public class MyService {
        private final MyRepository repository;

        @Autowired // Необязательна, если конструктор один
        public MyService(MyRepository repository) {
            this.repository = repository;
        }
    }
    ```
2.  **Через сеттер (Setter Injection):**
    ```java
    @Service
    public class MyService {
        private MyRepository repository;

        @Autowired
        public void setRepository(MyRepository repository) {
            this.repository = repository;
        }
    }
    ```
3.  **Через поле (Field Injection):**
    ```java
    @Service
    public class MyService {
        @Autowired
        private MyRepository repository;
    }
    ```

**Рекомендуемый способ — внедрение через конструктор.**

| Способ | Плюсы | Минусы |
| :--- | :--- | :--- |
| **Конструктор (Лучший)** | 1. Гарантирует, что объект создается в валидном состоянии. <br> 2. Позволяет делать зависимости `final` (неизменяемыми). <br> 3. Явно показывает все зависимости класса. <br> 4. Легко тестировать без Spring-контекста. | Большое количество зависимостей "загромождает" конструктор (но это сигнал к рефакторингу!). |
| **Сеттер** | 1. Позволяет создавать опциональные зависимости. <br> 2. Позволяет изменять зависимость в рантайме. <br> 3. Не создает циклических зависимостей. | 1. Объект может быть создан в невалидном состоянии. <br> 2. Зависимости могут быть изменены извне. |
| **Поле (Не рекомендуется)** | 1. Краткий синтаксис. | 1. **Нарушает инкапсуляцию** (использует рефлексию для установки приватных полей). <br> 2. **Сложно тестировать** — нужно использовать рефлексию для установки моков. <br> 3. Скрывает зависимости класса. |

### Что такое IoC-контейнер и как Spring реализует DI?

**IoC-контейнер** (в Spring это интерфейс `ApplicationContext`) — это "фабрика", которая читает конфигурацию вашего приложения, создает объекты (**бины**) и управляет их жизненным циклом и зависимостями.

**Как происходит DI (упрощенно):**

*   **Для полей/сеттеров:**
    1.  Spring создает экземпляр бина (вызывает конструктор по умолчанию).
    2.  Затем специальный компонент (`AutowiredAnnotationBeanPostProcessor`) с помощью **рефлексии** находит поля/сеттеры с аннотацией `@Autowired`.
    3.  Он запрашивает у контейнера нужную зависимость и устанавливает ее в поле или вызывает сеттер.
        Этот процесс происходит **после** создания объекта.

*   **Для конструктора:**
    1.  Это происходит **в момент создания** объекта.
    2.  Spring определяет, какой конструктор использовать (единственный, или помеченный `@Autowired`).
    3.  Он находит в контейнере все необходимые для конструктора зависимости.
    4.  Вызывает конструктор с уже готовыми зависимостями.

### Назовите шаблоны проектирования, используемые в Spring.

Spring активно использует множество классических шаблонов:

*   **Прокси (Proxy):** Основа для **AOP**. Используется для `@Transactional`, `@Secured`, `@Cacheable` для добавления логики "вокруг" вызова метода.
*   **Фабрика (Factory):** `ApplicationContext` — это фабрика бинов. Методы с аннотацией `@Bean` — это **Фабричные методы**.
*   **Одиночка (Singleton):** Область видимости бинов по умолчанию. Spring гарантирует наличие только одного экземпляра бина в контейнере.
*   **Шаблонный метод (Template Method):** Классы вроде `JdbcTemplate`, `RestTemplate`, `JmsTemplate`. Они берут на себя рутину (открытие/закрытие ресурсов, обработка ошибок), а вы предоставляете только специфичный код.
*   **Фронт-контроллер (Front Controller):** `DispatcherServlet` в Spring MVC. Это единая точка входа для всех HTTP-запросов.
*   **Наблюдатель (Observer):** Механизм событий (`ApplicationEvent` и `@EventListener`).
*   **Адаптер (Adapter):** `HandlerAdapter` в Spring MVC, позволяющий `DispatcherServlet` работать с разными типами обработчиков запросов.

### Что такое Spring бин и его Scope (область видимости)?

**Бин (Bean)** — это любой объект, жизненным циклом которого управляет Spring IoC-контейнер.

**Scope** определяет, сколько экземпляров бина будет создано и как долго они будут жить.

| Scope | Описание | Когда использовать | Потокобезопасность |
| :--- | :--- | :--- | :--- |
| **`singleton`** | **Один** экземпляр на весь Spring-контейнер. **(По умолчанию)** | Для stateless-компонентов (сервисы, репозитории, контроллеры). | **Нет.** Если бин хранит состояние, вы должны сами обеспечить потокобезопасность. |
| **`prototype`** | **Новый** экземпляр при каждом запросе на бин. | Для stateful-компонентов, где каждый клиент должен иметь свой экземпляр (например, "строители"). | **Да.** Каждый поток получает свой объект. |
| **`request`** | Один экземпляр на **HTTP-запрос**. (Только в веб-приложениях) | Для данных, специфичных для одного запроса (например, данные аутентификации). | **Да.** Один запрос = один поток. |
| **`session`** | Один экземпляр на **HTTP-сессию**. (Только в веб-приложениях) | Для данных, живущих между запросами одного пользователя (например, корзина покупок). | **Нет.** Один пользователь может делать несколько запросов одновременно. Требуется синхронизация. |
| **`application`** | Один экземпляр на `ServletContext` (на все веб-приложение). | Для глобальных данных приложения (например, кэш редко изменяемых данных). | **Нет.** Аналогично `singleton`. |

### В чем проблема внедрения `prototype` в `singleton`?

Если внедрить бин со скоупом `prototype` в `singleton`, он будет создан **только один раз** — в момент создания синглтона. Вы не будете получать новый экземпляр при каждом вызове.

**Решение:**

1.  **`@Lookup` метод:**
    ```java
    @Component
    public abstract class MySingleton {
        @Lookup
        public abstract MyPrototype createPrototype(); // Spring реализует этот метод за вас

        public void doWork() {
            MyPrototype p = createPrototype(); // Каждый раз новый экземпляр
            // ...
        }
    }
    ```
2.  **`ObjectFactory<T>`:**
    ```java
    @Component
    public class MySingleton {
        @Autowired
        private ObjectFactory<MyPrototype> prototypeFactory;

        public void doWork() {
            MyPrototype p = prototypeFactory.getObject(); // Каждый раз новый
            // ...
        }
    }
    ```

### В чем разница между `BeanFactory` и `ApplicationContext`?

| Характеристика | `BeanFactory` | `ApplicationContext` |
| :--- | :--- | :--- |
| **Отношение** | Базовый интерфейс, "движок". | **Наследует и расширяет** `BeanFactory`. |
| **Инициализация** | **Ленивая (Lazy)** по умолчанию. | **Немедленная (Eager)** для синглтонов (принцип Fail-Fast). |
| **Функциональность** | Только базовый IoC и DI. | Полная поддержка **AOP, событий, i18n, веб-среды**. |
| **Автоматизация** | Требует ручной регистрации расширений. | **Автоматически** находит и регистрирует `BeanPostProcessor`-ы, `@Aspect`-ы и др. |
| **Использование** | Практически не используется напрямую. | **Стандарт** для всех современных Spring-приложений. |

> **Вывод:** `ApplicationContext` — это `BeanFactory` "на стероидах", предоставляющий всю мощь фреймворка.

### Опишите жизненный цикл Spring-бина.

1.  **Парсинг метаданных:** Spring читает конфигурацию и создает "рецепты" для бинов (`BeanDefinition`).
2.  **Инстанцирование (Instantiation):** Spring создает экземпляр объекта, вызывая его конструктор.
3.  **Заполнение свойств (Population):** Spring внедряет зависимости через `@Autowired`, `@Value` и т.д. (на этом этапе работают `BeanPostProcessor`-ы).
4.  **Инициализация (Initialization):** Spring вызывает методы инициализации в следующем порядке:
    *   Метод, помеченный **`@PostConstruct`**.
    *   Метод `afterPropertiesSet()`, если бин реализует `InitializingBean`.
    *   Кастомный `init-method`, указанный в `@Bean`.
5.  **Бин готов к использованию.**
6.  **Уничтожение (Destruction):** Когда контекст закрывается, Spring вызывает методы уничтожения:
    *   Метод, помеченный **`@PreDestroy`**.
    *   Метод `destroy()`, если бин реализует `DisposableBean`.
    *   Кастомный `destroyMethod`.

### Различия между `@Component`, `@Service`, `@Repository`, `@Controller`.

Все эти аннотации помечают класс как бин и делают его кандидатом на автообнаружение. Разница в **семантике** и **дополнительном поведении**.

| Аннотация | Слой | Дополнительное поведение |
| :--- | :--- | :--- |
| **`@Component`** | Любой | Универсальная, базовая аннотация. **Нет** доп. поведения. |
| **`@Controller` / `@RestController`** | Представление (Web) | Указывает, что класс обрабатывает HTTP-запросы в Spring MVC. **`@RestController`** дополнительно добавляет `@ResponseBody` ко всем методам. |
| **`@Service`** | Бизнес-логика | Семантически выделяет сервисный слой. На данный момент **нет** доп. поведения, но это может измениться. |
| **`@Repository`** | Доступ к данным | **Ключевое отличие:** Включает **трансляцию платформо-специфичных исключений** (например, `HibernateException`) в единую иерархию `DataAccessException` Spring. |

### В чем разница между `@Bean` и `@Component`?

*   **`@Component`** (и его производные) ставится **на класс**. Это включает механизм **автоматического сканирования (`@ComponentScan`)**. Вы говорите Spring: "Найди этот класс и создай из него бин".
*   **`@Bean`** ставится **на метод** внутри класса, помеченного `@Configuration`. Это используется для **явного объявления** бина. Вы говорите Spring: "Выполни этот метод и зарегистрируй объект, который он вернет, как бин".

Используйте `@Bean`, когда:
*   Вы хотите создать бин из класса сторонней библиотеки, код которой вы не можете изменить.
*   Логика создания бина сложна и требует дополнительной конфигурации.

### Как разрешить неоднозначность при внедрении зависимостей?

Если у вас есть несколько бинов, реализующих один интерфейс, Spring не поймет, какой из них внедрять.

1.  **`@Primary`:** Помечает один из бинов как **основной, по умолчанию**. Spring выберет его, если не будет других уточнений.
    ```java
    @Component @Primary
    public class EmailNotificationService implements NotificationService { ... }
    ```
2.  **`@Qualifier("имя_бина")`:** Позволяет **явно указать**, какой бин нужен, по его имени. `@Qualifier` **имеет приоритет** над `@Primary`.
    ```java
    @Autowired
    @Qualifier("smsNotificationService") // Явно просим SMS-сервис
    private NotificationService service;
    ```

### Что такое профили (`@Profile`)?

**Профили** — это механизм, позволяющий активировать разные наборы бинов и конфигураций в зависимости от окружения. Это метка для ваших бинов и конфигураций.

**Основные сценарии:**
*   **Разные окружения:** Использовать H2 для `dev`-профиля и PostgreSQL для `prod`-профиля.
*   **Тестирование:** Подменять реальные сервисы на моки для `test`-профиля.
*   **Feature Toggles:** Включать/выключать функциональность по метке профиля.

**Как использовать:**
*   Аннотация `@Profile("prod")` на `@Bean` или `@Configuration`.
*   Активация через свойство `spring.profiles.active=prod` или JVM-параметр `-Dspring.profiles.active=prod`.
*   В тестах: `@ActiveProfiles("test")`.

### Расскажите о механизме событий (`@EventListener`).

Это реализация паттерна "Издатель-подписчик", позволяющая компонентам общаться, не имея прямых ссылок друг на друга (слабая связанность).

1.  **Событие (Event):** POJO-класс, обычно наследуется от `ApplicationEvent`, несущий информацию о том, что произошло.
2.  **Издатель (Publisher):** Любой бин, который внедряет `ApplicationEventPublisher` и вызывает его метод `publishEvent(myEvent)`.
3.  **Слушатель (Listener):** Любой метод в бине, помеченный аннотацией `@EventListener`. Spring автоматически вызовет его, когда будет опубликовано событие соответствующего типа.

**Продвинутые возможности:**
*   **`@Async`:** Выполняет слушателя в отдельном потоке.
*   **`@Order`:** Задает порядок выполнения нескольких слушателей.
*   **`@TransactionalEventListener`:** Привязывает выполнение слушателя к фазе транзакции (например, выполнить только после успешного коммита). Это критически важно для согласованности данных.