### Что такое XML Hell и ручная настройка?

<details>
<summary>Ответ</summary>

В "классическом" Spring (до Boot) для создания даже простого приложения требовалось:

1.  **Ручное управление зависимостями:** Самостоятельно подбирать десятки совместимых версий библиотек (`spring-core`, `spring-webmvc`, `jackson`, `tomcat-embed` и т.д.) в `pom.xml`. Это часто приводило к "аду зависимостей" (dependency hell).
2.  **Избыточная XML-конфигурация:** Создавать и настраивать множество XML-файлов (`web.xml`, `applicationContext.xml`, `mvc-config.xml`) для объявления бинов, `DispatcherServlet`, `DataSource`, `TransactionManager` и т.д. Это было долго, громоздко и подвержено ошибкам.
3.  **Внешнее развертывание:** Собирать приложение в WAR-файл и разворачивать его на отдельно установленном и настроенном сервере приложений (Tomcat, JBoss).

</details>

### Что такое Spring Boot? Ключевая идея

<details>
<summary>Ответ</summary>

**Spring Boot** — это не замена Spring Framework, а **надстройка** над ним, которая следует философии **"Соглашение вместо конфигурации" (Convention over Configuration)**.

Его ключевая идея — избавить разработчика от рутины. Spring Boot предоставляет:

1.  **Автоконфигурацию:** Автоматически настраивает приложение на основе библиотек в classpath. Например, видит Spring MVC — настраивает веб-сервер и `DispatcherServlet`.
2.  **Стартеры:** Упрощают управление зависимостями. Вместо 10-15 библиотек вы подключаете один "стартер" (например, `spring-boot-starter-web`), который уже содержит согласованный набор всех необходимых зависимостей.
3.  **Встроенный сервер:** Позволяет запускать приложение как обычный исполняемый JAR-файл (`java -jar app.jar`) без необходимости во внешнем сервере.

По сути, Spring Boot автоматизирует стандартные конфигурации, которые раньше приходилось писать вручную, но позволяет легко их переопределить при необходимости.

</details>

### Какие главные нововведения Spring Boot?
<details>
<summary>Ответ</summary>

### 1. Автоконфигурация (Autoconfiguration)

Это "магия" Spring Boot. На основе анализа classpath (подключенных библиотек) он автоматически создает и настраивает необходимые бины.
*   **Как работает:** Через условные аннотации (`@ConditionalOnClass`, `@ConditionalOnBean`).
*   **Пример:** Добавили `spring-boot-starter-data-jpa` и драйвер PostgreSQL? Boot автоматически создаст `DataSource`, `EntityManagerFactory` и `TransactionManager`.

### 2. "Стартеры" (Starter Dependencies)

Это "мета-зависимости", которые транзитивно подтягивают согласованный набор библиотек.
*   **Что решают:** Проблему "ада зависимостей".
*   **Пример:** `spring-boot-starter-web` добавляет в проект Spring MVC, встроенный Tomcat, Jackson для JSON и все остальное, что нужно для создания веб-приложения.

### 3. Встроенный сервер (Embedded Server)

Приложение по умолчанию упаковывается в исполняемый JAR-файл, внутри которого уже есть веб-сервер (Tomcat, Jetty или Netty).
*   **Преимущества:**
    *   Простой запуск (`java -jar my-app.jar`).
    *   Портативность и автономность.
    *   Идеально для микросервисов и Docker.

### 4. Внешняя конфигурация и Actuator

*   **Внешняя конфигурация:** Гибкий механизм управления настройками через `application.properties` или `application.yml`, с поддержкой профилей (`dev`, `prod`) и переопределения через переменные окружения.
*   **Actuator:** Стартер (`spring-boot-starter-actuator`), добавляющий production-ready эндпоинты для мониторинга (`/actuator/health`, `/actuator/metrics`) и управления приложением.

</details>

### Как работает автоконфигурация в Spring Boot?

<details>
<summary>Ответ</summary>

Процесс запускается аннотацией `@SpringBootApplication`, которая содержит в себе **`@EnableAutoConfiguration`**.

1.  **Поиск кандидатов:** При старте Spring ищет во всех JAR-файлах в classpath специальный файл `META-INF/spring.factories` (в Boot 3+ `META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports`). В этом файле под ключом `...EnableAutoConfiguration` перечислены сотни **потенциальных** классов автоконфигурации (например, `DataSourceAutoConfiguration`, `WebMvcAutoConfiguration`).
2.  **Фильтрация через условия:** Spring не применяет все эти конфигурации бездумно. Каждый такой класс помечен **условными аннотациями** (`@ConditionalOn...`).
    *   `@ConditionalOnClass`: Конфигурация активируется, только если в classpath есть определенный класс. (Например, `DataSourceAutoConfiguration` сработает, только если есть класс `DataSource`).
    *   `@ConditionalOnBean`/`@ConditionalOnMissingBean`: Конфигурация сработает, только если в контексте есть (или наоборот, отсутствует) определенный бин. Это позволяет вам переопределить стандартную конфигурацию, создав свой собственный бин.
    *   `@ConditionalOnProperty`: Конфигурация зависит от значения свойства в `application.properties`.
3.  **Создание бинов:** После фильтрации Spring обрабатывает только те классы автоконфигурации, чьи условия были выполнены, и создает бины, определенные внутри них (`@Bean`-методы).

</details>

### Расскажи про Starter в Spring Boot?

<details>
<summary>Ответ</summary>

**Starter (стартер)** — это дескриптор зависимостей (POM-файл в Maven), который объединяет в себе набор согласованных по версиям библиотек для определенной задачи.

**Связка "Стартер + Автоконфигурация"**

Это основа Spring Boot. Они работают вместе:

1.  **Стартер** приносит в проект "инструменты" (JAR-библиотеки). Например, `spring-boot-starter-web` добавляет в classpath Tomcat и Spring MVC.
2.  **Автоконфигурация** видит эти "инструменты" и знает, как ими пользоваться. Она автоматически настраивает встроенный Tomcat, `DispatcherServlet` и другие необходимые компоненты.

> **Стартеры решают проблему "ЧТО" (какие зависимости нужны), а Автоконфигурация — проблему "КАК" (как их настроить).**

</details>

### Как создать свой собственный Starter?

<details>
<summary>Ответ</summary>

Правильный стартер состоит из двух модулей:

1.  **`my-library-spring-boot-autoconfigure`:** Модуль с логикой автоконфигурации.
    *   Содержит класс `@Configuration` с условными `@Bean`-методами.
    *   Содержит класс `@ConfigurationProperties` для настройки через `application.properties`.
    *   Регистрирует свою автоконфигурацию в файле `META-INF/spring.factories` или `META-INF/spring/...AutoConfiguration.imports`.

2.  **`my-library-spring-boot-starter`:** Модуль-обертка с зависимостями.
    *   Его `pom.xml` не содержит кода.
    *   Он просто транзитивно подключает модуль `autoconfigure` и любые другие необходимые библиотеки (например, `jackson-databind`).

**Использование:** Разработчик в своем проекте добавляет только одну зависимость — на `starter`-модуль. Этого достаточно, чтобы получить все нужные библиотеки и автоматически сконфигурированные бины.

</details>

### Что делает `@Conditional`?

<details>
<summary>Ответ</summary>

**`@Conditional`** — это мета-аннотация, которая позволяет регистрировать компонент (например, `@Configuration` класс или `@Bean` метод) в контексте Spring только при выполнении определенного условия.

Это ядро механизма автоконфигурации. Вместо того чтобы писать логику `if-else` для создания бинов, вы декларативно указываете условия их создания.

</details>

### Какие есть Conditional?

<details>
<summary>Ответ</summary>

Spring Boot предоставляет множество готовых условных аннотаций:

*   **На основе классов/бинов:**
    *   `@ConditionalOnClass`: класс есть в classpath.
    *   `@ConditionalOnMissingClass`: класса нет в classpath.
    *   `@ConditionalOnBean`: бин такого типа уже есть в контексте.
    *   `@ConditionalOnMissingBean`: бина такого типа еще нет (ключ к переопределению).
*   **На основе конфигурации/окружения:**
    *   `@ConditionalOnProperty`: свойство в `application.properties` существует или имеет нужное значение.
    *   `@ConditionalOnExpression`: SpEL-выражение возвращает `true` (самый гибкий вариант).
*   **На основе типа приложения:**
    *   `@ConditionalOnWebApplication`: приложение является веб-приложением.
    *   `@ConditionalOnNotWebApplication`: приложение не является веб-приложением.
*   **Другие:** `@ConditionalOnResource`, `@ConditionalOnJava` и т.д.

</details>

### На каком этапе поднятия контекста они работают?

<details>
<summary>Ответ</summary>

Условия проверяются на разных этапах, что очень важно понимать.

| Этап жизненного цикла | Что происходит | Какие условия надежно работают |
| :--- | :--- | :--- |
| **1. Парсинг пользовательских `@Configuration`** | Проверка `@Conditional` на **классах**, найденных через `@ComponentScan`. | `@ConditionalOnClass`, `@ConditionalOnProperty`. Условия на бинах (`@ConditionalOnBean`) могут работать некорректно, т.к. полная картина бинов еще не ясна. |
| **2. Парсинг автоконфигураций** | Проверка `@Conditional` на **классах** из `spring.factories`. | Те же, что и на этапе 1. Отсекаются целые модули автоконфигурации. |
| **3. Пост-обработка `BeanFactory`** | Проверка `@Conditional` на **`@Bean`-методах** внутри всех конфигураций. | **ВСЕ**, включая `@ConditionalOnBean` и `@ConditionalOnMissingBean`, так как на этом этапе Spring видит полный список всех "чертежей" бинов (`BeanDefinition`). |
| **4. Инстанцирование бинов** | Условия уже отработали. Spring создает экземпляры. | - |

</details>

### Как создать свой Conditional?

<details>
<summary>Ответ</summary>

1.  **Создать класс с логикой:** Реализуйте интерфейс `org.springframework.context.annotation.Condition` и определите логику в методе `matches()`.
    ```java
    public class MyCustomCondition implements Condition {
        @Override
        public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
            // Ваша логика, например, проверка системного свойства
            return "true".equalsIgnoreCase(System.getProperty("my.flag"));
        }
    }
    ```

2.  **Создать свою аннотацию:** Свяжите ее с вашей логикой через `@Conditional`.
    ```java
    @Retention(RetentionPolicy.RUNTIME)
    @Conditional(MyCustomCondition.class) // <-- Связь с логикой
    public @interface ConditionalOnMyFlag {
    }
    ```

3.  **Использовать аннотацию:** Применяйте `@ConditionalOnMyFlag` к вашим бинам или конфигурациям.

</details>

### Что такое parent в Spring?

<details>
<summary>Ответ</summary>

Блок `<parent>` в `pom.xml` указывает на `spring-boot-starter-parent` и обеспечивает наследование, давая вашему проекту три ключевые возможности:

1.  **Централизованное управление версиями:** Ваш проект наследует **BOM (Bill of Materials)** — огромный список согласованных версий для сотен библиотек. Вы можете добавлять зависимости (например, `spring-boot-starter-web`), **не указывая версию**.
2.  **Разумные настройки по умолчанию:** Устанавливается версия Java, кодировка `UTF-8` и другие настройки сборки.
3.  **Конфигурация плагинов:** Предоставляет готовую конфигурацию `spring-boot-maven-plugin`, который отвечает за сборку исполняемого "fat" JAR-файла.

</details>

### Как работают Embedded Server?

<details>
<summary>Ответ</summary>

Вместо того чтобы вы деплоили свой код на сервер, **сервер теперь деплоится внутрь вашего кода**.

Приложение собирается в один исполняемый **"fat" JAR-файл**.

1.  **Структура JAR:** Внутри такого JAR-а лежат не только ваши классы (`BOOT-INF/classes`), но и все зависимости, включая сам сервер, в виде вложенных JAR-файлов (`BOOT-INF/lib/tomcat-embed-core.jar`).
2.  **Специальный загрузчик:** Стандартный `ClassLoader` Java не умеет загружать классы из вложенных JAR-ов. Spring Boot решает эту проблему с помощью кастомного загрузчика (`JarLauncher`).
3.  **Процесс запуска:** Когда вы выполняете `java -jar myapp.jar`, запускается `JarLauncher`. Он создает специальный `ClassLoader`, который умеет читать вложенные JAR-ы, и только потом вызывает `main` метод вашего приложения.

</details>

### Как Spring Boot запускает сервер?

<details>
<summary>Ответ</summary>

Это часть **автоконфигурации**:

1.  **Обнаружение:** Spring Boot видит в classpath `spring-boot-starter-web` и класс `Tomcat.class`.
2.  **Активация:** Это триггерит автоконфигурацию веб-сервера.
3.  **Создание Фабрики:** В контексте создается бин `TomcatServletWebServerFactory`. Это не сам сервер, а **фабрика**, которая знает, как его создать и настроить.
4.  **Запуск:** В конце поднятия контекста Spring вызывает у этой фабрики метод `getWebServer()`. Фабрика программно создает, настраивает (порт, контекст) и запускает экземпляр Tomcat, регистрируя в нем `DispatcherServlet`.

</details>

### Жизненный цикл: От `main()` до обработки запроса

<details>
<summary>Ответ</summary>

1.  `java -jar myapp.jar` -> запускается `JarLauncher` от Spring Boot.
2.  `JarLauncher` настраивает `ClassLoader` и вызывает `MyApplication.main(args)`.
3.  `SpringApplication.run()` создает и "освежает" `ApplicationContext`.
4.  В процессе срабатывает **автоконфигурация**: создаются бины `DispatcherServlet` и `TomcatServletWebServerFactory`.
5.  После создания бинов Spring просит фабрику (`TomcatServletWebServerFactory`) создать и запустить веб-сервер.
6.  Фабрика создает, настраивает и запускает Tomcat, передав ему `DispatcherServlet`.
7.  Сервер запущен и готов принимать HTTP-запросы, которые он передает в `DispatcherServlet` для дальнейшей обработки.

</details>

### Что такое `spring.factories`?

<details>
<summary>Ответ</summary>

**`spring.factories`** — это файл, расположенный в `META-INF/`, который Spring использует для реализации механизма **SPI (Service Provider Interface)**.

Он служит "индексом", позволяя различным JAR-модулям "заявлять" о своих компонентах (например, автоконфигурациях, слушателях событий) без необходимости явного сканирования. Spring при запуске читает все `spring.factories` на classpath и использует эту информацию для настройки.

</details>

### Как `spring.factories` влияет на автоконфигурацию?

<details>
<summary>Ответ</summary>

Это его ключевая роль.
1.  **Запуск:** Аннотация `@EnableAutoConfiguration` запускает процесс.
2.  **Поиск кандидатов:** Spring ищет все файлы `spring.factories` и читает из них список классов, перечисленных под ключом `org.springframework.boot.autoconfigure.EnableAutoConfiguration`.
3.  **Формирование "меню":** Spring собирает полный список всех потенциальных автоконфигураций из всех подключенных стартеров.
4.  **Условная активация:** **Наличие в файле не означает активацию.** Spring проходит по этому "меню" и проверяет для каждого класса `@Conditional` аннотации. Только если условия выполнены, конфигурация будет применена.

Таким образом, `spring.factories` предоставляет "меню" доступных конфигураций, а `@Conditional` решает, что из этого "меню" нужно "заказать".

</details>

### На что применили `spring.factories` в Spring Boot 2.7+?

<details>
<summary>Ответ</summary>

Начиная со Spring Boot 2.7 (и окончательно в 3.0), для автоконфигурации введен новый, более производительный механизм. Вместо `spring.factories` теперь используется файл:

*   **`META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports`**

Он содержит простой список имен классов автоконфигураций, по одному на строку. Это позволяет Spring читать нужную информацию быстрее. `spring.factories` по-прежнему поддерживается для обратной совместимости и других механизмов SPI.

</details>

### Что за директория `META-INF`?

<details>
<summary>Ответ</summary>

**`META-INF`** (Meta-Information) — это стандартная директория внутри Java-архивов (JAR, WAR), предназначенная для хранения метаданных. Содержимое этой папки — не код вашего приложения, а служебная информация для JVM, фреймворков и серверов приложений.

Если JAR-файл — это "контейнер" с кодом, то `META-INF` — это его **"паспорт" и "инструкция по применению"**.

</details>

### Зачем нужна директория `META-INF`?

<details>
<summary>Ответ</summary>

Она служит для нескольких ключевых целей:

1.  **Манифест (`MANIFEST.MF`):** "Паспорт" JAR-файла. Указывает `Main-Class` для запуска (`java -jar`), версию, classpath и другую основную информацию.
2.  **Обнаружение сервисов (SPI):** Стандартный механизм Java для поиска реализаций интерфейсов. Например, JDBC-драйверы регистрируют себя в `META-INF/services/java.sql.Driver`.
3.  **Конфигурация фреймворков:** Spring использует `spring.factories` (или `.imports` файл) для обнаружения автоконфигураций. JPA ищет там `persistence.xml`.
4.  **Подпись и безопасность:** Хранит файлы цифровых подписей для проверки целостности и подлинности JAR-архива.

</details>