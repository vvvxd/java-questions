### Что такое AOP и Сквозная Функциональность?

<details>
<summary>Ответ</summary>

**Сквозная функциональность (Cross-Cutting Concern)** — это логика, которая затрагивает множество модулей приложения. Классические примеры:
логирование, управление транзакциями, безопасность, кэширование.

**Аспектно-ориентированное программирование (AOP)** — это парадигма, которая позволяет выделить сквозную функциональность в отдельные
модули (аспекты) и декларативно применять её к коду, не изменяя его напрямую. AOP помогает лучше структурировать код, отделяя бизнес-логику
от технических задач.

Spring AOP — это реализация принципов AOP, которая тесно интегрирована со Spring IoC контейнером.

</details>

### Как Spring AOP работает и зачем ему прокси?

<details>
<summary>Ответ</summary>

Spring AOP работает путем создания **динамических прокси-объектов** для бинов во время выполнения (runtime). Прокси — это объект-обёртка,
который имеет те же публичные методы, что и оригинальный объект (цель), но добавляет к ним дополнительное поведение (например, логирование).

Когда вы вызываете метод бина, вы на самом деле обращаетесь к его прокси. Прокси выполняет логику аспекта (например, начинает транзакцию),
затем вызывает оригинальный метод целевого объекта, а после его завершения выполняет оставшуюся логику аспекта (например, коммитит
транзакцию).

Это позволяет добавлять новую функциональность без изменения исходного кода компонентов.

</details>

### Какие типы прокси может создавать Spring?

<details>
<summary>Ответ</summary>

Spring использует два механизма для создания прокси:

1. **JDK Dynamic Proxy:**
    * **Требование:** Целевой класс должен реализовывать хотя бы один интерфейс.
    * **Механизм:** Создаёт прокси-класс на лету, который реализует те же интерфейсы, что и целевой объект. `java.lang.reflect.Proxy` Это
      утилитный класс-фабрика. Его основная задача — создавать новые прокси-классы и их экземпляры. Перехват вызовов происходит
      через `java.lang.reflect.InvocationHandler`.
    * **Поведение по умолчанию:** Используется, если у бина есть интерфейс.

2. **CGLIB (Code Generation Library):**
    * **Требование:** Целевой класс и его методы не должны быть `final`.
    * **Механизм:** Создаёт подкласс (наследуется от) целевого класса и переопределяет его публичные методы для добавления логики аспекта.
      `net.sf.cglib.proxy.Enhancer`— это класс-фабрика, который динамически  создает подкласс вашего целевого класса, "улучшая" его новым поведением.Перехват происходит
      через `net.sf.cglib.proxy.MethodInterceptor`.
    * **Поведение по умолчанию:** Используется, если у бина нет интерфейсов. В современных версиях Spring Boot часто используется по
      умолчанию (`proxy-target-class=true`) для унификации поведения.

</details>

### Сравнение: JDK Proxy vs CGLIB

<details>
<summary>Ответ</summary>

| Характеристика                 | JDK Dynamic Proxy                              | CGLIB                                  |
|:-------------------------------|:-----------------------------------------------|:---------------------------------------|
| **Основное требование**        | Нужен **интерфейс**                            | Класс не должен быть **`final`**       |
| **Механизм**                   | Реализует интерфейсы                           | **Наследует** от класса                |
| **Перехват**                   | `InvocationHandler`                            | `MethodInterceptor`                    |
| **Вызов оригинала**            | `method.invoke()` (медленнее, через рефлексию) | `methodProxy.invokeSuper()` (быстрее)  |
| **Проблема `self-invocation`** | Присутствует                                   | Присутствует                           |
| **Область действия**           | Только методы, объявленные в интерфейсе        | Все публичные не-`final` методы класса |

</details>

### Ключевые термины AOP

<details>
<summary>Ответ</summary>

* **Aspect (Аспект):** Модуль (класс с аннотацией `@Aspect`), который инкапсулирует сквозную функциональность. Содержит в себе `Advice`
  и `Pointcut`.
* **Join Point (Точка соединения):** Любая точка в выполнении программы, где можно применить аспект. В Spring AOP это **только вызов
  публичного метода бина**.
* **Advice (Совет):** Действие, выполняемое аспектом. Это "что" и "когда" делать. Основные типы:
    * `@Before`: перед вызовом метода.
    * `@AfterReturning`: после успешного выполнения метода.
    * `@AfterThrowing`: если метод выбросил исключение.
    * `@After` (or `@AfterFinally`): после завершения метода (неважно, успешно или с ошибкой).
    * `@Around`: "вокруг" метода. Самый мощный совет, позволяет управлять вызовом метода (или даже не вызывать его) и изменять возвращаемое
      значение.
* **Pointcut (Срез):** Выражение, которое определяет, к каким именно `Join Points` (методам) применять `Advice`. Это "где" делать.
* **Weaving (Внедрение):** Процесс связывания аспекта с целевым объектом. В Spring AOP это происходит во время выполнения (runtime) при
  создании прокси.

</details>

### Практические вопросы AOP

<details>
<summary>Ответ</summary>

#### Проблема `self-invocation` (внутреннего вызова)

Рассмотрим код:

```java

@Service
public class MyService {

  @Transactional
  public void method1() {
    // ...
    this.method2(); // <-- Проблемный вызов
  }

  @Transactional(propagation = Propagation.REQUIRES_NEW)
  public void method2() {
    // ...
  }
}
```

При вызове `method1()` извне откроется транзакция, так как вызов идет через прокси. Однако последующий вызов `this.method2()` — это прямой
вызов метода внутри того же объекта, **минуя прокси**. В результате аннотация `@Transactional` на `method2` будет проигнорирована, и новая
транзакция не начнется.

#### Порядок выполнения аспектов

Если к одному методу применяется несколько аспектов, их порядок можно контролировать с помощью аннотации **`@Order(value)`** или реализуя
интерфейс `org.springframework.core.Ordered`. **Чем меньше значение `value`, тем выше приоритет** (тем раньше аспект будет выполнен).

#### Потеря возвращаемого значения в `@Around`

`@Around`-совет обязан вернуть результат, иначе вызывающий код получит `null`.

```java

@Around("myPointcut()")
public Object logExecutionTime(ProceedingJoinPoint joinPoint) throws Throwable {
  // ... логика до
  Object result = joinPoint.proceed(); // Вызываем оригинальный метод
  // ... логика после
  return result; // <-- Важно вернуть результат!
}
```

#### Stateful-аспекты (хранящие состояние)

По умолчанию аспект — это синглтон. Если нужно хранить состояние для каждого целевого объекта, можно использовать
аннотацию `@Aspect("perthis(pointcutExpression())")`. Это создаст новый экземпляр аспекта для каждого прокси-объекта, соответствующего
pointcut'у.

</details>

### В чем разница между Spring AOP и AspectJ?

<details>
<summary>Ответ</summary>

Это два разных подхода к реализации AOP.

| Характеристика                 | Spring AOP                               | AspectJ                                       |
|:-------------------------------|:-----------------------------------------|:----------------------------------------------|
| **Основной механизм**          | Динамические прокси (JDK/CGLIB)          | Модификация байт-кода                         |
| **Время внедрения (Weaving)**  | **Runtime** (во время выполнения)        | **Compile-time** или **Load-time**            |
| **Типы Join Points**           | Только выполнение публичных методов бина | Методы, конструкторы, поля, стат. блоки и др. |
| **Область действия**           | Только Spring-бины                       | Любые Java-объекты                            |
| **Проблема `self-invocation`** | **Присутствует**                         | **Отсутствует** (т.к. байт-код изменен)       |
| **Простота настройки**         | Очень просто, "из коробки" в Spring      | Требует настройки (плагин, java-агент)        |

**Как они работают вместе?**
Чаще всего вы используете **синтаксис AspectJ** (`@Aspect`, `@Pointcut`) для определения аспектов, но **реализует их Spring AOP** через
прокси. Это самый распространенный и удобный вариант в экосистеме Spring.

**Когда что выбирать?**

* **Spring AOP (95% случаев):** Идеален для большинства задач: транзакции, безопасность, логирование на уровне сервисов. Он прост и не
  требует сложной настройки.
* **AspectJ:** Нужен, когда возможностей Spring AOP не хватает:
    * Применить аспект к объектам, не управляемым Spring (например, к сущностям).
    * Перехватить доступ к полям или вызовы конструкторов.
    * Архитектурно решить проблему `self-invocation`.

</details>