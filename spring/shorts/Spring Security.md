### Что такое аутентификация и авторизация?

*   **Аутентификация** — это процесс проверки личности пользователя (кто вы?).
    1.  Данные (логин/пароль) упаковываются в токен (`UsernamePasswordAuthenticationToken`).
    2.  Токен передается в `AuthenticationManager` для проверки.
    3.  В случае успеха `AuthenticationManager` возвращает полностью заполненный объект `Authentication` с данными пользователя и его правами.
    4.  Этот объект помещается в `SecurityContextHolder`, делая его доступным во всем приложении для текущего запроса.

*   **Авторизация** — это процесс проверки прав доступа пользователя (что вам можно делать?). Происходит **после** успешной аутентификации.
    1.  Система определяет права (роли) аутентифицированного пользователя.
    2.  Эти права сравниваются с требованиями для доступа к защищенному ресурсу.

---

### Что такое Spring Security?

**Spring Security** — это фреймворк для обеспечения безопасности в Java-приложениях.

**Основные задачи:**
*   **Аутентификация**: Проверка подлинности пользователя (логин/пароль, JWT, OAuth2).
*   **Авторизация**: Контроль доступа к ресурсам на основе ролей и прав.
*   **Защита от атак**: Предотвращение CSRF, XSS, фиксации сессий и других уязвимостей.
*   **Интеграция**: Поддержка стандартов LDAP, SAML, OAuth2, OpenID Connect.

В основе Spring Security лежит **цепочка фильтров (Filter Chain)**, которая перехватывает и обрабатывает HTTP-запросы.

---

### Как Security работает внутри: Цепочка фильтров

Spring Security встраивается в обработку запросов через `DelegatingFilterProxy` — специальный сервлет-фильтр, который передает управление цепочке фильтров Spring Security (`SecurityFilterChain`).

**Процесс обработки запроса:**
1.  **Запрос клиента** поступает на сервер.
2.  `DelegatingFilterProxy` перехватывает его и направляет в `SecurityFilterChain`.
3.  Запрос последовательно проходит через **набор фильтров**, каждый из которых выполняет свою задачу (проверка JWT, управление сессией, проверка CSRF и т.д.).
4.  Если все фильтры успешно отработали, запрос доходит до **целевого ресурса** (например, контроллера).
5.  Ответ проходит через фильтры в обратном порядке и возвращается клиенту.

#### Ключевые фильтры (для REST API с JWT)

Для stateless-приложений с JWT многие стандартные фильтры отключаются (`csrf`, `sessionManagement`). Важными остаются:

*   **`JwtAuthenticationFilter` (кастомный)**:
    *   **Позиция**: Добавляется перед `UsernamePasswordAuthenticationFilter`.
    *   **Задача**: Извлекает JWT из заголовка, валидирует его, извлекает данные пользователя (логин, роли) и создает объект `Authentication`, помещая его в `SecurityContextHolder`.
*   **`ExceptionTranslationFilter`**:
    *   **Задача**: Перехватывает исключения безопасности (`AuthenticationException`, `AccessDeniedException`) и преобразует их в HTTP-ответы (401 Unauthorized, 403 Forbidden).
*   **`FilterSecurityInterceptor`**:
    *   **Задача**: Последний фильтр в цепочке, который выполняет авторизацию. Он проверяет, имеет ли пользователь, указанный в `SecurityContext`, доступ к запрошенному URL на основе настроенных правил.

---

### Основные компоненты Spring Security

*   **`SecurityContextHolder`**: Хранит `SecurityContext` для текущего потока (thread-local), обеспечивая доступ к данным аутентификации в любом месте приложения.
*   **`SecurityContext`**: Содержит объект `Authentication`.
*   **`Authentication`**: Представляет текущего пользователя, его права (`GrantedAuthority`) и статус аутентификации.
*   **`UserDetails`**: Интерфейс с информацией о пользователе (логин, пароль, права, статус аккаунта).
*   **`UserDetailsService`**: Сервис, который загружает `UserDetails` по имени пользователя из хранилища (БД, LDAP и т.д.).
*   **`AuthenticationManager`**: Центральный компонент для обработки аутентификации. Он принимает `Authentication` токен и пытается его аутентифицировать через `AuthenticationProvider`.
*   **`OncePerRequestFilter`**: Базовый класс для фильтров, гарантирующий выполнение **только один раз** за запрос. Идеален для создания кастомных фильтров (например, `JwtAuthenticationFilter`).

---

### Кодирование, шифрование и хеширование

| Характеристика | Кодирование | Шифрование | Хеширование |
| :--- | :--- | :--- | :--- |
| **Цель** | Совместимость форматов | Конфиденциальность | Целостность, хранение паролей |
| **Обратимость** | **Обратимый** | **Обратимый** (с ключом) | **Необратимый** |
| **Ключ** | Не нужен | Нужен | Не нужен (но используется "соль") |
| **Примеры** | Base64, URL-encode | AES, RSA | BCrypt, SHA-256, Argon2 |
| **Применение** | JWT (заголовок, payload) | Защита данных (HTTPS, JWE) | **Хранение паролей**, цифровые подписи |

**Для паролей в Spring Security используется хеширование** (например, с `BCryptPasswordEncoder`), так как оно необратимо и защищает от утечек.

---

### Настройка авторизации

#### В `SecurityFilterChain` (конфигурация `HttpSecurity`)

*   **`hasAuthority('PERMISSION_NAME')`**: Проверяет наличие конкретного права. Используется для гранулярного контроля.
*   **`hasRole('ROLE_NAME')`**: Проверяет наличие роли. Автоматически добавляет префикс `ROLE_` (т.е. `hasRole('ADMIN')` ищет `ROLE_ADMIN`).
*   **`access(SpelExpression)`**: Позволяет использовать сложные правила авторизации с помощью Spring Expression Language (SpEL).

**Рекомендация**: Используйте `hasRole` для простых ролевых моделей, `hasAuthority` для систем с детализированными правами.

#### На уровне методов (аннотации)

Для включения нужно добавить `@EnableMethodSecurity` в класс конфигурации.

*   **`@PreAuthorize`**: Проверка **до** выполнения метода. Самая гибкая и часто используемая аннотация.
    ```java
    @PreAuthorize("hasRole('ADMIN') or #user.id == authentication.principal.id")
    public void updateUser(User user) { /* ... */ }
    ```
*   **`@PostAuthorize`**: Проверка **после** выполнения метода, на основе возвращаемого значения.
    ```java
    @PostAuthorize("returnObject.owner == authentication.name")
    public Document getDocument(Long id) { /* ... */ }
    ```
*   **`@Secured` / `@RolesAllowed`**: Простые аннотации для проверки ролей (без SpEL).

#### Что быстрее: `SecurityFilterChain` или `@PreAuthorize`?

**`SecurityFilterChain` быстрее.** Проверка происходит на раннем этапе в цепочке фильтров, **до** того, как запрос достигнет контроллера. Это отклоняет неавторизованные запросы, не тратя ресурсы на дальнейшую обработку.

`@PreAuthorize` работает позже, перехватывая вызов метода с помощью AOP. Используйте его, когда логика доступа зависит от параметров метода, которые недоступны в `SecurityFilterChain`.