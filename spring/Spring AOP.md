## Что такое AOP? Как это относиться к IoC?

<details>
<summary>Ответ</summary>

Аспектно-ориентированное программирование (АОП) - парадигма программирования, основанная на идее разделения функциональности для улучшения разбиения программы на модули. AOP и Spring - взаимодополняющие технологии, которые позволяют решать сложные проблемы путем разделения функционала на отдельные модули. АОП предоставляет возможность реализации сквозной логики - т.е. логики, которая применяется к множеству частей приложения - в одном месте и обеспечения автоматического применения этой логики по всему приложению. Подход Spring к АОП заключается в создании "динамических прокси" для целевых объектов и "привязывании" объектов к конфигурированному совету для выполнения сквозной логики.

</details>

### Почему Spring желает создавать прокси?

<details>
<summary>Ответ</summary>

Потому что это позволяет Spring дать вашим компонентам дополнительные функции без изменения кода. В сущности, это то, что является аспектно-ориентированным (или: AOP) программированием.

Давайте рассмотрим самый популярный пример AOP — аннотацию Spring @Transactional.

</details>

### В чем разница между Сквозной Функциональностью (Cross Cutting Concerns) и АОП (аспектно оринтированное программирование)?

<details>
<summary>Ответ</summary>

Сквозная Функциональность — функциональность, которая может потребоваться вам на нескольких различных уровнях — логирование, управление производительностью, безопасность и т.д.

АОП — один из подходов к реализации данной проблемы

</details>

### Как Spring AOP создает прокси-объекты?

<details>
<summary>Ответ</summary>

для создания прокси объектов может использоваться как JDK так и CGLib, но предпочтение должно отдаваться JDK. И, если класс имеет хотя бы один интерфейс, то именно JDK dynamic proxy и будет использоваться (хотя это можно изменить, явно задав флаг proxy-target-class). При создании прокси объекта с помощью JDK на вход передаются все интерфейсы класса и метод для имплементации нового поведения. В результате получаем объект, который абсолютно точно реализует паттерн Proxy. Все это происходит на этапе создания бинов, поэтому, когда начинается внедрение зависимостей, то в реальности внедрен будет этот самый прокси-объект. И все обращения будут производиться именно к нему. Но выполнив свою часть функционала, он обратиться к объекту исходного класса и передаст ему управление. Если же этот объект сам обратиться к одному из своих методов, то это будет уже прямой вызов без всяких прокси.

</details>

### Что такое прокси-объекты и какие типы прокси-объектов может создавать Spring?

<details>
<summary>Ответ</summary>

Прокси это специальный объект, который имеет такие же публичные методы как и бин, но у которого есть дополнительная функциональность.Два вида прокси:

JDK dynamic proxy — динамическое прокси. API встроены в JDK. Объекты создаются на основе интерфейсов.

CGLib proxy — не встроен в JDK. Используется когда интерфейс объекта недоступен, он создает классы наследники.

Плюсы прокси-объектов:Позволяют добавлять доп. логику — управление транзакциями, безопасность, логирование

Отделяет некоторый код(логирование и т.п.) от основной логики

</details>

### Как JDK Dynamic Proxy создаёт прокси?

<details>
<summary>Ответ</summary>

**JDK Dynamic Proxy может создавать прокси только для классов, которые реализуют один или несколько интерфейсов.**

Он не может проксировать "чистые" классы (POJO), которые не имплементируют интерфейсы. Именно поэтому для таких случаев Spring использует библиотеку CGLIB.

В этом механизме всего два главных действующих лица из пакета `java.lang.reflect`:

1.  **`java.lang.reflect.Proxy`:** Это утилитный класс-фабрика. Его основная задача — создавать новые прокси-классы и их экземпляры. У него нет публичного конструктора, и вы работаете с ним только через статические методы, главный из которых — `newProxyInstance()`.

2.  **`java.lang.reflect.InvocationHandler`:** Это интерфейс. И это **сердце** всего механизма. Ваша "логика аспекта" (логирование, безопасность, транзакции) будет жить именно здесь. У этого интерфейса всего один метод:
    ```java
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable;
    ```
    *   `proxy`: Ссылка на сам прокси-объект, на котором вызвали метод. Полезна в редких случаях, когда логике нужно знать о своем "носителе".
    *   `method`: Объект `java.lang.reflect.Method`, представляющий метод интерфейса, который был вызван (например, `pay()` или `save()`). Из него можно получить имя метода, параметры, аннотации и т.д.
    *   `args`: Массив объектов, содержащий аргументы, с которыми был вызван метод.

</details>

### Мы хотим логировать все вызовы методов нашего сервиса оплаты. Как это реализовать с помощью JDK Dynamic Proxy?

<details>
<summary>Ответ</summary>

**Шаг 1: Определяем контракт (интерфейс)**

Это обязательное условие.
```java
public interface PaymentService {
    void pay(int amount);
    String checkStatus(String transactionId);
}
```

**Шаг 2: Создаем реальную реализацию (Target Object)**

Это наш "чистый" бизнес-класс. Он ничего не знает о логировании.
```java
public class RealPaymentService implements PaymentService {
    @Override
    public void pay(int amount) {
        System.out.println(">>> Бизнес-логика: списание " + amount + " рублей.");
    }

    @Override
    public String checkStatus(String transactionId) {
        System.out.println(">>> Бизнес-логика: проверка статуса транзакции " + transactionId);
        return "SUCCESS";
    }
}
```

**Шаг 3: Создаем обработчик вызовов (Invocation Handler)**

Это и есть наша "аспектная логика". Здесь мы реализуем интерфейс `InvocationHandler`.
```java
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.util.Arrays;

public class LoggingInvocationHandler implements InvocationHandler {

    private final Object target; // Ссылка на оригинальный, реальный объект

    public LoggingInvocationHandler(Object target) {
        this.target = target;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println(
            "[ЛОГ] Перед вызовом: " + method.getName() +
            " с аргументами: " + Arrays.toString(args)
        );

        // Ключевой момент! Вызываем оригинальный метод на реальном объекте
        Object result = method.invoke(target, args);

        System.out.println(
            "[ЛОГ] После вызова: " + method.getName() +
            " вернул результат: " + result
        );

        return result; // Возвращаем результат клиенту
    }
}
```

**Шаг 4: Собираем все вместе — создаем прокси!**

В главном методе мы используем `Proxy.newProxyInstance()` для создания нашего "секретаря".
```java
import java.lang.reflect.Proxy;

public class Main {
    public static void main(String[] args) {
        // 1. Создаем оригинальный объект
        PaymentService realService = new RealPaymentService();

        // 2. Создаем наш обработчик (Invocation Handler), передавая ему оригинал
        InvocationHandler handler = new LoggingInvocationHandler(realService);

        // 3. Создаем прокси с помощью фабрики Proxy
        PaymentService proxyService = (PaymentService) Proxy.newProxyInstance(
            PaymentService.class.getClassLoader(), // Класс-загрузчик
            new Class<?>[]{ PaymentService.class }, // Массив интерфейсов, которые должен реализовать прокси
            handler                                // Наш обработчик
        );

        // 4. Используем прокси. Клиентский код не видит разницы!
        System.out.println("--- Работаем через прокси ---");
        proxyService.pay(500);
        System.out.println("-----------------------------");
        String status = proxyService.checkStatus("tx-12345");
        System.out.println("Финальный статус: " + status);
    }
}
```

</details>

### Что на самом деле делает `Proxy.newProxyInstance()`?

<details>
<summary>Ответ</summary>

Вот что происходит в недрах JVM в момент вызова этого метода:

1.  **Генерация байт-кода:** JVM на лету генерирует байт-код для совершенно нового класса. У этого класса нет исходного `.java` файла.
2.  **Имя класса:** Имя обычно выглядит как `$Proxy0`, `$Proxy1` и т.д.
3.  **Структура сгенерированного класса:** Если бы мы могли декомпилировать этот класс, он бы выглядел примерно так:

    ```java
    // Этот класс генерируется JVM в памяти
    public final class $Proxy0 extends java.lang.reflect.Proxy implements PaymentService {

        // Скрытое статическое поле для хранения Method объектов для каждого метода интерфейса
        private static Method m1_pay;
        private static Method m2_checkStatus;
        // ... и для методов equals, hashCode, toString

        // Конструктор, который принимает наш обработчик
        public $Proxy0(InvocationHandler handler) {
            super(handler); // Сохраняем handler в родительском классе Proxy
        }

        // Реализация метода из интерфейса PaymentService
        @Override
        public final void pay(int amount) {
            try {
                // Ключевой момент!
                // Вызов не содержит бизнес-логики.
                // Он просто "упаковывает" информацию о вызове и передает ее в наш handler.
                // this.h - это ссылка на наш LoggingInvocationHandler
                this.h.invoke(this, m1_pay, new Object[]{amount});
            } catch (Throwable e) {
                // Обработка исключений
                throw new UndeclaredThrowableException(e);
            }
        }

        @Override
        public final String checkStatus(String transactionId) {
             try {
                return (String) this.h.invoke(this, m2_checkStatus, new Object[]{transactionId});
            } catch (Throwable e) {
                throw new UndeclaredThrowableException(e);
            }
        }

        // ... также генерируются реализации для equals, hashCode, toString ...
    }
    ```

4.  **Загрузка и создание экземпляра:** После генерации байт-кода этот новый класс загружается в JVM с помощью переданного `ClassLoader`, и затем создается его экземпляр через конструктор, в который передается наш `LoggingInvocationHandler`.

</details>

### Как CGLIB (Code Generation Library) создаёт прокси?

<details>
<summary>Ответ</summary>

**CGLIB может создавать прокси для любого класса, который не является `final` и имеет не-`final` методы. Ему не нужны интерфейсы.**

Он достигает этого за счет другой стратегии — **создания подкласса (наследования)**, а не реализации интерфейса.

Основные классы CGLIB находятся в пакете `org.springframework.cglib` (Spring включает свою перепакованную версию CGLIB, чтобы избежать конфликтов версий).

1.  **`net.sf.cglib.proxy.Enhancer`:** Это аналог `java.lang.reflect.Proxy` из JDK. `Enhancer` (Улучшатель) — это класс-фабрика, который динамически создает подкласс вашего целевого класса, "улучшая" его новым поведением.

2.  **`net.sf.cglib.proxy.MethodInterceptor`:** Это аналог `java.lang.reflect.InvocationHandler`. Это интерфейс, который вы реализуете, чтобы определить логику перехвата. Его единственный метод `intercept` — это то место, где будет жить ваш "аспект".

    ```java
    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable;
    ```
    *   `obj`: Ссылка на созданный прокси-объект (подкласс).
    *   `method`: Объект `java.lang.reflect.Method`, представляющий перехваченный метод.
    *   `args`: Массив аргументов, с которыми вызвали метод.
    *   `proxy` (`MethodProxy`): **Это ключевое отличие и оптимизация CGLIB!** Это специальный объект CGLIB, который предоставляет очень быстрый способ вызова оригинального метода (метода суперкласса). Он намного производительнее, чем `method.invoke()`.

</details>

### Мы хотим логировать все вызовы методов нашего сервиса оплаты. Как это реализовать с помощью JDK Dynamic Proxy?

<details>
<summary>Ответ</summary>

**Задача:** Мы хотим логировать вызовы методов сервиса, у которого нет интерфейса.

**Шаг 1: Создаем целевой класс (Target Object)**

Это обычный POJO. Обратите внимание: **нет `implements`**. Методы не должны быть `final`.
```java
// Этот класс не реализует интерфейсов
public class BookService {
    public void addBook(String title) {
        System.out.println(">>> Бизнес-логика: добавление книги '" + title + "' в базу данных.");
    }

    public String findBookById(int id) {
        System.out.println(">>> Бизнес-логика: поиск книги по id " + id);
        if (id == 42) {
            return "Автостопом по галактике";
        }
        return null;
    }
}
```

**Шаг 2: Создаем перехватчик методов (Method Interceptor)**

Это наша "аспектная логика" в стиле CGLIB.
```java
import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;
import java.lang.reflect.Method;
import java.util.Arrays;

public class LoggingMethodInterceptor implements MethodInterceptor {

    @Override
    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
        // Игнорируем методы из класса Object, чтобы не логировать вызовы hashCode, equals и т.д.
        if (method.getDeclaringClass() != Object.class) {
            System.out.println(
                "[ЛОГ CGLIB] Перед вызовом: " + method.getName() +
                " с аргументами: " + Arrays.toString(args)
            );
        }

        // Ключевой момент! Вызываем оригинальный метод через MethodProxy.
        // Это быстрее, чем method.invoke()
        Object result = proxy.invokeSuper(obj, args);

        if (method.getDeclaringClass() != Object.class) {
             System.out.println(
                "[ЛОГ CGLIB] После вызова: " + method.getName() +
                " вернул результат: " + result
            );
        }

        return result;
    }
}
```

**Шаг 3: Собираем все вместе с помощью `Enhancer`**

```java
import net.sf.cglib.proxy.Enhancer;

public class MainCGLib {
    public static void main(String[] args) {
        // 1. Создаем Enhancer
        Enhancer enhancer = new Enhancer();

        // 2. Указываем, какой класс мы хотим расширить (создать подкласс)
        enhancer.setSuperclass(BookService.class);

        // 3. Устанавливаем наш перехватчик (callback)
        enhancer.setCallback(new LoggingMethodInterceptor());

        // 4. Создаем прокси-объект
        BookService proxyService = (BookService) enhancer.create();

        // 5. Используем прокси. Клиентский код не видит разницы!
        System.out.println("--- Работаем через CGLIB прокси ---");
        proxyService.addBook("Война и Мир");
        System.out.println("------------------------------------");
        String book = proxyService.findBookById(42);
        System.out.println("Найденная книга: " + book);
    }
}
```

</details>

### Что на самом деле делает `Enhancer`?

<details>
<summary>Ответ</summary>

1.  **Генерация байт-кода:** Как и JDK Proxy, CGLIB генерирует байт-код нового класса на лету.

2.  **Имя класса:** Имя обычно содержит имя родительского класса и хэш, например: `BookService$$EnhancerByCGLIB$$a1b2c3d4`.

3.  **Структура сгенерированного класса:** Вот здесь и кроется главное отличие. CGLIB создает **подкласс**.

    ```java
    // Этот класс генерируется CGLIB в памяти
    public class BookService$$EnhancerByCGLIB$$a1b2c3d4 extends BookService {

        // Ссылка на наш перехватчик
        private MethodInterceptor CGLIB$CALLBACK_0;

        // Переопределенный метод из родительского класса BookService
        @Override
        public final void addBook(String title) {
            MethodInterceptor interceptor = this.CGLIB$CALLBACK_0;
            if (interceptor == null) {
                // Если нет перехватчика, вызываем оригинальный метод напрямую
                super.addBook(title);
                return;
            }
            // Иначе, передаем управление в наш interceptor
            // MethodProxy для addBook передается сюда скрыто
            interceptor.intercept(this, /* Method объект для addBook */, new Object[]{title}, /* MethodProxy объект */);
        }

        // Еще один переопределенный метод
        @Override
        public final String findBookById(int id) {
            MethodInterceptor interceptor = this.CGLIB$CALLBACK_0;
            if (interceptor == null) {
                return super.findBookById(id);
            }
            return (String) interceptor.intercept(this, /* Method объект для findBookById */, new Object[]{id}, /* MethodProxy объект */);
        }

        // ... и так для всех не-final, не-private методов ...
    }
    ```

</details>

### Какие есть ограничения и важные моменты CGLIB?

<details>
<summary>Ответ</summary>

*   **Final классы:** Нельзя создать подкласс `final` класса. CGLIB выбросит исключение.
*   **Final методы:** `final` метод нельзя переопределить. Поэтому CGLIB не сможет его перехватить. Вызов такого метода на прокси-объекте пойдет напрямую в оригинальную реализацию, **минуя `intercept`**.
*   **Private методы:** Не перехватываются, так как они не видны в подклассе.
*   **Конструкторы:** CGLIB вызывает конструктор суперкласса. Если у вашего класса нет конструктора по умолчанию (без аргументов), вам нужно будет указать `enhancer.create(argTypes, args)` и передать нужные аргументы для вызова соответствующего конструктора.
*   **Проблема `self-invocation`:** Существует точно так же, как и в JDK Proxy. Вызов `this.anotherMethod()` изнутри `BookService` не будет перехвачен, потому что он не проходит через прокси-подкласс.

</details>

### JDK Proxy vs CGLIB

<details>
<summary>Ответ</summary>

| Характеристика | JDK Dynamic Proxy | CGLIB |
| :--- | :--- | :--- |
| **Основное требование** | Нужен хотя бы один **интерфейс** | Класс не должен быть **`final`** |
| **Механизм** | Реализует интерфейсы | **Наследует** от класса |
| **Перехват** | `InvocationHandler` | `MethodInterceptor` |
| **Вызов оригинала** | `method.invoke(target, args)` (медленнее, через рефлексию) | `methodProxy.invokeSuper(proxy, args)` (быстрее) |
| **Ограничения** | Не работает с классами без интерфейсов | Не работает с `final` классами/методами |

**Как это использует Spring:**
Spring AOP по умолчанию сам решает, что использовать.
*   Если ваш бин реализует хотя бы один интерфейс, Spring по умолчанию использует **JDK Dynamic Proxy**.
*   Если ваш бин — это просто класс без интерфейсов, Spring использует **CGLIB**.

В современных версиях Spring Boot часто по умолчанию используется CGLIB (`proxy-target-class=true`), даже если есть интерфейсы, так как это решает некоторые тонкие проблемы (например, с аннотациями на уровне класса, а не интерфейса) и унифицирует поведение проксирования. Вы можете управлять этим поведением через свойство `spring.aop.proxy-target-class` в `application.properties`.

</details>

### Почему Spring нужен CGLIB?

<details>
<summary>Ответ</summary>

Сериализация прокси-объектов, созданных JDK, может быть сложной. `InvocationHandler` должен быть сериализуемым, и нужно правильно обработать десериализацию, чтобы восстановить связь с целевым объектом (который тоже должен быть сериализуемым). Это требует дополнительного кода и внимания.

| Проблема JDK Proxy | Как решает CGLIB |
| :--- | :--- |
| **1. Требует интерфейс** | **Не требует.** Работает с обычными классами. |
| **2. Self-invocation не перехватывается** | Проблема остается, но CGLIB предлагает более естественный способ ее решения через `proxy-target-class=true`, делая поведение проксирования более предсказуемым. |
| **3. Нельзя вызвать методы не из интерфейса** | **Можно.** Так как прокси является подклассом, его можно безопасно привести к типу родительского класса и вызвать любые публичные методы. |
| **4. Производительность `method.invoke()`** | Использует более быстрый механизм `MethodProxy.invokeSuper()`. |

</details>

### Что такое Aspect в АОП?

<details>
<summary>Ответ</summary>

Аспект (англ. aspect) - модуль или класс, реализующий сквозную функциональность. Аспект изменяет поведение остального кода, применяя совет в точках соединения, определённых некоторым срезом.

@Aspect
@Component
public class MyAspect {
...
}

@Aspect: Говорит Spring: "Этот класс содержит AOP-логику, проанализируй его на наличие Pointcut'ов и Advice'ов".
@Component: Говорит Spring: "Создай экземпляр этого класса и положи его в IoC-контейнер как бин".

Без @Component (или аналога) Spring проигнорирует ваш класс с @Aspect

</details>

### Что такое Pointcut в АОП?

<details>
<summary>Ответ</summary>

Срез (англ. pointcut) - набор точек соединения. Срез определяет, подходит ли данная точка соединения к данному совету. Самые удобные реализации АОП используют для определения срезов синтаксис основного языка (например, в AspectJ применяются Java-сигнатуры) и позволяют их повторное использование с помощью переименования и комбинирования.

@Pointcut("execution(public * com.example.demoAspects.MyService.*(..))")
public void callAtMyServicePublic() { }

</details>

### Что такое Advice в АОП?

<details>
<summary>Ответ</summary>

Совет (англ. advice) - фрагмент кода, который должен выполняться в отдельной точке соединения (Pointcut). Существует несколько типов советов, совет может быть выполнен до, после или вместо точки соединения.

@Before — перед вызовом метода
@After — после вызова метода
@AfterReturning — после возврата значения из функции
@AfterThrowing — в случае exception
@AfterFinally — в случае выполнения блока finally
@Around — можно сделать пред., пост., обработку перед вызовом метода, а также вообще обойти вызов метода.

на один Pointcut можно «повесить» несколько Advice разного типа.

</details>

### Что такое JointPoint в АОП?

<details>
<summary>Ответ</summary>

Точка соединения (англ. joinpoint) - это четко определенная точка в выполняемой программе, где следует применить совет. Типовые примеры точек соединения включают обращение к методу, собственно Method Invocation, инициализацию класса и создание экземпляра объекта. Многие реализации АОП позволяют использовать вызовы методов и обращения к полям объекта в качестве точек соединения.

</details>

### Почему возвращаемое значение при применении аспекта @Around может потеряться? Назовите причины.

<details>
<summary>Ответ</summary>

Метод, помеченный аннотацией @Around, должен возвращать значение, которое он (метод) получил из joinpoint.proceed()

@Around("trackTimeAnnotation()")
public Object around(ProceedingJoinPoint joinPoint) throws Throwable{
long startTime = System.currentTimeMillis();
Object retVal = joinPoint.proceed();
long timeTaken = System.currentTimeMillis() - startTime;
logger.info("Time taken by {} is equal to {}",joinPoint, timeTaken);
return retVal;
}

</details>

### Что если вам нужен аспект, который хранит состояние, специфичное для каждого целевого объекта?

<details>
<summary>Ответ</summary>

По умолчанию аспект, как и любой другой Spring-бин, является **синглтоном**. Один-единственный экземпляр аспекта обслуживает все вызовы ко всем целевым объектам. Это эффективно, потому что большинство аспектов (логирование, транзакции) не хранят состояние (`stateless`).

Но что если вам нужен аспект, который хранит состояние, специфичное для каждого целевого объекта? Для этого существуют **"per-clauses"**.

Они задаются в значении аннотации: `@Aspect("perthis(pointcutExpression())")`.

*   **`perthis(Pointcut)`**
    *   **Что делает:** Создает **новый экземпляр аспекта для каждого уникального ПРОКСИ-ОБЪЕКТА**, который соответствует указанному pointcut'у.
    *   **Аналогия:** У каждого VIP-клиента (прокси) есть свой личный телохранитель (аспект). Если у вас два разных бина `UserService` и `OrderService`, и оба они подпадают под pointcut, будет создано **два** экземпляра аспекта.
    *   **Когда использовать:** Когда аспекту нужно хранить состояние, связанное с конкретным экземпляром прокси. Например, считать, сколько раз был вызван метод на *конкретном* экземпляре сервиса.

    *   **Пример:**
        ```java
        @Service
        public class MyService {
            @Loggable public void doWork() {}
        }

        @Aspect("perthis(com.example.MyPointcuts.loggableMethods())") // <-- Настройка
        @Component
        public class PerProxyStatefulAspect {
            private int callCounter = 0;

            @Before("com.example.MyPointcuts.loggableMethods()")
            public void countCall(JoinPoint jp) {
                callCounter++;
                System.out.printf("Прокси '%s', вызов #%d\n",
                    jp.getThis().getClass().getName(), callCounter);
            }
        }
        ```
        Если вы вызовете `doWork()` на одном и том же экземпляре `MyService` несколько раз, счетчик будет расти. Если у вас будет два разных бина `MyService`, у каждого будет свой аспект со своим счетчиком.

*   **`pertarget(Pointcut)`**
    *   **Что делает:** Очень похоже на `perthis`, но создает **новый экземпляр аспекта для каждого уникального ЦЕЛЕВОГО ОБЪЕКТА (target)**.
    *   **Тонкое различие:** `perthis` привязывается к прокси, `pertarget` — к оригинальному объекту за прокси. В случае с CGLIB-прокси это почти всегда одно и то же. В случае с JDK-прокси — это разные объекты. `perthis` более распространен.

*   **`pertypewithin(TypeNamePattern)` (не является частью Spring AOP, только AspectJ)**
    *   Создает общий экземпляр аспекта для всех объектов определенного типа.

**Важно:** Модели `perthis` и `pertarget` — это продвинутая функциональность. 99% аспектов прекрасно живут как синглтоны.

</details>

### Какой порядок выполнения (Ordering) аспектов если их несколько?

<details>
<summary>Ответ</summary>

Что если у вас есть два аспекта, которые применяются к одному и тому же методу? Например, аспект безопасности (`@PreAuthorize`) и аспект транзакций (`@Transactional`). В каком порядке они выполнятся?

**Порядок имеет решающее значение!** Вы наверняка хотите, чтобы проверка безопасности произошла **до** начала транзакции. Если проверка провалится, не нужно тратить ресурсы на открытие транзакции, которую тут же придется откатить.

Для управления порядком используются:
1.  **Аннотация `@Order(value)`**
2.  **Интерфейс `org.springframework.core.Ordered`**

</details>

### Что такое weaving, target и introduction в АОП?

<details>
<summary>Ответ</summary>

Связывание(англ. weaving) представляет собой процесс действительной вставки аспектов в определенную точку кода приложения. Для решений АОП времени компиляции это делается на этапе компиляции, обычно в виде дополнительного шага процесса сборки. Аналогично, для решений АОП времени выполнения связывание происходит динамически во время выполнения. В AspectJ поддерживается еще один механизм связывания под названием связывание во время загрузки (load-time weaving - LTW), который перехватывает лежащий в основе загрузчик классов JVM и обеспечивает связывание с байт-кодом, когда он загружается загрузчиком классов.

Цель(англ. target) - это объект, поток выполнения которого изменяется каким-то процессом АОП. На целевой объект часто ссылаются как на объект, снабженный советом.

Внедрение (англ. introduction, введение) - представляет собой процесс, посредством которого можно изменить структуру объекта за счет введения в него дополнительных методов или полей, изменение иерархии наследования для добавления функциональности аспекта в инородный код. Обычно реализуется с помощью некоторого метаобъектного протокола (англ. metaobject protocol, MOP).

</details>

### В чем разница между Spring AOP и AspectJ АОП?

<details>
<summary>Ответ</summary>

Отличный вопрос, который затрагивает самое сердце AOP в Java-экосистеме. Разница между Spring AOP и AspectJ фундаментальна и заключается в их подходе, возможностях и времени применения аспектов.

Если говорить кратко:
*   **Spring AOP** — это **простой и прагматичный** фреймворк, реализованный с помощью **прокси-объектов во время выполнения (runtime)**. Он хорошо интегрирован в Spring, но имеет ограничения.
*   **AspectJ** — это **мощный и полноценный** язык расширения для Java, который **изменяет байт-код** на этапе компиляции или загрузки классов. Он не ограничен Spring-экосистемой.

Давайте разберем отличия подробно по ключевым критериям.

### Механизм и время внедрения (Weaving)

Это самое главное отличие. **"Weaving" (сплетение, внедрение)** — это процесс, в ходе которого логика аспекта встраивается в основной код.

*   **Spring AOP: Runtime Weaving (Внедрение во время выполнения)**
    *   **Как работает:** Spring не изменяет исходный код или скомпилированные `.class` файлы. Вместо этого, при запуске приложения, он на лету создает **прокси-объекты** (с помощью JDK Dynamic Proxy или CGLIB) для ваших бинов. Вся логика аспекта находится внутри этих прокси.
    *   **Когда происходит:** В момент создания бина в IoC-контейнере.

*   **AspectJ: Compile-time / Post-compile / Load-time Weaving**
    *   **Как работает:** AspectJ напрямую модифицирует байт-код ваших `.class` файлов, встраивая в них логику аспекта. Оригинальный класс "мутирует".
    *   **Когда происходит:**
        1.  **Compile-time Weaving (на этапе компиляции):** У вас есть исходный код и аспекта, и основного приложения. Специальный компилятор `ajc` (AspectJ Compiler) компилирует их вместе, создавая уже "сплетенные" `.class` файлы.
        2.  **Post-compile Weaving (бинарное внедрение):** У вас уже есть скомпилированные `.class` файлы (или `.jar`). AspectJ "внедряет" логику аспекта в них, не трогая исходники.
        3.  **Load-time Weaving (LTW, на этапе загрузки):** Ничего не меняется до запуска. Но при запуске приложения специальный Java-агент перехватывает загрузку классов и "на лету" модифицирует их байт-код перед тем, как JVM их увидит.

### Мощность и типы Join Points

*   **Spring AOP: Ограниченный**
    *   Поддерживает только **один** тип Join Point: **выполнение метода (method execution)**.
    *   Вы можете применять аспекты только к публичным методам Spring-бинов. Вы не можете перехватить вызов конструктора, доступ к полю, статический блок инициализации и т.д.

*   **AspectJ: Всеобъемлющий**
    *   Поддерживает огромное количество Join Points:
        *   **Выполнение метода или конструктора** (`execution`).
        *   **Вызов метода или конструктора** (`call`). (В чем разница? `execution` — это внутри самого метода, `call` — в месте, откуда метод вызывается).
        *   **Чтение или запись поля** (`get`, `set`).
        *   **Блоки статической инициализации**.
        *   **Обработка исключений** (`handler`).
        *   И многое другое.

### Область применения

*   **Spring AOP:** Работает **только с бинами**, управляемыми Spring-контейнером. Если вы создадите объект через `new MyObject()`, никакой аспект на него применен не будет, даже если он подпадает под Pointcut.

*   **AspectJ:** Работает с **любыми Java-объектами**, независимо от того, как они созданы. Он не привязан к Spring.

</details>

### Сравни Spring AOP и AspectJ?

<details>
<summary>Ответ</summary>

| Характеристика | Spring AOP | AspectJ |
| :--- | :--- | :--- |
| **Основной механизм** | Динамические прокси (JDK/CGLIB) | Модификация байт-кода |
| **Время внедрения (Weaving)** | **Runtime** (во время выполнения) | **Compile-time**, **Post-compile**, **Load-time** |
| **Типы Join Points** | Только выполнение методов | Методы, конструкторы, поля, обработчики исключений и др. |
| **Область действия** | Только Spring-бины | Любые Java-объекты |
| **Производительность** | Небольшой оверхед на вызов прокси | Нет оверхеда в рантайме (т.к. код уже встроен) |
| **Проблема `self-invocation`** | **Присутствует.** Вызов `this.method()` не перехватывается | **Отсутствует** (при compile/load-time weaving), т.к. байт-код изменен |
| **Простота настройки** | Очень просто, "из коробки" в Spring | Требует настройки (плагин для Maven/Gradle, java-агент) |

</details>

### Как они могут работать вместе AspectJ и Spring AOP?

<details>
<summary>Ответ</summary>

Очень часто возникает путаница, потому что Spring позволяет использовать синтаксис аннотаций AspectJ (`@Aspect`, `@Pointcut` и т.д.) для определения аспектов, которые потом реализуются через Spring AOP.

**Spring может использовать AspectJ тремя способами:**

1.  **Синтаксис AspectJ + Реализация Spring AOP (самый частый случай):**
    *   Вы пишете аспекты, используя аннотации `@Aspect`, `@Pointcut` и т.д., которые являются частью библиотеки AspectJ.
    *   Однако Spring Framework просто **интерпретирует** эти аннотации и создает свои **прокси-объекты**.
    *   Вы получаете удобный синтаксис AspectJ, но со всеми ограничениями Spring AOP (только выполнение методов, проблема `self-invocation`).

2.  **Синтаксис AspectJ + Реализация AspectJ (Compile-time):**
    *   Вы настраиваете плагин `aspectj-maven-plugin` (для Maven) и компилируете проект с его помощью.
    *   Вы получаете всю мощь AspectJ. Это уже не Spring AOP.

3.  **Синтаксис AspectJ + Реализация AspectJ (Load-Time Weaving в Spring):**
    *   Это "золотая середина". Вы можете включить LTW в Spring с помощью аннотации `@EnableLoadTimeWeaving` и конфигурации с `-javaagent`.
    *   В этом режиме Spring все еще управляет жизненным циклом аспектов (в них можно внедрять зависимости), но само внедрение происходит через AspectJ-агент, который меняет байт-код.
    *   Это решает проблему `self-invocation` и позволяет применять аспекты к любым объектам, сохраняя при этом интеграцию со Spring.

</details>

### Когда что выбирать Spring AOP или AspectJ?

<details>
<summary>Ответ</summary>

*   **Выбирайте Spring AOP в 9% случаев.**
    Для большинства стандартных задач в enterprise-приложениях (управление транзакциями, безопасность, логирование на уровне сервисов) его возможностей более чем достаточно. Он прост, не требует дополнительных шагов сборки и отлично выполняет свою работу.

*   **Выбирайте AspectJ, когда вам нужно:**
    1.  **Применить аспект к объектам, не управляемым Spring** (например, к доменным сущностям, создаваемым через `new`).
    2.  **Перехватить что-то кроме выполнения метода** (например, доступ к полю для реализации ленивой загрузки).
    3.  **Решить проблему `self-invocation`** на уровне архитектуры, без "костылей" вроде внедрения прокси в самого себя.
    4.  **Выжать максимальную производительность** в критически важных участках кода, убрав оверхед от вызовов прокси.

</details>

### Что на самом деле выполнится (с точки зрения транзакций), если вызвать method1()?

<details>
<summary>Ответ</summary>

public class MyServiceImpl {

@Transactional
public void method1() {
//do something
method2();
}

@Transactional (propagation=Propagation.REQUIRES_NEW)
public void method2() {
//do something
}

}

В связи с тем, что для поддержки транзакций через аннотации используется Spring AOP, в момент вызова method1() на самом деле вызывается метод прокси объекта. Создается новая транзакция и далее происходит вызов method1() класса MyServiceImpl. А когда из method1() вызовем method2(), обращения к прокси нет, вызывается уже сразу метод нашего класса и, соответственно, никаких новых транзакций создаваться не будет

</details>