Что такое Spring Boot Actuator?

Spring Boot Actuator является подпроектом (sub-project) в проекте Spring Boot. Он построен для собрания и мониторинга инфомации приложения. Вы можете внедрить его в свое приложение и использовать его свойства. Для мониторинга приложения вам нужно получить доступ в endpoint (Конечные точки) построенные в Spring Boot Actuator, одновременно, вы можете создать свои отдельные endpoint если хотите.

--------------------------------------------------------------------------------------------------------------------
Какие основные функции Spring Boot Actuator?

Конечно! Если сгруппировать все возможности Spring Boot Actuator, то можно выделить **четыре основные функции**:

### 1. Мониторинг Здоровья и Состояния (Health Monitoring)

Это самая важная и часто используемая функция. Actuator позволяет в реальном времени понимать, насколько "здорово" ваше приложение.

*   **Эндпоинт:** `/actuator/health`
*   **Что делает:** Проверяет, способно ли приложение выполнять свою работу. По умолчанию он возвращает простой статус `UP` (работает) или `DOWN` (не работает).
*   **Ключевые особенности:**
    *   **Автоматическая проверка зависимостей:** Actuator сам проверяет доступность базы данных, брокеров сообщений (RabbitMQ, Kafka), кэша (Redis) и других сервисов, если они есть в проекте.
    *   **Интеграция с Kubernetes:** Предоставляет отдельные эндпоинты для `liveness` и `readiness` проб, что позволяет оркестратору принимать умные решения (перезапустить контейнер или просто убрать его из-под нагрузки).
    *   **Детализированный отчёт:** Можно настроить так, чтобы эндпоинт показывал состояние каждого отдельного компонента.


### 2. Сбор Метрик Производительности (Metrics Collection)

Actuator собирает огромное количество данных о том, как работает ваше приложение. Эти данные необходимы для анализа производительности, поиска узких мест и настройки алертов.

*   **Эндпоинт:** `/actuator/metrics`
*   **Что делает:** Предоставляет доступ к числовым показателям (метрикам).
*   **Ключевые метрики "из коробки":**
    *   **JVM:** Использование памяти (heap/non-heap), работа сборщика мусора, количество потоков.
    *   **CPU:** Загрузка процессора.
    *   **HTTP-сервер:** Количество запросов, время ответа, количество ошибок по кодам (2xx, 4xx, 5xx).
    *   **Кэш:** Количество попаданий и промахов в кэш.
    *   **Пулы соединений с БД:** Количество активных и ожидающих соединений.
*   **Интеграция:** Легко интегрируется с системами мониторинга, такими как **Prometheus**, для сбора метрик и их визуализации в **Grafana**.


### 3. Диагностика и Отладка (Diagnostics & Debugging)

Эта группа функций помогает разработчикам и инженерам по эксплуатации заглянуть "под капот" работающего приложения, чтобы понять, что пошло не так, без необходимости перезапуска или подключения отладчика.

*   **Ключевые эндпоинты:**
    *   `/actuator/loggers`: Позволяет **просматривать и изменять уровни логирования на лету**. Это бесценно для отладки проблем в production.
    *   `/actuator/env`: Показывает все переменные окружения и свойства конфигурации, доступные приложению. Помогает понять, почему приложение настроено не так, как вы ожидали.
    *   `/actuator/beans`: Выводит полный список всех бинов, созданных в Spring-контейнере. Помогает при отладке проблем с Dependency Injection.
    *   `/actuator/mappings`: Показывает, какие URL-адреса каким методам контроллеров соответствуют.
    *   `/actuator/heapdump` и `/actuator/threaddump`: Позволяют сделать "снимок" памяти и потоков для глубокого анализа.


### 4. Управление и Информирование (Management & Info)

Эта функция позволяет получать общую информацию о приложении и, в некоторых случаях, управлять его жизненным циклом.

*   **Ключевые эндпоинты:**
    *   `/actuator/info`: Отображает любую статическую информацию, которую вы захотите добавить: версию сборки, git-коммит, контактную информацию и т.д. Очень полезно, чтобы быстро проверить, какая версия кода развернута.
    *   `/actuator/shutdown`: Корректно останавливает приложение. По умолчанию выключен из соображений безопасности, но может быть полезен для управляемого выключения.

--------------------------------------------------------------------------------------------------------------------

Что делает endpoint /health?

Отличный вопрос! Endpoint `/health` в Spring Boot Actuator — это один из самых важных и часто используемых инструментов для мониторинга приложений. Давайте разберем его подробно.

### Что делает endpoint `/health`?

Если коротко, **endpoint `/health` предоставляет сводную информацию о состоянии "здоровья" вашего приложения.**

Он отвечает на вопрос: "Приложение в порядке и готово ли оно выполнять свою работу?". Ответ не просто "да/нет", а детализированный отчет о состоянии ключевых компонентов, от которых зависит работа приложения.

Типичный ответ от `/health` может выглядеть так:

**Простой ответ (по умолчанию, без деталей):**
```json
{
  "status": "UP"
}
```
`UP` означает, что все проверенные компоненты в порядке. Если хотя бы один важный компонент неисправен, статус будет `DOWN`.

**Детализированный ответ (если включен показ деталей):**
```json
{
  "status": "DOWN",
  "components": {
    "db": {
      "status": "DOWN",
      "details": {
        "error": "org.springframework.jdbc.CannotGetJdbcConnectionException: Failed to obtain JDBC Connection"
      }
    },
    "diskSpace": {
      "status": "UP",
      "details": {
        "total": 250796732416,
        "free": 118458920960,
        "threshold": 10485760
      }
    },
    "rabbit": {
      "status": "UP",
      "details": {
        "version": "3.8.9"
      }
    }
  }
}
```
В этом примере общий статус `DOWN`, потому что компонент базы данных (`db`) неисправен, хотя остальные (`diskSpace`, `rabbit`) в порядке.

### Как он работает изнутри?

Внутренний механизм `/health` построен на нескольких ключевых концепциях Spring Boot:

**1. Интерфейс `HealthIndicator`**

Это сердце системы. Каждый компонент, состояние которого нужно проверить (база данных, дисковое пространство, брокер сообщений и т.д.), имеет свою реализацию этого интерфейса.

У `HealthIndicator` есть всего один метод:
```java
@FunctionalInterface
public interface HealthIndicator {
    Health health();
}
```
Этот метод должен вернуть объект `Health`, который содержит:
*   **Статус:** `UP`, `DOWN`, `OUT_OF_SERVICE` (не участвует в агрегации), `UNKNOWN`.
*   **Детали (опционально):** Дополнительная информация в виде `Map<String, Object>`, например, версия СУБД, свободное место на диске или сообщение об ошибке.

**2. Автоконфигурация индикаторов**

Spring Boot — это магия автоконфигурации. Когда вы добавляете в проект зависимость, например, `spring-boot-starter-data-jpa`, Spring Boot автоматически обнаруживает это и создает в контексте приложения бин `DataSourceHealthIndicator`.

Вот некоторые из стандартных, автоматически настраиваемых индикаторов:
*   `DataSourceHealthIndicator` (для баз данных JDBC)
*   `MongoHealthIndicator` (для MongoDB)
*   `RedisHealthIndicator` (для Redis)
*   `RabbitHealthIndicator` (для RabbitMQ)
*   `DiskSpaceHealthIndicator` (проверяет свободное место на диске)
*   и многие другие...

**3. Агрегация результатов**

Когда вы делаете запрос к `/health`, происходит следующее:
1.  `HealthEndpoint` (класс, отвечающий за обработку запроса) находит все бины, реализующие `HealthIndicator`, в контексте приложения.
2.  Он поочередно вызывает у каждого индикатора метод `health()`.
3.  Затем он **агрегирует** все полученные результаты. Правило агрегации по умолчанию очень простое:
    *   Если **хотя бы один** индикатор вернул статус `DOWN`, общий статус будет `DOWN`.
    *   Если все индикаторы вернули `UP`, общий статус будет `UP`.

**4. Отображение деталей**

По соображениям безопасности, по умолчанию детализированная информация скрыта. Её можно включить в `application.properties`:
```properties
# Показывать детали всегда (не рекомендуется для продакшена)
management.endpoint.health.show-details=always

# Показывать детали только для аутентифицированных пользователей (рекомендуемый вариант)
management.endpoint.health.show-details=when-authorized
```

---

### Как /health используется на практике?

Endpoint `/health` — это критически важный инструмент для построения надежных систем.

**1. Мониторинг и оповещения (Alerting)**
Системы мониторинга (Prometheus, Zabbix, Nagios) регулярно опрашивают `/health` endpoint. Если статус меняется с `UP` на `DOWN`, система может автоматически отправить оповещение (в Slack, на почту, в PagerDuty) дежурному инженеру.

**2. Балансировщики нагрузки (Load Balancers)**
Балансировщики (например, NGINX, HAProxy или облачные вроде AWS ELB/ALB) используют health checks, чтобы определять, какие экземпляры приложения работоспособны.
*   Если `/health` отвечает `200 OK` (статус `UP`), балансировщик направляет на этот экземпляр пользовательский трафик.
*   Если `/health` отвечает ошибкой (например, `503 Service Unavailable`, статус `DOWN`), балансировщик временно исключает этот экземпляр из ротации и перестает посылать на него трафик, пока тот не "выздоровеет".

**3. Оркестраторы контейнеров (Kubernetes, Docker Swarm)**
Kubernetes использует health checks для управления жизненным циклом подов (контейнеров):
*   **Liveness Probe (проверка жизнеспособности):** Kubernetes периодически опрашивает `/health`. Если endpoint перестает отвечать или возвращает `DOWN`, Kubernetes считает, что контейнер "завис", и перезапускает его.
*   **Readiness Probe (проверка готовности):** Kubernetes использует эту проверку, чтобы понять, готов ли под принимать трафик. Например, при старте приложение может быть запущено, но ему нужно время на "прогрев" (установление соединения с БД, заполнение кэшей). Пока `/health` не вернет `UP`, Kubernetes не будет направлять на этот под трафик.

**4. Автоматизация развертывания (CI/CD)**
В пайплайнах Blue-Green или Canary deployment, после развертывания новой версии приложения, система автоматизации проверяет ее `/health` endpoint. Трафик на новую версию переключается только после того, как она подтвердит свою полную работоспособность.


--------------------------------------------------------------------------------------------------------------------

Как написать свой индикатор?

Наряду со встроенными HealthIndicator, предоставляемыми Spring Boot Actuator, мы можем создавать собственные индикаторы состояния. Для этого вам нужно создать класс, который реализует интерфейс HealthIndicator, реализовать его метод health() и вернуть Health в качестве ответа с соответствующей информацией,

--------------------------------------------------------------------------------------------------------------------
Конечно! Давайте погрузимся глубже в механику каждого из этих эндпоинтов. Понимание их внутреннего устройства покажет, что это не "магия", а грамотное использование существующих API Spring Framework и JVM.

### `/actuator/loggers` — Как он работает?

**Ключевой механизм:** Взаимодействие с API системы логирования через абстракцию Spring Boot.

Spring Boot не реализует логирование с нуля. Он использует стандартные фреймворки (Logback, Log4j2 и т.д.), но предоставляет над ними единый управляющий слой — интерфейс `LoggingSystem`.

**Процесс работы:**

1.  **Обнаружение системы логирования:** При старте приложения Spring Boot проверяет classpath, определяет, какой фреймворк логирования используется (например, видит `logback-classic.jar`), и создает соответствующий бин `LoggingSystem` (например, `LogbackLoggingSystem`).

2.  **Обработка GET-запроса (просмотр):**
    *   HTTP-запрос приходит на `LoggersEndpoint`.
    *   `LoggersEndpoint` получает доступ к бину `LoggingSystem`.
    *   Он вызывает метод типа `loggingSystem.getLoggerConfigurations()`.
    *   Реализация `LogbackLoggingSystem` обращается к "сердцу" Logback — `LoggerContext`. Она вызывает `loggerContext.getLoggerList()`, чтобы получить все экземпляры `ch.qos.logback.classic.Logger`.
    *   Для каждого логгера она получает его имя и уровень (`logger.getLevel()`, `logger.getEffectiveLevel()`).
    *   `LoggersEndpoint` форматирует эту информацию в JSON и отправляет клиенту.

3.  **Обработка POST-запроса (изменение):**
    *   Запрос с телом `{"configuredLevel": "DEBUG"}` приходит на `/actuator/loggers/com.example.myapp.MyService`.
    *   `LoggersEndpoint` вызывает `loggingSystem.setLogLevel("com.example.myapp.MyService", LogLevel.DEBUG)`.
    *   `LogbackLoggingSystem` снова обращается к `LoggerContext`, находит нужный `Logger` по имени (`loggerContext.getLogger("com.example.myapp.MyService")`).
    *   Затем он вызывает нативный метод Logback: `logger.setLevel(Level.DEBUG)`.
    *   **Вот и все!** Изменение происходит мгновенно в памяти работающего `LoggerContext`. Никакой перезагрузки конфигурационных файлов, никаких перезапусков.

**Почему это так мощно:** Spring Boot абстрагирует вас от деталей конкретной реализации логирования. Вы используете один и тот же эндпоинт, а под капотом Spring сам знает, вызвать ли методы `LoggerContext` из Logback или `LoggerConfig` из Log4j2.

---

### `/actuator/env` — Как он работает?

**Ключевой механизм:** Интроспекция центрального объекта `Environment` из Spring.

В Spring `Environment` — это не просто набор переменных. Это сложная иерархическая структура, представляющая все источники конфигурации.

**Процесс работы:**

1.  **Иерархия `PropertySource`:** `Environment` содержит упорядоченный список объектов `PropertySource`. Каждый `PropertySource` представляет один источник:
    *   `CommandLinePropertySource` (аргументы командной строки `--`)
    *   `SystemEnvironmentPropertySource` (переменные окружения ОС)
    *   `PropertiesPropertySource` (системные свойства `-D`)
    *   `OriginTrackedMapPropertySource` (свойства из `application.properties`/`.yml`)
    *   И многие другие...
        Порядок в этом списке определяет приоритет: источники, находящиеся выше в списке, переопределяют те, что ниже.

2.  **Обработка GET-запроса:**
    *   `EnvironmentEndpoint` получает из контекста приложения бин `Environment`.
    *   Он итерируется по всем `PropertySource`, содержащимся в `Environment`.
    *   Для каждого `PropertySource` он извлекает его имя (например, "systemEnvironment") и все пары ключ-значение.
    *   **Санитизация (Sanitization):** Перед тем как показать свойство, эндпоинт проверяет его ключ. Если ключ соответствует паттернам по умолчанию (например, `.*password.*`, `.*secret.*`, `.*key.*`), его значение заменяется на `******`. Этот механизм настраивается.
    *   Он собирает всю эту информацию, включая активные профили (`environment.getActiveProfiles()`), и формирует большой JSON-ответ, отражающий эту иерархию.

**Почему это так мощно:** Эндпоинт не просто показывает вам плоский список свойств. Он показывает **историю** каждого свойства и **причину**, по которой оно имеет именно такое значение, раскрывая всю иерархию переопределений.

---

### `/actuator/beans` — Как он работает?

**Ключевой механизм:** Прямой опрос `ApplicationContext` (IoC-контейнера).

`ApplicationContext` — это реестр всех объектов (бинов), которыми управляет Spring. `/beans` просто предоставляет HTTP-интерфейс для заглядывания в этот реестр.

**Процесс работы:**

1.  **Доступ к контексту:** `BeansEndpoint` получает `ApplicationContext` через внедрение зависимостей.
2.  **Получение списка бинов:** Он вызывает `applicationContext.getBeanDefinitionNames()` для получения имен всех бинов, известных контейнеру.
3.  **Интроспекция каждого бина:** Для каждого имени бина он:
    *   Получает `BeanDefinition` — это "рецепт" создания бина. Из него извлекается мета-информация: имя класса, область видимости (`scope`), является ли он `primary`, `lazy` и т.д.
    *   Получает сам экземпляр бина через `applicationContext.getBean(name)`.
    *   Получает список зависимостей, вызывая `applicationContext.getDependenciesForBean(name)`.
4.  **Сборка ответа:** Вся собранная информация (имя, псевдонимы, класс, зависимости, скоуп) упаковывается в структурированный JSON.

**Почему это так мощно:** Это дает вам рентгеновское зрение работающего IoC-контейнера. Вы видите не только то, что *должно было* быть создано согласно вашей конфигурации, а то, что *было* создано на самом деле, со всеми его реальными связями.

---

### `/actuator/mappings` — Как он работает?

**Ключевой механизм:** Опрос бинов типа `HandlerMapping`.

В Spring MVC (и WebFlux) не контроллеры напрямую обрабатывают запросы. Запросы сначала попадают в `DispatcherServlet`, который спрашивает у бинов-`HandlerMapping`-ов: "Кто из вас может обработать этот URL?".

**Процесс работы:**

1.  **Поиск `HandlerMapping`-ов:** `MappingsEndpoint` запрашивает у `ApplicationContext` все бины, реализующие интерфейс `HandlerMapping`. Самый важный из них для REST API — это `RequestMappingHandlerMapping`.
2.  **Запрос карты эндпоинтов:** `MappingsEndpoint` обращается к `RequestMappingHandlerMapping` и вызывает его внутренний метод, например, `getHandlerMethods()`. Этот метод возвращает `Map<RequestMappingInfo, HandlerMethod>`.
    *   `RequestMappingInfo`: Объект, хранящий всю информацию из аннотации `@RequestMapping` — URL-паттерн, HTTP-метод(ы), заголовки, параметры.
    *   `HandlerMethod`: Объект, указывающий на конкретный метод в конкретном классе контроллера.
3.  **Форматирование ответа:** Эндпоинт итерируется по этой карте и для каждой записи извлекает детали из `RequestMappingInfo` и `HandlerMethod`, после чего формирует удобный для чтения JSON.

**Почему это так мощно:** Вы получаете финальную, "скомпилированную" карту маршрутизации приложения, учитывающую все нюансы (контекстные пути, префиксы и т.д.), в том виде, в котором ее видит сам `DispatcherServlet`.

---

### `/actuator/heapdump` и `/actuator/threaddump`  — Как работает?

**Ключевой механизм:** Использование стандартных диагностических инструментов JVM через JMX (Java Management Extensions).

Эти эндпоинты — самые "низкоуровневые", так как они являются тонкими обертками над API самой виртуальной машины.

**`/heapdump`:**

1.  **Поиск `MXBean`:** Код эндпоинта использует `java.lang.management.ManagementFactory` для получения доступа к `HotSpotDiagnosticMXBean`. Это специфичный для HotSpot JVM (наиболее распространенной) бин, предоставляющий расширенные диагностические операции.
2.  **Вызов нативного метода:** Он вызывает метод `hotSpotDiagnosticMXBean.dumpHeap(filePath, live)`, передавая путь к временному файлу.
3.  **Действие JVM:** Этот вызов — команда напрямую для JVM. Она инициирует "Stop-The-World" паузу, проходит по всей куче, сериализует граф объектов в бинарный формат `hprof` и сохраняет его в указанный файл.
4.  **Отправка файла:** Spring Actuator открывает этот файл и стримит его байты в HTTP-ответ с заголовком `Content-Type: application/octet-stream`.

**`/threaddump`:**

1.  **Поиск `MXBean`:** Эндпоинт использует `ManagementFactory.getThreadMXBean()` для получения стандартного `ThreadMXBean`, который есть в любой JVM.
2.  **Вызов метода:** Он вызывает `threadMXBean.dumpAllThreads(lockedMonitors, lockedSynchronizers)`.
3.  **Действие JVM:** Этот метод не останавливает мир, а быстро делает "снимок" состояния всех потоков. Он возвращает массив объектов `ThreadInfo`. Каждый `ThreadInfo` содержит имя потока, его состояние (`RUNNABLE`, `BLOCKED` и т.д.) и полный stack trace.
4.  **Форматирование:** Actuator просто форматирует этот массив `ThreadInfo` в стандартный, легко читаемый текстовый формат (или JSON), который вы видите в ответе.

--------------------------------------------------------------------------------------------------------------------

### Что делает endpoint `/actuator/metrics`?

**Endpoint `/actuator/metrics` предоставляет детальные числовые измерения (метрики) о производительности и внутреннем состоянии вашего приложения.**

Это ваш приборный щиток, показывающий всё: от использования памяти JVM и загрузки процессора до количества обработанных HTTP-запросов и времени ответа.

### Как /actuator/metrics работает изнутри?

За всей этой магией стоит **Micrometer**.

1.  **Micrometer — это "SLF4J для метрик"**. Это фасад, абстракция для сбора метрик. Он позволяет вашему коду собирать метрики, не привязываясь к конкретной системе мониторинга (Prometheus, InfluxDB, Datadog и т.д.).

2.  **Автоконфигурация Spring Boot.** Spring Boot Actuator автоматически настраивает Micrometer. Он сканирует ваш classpath и создает бины для сбора стандартных метрик:
    *   **JVM metrics:** память, сборка мусора, потоки.
    *   **System metrics:** CPU, файловые дескрипторы.
    *   **Application metrics:** `http.server.requests` (таймер, который измеряет количество и длительность запросов), метрики Log4j/Logback.
    *   **DataSource metrics:** метрики пула соединений (активные, ожидающие соединения).
    *   ...и так далее.

3.  **`MeterRegistry`.** Все метрики регистрируются в `MeterRegistry`. Это центральное хранилище. Когда вы делаете запрос к `/actuator/metrics`, Actuator просто обращается к этому `MeterRegistry` и форматирует данные в JSON.

4.  **Типы метрик (Meters):** Micrometer оперирует несколькими основными типами метрик:
    *   **`Counter`:** Счетчик, который может только увеличиваться (например, `http.server.requests` с тегом `exception`).
    *   **`Gauge`:** Измеритель, который показывает текущее значение, которое может как расти, так и падать (например, `jvm.memory.used` или количество сообщений в очереди).
    *   **`Timer`:** Измеряет и количество событий, и их продолжительность. Идеально для отслеживания времени ответа API.
    *   **`DistributionSummary`:** Измеряет распределение событий (например, размер тела запроса).

--------------------------------------------------------------------------------------------------------------------
Как добавить свой метод в actuator?

Существует два основных способа это сделать, в зависимости от того, что вам нужно:

1.  **Простой способ (@Endpoint):** Создание полностью нового, независимого эндпоинта (например, `/actuator/mycustomendpoint`). Это самый распространенный и гибкий подход.
2.  **Сложный способ (@EndpointExtension):** Расширение существующего эндпоинта Actuator (например, добавление новой операции к `/actuator/health`). Это используется реже, в более специфических случаях.


Предположим, мы хотим создать эндпоинт `/actuator/appstate`
Аннотация `@Endpoint` сообщает Spring Boot, что этот класс является эндпоинтом Actuator. **Важно:** `id` в аннотации — это часть URL. `id = "appstate"` превратится в путь `/actuator/appstate`.

```java
import org.springframework.boot.actuate.endpoint.annotation.Endpoint;
import org.springframework.stereotype.Component;

@Component
@Endpoint(id = "appstate") // Это будет /actuator/appstate
public class AppStateEndpoint {
    // Здесь будут наши методы
}
```
**Добавьте методы для обработки HTTP-запросов**

Для этого используются специальные аннотации, похожие на `@GetMapping`, `@PostMapping` и т.д., но для Actuator:

*   `@ReadOperation`: Соответствует HTTP `GET`. Используется для получения данных.
*   `@WriteOperation`: Соответствует HTTP `POST`. Используется для изменения состояния.
*   `@DeleteOperation`: Соответствует HTTP `DELETE`. Используется для удаления ресурсов.

