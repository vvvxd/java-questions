что такое удаленный вызов процедур?

RPC - это форма взаимодействия клиент-сервер, в которой используется вызов функции, а не обычный HTTP-вызов.

Он использует IDL (язык определения интерфейса) как форму контракта на вызываемые функции и на тип данных.

Если вы все еще этого не осознали, RPC в gRPC означает удаленный вызов процедуры. И да, gRPC действительно копирует этот архитектурный стиль взаимодействия клиент-сервер с помощью вызовов функций.
Так что gRPC технически не новая концепция. Скорее он был заимствован из этой старой техники и усовершенствован, что сделало его очень популярным всего за 5 лет.

--------------------------------------------------------------------------------------------------------------------
Что такое gRPC

gRPC — опенсорсный фреймворк для удаленного вызова процедур.
В 2015 году Google открыла исходный код своего проекта, который в конечном итоге получил название gRPC. Но что на самом деле означает «g» в gRPC?
Google меняет значение буквы «g» для каждой версии до такой степени, что они даже сделали README, чтобы перечислить все значения.
С момента появления gRPC он приобрел довольно большую популярность, и многие компании его используют.

--------------------------------------------------------------------------------------------------------------------
Что делает gRPC таким популярным?

Существует множество причин, по которым gRPC так популярен:
Абстракция - это просто (это вызов функции)
Поддерживается на многих языках.
Это очень эффективно
HTTP-вызовы часто сбивают с толку, поэтому это упрощает

И помимо всех вышеперечисленных причин, gRPC популярен, потому что очень популярны микросервисы.

Микросервисы часто запускают несколько сервисов на разных языках программирования. У них также часто бывает много сервисов для обслуживания взаимодействий.

Именно здесь gRPC помогает больше всего, предоставляя поддержку и возможности для решения типичных проблем, возникающих в таких ситуациях.

gRPC очень популярен в сервисе для сервисных вызовов, поскольку часто HTTP-вызовы труднее понять с первого взгляда.

Обдумывать функции gRPC гораздо проще, поэтому разработчикам не нужно беспокоиться о написании большого количества документации, потому что сам код должен все объяснять.

Некоторые службы также могут быть написаны на разных языках, и gRPC поставляется с несколькими библиотеками для поддержки этого.

Производительность - это вишенка на вершине - и это большая изюминка.

--------------------------------------------------------------------------------------------------------------------
Архитектура gRPC ключевые отличия

HTTP / 2
Мультиплексирование запроса / ответа
Сжатие заголовка
Буфер протокола, он же Protobuf

--------------------------------------------------------------------------------------------------------------------
HTTP / 2

HTTP с нами давно. Сейчас почти все серверные службы используют этот протокол.
История HTTP
Как видно из рисунка выше, HTTP / 1.1 долгое время оставался актуальным.
Затем в 2015 году появился HTTP / 2, который по сути заменил HTTP / 1.1 как самый популярный транспортный протокол в Интернете.
Если вы помните, что 2015 год был годом выхода gRPC, это было отнюдь не совпадение. HTTP / 2 также был создан Google для использования gRPC в своей архитектуре.
HTTP / 2 - одна из главных причин, по которой gRPC может работать так хорошо. И в следующем разделе вы увидите, почему.

--------------------------------------------------------------------------------------------------------------------
Мультиплексирование запроса / ответа

В традиционном протоколе HTTP невозможно отправить несколько запросов или получить несколько ответов вместе в одном соединении. Для каждого из них необходимо будет создать новое соединение.
Этот вид мультиплексирования запроса / ответа стал возможным в HTTP / 2 с введением нового уровня HTTP / 2, называемого двоичным кадрированием.
Этот двоичный уровень инкапсулирует и кодирует данные. На этом уровне HTTP-запрос / ответ разбивается на кадры.
Кадр заголовков содержит типичную информацию заголовков HTTP, а кадр данных содержит полезную нагрузку. Используя этот механизм, можно получать данные из нескольких запросов в одном соединении.
Это позволяет получать полезные данные из нескольких запросов с одним и тем же заголовком, таким образом идентифицируя его как один запрос.

--------------------------------------------------------------------------------------------------------------------
Сжатие заголовка

Возможно, вы сталкивались со многими случаями, когда заголовки HTTP даже больше, чем полезная нагрузка. И HTTP / 2 имеет очень интересную стратегию под названием HPack, чтобы справиться с этим.
Во-первых, все в HTTP / 2 кодируется перед отправкой, включая заголовки. Это действительно помогает с производительностью, но это не самое главное в сжатии заголовков.
HTTP / 2 отображает заголовок как на стороне клиента, так и на стороне сервера. Исходя из этого, HTTP / 2 может узнать, содержит ли заголовок то же значение, и отправляет значение заголовка, только если оно отличается от предыдущего заголовка.
Как видно на картинке выше, запрос №2 отправит только путь, поскольку другие значения точно такие же. И да, это значительно сокращает размер полезной нагрузки и, в свою очередь, еще больше улучшает производительность HTTP / 2.

--------------------------------------------------------------------------------------------------------------------
Буфер протокола, он же Protobuf

Protobuf - это наиболее часто используемый IDL (язык определения интерфейса) для gRPC. Здесь вы в основном храните свои данные и функциональные контракты в виде прото-файла.
message Person { required string name = 1; required int32 id = 2; optional string email = 3; }
Поскольку это форма контракта, и клиент, и сервер должны иметь один и тот же прото-файл. Файл proto действует как посреднический контракт для клиента для вызова любых доступных функций с сервера.
Protobuf также владеет механизмами, в отличие от обычного REST API, который просто отправляет строки JSON в виде байтов. Эти механизмы позволяют значительно уменьшить полезную нагрузку и повышать производительность.
Метод кодирования, который использует Protobuf, довольно сложен. Если вы хотите глубже понять, как это работает, ознакомьтесь с этой исчерпывающей документацией.

--------------------------------------------------------------------------------------------------------------------
gRPC Метаданные

Вместо использования обычного заголовка HTTP-запроса в gRPC есть нечто, называемое метаданными. Метаданные - это тип данных "ключ-значение", которые могут быть установлены на стороне клиента или сервера.
Header могут быть назначены на стороне клиента, в то время как серверы могут назначать Header и Trailers при условии, что они оба находятся в форме метаданных.

--------------------------------------------------------------------------------------------------------------------
gRPC Потоковая передача

Потоковая передача - одна из основных концепций gRPC, при которой в одном запросе может выполняться несколько вещей. Это стало возможным благодаря возможности мультиплексирования HTTP / 2, упомянутой ранее.
Есть несколько видов стриминга:
RPC потоковой передачи сервера: когда клиент отправляет один запрос, а сервер может отправить обратно несколько ответов. Например, когда клиент отправляет запрос на домашнюю страницу со списком из нескольких элементов, сервер может отправлять ответы отдельно, что позволяет клиенту использовать отложенную загрузку.
Клиентский Streaming RPC: когда клиент отправляет несколько запросов, а сервер отправляет только один ответ. Например, zip / чанк, загруженный клиентом.
Двунаправленный потоковый RPC: когда и клиент, и сервер отправляют сообщения друг другу одновременно, не дожидаясь ответа.

--------------------------------------------------------------------------------------------------------------------
gRPC Перехватчики

gRPC поддерживает использование перехватчиков для своего запроса / ответа. Перехватчики, ну, перехватывают сообщения и позволяют изменять их.
Звучит знакомо? Если вы играли с HTTP-процессами в REST API, перехватчики очень похожи на промежуточное ПО.
Библиотеки gRPC обычно поддерживают перехватчики и позволяют легко реализовать. Перехватчики обычно используются для:
Изменяет запрос / ответ перед передачей. Его можно использовать для предоставления обязательной информации перед отправкой на клиент / сервер.
Позволяют вам управлять каждым вызовом функции, например, добавлять дополнительные записи для отслеживания времени отклика.

--------------------------------------------------------------------------------------------------------------------
gRPC Балансировки нагрузки

Если вы еще не знакомы с балансировкой нагрузки, это механизм, который позволяет распределять клиентские запросы по нескольким серверам.
Но балансировка нагрузки обычно выполняется на уровне прокси (например, NGINX). Так почему я говорю об этом здесь?
Оказывается, gRPC поддерживает метод балансировки нагрузки клиентом. Он уже реализован в библиотеке Golang и может быть легко использован.
Хотя это может показаться какой-то безумной магией, на самом деле это не так. Есть какой-то DNS-преобразователь для получения списка IP-адресов и алгоритм балансировки нагрузки под капотом.

--------------------------------------------------------------------------------------------------------------------
gRPC Отмена вызова

Клиенты gRPC могут отменить вызов gRPC, когда ему больше не нужен ответ. Однако откат на стороне сервера невозможен.
Эта функция особенно полезна для потоковой передачи на стороне сервера, когда могут поступать несколько запросов к серверу. Библиотека gRPC оснащена шаблоном метода наблюдателя, чтобы знать, отменен ли запрос, и позволяет ему отменить сразу несколько соответствующих запросов.

--------------------------------------------------------------------------------------------------------------------
API RPC

Как предшественник REST, RPC (удаленный вызов процедур) представляет собой программную архитектуру, восходящую к 1970-м годам. RPC позволяет вызывать функцию на удаленном сервере в определенном формате и получать ответ в том же формате. Не имеет значения, какой формат использует сервер, выполняющий запрос, и не имеет значения, локальный это сервер или удаленный. RPC позволяет вызывать функцию на сервере и получать результат в том же формате.
Основная концепция RPC API аналогична концепции REST API. RPC API определяет правила взаимодействия и методы, которые клиент может использовать для взаимодействия с ним. Клиенты отправляют вызовы, которые используют «аргументы» для вызова этих методов. Однако в случае RPC API метод находится в URL-адресе. Аргументы, вызывающие методы, находятся в строке запроса. Чтобы проиллюстрировать это, вот как запрос RPC API сравнивается с запросом REST API:
RPC: запрос RPC API может использовать POST / deleteSmth и иметь строку запроса, которая говорит {"id": 777}
REST: запрос REST API записывает этот запрос как DELETE / smth / 777.

--------------------------------------------------------------------------------------------------------------------
Погружение в API gRPC

Как вариант архитектуры RPC, gRPC был создан Google для ускорения передачи данных между микросервисами и другими системами, которым необходимо взаимодействовать друг с другом. По сравнению с REST API, gRPC API уникальны в следующих отношениях:
Протобуф (Protobuf) вместо JSON
Построен на HTTP 2 вместо HTTP 1.1
Создание собственного кода вместо использования сторонних инструментов, таких как Swagger
Передача сообщений в 7-10 раз быстрее
Более долгая имплементация и реализация, чем REST
Думаю, стоит детальнее разобрать каждое из этих различий между API REST и gRPC.

--------------------------------------------------------------------------------------------------------------------
Protobuf вместо JSON / XML

И REST API, и RPC API отправляют и получают сообщения с использованием форматов обмена сообщениями JSON или XML. Они также могут использовать другие форматы, но наиболее распространены JSON и XML. Из них JSON стал самым популярным форматом, поскольку он гибкий, эффективный, платформенно-независимый и не зависит от языка. Он также основан на тексте и удобочитаем для человека, что упрощает работу операторам. Проблема в том, что для определенных случаев использования JSON недостаточно быстр или легковесен при передаче данных между системами.В отличие от REST и RPC, gRPC преодолевает проблемы, связанные со скоростью и весом, и предлагает большую эффективность при передаче сообщений, используя формат обмена сообщениями Protobuf (буферы протокола). Вот несколько подробностей о Protobuf:
Независимость от платформы и языка, например как JSON
Сериализует и десериализует структурированные данные для передачи в двоичном формате.
Поскольку он является сильно сжатым форматом, он не обеспечивает удобочитаемости JSON.
Ускоряет передачу данных, удаляя множество обязанностей, которыми управляет JSON, поэтому он может сосредоточиться исключительно на сериализации и десериализации данных.
Передача данных происходит быстрее, потому что Protobuf уменьшает размер сообщений и служит легким форматом обмена сообщениями.

--------------------------------------------------------------------------------------------------------------------
Построен на HTTP 2 вместо HTTP 1.1

Еще один способ повышения эффективности gRPC - использование протокола HTTP 2.
API-интерфейсы REST обычно построены на HTTP 1.1, который использует модель взаимодействия запрос-ответ. Это означает, что когда микросервис получает несколько запросов от более чем одного клиента, он должен обслуживать их по одному, что замедляет работу всей системы. API REST также могут использовать HTTP 2, они по-прежнему ограничены моделью запрос-ответ и не используют поддержку HTTP 2 для двунаправленной потоковой связи.
В отличие от этого, gRPC использует HTTP 2 и пользуется преимуществами поддержки HTTP 2 как для взаимодействия с клиентом, так и для двунаправленной связи. Таким образом, gRPC может управлять «унарными» взаимодействиями, аналогичными HTTP 1.1 (когда клиент отправляет один запрос, а сервер отправляет один ответ). В то же время клиенты могут также открывать долговременные соединения, в которых каждый вызов RPC открывает новый поток HTTP 2, также известный как двунаправленная, «мультиплексируемая» или потоковая связь.
В HTTP 2, когда микросервис получает несколько запросов от более чем одного клиента, он достигает мультиплексирования, обслуживая множество запросов и ответов одновременно. В этом отношении API-интерфейсы gRPC отступают от ограничений API-интерфейсов REST в их способности непрерывно передавать информацию.

--------------------------------------------------------------------------------------------------------------------
GRPC предоставляет три типа потоковой передачи:

На стороне сервера: клиент отправляет сообщение запроса на сервер. Сервер возвращает поток ответов клиенту. После завершения ответов сервер отправляет сообщение о состоянии (и в некоторых случаях конечные метаданные), что завершает процесс. После получения всех ответов клиент завершает свой процесс.
На стороне клиента: клиент отправляет поток сообщений запросов на сервер. Сервер возвращает один ответ клиенту. Он (обычно) отправляет ответ после получения всех запросов от клиента и сообщения о состоянии (и в некоторых случаях конечных метаданных).
Двунаправленный: клиент и сервер передают данные друг другу без особого порядка. Клиент - это тот, кто инициирует такой вид двунаправленной потоковой передачи. Клиент также завершает соединение

--------------------------------------------------------------------------------------------------------------------
Встроенная генерация кода вместо использования сторонних инструментов

Функции генерации кода встроены в gRPC через встроенный компилятор протоколов. При использовании REST API необходимо использовать сторонний инструмент, например Swagger, для автоматической генерации кода для вызовов API на разных языках.
Компилятор protoc, поставляемый с gRPC, совместим с широким спектром языков программирования. Это делает gRPC отличным средством для многоязычных сред, где вы подключаете множество различных микросервисов, написанных на разных языках и работающих на разных платформах.
Напротив, REST API не предлагает функций генерации собственного кода. Вы должны использовать сторонний инструмент, такой как Swagger, для генерации кода для вызовов API на разных языках. Это не доставляет неудобств, но стоит отметить, что gRPC не зависит от каких-либо внешних инструментов для генерации кода.

--------------------------------------------------------------------------------------------------------------------
Передача сообщений в 7-10 раз быстрее

Согласно широко цитируемым тестам, опубликованным Руваном Фернандо, соединения gRPC API значительно быстрее, чем соединения REST API. Фактически, он сообщил, что они в 7-10 раз быстрее:
GRPC примерно в 7 раз быстрее REST при получении данных и примерно в 10 раз быстрее, чем REST при отправке данных для этой конкретной полезной нагрузки. В основном это связано с плотной упаковкой буферов протокола и использованием HTTP / 2 в gRPC

--------------------------------------------------------------------------------------------------------------------
Более долгая реализация и имплементация, чем REST

Несмотря на преимущества в скорости передачи сообщений, реализация gRPC API намного медленнее, чем реализация REST API. По словам Руана Фернандо, внедрение простой службы gRPC занимает около 45 минут. Реализация веб-API или REST API занимает всего около 10 минут.
Фернандо сообщает, что дополнительное время внедрения отражает отсутствие встроенной поддержки gRPC в сторонних инструментах. Это в первую очередь потому, что gRPC еще не получил широкого распространения, особенно по сравнению с повсеместным распространением REST API. Вот что Фернандо говорит о времени внедрения gRPC:
Мне пришлось потратить примерно 45 минут на внедрение этой простой службы gRPC, из которых я потратил всего около 10 минут на создание WebAPI. В основном это связано с тем, что REST давно стал мейнстримом, и большинство основных фреймворков (например, ASP.NET Core MVC) имеют встроенную поддержку для быстрого развертывания таких сервисов (с помощью соглашений и шаблонов)

--------------------------------------------------------------------------------------------------------------------
Когда использовать REST API

Независимо от того, создаете ли вы внутреннюю систему или открытую систему, которая предоставляет свои ресурсы остальному миру, REST API, вероятно, останутся фактическим выбором для интеграции приложений в течение очень долгого времени. Кроме того, REST API идеально подходят, когда системе требуется высокоскоростная итерация и стандартизация протокола HTTP. Благодаря универсальной поддержке сторонних инструментов REST API должны быть вашим первым аргументом в пользу интеграции приложений, интеграции микросервисов и разработки веб-сервисов.

--------------------------------------------------------------------------------------------------------------------
Когда использовать API gRPC

Что касается gRPC, в большинстве сторонних инструментов по-прежнему отсутствуют встроенные функции для совместимости с gRPC. Таким образом, gRPC в основном используется для создания внутренних систем, то есть инфраструктуры, закрытой для внешних пользователей. С учетом этого предостережения, API-интерфейсы gRPC могут быть полезны в следующих случаях:

Соединения с микросервисами: связь с низкой задержкой и высокой пропускной способностью gRPC делает его особенно полезным для подключения архитектур, состоящих из легких микросервисов, где эффективность передачи сообщений имеет первостепенное значение.

Системы где используется несколько языков программирования: благодаря поддержке генерации собственного кода для широкого спектра языков разработки, gRPC отлично подходит для управления соединениями в среде с наличием нескольких языков.

Потоковая передача в реальном времени: когда требуется связь в реальном времени, способность gRPC управлять двунаправленной потоковой передачей позволяет вашей системе отправлять и получать сообщения в режиме реального времени, не дожидаясь ответа отдельного клиента.

Сети с низким энергопотреблением и низкой пропускной способностью: использование gRPC сериализованных сообщений Protobuf обеспечивает легкий обмен сообщениями, большую эффективность и скорость для сетей с ограниченным диапазоном пропускания и маломощных сетей (особенно по сравнению с JSON). Интернет вещей может быть примером такой сети, в которой могут быть полезны API gRPC.

--------------------------------------------------------------------------------------------------------------------