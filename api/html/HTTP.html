<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Вопросы по собеседованию</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .question-block {
            cursor: pointer;
            transition: background-color 0.3s ease;
            word-break: break-word;
        }
        .question-block:hover {
            background-color: #f3f4f6;
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen">

<!-- Контейнер с вопросом -->
<div id="question-container" class="bg-white shadow-lg rounded-lg p-6 w-[800px] h-[750px] flex items-center justify-center text-center relative">
    <div id="question-block" class="question-block p-4 border-b w-full h-full flex items-center justify-center text-center relative" onclick="toggleAnswer()">
        <strong class="text-lg block" id="question-text"></strong>
        <div id="answer-text" class="text-gray-700 hidden" onclick="toggleAnswer()"></div>
    </div>
</div>

<!-- Навигация -->
<div class="absolute bottom-10 flex justify-center gap-4">
    <button onclick="prevQuestion()" class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600">Назад</button>
    <button onclick="location.href='main.html'" class="bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600">На главную</button>
    <button onclick="nextQuestion()" class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600">Вперед</button>
</div>

<!-- Модальное окно -->
<div id="modal" class="fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 hidden">
    <div class="bg-white p-6 rounded-lg shadow-lg w-[900px] h-[800px] overflow-y-auto">
        <h2 class="text-lg font-semibold mb-4">Ответ</h2>
        <p id="modal-answer" class="text-gray-700"></p>
        <button onclick="closeModal()" class="mt-4 bg-red-500 text-white px-4 py-2 rounded hover:bg-red-600 w-full">Закрыть</button>
    </div>
</div>

<script>
    let currentQuestionIndex = 0;
    const MAX_ANSWER_LENGTH = 2000; // Максимальная длина ответа для отображения без модального окна

    const questions = [
        {
  question: "HTTP это?",
  answer: "Протокол передачи гипертекста HTTP (Hypertext Transfer Protocol) - это протокол для распределённых информационных систем. Он был создан для обмена данными по сети Интернет.<br>HTTP базируется на протоколе TCP/IP, который используется для передачи данных (HTML страниц, результатов запросов, изображений и т.д.) по сети Интернет. По умолчанию, TCP использует 80-й порт, другие порты могут быть настроены дополнительно. TCP предоставляет стандартизированный способ взаимосвязи компьютеров между собой. Спецификация HTTP определяет, как именно запросы клиента должны быть построены и отправлен на сервер и то, как сервер должен отвечать на эти запросы."
}
,{
  question: "Основные свойства HTTP",
  answer: "HTTP является простым, но в то же время сильным протоколом благодаря трем свойствам:HTTP не зависит от соединения Клиент HTTP (чаще всего, браузер), отправляет HTTP запрос и, после отправки запроса, отсоединяется от сервера и ждёт ответа. Сервер обрабатывает запрос и создаёт новое соединение с клиентом для отправки ответа.HTTP не привязан к конкретному типу данныхЭто означает, что с помощью HTTP мы можем передавать любой тип данных, при условии, что и клиент и сервер 'умеют' работать с данным типом данных. Сервер и клиент должны определить тип контента с помощью определённого типа MIME.HTTP взаимодействует только через соединениеКлиент и сервер могут взаимодействовать друг с другом только с помощью запроса. После этого они 'забывают' друг о друге. Из-за этой особенности протокола ни клиент, ни сервер не могут получить информацию 'за пределами' запроса.HTTP/1.0 использует соединение для каждого цикла 'запрос/ответ'.HTTP/1.1 может использовать один или несколько циклов 'запрос-ответ' внутри одного соединения."
}
,{
  question: "Идемпотентный метод",
  answer: "Метод HTTP является идемпотентным, если повторный идентичный запрос, сделанный один или несколько раз подряд, имеет один и тот же эффект, не изменяющий состояние сервера. Другими словами, идемпотентный метод не должен иметь никаких побочных эффектов (side-effects), кроме сбора статистики или подобных операций. Корректно реализованные методы GET, HEAD, PUT и DELETE идемпотентны, но не метод POST. Также все безопасные методы являются идемпотентными.Для идемпотентности нужно рассматривать только изменение фактического внутреннего состояния сервера, а возвращаемые запросами коды статуса могут отличаться: первый вызов DELETE вернёт код 200, в то время как последующие вызовы вернут код 404. Из идемпотентности DELETE неявно следует, что разработчики не должны использовать метод DELETE при реализации RESTful API с функциональностью удалить последнюю запись."
}
,{
  question: "Базовая архитектура HTTP",
  answer: "В крайне упрощённой форме, архитектуру HTTP можно представить следующим образом:Протокол HTTP основан клиент-серверной архитектуре, в которой браузер, 'поисковик' и т.д. действует как 'клиент', а веб-сервер - как 'сервер'.<br>Клиент<br>Клиент HTTP отправляет запрос на сервер в виде метода запроса, URL и версии протокола, после которых идёт MIME сообщение, которое и содержит модификаторы запроса, информацию о клиенте и, возможно контент соединения TCP/IP.<br>Сервер<br>Сервер HTTP отвечает на запрос строкой статуса, которая включает в себя версию протокола и код успешного выполнения, либо ошибки, после которого идёт сообщение MIME, содержащее информацию о сервере, мета-информацию о сущности и, возможно, контент самой сущности."
}
,{
  question: "Стартовая строка HTTP",
  answer: "Cтартовая строка является обязательным элементом, так как указывает на тип запроса/ответа, заголовки и тело сообщения могут отсутствовать.<br>Стартовые строки различаются для запроса и ответа. Строка запроса выглядит так:<br>Метод URI HTTP/Версия протокола<br>Пример запроса:<br>GET /web-programming/index.html HTTP/1.1<br>Стартовая строка ответа сервера имеет следующий формат:<br>HTTP/Версия КодСостояния [Пояснение]<br>Например, на предыдущий наш запрос клиентом данной страницы сервер ответил строкой:<br>HTTP/1.1 200 Ok"
}
,{
  question: "Заголовки HTTP",
  answer: "HTTP header обеспечивает необходимую информацию о запросе, ответе или об отправленном объекте в теле сообщения. Существует четыре типа HTTP сообщений header'a:<br>General-header Применимы как для запроса, так и для ответа.<br>Request-header Применимы только для запроса.<br>Response-header Применимы только для ответа.<br>Entity-header Определяют метаинформацию об объекте, переданном в теле, либо, если сообщение не содержит тела, о ресурсе, определённом запросом."
}
,{
  question: "Тело сообщения HTTP",
  answer: "Это опциональный (не обязательный) элемент HTTP сообщения, который содержит объект, связанный с запросом, либо с ответом. Если объект тела связан с обычным Content-Type и Content-Length, то строки элемента header определяют тип конкретного объекта.<br>Тело сообщения содержит данные HTTP запроса (тип данных и т.д.), а HTTP ответ содержит данные, полученные от сервера (файлы, изображения и т.д.)."
}
,{
  question: "Метод запроса http",
  answer: "Данный элемент указывает метод, который должен быть вызван на стороне сервера по указанному идентификатору URI.<br>В HTTP существует восемь методов:<br>HEAD Используется для получения строки статуса и заголовка от сервера по URI. Не изменяет данные.<br>GET Используется для получения данных от сервера по указанному URI. Не изменяет данные.<br>POST Используется для отправки данных на сервер (например информации о разработчике и т.д.) с помощью форм HTML.<br>PUT Замещает все предыдущие данные на ресурсе новыми загруженными данными.<br>DELETE Удаляет все текущие данные на ресурсе, определённом URI.<br>CONNECT Устанавливает туннельное соединение с сервером по указанному URI.<br>OPTIONS Описывает свойства соединения для указанного ресурса.<br>TRACE Предоставляет сообщение, содержащее обратный трейс расположения указанного в URI ресурса.URI (Uniform Resource Identifier) - это идентификатор ресурса на который отправляется запрос."
}
,{
  question: "Код статуса HTTP",
  answer: "В ответ на запрос от клиента, сервер отправляет ответ, который содержит, в том числе, и код состояния. Данный код несёт в себе особый смысл для того, чтобы клиент мог отчётливей понять, как интерпретировать ответ:<br>1xx: Информационные сообщения<br>Набор этих кодов был введён в HTTP/1.1. Сервер может отправить запрос вида: Expect: 100-continue, что означает, что клиент ещё отправляет оставшуюся часть запроса. Клиенты, работающие с HTTP/1.0 игнорируют данные заголовки.<br>2xx: Сообщения об успехе<br>Если клиент получил код из серии 2xx, то запрос ушёл успешно. Самый распространённый вариант - это 200 OK. При GET запросе, сервер отправляет ответ в теле сообщения. Также существуют и другие возможные ответы:<br>202 Accepted: запрос принят, но может не содержать ресурс в ответе. Это полезно для асинхронных запросов на стороне сервера. Сервер определяет, отправить ресурс или нет.<br>204 No Content: в теле ответа нет сообщения.<br>205 Reset Content: указание серверу о сбросе представления документа.<br>206 Partial Content: ответ содержит только часть контента. В дополнительных заголовках определяется общая длина контента и другая инфа.<br>3xx: Перенаправление<br>Своеобразное сообщение клиенту о необходимости совершить ещё одно действие. Самый распространённый вариант применения: перенаправить клиент на другой адрес.<br>301 Moved Permanently: ресурс теперь можно найти по другому URL адресу.<br>303 See Other: ресурс временно можно найти по другому URL адресу. Заголовок Location содержит временный URL.<br>304 Not Modified: сервер определяет, что ресурс не был изменён и клиенту нужно задействовать закэшированную версию ответа. Для проверки идентичности информации используется ETag (хэш Сущности - Enttity Tag);<br>4xx: Клиентские ошибки<br>Данный класс сообщений используется сервером, если он решил, что запрос был отправлен с ошибкой. Наиболее распространённый код: 404 Not Found. Это означает, что ресурс не найден на сервере. Другие возможные коды:<br>400 Bad Request: вопрос был сформирован неверно.<br>401 Unauthorized: для совершения запроса нужна аутентификация. Информация передаётся через заголовок Authorization.<br>403 Forbidden: сервер не открыл доступ к ресурсу.<br>405 Method Not Allowed: неверный HTTP метод был задействован для того, чтобы получить доступ к ресурсу.<br>409 Conflict: сервер не может до конца обработать запрос, т.к. пытается изменить более новую версию ресурса. Это часто происходит при PUT запросах.<br>5xx: Ошибки сервера<br>Ряд кодов, которые используются для определения ошибки сервера при обработке запроса. Самый распространённый: 500 Internal Server Error. Другие варианты:<br>501 Not Implemented: сервер не поддерживает запрашиваемую функциональность.<br>503 Service Unavailable: это может случиться, если на сервере произошла ошибка или он перегружен. Обычно в этом случае, сервер не отвечает, а время, данное на ответ, истекает."
}
,{
  question: "Чем отличаются HTTP и HTTPS?",
  answer: "HTTP (HyperText Transfer Protocol - 'протокол передачи гипертекста') - протокол прикладного уровня передачи данных (изначально - в виде гипертекстовых документов в формате HTML, в настоящий момент используется для передачи произвольных данных). Основой HTTP является технология 'клиент-сервер', то есть предполагается существование потребителей (клиентов), которые инициируют соединение и посылают запрос, и поставщиков (серверов), которые ожидают соединения для получения запроса, производят необходимые действия и возвращают обратно сообщение с результатом.<br>HTTPS (HyperText Transfer Protocol Secure) - расширение протокола HTTP, поддерживающее шифрование. Данные, передаваемые по протоколу HTTPS, 'упаковываются' в криптографический протокол SSL или TLS. В отличие от HTTP, для HTTPS по умолчанию используется TCP-порт 443."
}
,{
  question: "В каких случаях необходим сертификат HTTPS?",
  answer: "Обязательное использование защищенного протокола передачи данных требует вся информация, касающаяся проведения платежей в интернете: оплата товаров в интернет-магазинах любым способом (индивидуальная платежная карта, онлайн системы платежей и пр.), оплата услуг через интернет-банкинг, совершение платежей в онлайн сервисах (казино, online-курсы и т.п.) и многое другое.<br>Использовать протокол HTTPS рекомендуется также на сайтах, которые для доступа к определенному контенту запрашивают личные данные пользователей, например, номер паспорта - такие данные необходимо защищать от перехвата злоумышленниками.<br>Если на вашем сайте используется что-либо похожее, то вам стоит серьезно задуматься над переходом на HTTPS. Поэтому далее мы рассмотрим, что для этого необходимо."
}
,{
  question: "Что нужно для перехода сайта на HTTPS?",
  answer: "Работа протокола HTTPS основана на том, что компьютер пользователя и сервер выбирают общий секретный ключ, с помощью которого и происходит шифрование передаваемой информации. Этот ключ уникальный и генерируется для каждого сеанса. Считается, что его подделать невозможно, так как в нем содержится более 100 символов. Во избежание перехвата данных третьим лицом используется цифровой сертификат - это электронный документ, который идентифицирует сервер. Каждый владелец сайта (сервера) для установки защищенного соединения с пользователем должен иметь такой сертификат.<br>В этом электронном документе указываются данные владельца и подпись. С помощью сертификата вы подтверждаете, что:<br>лицо, которому он выдан, действительно существует;<br>оно является владельцем сервера (сайта), который указан в сертификате.<br>Первое, что делает браузер при установке соединения по протоколу HTTPS - проверку подлинности сертификата, и только в случае успешного ответа начинается обмен данными.<br>Сертификатов существует несколько видов в зависимости от следующих факторов:<br>необходимого уровня безопасности;<br>количества доменных имен и поддоменов;<br>количества владельцев."
}
,{
  question: "Чем отличаются методы get и post?",
  answer: "GET передает данные серверу используя URL, а POST передает данные, используя тело HTTP запроса.<br>Длина URL'а ограничена 1024 символами, что и будет верхним пределом для данных, которые можно отослать GET'ом. POST может отправлять гораздо большие объемы данных. Кроме того, передача данных методом POST более безопасна, чем методом GET, так как секретные данные (например пароль) не отображаются напрямую в web-клиенте пользователя (в отличии от URL, который виден почти всегда)."
}
,{
  question: "Что такое ресурс?",
  answer: "Ресурс — это ключевая абстракция, на которой концентрируется протокол HTTP. Ресурс — это все, что вы хотите показать внешнему миру через ваше приложение. Например, если мы пишем приложение для управления задачами, экземпляры ресурсов будут следующие:<br>Конкретный пользователь<br>Конкретная задача<br>Список задач"
}
,{
  question: "Когда можно использовать GET запрос вместо POST для создания ресурса?",
  answer: "Невозможно использовать GET запрос для изменения (создания) ресурса."
}
,{
  question: "Http 1.1",
  answer: "HTTP 1.1 позволяет обрабатывать лишь один поступивший запрос на одно TCP-соединение, поэтому браузеру приходится устанавливать несколько соединений, чтобы обрабатывать одновременно несколько запросов.<br>Но параллельное использование многочисленных соединений приводит к перегрузке TCP, следовательно, к несправедливой монополизации сетевых ресурсов. Браузеры, использующие многочисленные соединения для обработки дополнительных запросов, занимают львиную долю доступных сетевых ресурсов, что приводит к снижению сетевой производительности для других пользователей.<br>Отправка браузерами многочисленных запросов приводит к дублированию данных в сетях передачи, что, в свою очередь, требует использования дополнительных протоколов, позволяющих безошибочно извлекать на конечных узлах нужную информацию.<br>Сетевой индустрии фактически пришлось хакнуть эти ограничения с помощью таких методик, как доменный шардинг (domain sharding), конкатенация, встраивание и спрайтинг (spriting) данных, а также ряд других. Неэффективное использование HTTP 1.1 базовых TCP-соединений является причиной плохой приоритезации ресурсов, и в результате — экспоненциальной деградации производительности по мере роста сложности, функциональности и объёма веб-приложений."
}
,{
  question: "Http 2",
  answer: "В HTTP/1.1 для каждого запроса требуется устанавливать отдельное TCP-соединение. Мультиплексирование же позволяет браузеру выполнять множество запросов в рамках одного TCP-соединения. На одном соединении запросы разделяются на чередующиеся пакеты, сгруппированные в отдельные потоки.<br>В современных браузерах количество одновременных TCP-соединений ограничено. Поэтому страницы с большим количеством статического контента загружаются не так быстро, как хотелось бы.<br>В HTTP/2 благодаря мультиплексированию статические элементы загружаются параллельно, и благодаря этому существенно улучшается производительность.Запросы приоритизируются, благодаря чему снимается проблема с одновременной отправкой всех запросов.<br>Каждому запросу можно назначить приоритет.Существует два подхода к назначению приоритетов: на основе веса и на основе зависимостей.<br>В первом подходе каждый поток получает определённый вес. Потом на основе веса сервер распределяет нагрузку между потоками. Такой подход уже использовался в протоколе SPDY.<br>Второй метод, являющийся основным в HTTP/2, заключается в следующем: браузер просит сервер загружать определённые элементы контента в первую очередь. Например, сначала браузер может попросить сервер сначала загрузить CSS-файлы или JavaScript, а уже потом — HTML или изображения.<br>В HTTP/2 приоритизация является не обязательным, а желательным методом. Однако мультиплексирование без неё работать должным образом не будет. Скорость загрузки может быть даже ниже, чем HTTP/1.1. Ресурсы с более низким приоритетом будут занимать полосу, что приведёт снижению производительности.Реализовано сжатие HTTP-заголовков. Каждый отправленный заголовок содержит информацию об отправителе и получателе, а это - избыточные объёмы. Благодаря сжатию полная информация отправляется только в первом заголовке, в последующих отправленных заголовках такой информации уже нет.В отличие от текстового протокола HTTP, HTTP/2 - бинарный. Благодаря этому можно обрабатывать небольшие сообщения, из которых формируются более крупные.Server Push. Если в версии HTTP/1 браузер должен был сначала получить домашнюю страницу, и лишь из неё понять, какие ресурсы ему необходимы для рендеринга, то HTTP/2 позволяет отправить все необходимые ресурсы сразу, при первичном обращении к серверу."
}
,{
  question: "Как HTTP/2 работает с HTTPS",
  answer: "HTTPS используется для установления сетевого соединения высокой степени безопасности, что играет большую роль при обработке важной деловой и пользовательской информации. Основные цели злоумышленников — банки, обрабатывающие финансовые транзакции, и учреждения здравоохранения, в которых накапливаются истории болезней. HTTPS работает в качестве слоя, защищающего от постоянных киберугроз, хотя отражение сложных атак, направленных на ценные корпоративные сети, обусловлено не только соображениями безопасности.<br>Браузерная поддержка HTTP/2 включает в себя HTTPS-шифрование, и фактически улучшает общую производительность обеспечения безопасности при работе с HTTPS. Ключевыми особенностями HTTP/2, позволяющими обеспечить безопасность цифровых коммуникаций в чувствительном сетевом окружении, являются:<br>меньшее количество TLS-хэндшейков,<br>меньшее потребление ресурсов на стороне клиента и сервера,<br>улучшенные возможности повторного использования имеющихся веб-сессий, но без уязвимостей, характерных для HTTP 1.x.HTTPS применяется не только в широко известных компаниях и для обеспечения кибербезопасности. Этот протокол также полезен владельцам онлайн-сервисов, обычным блогерам, интернет-магазинам и даже пользователям соцсетей. Для HTTP/2 необходима самая свежая, наиболее безопасная версия TLS, поэтому все онлайн-сообщества, владельцы компаний и вебмастеры должны удостовериться, что их сайты по умолчанию используют HTTPS.Обычные процедуры настройки HTTPS включают в себя использование планов веб-хостинга, приобретение, активацию и установку сертификатов безопасности, а также обновление самого сайта, чтобы он мог использовать HTTPS."
}
,{
  question: "Http 3",
  answer: "HTTP/3 — новая версия HTTP, которая в отличие от предыдущих работает не с TCP как транспортным протоколом, а с UDP и QUIC. QUIC — тоже инновационная и экспериментальная технология, хотя и разработанная в 2013 году, но заметно выигрывающая в скорости у TCP. Во многом достоинства HTTP/3 обязаны как раз ей.Два главных преимущества нового протокола и протокола QUIC, с которым он работает в связке:Скорость. QUIC избавлен от некоторых задержек TCP. Например, ему требуется меньшее количество «рукопожатий» для установки соединения (когда устройства «договариваются» друг с другом о протоколе безопасности), и он не блокирует все потоки данных, когда в одном из них возникла проблема. Скажем, TCP затормозит загрузку всей страницы, если в отображении фавикона возникла проблема — у QUIC такого не происходит.Шифрование данных. TCP передавал данные открыто, в случае с QUIC это невозможно, и каждый пакет данных шифруется индивидуально."
}
,{
  question: "КАКАЯ ПРОБЛЕМА БЫЛА У HTTP/2",
  answer: "Одной из главных задач при разработке HTTP/2 было обеспечить параллельную передачу нескольких типов данных. Для этого в протоколе реализовали мультиплексирование.<br>В HTTP/1.1 в одном TCP-соединении разные типы данных (картинки, стили, скрипты) можно было передавать только последовательно, друг за другом, а для одновременной передачи приходилось создавать дополнительные TCP-соединения. В HTTP/2 благодаря мультиплексированию появилась возможность передавать разные типы информации параллельно в одном соединении.Это было серьёзным улучшением. Но оставалась проблема. Если один из пакетов терялся, всё мультиплексирование было насмарку. TCP останавливал доставку абсолютно всех данных, даже других типов файлов. И передача прекращалась до тех пор, пока утерянный пакет не будет отправлен снова и доставлен получателю."
}
,{
  question: "КАК HTTP/3 РЕШАЕТ ЭТУ ПРОБЛЕМУ",
  answer: "В HTTP/3 проблема исчезает благодаря мультиплексированию, реализованному в QUIC.<br>Потеря элемента прерывает передачу только одного потока. А все остальные типы файлов продолжают передаваться без изменений. И клиент продолжает получать запрошенные данные."
}
,{
  question: "Что такое SSL/TLS",
  answer: "Перейдем к понятию SSL/TLS. SSL — это сертификат, который подтверждает подлинность веб-сайта. Аббревиатура переводится как Secure Sockets Layer.SSL-сертификат подтверждает ваш домен или организации и позволяет установить безопасное соединение. Он содержит индивидуальный ключ вашего домена, с помощью которого информация между сервером и клиентом (вами) зашифровывается.Протокол SSL был выпущен более 25 лет назад компанией NetScape в нескольких версиях, но ни одна из них не могла полностью обеспечить безопасность данных пользователей. Поэтому в 1999 году компания IEFT создала новую версию сертификата — TLS (Transport Layer Security), которая смогла решить проблемы предшественника. Первые версии протокола сейчас не актуальны, но TLS-соединение 2008 и 2018 года все еще используются в наши дни.Правильная настройка работы на вашем сайте SSL-сертификата — это гарантия, что данные между пользователем и веб-сайтом или двумя системами зашифрованы. К таким данным относятся имена, адреса, номера телефонов, номера банковских карт и другая информация. SSL не позволяет сторонним пользователям, в том числе и злоумышленники, воспользоваться ими."
}
,{
  question: "Как работает SSL",
  answer: "SSL-сертификат позволяет установить TLS-соединение с сервером, которое работает по следующей схеме:Когда пользователь заходит на веб-сайт, браузер запрашивает информацию о сертификате у сервера, который высылает копию SSL-сертификата с открытым ключом. Далее, браузер проверяет сертификат, название которого должно совпадать с именем веб-сайта.Кроме того, проверяется дата действия сертификата и наличие корневого сертификата, выданного надежным центром сертификации. Если браузер доверяет сертификату, то он генерирует предварительный секрет (pre-master secret) сессии на основе открытого ключа, используя максимально высокий уровень шифрования, который поддерживают обе стороны.Сервер расшифровывает предварительный секрет с помощью своего закрытого ключа, соглашается продолжить коммуникацию и создать общий секрет (master secret), используя определенный вид шифрования. Теперь обе стороны используют симметричный ключ, который действителен только для данной сессии. После ее завершения ключ уничтожается, а при следующем посещении сайта процесс рукопожатия запускается сначала.Все шаги для подключения по безопасному соединению занимают миллисекунды.<br>Сценарий подключения по TLS-соединению возможен, если сервер воспринимает ваш сертификат как действительный. Если же ваш сертификат невалиден, то вы не сможете подключиться к сайту по безопасному соединению. Невалидным может считаться сертификат, срок действия которого истек. Ошибку также может вызвать самоподписной сертификат. Браузеры принимают только сертификаты, которые были выпущены у сертифицированных центров.<br>Чтобы проверить валидность сертификата вы можете воспользоваться онлайн-ресурсами. Например, с помощью инструмента «Проверка SSL» от 2IP"
}
,{
  question: "Зачем нужен SSL",
  answer: "Из описания выше становится понятно, что SSL-сертификат необходим, чтобы данные пользователей вашего сайта были в безопасности. Если на вашем веб-сайте нужно зарегистрироваться или ввести личные данные (имена, e-mail, номера телефонов или кредитных карт), то важно сохранить эти данные от утечек. SSL-сертификаты помогают сохранить конфиденциальность онлайн-транзакций и гарантируют пользователям, что веб-сайт является подлинным и безопасным для ввода личных данных.<br>SSL играет роль и в SEO-оптимизации. Google и Яндекс учитывают наличие валидного сертификата и работу сайта по HTTPS как один из факторов ранжирования сайта в поисковой выдаче.<br>Если ваш сайт работает по HTTP, то рядом с адресной строкой браузеры выводят предупреждение «Не защищено», а значит пользователи будут меньше доверять вашему ресурсу."
}
,{
  question: "Виды сертификатов",
  answer: "DV — Domain Validation — для подтверждения домена. Это значит, что сертификат подтверждает именно домен сайта, а не его владельца. Он показывает, что подключение защищено, и клиент обменивается зашифрованной информацией с сервером.<br>OV — Organization Validation — для подтверждения организации и домена. Он позволяет проверить не только домен, но и его владельца. Этот сертификат могут получить как физические, так и юридические лица. OV отлично подойдет для социальных сетей, форумов, интернет-магазинов или других ресурсов с приемом платежей.<br>EV — Extended Validation — для расширенного подтверждения организации и домена. Сертификат с самым высоким уровнем защиты. Рассмотрение его получения на ресурс самый длительный — сертификационная организация проверяет не только владельца, но и регистрационные данные владельца. Предназначен только для юридических лиц. Его могут заказать финансовые организации, страховые компании, корпоративные сайты и другой крупный бизнес."
}
,
    ];

    const questionText = document.getElementById('question-text');
    const answerText = document.getElementById('answer-text');
    const modal = document.getElementById('modal');
    const modalAnswer = document.getElementById('modal-answer');

    function toggleAnswer() {
        const answer = questions[currentQuestionIndex].answer;
        if (answer.length > MAX_ANSWER_LENGTH) {
            showModal(answer);
        } else {
            if (answerText.classList.contains('hidden')) {
                answerText.innerHTML = answer;
                answerText.classList.remove('hidden');
                questionText.classList.add('hidden');
            } else {
                answerText.classList.add('hidden');
                questionText.classList.remove('hidden');
            }
        }
    }

    function showModal(answer) {
        modalAnswer.innerHTML = answer;
        modal.classList.remove('hidden');
    }

    function showQuestion(index) {
        questionText.textContent = questions[index].question;
        answerText.innerHTML = ""; // Скрываем ответ при смене вопроса
        questionText.classList.remove('hidden');
        answerText.classList.add('hidden');
    }

    function nextQuestion() {
        if (currentQuestionIndex < questions.length - 1) {
            currentQuestionIndex++;
            showQuestion(currentQuestionIndex);
        }
    }

    function prevQuestion() {
        if (currentQuestionIndex > 0) {
            currentQuestionIndex--;
            showQuestion(currentQuestionIndex);
        }
    }

    function closeModal() {
        modal.classList.add('hidden');
    }

    showQuestion(currentQuestionIndex);
</script>

</body>
</html>
