<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Вопросы по собеседованию</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .question-block {
            cursor: pointer;
            transition: background-color 0.3s ease;
            word-break: break-word;
        }
        .question-block:hover {
            background-color: #f3f4f6;
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen">

<!-- Контейнер с вопросом -->
<div id="question-container" class="bg-white shadow-lg rounded-lg p-6 w-[800px] h-[750px] flex items-center justify-center text-center relative">
    <div id="question-block" class="question-block p-4 border-b w-full h-full flex items-center justify-center text-center relative" onclick="toggleAnswer()">
        <strong class="text-lg block" id="question-text"></strong>
        <div id="answer-text" class="text-gray-700 hidden" onclick="toggleAnswer()"></div>
    </div>
</div>

<!-- Навигация -->
<div class="absolute bottom-10 flex justify-center gap-4">
    <button onclick="prevQuestion()" class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600">Назад</button>
    <button onclick="location.href='main.html'" class="bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600">На главную</button>
    <button onclick="nextQuestion()" class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600">Вперед</button>
</div>

<!-- Модальное окно -->
<div id="modal" class="fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 hidden">
    <div class="bg-white p-6 rounded-lg shadow-lg w-[900px] h-[800px] overflow-y-auto">
        <h2 class="text-lg font-semibold mb-4">Ответ</h2>
        <p id="modal-answer" class="text-gray-700"></p>
        <button onclick="closeModal()" class="mt-4 bg-red-500 text-white px-4 py-2 rounded hover:bg-red-600 w-full">Закрыть</button>
    </div>
</div>

<script>
    let currentQuestionIndex = 0;
    const MAX_ANSWER_LENGTH = 2000; // Максимальная длина ответа для отображения без модального окна

    const questions = [
        {
  question: "Что такое REST?",
  answer: "REST (сокр. от англ. Representational State Transfer — «передача состояния представления») — архитектурный стиль взаимодействия компонентов распределённого приложения в сети. Архитектурный стиль - это набор согласованных ограничений и принципов проектирования, позволяющий добиться определённых свойств системы. REST представляет собой согласованный набор ограничений, учитываемых при проектировании распределённой гипермедиа-системы. В определённых случаях (интернет-магазины, поисковые системы, прочие системы, основанные на данных) это приводит к повышению производительности и упрощению архитектуры. В широком смысле компоненты в REST взаимодействуют наподобие взаимодействия клиентов и серверов во Всемирной паутине. REST является альтернативой RPC.В сети Интернет вызов удалённой процедуры может представлять собой обычный HTTP-запрос (обычно GET или POST; такой запрос называют REST-запрос), а необходимые данные передаются в качестве параметров запроса. Для веб-сервисов, построенных с учётом REST, то есть не нарушающих накладываемых им ограничений, применяют термин «RESTful»."
}
,{
  question: "Какие HTTP методы поддерживаются в REST?",
  answer: "GET;<br>POST;<br>PUT;<br>DELETE;<br>OPTIONS;<br>HEAD."
}
,{
  question: "Преимущества, которые дает REST",
  answer: "У приложений, которые соблюдают все ограничения, есть такие преимущества: надёжность (не нужно сохранять информацию о состоянии клиента, которая может быть утеряна);производительность (за счёт использования кэша);масштабируемость;прозрачность системы взаимодействия;простота интерфейсов;портативность компонентов;лёгкость внесения изменений;способность эволюционировать, приспосабливаясь к новым требованиям."
}
,{
  question: "REST свойства",
  answer: "Производительность,<br>Масштабируемость,<br>Гибкость к изменениям,<br>Отказоустойчивость,<br>Простота поддержки."
}
,{
  question: "Принципы REST",
  answer: "6 принципов REST — ограничений, которые и помогают нам добиться этих нефункциональных требований.<br>6 принципов REST:<br>Клиент-серверная архитектура<br>Stateless<br>Кэширование<br>Единообразие интерфейса<br>Layered system<br>Code on demand"
}
,{
  question: "Принцип 1. Клиент-серверная архитектура",
  answer: "В основе данного ограничения лежит разграничение потребностей. Необходимо отделять потребности клиентского интерфейса от потребностей сервера, хранящего данные. Данное ограничение повышает переносимость клиентского кода на другие платформы, а упрощение серверной части улучшает масштабируемость системы. Само разграничение на 'клиент' и 'сервер' позволяет им развиваться независимо друг от друга."
}
,{
  question: "Принцип 2. Stateless",
  answer: "Архитектура REST требует соблюдения следующего условия. В период между запросами серверу не нужно хранить информацию о состоянии клиента и наоборот. Все запросы от клиента должны быть составлены так, чтобы сервер получил всю необходимую информацию для выполнения запроса. Таким образом и сервер, и клиент могут 'понимать' любое принятое сообщение, не опираясь при этом на предыдущие сообщения."
}
,{
  question: "Принцип 3. Кэширование",
  answer: "Клиенты могут выполнять кэширование ответов сервера. У тех, в свою очередь, должно быть явное или неявное обозначение как кэшируемых или некэшируемых, чтобы клиенты в ответ на последующие запросы не получали устаревшие или неверные данные. Правильное использование кэширования помогает полностью или частично устранить некоторые клиент-серверные взаимодействия, ещё больше повышая производительность и расширяемость системы."
}
,{
  question: "Принцип 4. Единообразие интерфейса.",
  answer: "К фундаментальным требованиям REST архитектуры относится и унифицированный, единообразный интерфейс. Клиент должен всегда понимать, в каком формате и на какие адреса ему нужно слать запрос, а сервер, в свою очередь, также должен понимать, в каком формате ему следует отвечать на запросы клиента. Этот единый формат клиент-серверного взаимодействия, который описывает, что, куда, в каком виде и как отсылать и является унифицированным интерфейсом"
}
,{
  question: "Принцип 5. Layered system (слоистая архитектура)",
  answer: "Под слоями подразумевается иерархическая структура сетей. Иногда клиент может общаться напрямую с сервером, а иногда — просто с промежуточным узлом. Применение промежуточных серверов способно повысить масштабируемость за счёт балансировки нагрузки и распределённого кэширования. Приведем пример. Представим себе некоторое мобильное приложение, которое пользуется популярностью во всем мире. Его неотъемлемая часть — загрузка картинок. Так как пользователей — миллионы человек, один сервер не смог бы выдержать такой большой нагрузки. Разграничение системы на слои решит эту проблему. Клиент запросит картинку у промежуточного узла, промежуточный узел запросит картинку у сервера, который наименее загружен в данный момент, и вернет картинку клиенту. Если здесь на каждом уровне иерархии правильно применить кэширование, то можно добиться хорошей масштабируемости системы."
}
,{
  question: "Принцип 6. Code on done (код по требованию)",
  answer: "Данное ограничение подразумевает, что клиент может расширять свою функциональность, за счет загрузки кода с сервера в виде апплетов или сценариев."
}
,{
  question: "Ограничения REST опциональны (необязательны)?",
  answer: "С точки зрения создателя этой концепции существует ровно одно необязательное ограничение — код по требованию. Все остальные ограничения должны выполняться. Если одно из них не выполняется — это уже не REST-подход."
}
,{
  question: "REST — протокол передачи данных?",
  answer: "REST — это не протокол передачи данных. Он не определяет правила о том, как мы должны передавать запросы, какая у них должна быть структура, что мы должны возвращать в ошибках. Единственное, что косвенно можно было бы приписать — это указание на то, что каждый ответ сервера должен содержать информацию о том, можно ли его кэшировать.<br>Но, в целом, REST — это концепция, парадигма, но не протокол. В отличие от HTTP, который действительно является протоколом."
}
,{
  question: "REST — это всегда HTTP?",
  answer: "С одной стороны, ни один из архитектурных принципов REST не говорит нам о том, какой транспорт мы должны использовать — HTTP или очереди.<br>Но при этом в жизни очень часто встречаются люди, для которых REST и HTTP — это аксиома.<br>Поэтому, если сказать человеку, что REST — это необязательно HTTP, то вас могут посчитать сумасшедшими.<br>Почему же все считают, что REST — это HTTP? Здесь нужно сделать ремарку, что одним из главных авторов протокола HTTP — это Рэй Филдинг, автор концепции REST. Рэй Филдинг стремился спроектировать HTTP так, чтобы с помощью него концепцию REST было максимально удобно реализовывать."
}
,{
  question: "REST — это обязательно JSON?",
  answer: "Почему так сложилось? Главная причина в том, что какое-то время назад сервисы вида JSON over HTTP стали противопоставлять SOAP. JSON одновременно стал популярным и стал антагонистом XML, как SOAP подходу. JSON использовался, потому что это не SOAP."
}
,{
  question: "Сколько уровней зрелости REST?",
  answer: "4"
}
,{
  question: "Уровень 0",
  answer: "В первую очередь, он выделил нулевой уровень. К нему относятся любые сервисы, которые в качестве транспорта используют HTTP и какой-то формат представления данных. Например, когда мы говорим про JSON over HTTP - мы говорим про нулевой уровень.<br>Если более наглядно «пощупать ручками» с точки зрения использования протокола HTTP, то можно представить, что мы выставляем некоторый API. Мы начинаем с того, что объявляем единый путь для отправки команд и всегда используем один и тот же HTTP-глагол для совершения абсолютно любых действий с любыми объектами. Например: создай вебинар, запиши вебинар, удали вебинар и т.д. То есть мы всегда используем один и тот же URL и всегда используем один и тот же HTTP-метод, обычно POST."
}
,{
  question: "Уровень 1",
  answer: "Следующий уровень — первый. Мы уже научились использовать разные ресурсы и делаем это не по одному URL. Но при этом всё ещё игнорируем HTTP-глаголы.<br>Мы просто разделяем явно наши объекты, как некоторые ресурсы. Например: спикер, курс, вебинар. Но, независимо от того, что мы хотим сделать — удалить, создать, редактировать, мы всё равно используем один и тот же HTTP-глагол POST."
}
,{
  question: "Уровень 2",
  answer: "Второй уровень — это когда мы начинаем правильно с точки зрения спецификации HTTP-протокола использовать HTTP-глаголы.<br>Например, если есть спикер, то, чтобы создать спикера и получить информацию о нём, я использую соответствующий глагол: GET, POST. Когда хочу создать или удалить спикера — я использую глаголы: PUT, DELETE.<br>По сути, второй уровень зрелости — это то, что чаще всего называют REST.<br>Надо понимать, что, с точки зрения изначальной концепции, если мы дошли до второго уровня зрелости, то это еще не означает, что мы спроектировали REST-систему/ REST-сервис. Но в очень распространённом понимании соответствие 2-ому уровню часто называют RESTfull сервисом.<br>RESTfull-сервис — это такой сервис, который спроектирован с учётом REST-ограничений. Хотя, в целом, правильнее сервис такого уровня зрелости называть HTTP-сервисом или HTTP-API, нежели REST-API."
}
,{
  question: "Уровень 3",
  answer: "Третий уровень зрелости — это уровень, в котором мы начинаем использовать концепцию HATEOAS. Когда мы передаём информацию, ресурсы, мы сообщаем потребителям (клиентам) о том, какие ещё действия необходимо совершить ресурсу, а также связи с другими ресурсами."
}
,{
  question: "Выводы, которые мы можем сделать из модели зрелости?",
  answer: "Итак, как нам эта модель может помочь понять то, что наши коллеги называют RESTом в каждой отдельно взятой компании? REST у вас или не REST?<br>Первая распространенная трактовка термина REST — всё, что передаётся в виде JSON поверх HTTP.<br>Вторая, не менее популярная версия, REST — это сервис второго уровня зрелости, то есть HTTP-API, составленное в соответствии со спецификацией HTTP-протокола. Если мы правильно выделяем ресурсы, правильно используем HTTP-глаголы, а также выполняем некоторые требования HTTP-протокола, то у нас REST."
}
,{
  question: "REST и Ресурсы?",
  answer: "Важно отметить, что с REST вам нужно думать о приложении с точки зрения ресурсов:Определите, какие ресурсы вы хотите открыть для внешнего мираИспользуйте глаголы, уже определенные протоколом HTTP, для выполнения операций с этими ресурсами.Вот как обычно реализуется служба REST:<br>Формат обмена данными: здесь нет никаких ограничений. JSON — очень популярный формат, хотя можно использовать и другие, такие как XML<br>Транспорт: всегда HTTP. REST полностью построен на основе HTTP.<br>Определение сервиса: не существует стандарта для этого, а REST является гибким. Это может быть недостатком в некоторых сценариях, поскольку потребляющему приложению может быть необходимо понимать форматы запросов и ответов. Однако широко используются такие языки определения веб-приложений, как WADL (Web Application Definition Language) и Swagger.<br>REST фокусируется на ресурсах и на том, насколько эффективно вы выполняете операции с ними, используя HTTP."
}
,{
  question: "Что такое resource в REST?",
  answer: "Это уникальный URL с представлением объекта, который может быть получен с помощью запросов GET и изменен с помощью PUT, POST, DELETE."
}
,{
  question: "Что такое URI ресурса?",
  answer: "Когда вы разрабатываете RESTful сервисы, вы должны сосредоточить свое внимание на ресурсах приложения. Способ, которым мы идентифицируем ресурс для предоставления, состоит в том, чтобы назначить ему URI — универсальный идентификатор ресурса. Например:<br>Создать пользователя: POST /users<br>Удалить пользователя: DELETE /users/1<br>Получить всех пользователей: GET /users<br>Получить одного пользователя: GET /users/1"
}
,{
  question: "Понятие веб-сервисов?",
  answer: "Есть несколько видов веб-сервисов, среди которых REST и SOAP. Для каждого сервиса есть:<br>Поставщик сервиса, который предоставляет сервис<br>Потребитель сервиса, который им пользуется<br>Потребитель должен знать детали предоставляемой услуги. По этой причине должен быть заключен договор. Договор на обслуживание определяет:<br>Каковы входы и выходы из сервиса?<br>По какому URL-адресу доступен сервис?<br>Как отправлять авторизацию?"
}
,{
  question: "Что такое Contract First подход?",
  answer: "При подходе «Contract First» (контракт сначала) вы сначала определяете контракт, а затем внедряете сервис. Давайте рассмотрим пример."
}
,{
  question: "Использованеи Consumer First подход",
  answer: "Кто будет пользоваться вашим сервисом? Потребитель услуг.Вы смотрите на сервис с точки зрения потребителя?<br>Если вы разрабатываете API, сможет ли ваш потребитель понять ваш API?<br>Если вы опубликуете свои ресурсы, сможет ли потребитель найти и получить к ним доступ?<br>Сможет ли потребитель понять ваши URI?<br>Какой тип услуги вы предоставляете?<br>Это мобильное приложение или веб-приложение?<br>Каких потребителей вы ожидаете, и могут ли эти типы потребителей измениться в будущем?<br>Если вы реализуете что-то вроде HATEOAS, подумайте, как ваши потребители будут использовать это, прежде чем внедрять.<br>Самое главное — иметь отличную документацию<br>Сделайте вещи проще для ваших потребителей, чтобы сэкономить ваше время<br>Чем больше потребители могут сделать самостоятельно, тем меньше работы для вас<br>Всякий раз, когда у вас проходит обсуждение или ревью сервиса, ставьте требования потребителя на первое место."
}
,{
  question: "Contract First подход пример",
  answer: "Давайте сначала рассмотрим случай использования WSDL — языка определения веб-сервисов. Вот пример использования:WSDL обычно используется с веб-сервисами SOAP/XML. В таком случае вы обычно определяете<br>Что подразумевается под контрактом?<br>Когда мы начинаем с заключения договора, мы определяем WSDL, а затем делимся им с нашим потребителем. Все это может произойти еще до того, как мы внедрим сервис и сделаем его доступным.Контракт сообщает потребителю, каким ожидается обмен запросами и ответами. Как только договор заключен, поставщик услуг может работать над предоставлением услуги, соответствующей договору. Потребитель услуг может работать над разработкой приложения для его использования."
}
,{
  question: "Преимущества подхода Contract First",
  answer: "Команды могут разрабатывать параллельноПоскольку кодирование происходит на основе контракта, поставщики услуг и группы потребителей услуг четко понимают подход и детали коммуникации. Следовательно, разработка может происходить одновременно.Команды знают, что ожидатьПоскольку кодирование происходит на основе контракта, команды производителей и потребителей имеют представление об ожиданиях друг друга. В результате, если межгрупповое тестирование невозможно из-за разных темпов разработки, программное обеспечение-заглушка может использоваться для моделирования над поведения другой стороны на основе контракта.Кроссплатформенная совместимостьПоскольку параметры сервиса зависят только от контракта, фактическая структура программного обеспечения, используемая для разработки сервиса, не имеет большого значения. Поставщик услуг и потребитель услуг могут использовать разные технологии.Позволяет повторно использовать схемыСхемы, которые используются для определения договора на услугу, хорошо определены в WSDL. Следовательно, если части служб повторяются в других службах, то соответствующие схемы также можно использовать повторно."
}
,{
  question: "Недостатки подхода Contract Firs",
  answer: "Требуется дополнительные начальные затратыБольшая часть этих затрат будет сосредоточена вокруг соглашения об обслуживании. Вы должны убедиться, что договор четко определен и не меняется очень часто.Механизм для обновления контракта и обменаВ течение срока пользования сервиса, если вы обновляете договор, это влияет на все другие заинтересованные стороны. Следовательно, должен существовать надлежащий механизм для передачи изменений различным потребителям."
}
,{
  question: "Что такое Code-First подход?",
  answer: "Всякий раз, когда вы разрабатываете сервис, такой как REST API или SOAP API, вы можете выбрать один из двух подходов:<br>Code First и генерируйте контракт из кода<br>Contract First и разработка кода на основе контракта"
}
,{
  question: "Использование Contract First подход",
  answer: "Что такое контракт?Создатель веб-сервиса считается поставщиком сервиса. Приложение, которое использует веб-сервис, является потребителем сервиса. Контракт — это соглашение между поставщиком и потребителем об услуге.Чтобы правильно использовать услугу, потребитель сервиса должен полностью понимать договор. Контракт включает в себя детали многих аспектов обслуживания, таких как:<br>Как вызвать веб-сервис?<br>Какой транспорт используется?<br>Каковы структуры запроса и ответа?<br>Это также называется определением сервиса (service definition).При contract first подходе вы сначала определяете контракт на обслуживание, а затем только внедряете сервис."
}
,{
  question: "Spring Boot Code First пример REST API",
  answer: "Мы разрабатываем RESTful веб-сервис, используя Spring Boot Framework для генерации API. Например, в API retrieveAllUsers () мы открываем URI «/users» ивозвращаем всех пользователей (ресурс /users),вызывая метод сервиса.Когда мы переходим на этот URL, мы возвращаем всех пользователей:Аналогичным образом определены и другие сервисные методы, каждый из которых имеет свой собственный URI. В этом примере мы берем код и генерируем из него документацию. В этой документации указано, как пользователь может использовать сервис. Для этого мы используем формат документации Swagger:Swagger позволяет нам генерировать документацию из кода. Например, вот что Swagger генерирует для запроса на получение всех пользователей:Он выводит тип получаемого нами ответного сообщения и сопровождающий его статус ответа. Вы даже можете вызвать этот сервис из Swagger получить ответ:Вы также можете отправить запрос POST в '/users':Swagger сообщит нам, как структурировать сообщение запроса и указать внутри него отдельные форматы полей. Он также сообщит вам тип ответа, который вы получите, вместе с кодом ответа. То, что Swagger генерирует из кода, называется контрактом."
}
,{
  question: "Преимущества Code First",
  answer: "Основные преимущества этого подхода:<br>Контракты с минимальными усилиями: генерация контракта не требует дополнительных усилий. Это всего лишь побочный продукт разработки сервиса, так как он может быть автоматически сгенерирован из кода<br>Синхронизация кода и контракта: поскольку контракт генерируется из кода, они всегда синхронизируются друг с другом"
}
,{
  question: "Недостатки Code First",
  answer: "Недостатки этого подхода заключаются в следующем:<br>Нет параллельной разработки<br>Производитель услуг и потребители услуг не могут разрабатывать параллельно. Сначала необходимо разработать сервис, затем сгенерировать контракт, и только после этого можно написать код потребителя, который будет придерживаться контракта. Без понимания контракта потребитель не может быть разработан.<br>Нет цели для команд<br>Поскольку договор не может быть известен до того, как сервис будет разработан, не существует цели для различных заинтересованных сторон в разработке. Следовательно, есть все шансы, что направления будут отклоняться, и будут внесены ненужные изменения, что приведет к напрасной трате усилий.<br>Нет кроссплатформенной совместимости<br>На некоторых старых платформах не так просто сгенерировать контракт из кода. В результате этого для сгенерированных контрактов довольно часто возникает несовместимость между платформами.По этому вопросу имеется авторское видео.<br>Резюме<br>В этой статье мы исследовали Code First подход построения REST API. Несмотря на то, что подход, основанный на коде, эффективен с точки зрения разработчика, он сталкивается с серьезными проблемами, когда речь идет о совместной разработке поставщика и потребителя."
}
,{
  question: "Организационные стандарты для REST API",
  answer: "Важным ориентиром организационных стандартов является YARAS.YARAS означает Yet Another RESTful API Standard (еще один стандарт RESTful API). YARAS предоставляет стандарты, руководства и соглашения, которые необходимо соблюдать при разработке RESTful веб-сервисов. Он дает рекомендации для следующих вещей:<br>Как вы должны назвать свои услуги<br>Как вы должны структурировать свой запрос и ответ<br>Как вы должны реализовать фильтрацию, сортировку, разбиение на страницы и другие действия<br>Как вы должны подходить к версионированию<br>Как вам нужно подходить к документации API"
}
,{
  question: "Единый подход к разработке сервисов",
  answer: "Вам нужно решить множество сложных проблем, прежде чем приступить к проектированию RESTful веб-сервисов. Все перечисленное выше, необходимо выяснить.Руководство вашей организация не захочет, чтобы команды, которые занимаются различными ресурсами, разные подходы к этим вещам.Например, нежелательно, чтобы Команда-A организовывала версионность на основе параметров запроса, а Команда-B использовало версионность на основе URI.Поэтому важно, чтобы у вас были четко определенные организационные стандарты для подхода к RESTful веб-сервисАМ."
}
,{
  question: "Кастомизация YARAS ПОД организационные нужды",
  answer: "Хорошая вещь в YARAS — это то, что он может быть настроен для удовлетворения потребностей, специфичных для организации. Например, вы можете:<br>Настройте, как должны выглядеть тела запросов и ответов<br>Выберите конкретный вид системы управления версиями<br>Поскольку YARAS имеет достаточно всеобъемлющий охват, вы можете быть уверены, что не пропустили ни одного важного решения."
}
,{
  question: "Выбор стандартного общеорганизационного REST API фреймвока",
  answer: "Типичными фреймвоками, которые используются для создания веб-сервисов RESTful в мире Java, являются Spring MVC, Spring REST и JAX-RS.Если вы создадите специфичную для организации фреймвок/архетип/эталонное приложение, придерживающееся общих стандартов организации, поверх предпочтительной REST API платформы, это позволит командам легко придерживаться общих стандартов.Типичные особенности включают в себя:<br>Структуры запросов и ответов<br>Обработка ошибок<br>фильтрация<br>Поиск<br>Versioning<br>Поддержка ложных ответов<br>HATEOAS<br>Стандартный фреймвок обеспечивает единый подход к проектированию и внедрению сервисов во всей организации."
}
,{
  question: "Децентрализованное управление REST API",
  answer: "Создайте группу экспертов из команд, создающих REST API, и сформируйте команду управления. Команда несет ответственность за<br>Улучшение стандартов REST API<br>Построение / Проектирование ваших REST API фреймвоков"
}
,{
  question: "Широкое использование HTTP",
  answer: "Всякий раз, когда вы думаете о веб-сервисах RESTful, думайте о HTTP.HTTP имеет все функции, которые помогут вам создавать отличные веб-сервисы."
}
,{
  question: "Используйте правильные методы HTTP-запросов",
  answer: "Подумайте о методах HTTP-запросов, которые вам нужно использовать. Когда вы думаете о реализации какой-либо операции, определите ресурс, на котором она должна быть выполнена, а затем найдите соответствующий метод HTTP-запроса. Вы извлекаете детали, создаете что-то, обновляете что-то существующее или удаляете существующее?Использование HTTP методов:<br>GET для получения<br>POST для создания<br>PUT для обновления<br>DELETE для удаления<br>PATCH для частичных обновлений"
}
,{
  question: "Используйте соответствующий статус ответа HTTP",
  answer: "При выполнении операции убедитесь, что вы вернули правильный статус ответа.Например, когда конкретный ресурс не найден, не выбрасывайте исключение сервера. Вместо этого отправьте соответствующий код ответа в ответном сообщении, например 404.Если на самом деле существует исключение сервера, отправьте обратно код 500.В случае ошибки проверки отправьте код для неверного запроса."
}
,{
  question: "Фокус на представление",
  answer: "Каждый ресурс может иметь несколько представлений — в формате XML или JSON. Потребитель услуг может выбрать представление по своему выбору.Сервис возвращает 3 элемента users, когда мы отправляем запрос GET. В этом случае мы получаем JSON-представление ресурса /users.Когда потребитель не указывает предпочтительное представление, мы используем JSON.Потребитель может отправить заголовок Accept, чтобы указать представление."
}
,{
  question: "Используйте множественное число",
  answer: "Всегда используйте множественное число, когда вы именуете ресурсы.Давайте посмотрим на простой пример. Предположим, у нас есть сервис, который размещает ресурс пользователя. Ниже описано, как получить к ним доступ:<br>Создать пользователя: POST /users<br>Удалить пользователя: DELETE /users/1<br>Получить всех пользователей: GET /users<br>Получить одного пользователя: GET /users/1<br>Предпочтение множественного users единственному user делает URI более читабельным.<br>Например, если мы используем /user вместо /users для получения, GET /user не передает правильное сообщение читателю."
}
,{
  question: "Создать хорошую документацию",
  answer: "Потребители должны понимать, как наилучшим образом использовать сервис, и лучший способ помочь им — создавать хорошую документацию.Веб-сервисы SOAP могут использовать функциональность WSDL, в то время как RESTful веб-сервисы имеют опции Swagger (теперь стандарт документации Open API).Выбор формата — это только одна часть создания хорошей документации. Что также важно, так это предоставление нужного количества информации, чтобы помочь потребителю.Документация должна быть полной и включать следующие пункты:<br>Что такое структура запроса и ответа?<br>Как потребитель должен аутентифицировать себя?<br>Каковы пределы использования?<br>Укажите все типы ответных сообщений и соответствующие коды состояния, которые можно ожидать от службы"
}
,{
  question: "Создать общий портал документации REST API",
  answer: "Полезно было бы иметь общий портал документации REST API для всей организации. Взгляните на один такой портал:Такой портал объединяет все ресурсы, имеющиеся в организации. Наличие пользовательского интерфейса, такого как Swagger UI, будет иметь свои дополнительные преимущества. Используя Swagger UI, вы можете посмотреть документацию более подробно:Это может быть использовано даже нетехническими пользователями. Информация, предоставляемая здесь, включает в себя:<br>Ожидаемый формат ответа<br>Тип контента<br>Поддерживаемые коды ответов<br>Интерес также может представлять формат документации в стиле «живой запрос/ответ»."
}
,{
  question: "Поддержка версий",
  answer: "Управление версиями влечет за собой большую сложность для веб-службы. Поддерживать несколько разных версий одного и того же веб-сервиса очень сложно. Старайтесь избегать этого, когда это возможно.<br>Однако в определенных сценариях управление версиями неизбежно.<br>Давайте начнем с рассмотрения примера службы. Предположим, что мы изначально определили службу, имеющую класс PersonV1, следующим образом:<br>Эта версия класса не учитывает, что у имени может быть много подразделов, таких как имя и фамилия. Посмотрите это:Вторая версия исходного класса была обновлена, чтобы исправить эту аномалию:<br>Мы не можем сразу перенести весь сервис для использования PersonV2! Там могут быть другие потребители, которые ожидают ответов в формате PersonV1.<br>Вот где требуется управление версиями.Давайте теперь посмотрим на варианты, которые мы имеем для управления версиями этих двух ресурсов."
}
,{
  question: "Использование разных URI",
  answer: "У нас есть один вариант — использовать разные URI для этих разных ресурсов. В приведенном ниже коде экзамена мы используем URI v1/person и v2/person для их различения:Если вы выполняете запрос GET для ресурса v1/person:<br>Вы получите информацию, соответствующую v1.<br>Для другого ресурса v2 другую"
}
,{
  question: "Использование параметра запроса",
  answer: "Второй метод управления версиями использует параметр запроса:В URI /person/param, если мы отправляем параметр с версией=1, мы возвращаем ресурс типа PersonV1:<br>Для того же URI параметр с version=2 возвращает ресурс типа PersonV2:<br>Этот метод называется управлением версиями с помощью параметров запроса."
}
,{
  question: "Использование Header (заголовка)",
  answer: "Другим способом вы можете сделать это управление версиями, указав заголовок. Здесь мы используем заголовок с именем X-API-VERSION и пометили URI как /person/header. Когда значение заголовка равно 1, возвращается ресурс типа PersonV1:Когда его значение равно 2, ресурс типа PersonV2 извлекается:Мы используем атрибут в заголовке запроса, чтобы выполнить управление версиями для нас."
}
,{
  question: "Использование Accept Header",
  answer: "Последний метод для создания версий использует Accept Header. Если потребитель включает первую информацию о версиях в Accept Header запроса GET, возвращается следующий ресурс:В противном случае возвращается ресурс типа PersonV2:Этот способ управления версией называется Accept Header Versioning или Media Type Versioning, поскольку MIME-типы обычно являются содержимым заголовка Accept."
}
,{
  question: "Сравнение методов управления версиями",
  answer: "До сих пор мы видели четыре типа методов версиями:<br>Использование разных URI<br>Использование параметра запроса<br>Использование заголовка<br>Использование Accept Header / Media Type<br>Какой из них самый лучший? Правда в том, что на этот вопрос нет однозначного ответа. В том-то и дело, что разные интернет-гиганты покровительствуют разным типам версий.<br>Использование разных URI — Twitter<br>Использование параметра запроса — Amazon<br>Использование заголовка — Microsoft<br>Использование Accept Header / Media Type — GitHub<br>Вам необходимо оценить эти четыре варианта в соответствии с вашими конкретными потребностями. Есть ряд важных факторов, которые следует учитывать:<br>URI Pollution (Загрязнение URI): управляя версиями с использованием URI и параметров запроса мы в конечном итоге загрязняем пространство URI. Это происходит потому, что мы добавляем префиксы и суффиксы к основным строкам URI. Управление версиями с использованием заголовка позволяет избежать этого.<br>Misuse Of HTTP Headers (Неправильное использование заголовков HTTP). В случае управления версиями с использованием заголовков и Media Type происходит неправильное использование заголовков HTTP, поскольку они изначально не предназначались для управления версиями.<br>Caching (Кэширование): ресурс определяется его URI. Однако, если вы не используете URI для определения его версии, а используете механизм на основе заголовка, информация о версиях не может быть кэширована. Если для вас важно HTTP-кеширование, используйте управления версиями на основе URI или параметра запроса.<br>Browser Request Executability (Выполняемость запроса браузера): для управления версиями на основе заголовка и типа медиа требуется использование таких инструментов, как Postman. Тем не менее, если потребители службы не разбираются в технических вопросах, то предпочтительнее использовать управления версиями на основе URI или параметра запроса.<br>API Documentation (Документация API): Вам также нужно подумать о том, как вы хотите документировать свои API. Версионность на основе URI и параметра запроса проще документировать, чем два других типа управления версиями.<br>Поймите, что не существует единого идеального решения!"
}
,{
  question: "Когда потребитель запрашивает несуществующий ресурс",
  answer: "Если мы отправим запрос GET для поиска существующего пользователя, мы получим следующий ответ:Если вы ищете несуществующего пользователя:То, что вы получите, это статус 404 Not Found. Это хорошая обработка ошибок, поскольку она правильно определяет, что ресурс не найден, и не возвращает ошибку сервера.Давайте теперь отправим запрос GET на несуществующий URI:Как видидите, вы получаете статусы ответа 404 Not Found. Неправильный URL указывает на несуществующий ресурс."
}
,{
  question: "Важные статусы ответа",
  answer: "200 — успех<br>404 — ресурс не найден<br>400 — неверный запрос (например, ошибка проверки)<br>201 — создан<br>401 — несанкционированный (при неудачной авторизации)<br>500 — ошибка сервера"
}
,{
  question: "Что означает HATEOAS?",
  answer: "Термин HATEOAS означает фразу «Hypermedia As The Engine Of Application State» (Гипермедиа как двигатель состояния приложения). Чтобы понять это глубже, нам сначала нужно понять значение гипермедиа. Взгляните на следующую веб-страницу:Когда браузер загружает страницу, вы определенно можете увидеть весь контент, который может предложить эта страница. Что еще более интересно, страница также позволяет вам выполнять множество действий с этими данными, например:<br>Нажатие на кнопки (зеленое «Clone» (Клонировать) или «Download» (Скачать)<br>Нажатие на вкладки (например, для просмотра «Issues» (Проблемы))<br>и еще несколько<br>Теперь давайте посмотрим, как ведут себя наши REST API:Если вы посмотрите на типичный запрос GET к RESTful серверу, такой как этот:Запрос GET localhost:8080/users получает набор данных трех пользователей в этом случае. Отправив запрос с помощью GET localhost:8080/users/1, вы получите сведения только о первом пользователе. Как правило, когда мы выполняем запрос REST, мы получаем только данные, а не какие-либо действия с ними. Вот где HATEOAS восполняет пробел. Запрос HATEOAS позволяет вам не только отправлять данные, но и указывать связанные действия:Этот пример был в формате JSON. Формат XML для другого примера будет выглядеть примерно так:Когда вы отправляете этот запрос для получения данных учетной записи, вы получаете оба:<br>Номер счета и данные баланса<br>Ссылки, которые обеспечивают действия, чтобы сделать депозит/снятие/перевод/закрытие<br>С HATEOAS запрос на REST ресурс дает мне как данные, так и действия, связанные с данными."
}
,{
  question: "Зачем нам нужен HATEOAS?",
  answer: "Единственная самая важная причина для HATEOAS — слабая связь (loose coupling). Если потребителю службы REST необходимо жестко закодировать все URL-адреса ресурсов, он тесно связан с реализацией вашей службы. Вместо этого, если вы вернете URL-адреса, которые он может использовать для действий, он будет слабосвязанным. Нет строгой зависимости от структуры URI, так как она указана и используется в ответе. Несколько важных тем, связанных с HATEOAS:"
}
,{
  question: "HAL — язык гипертекстовых приложений",
  answer: "При разработке службы RESTful необходимо указать, как возвращать данные и ссылки, соответствующие запросу. HAL — это формат, который обеспечивает простой и согласованный способ гиперссылки между ресурсами в вашем REST API.С HAL у вас есть несколько категорий представлений:<br>Links (Ссылки): указано как комбинация<br>Target (Цель) — указана в качестве URI<br>Relation (Отношение) — имяEmbedded Resources (Встроенные ресурсы): другие ресурсы, содержащиеся в данном REST ресурсе<br>State (Состояние): фактические данные ресурса<br>Если вам довелось использовать Spring Framework для разработки REST сервиса, то Spring HATEOAS — хороший механизм для вашего сервиса.По этому вопросу имеется авторское видео."
}
,{
  question: "Что такое Swagger?",
  answer: "это фреймворк для спецификации RESTful API. Его прелесть заключается в том, что он дает возможность не только интерактивно просматривать спецификацию, но и отправлять запросы - так называемый Swagger UI.<br>Также возможно сгенерировать непосредственно клиента или сервер по спецификации API Swagger, для этого понадобится Swagger Codegen."
}
,{
  question: "Open API",
  answer: "Было бы здорово иметь возможность один раз описать свой HTTP API, и из этого описание получить совпадающие каркасы для реализации бекенда и фронтенда, которые, из-за отсутствия человека в цепочке, будут с большей вероятностью совпадать. (При условии, что генерация этих каркасов реализована без ошибок, но это, на самом деле, более простая задача.)<br>О, чудо! Такое уже придумали! И называется оно OpenAPI!<br>OpenAPI позволяет формально описывать HTTP API в виде YAML файлов. Довольно обширный пример можно посмотреть на editor.swagger.io. Там можно смотреть исходный YAML и человеко-читаемую HTML страничку одновременно.<br>Если изначальную спецификацию архитектор опишет в виде OpenAPI спецификации, то все взаимодействие между бекендом и фронтендом можно будет сгенерировать автоматически, и оно будет гарантированно совпадать. Таким образом мы вообще исключаем из цепочки человеческий фактор!"
}
,{
  question: "Основные подходы Swagger",
  answer: "Swagger имеет два подхода к написанию документации:Документация пишется на основании вашего кода.Данный подход позиционируется как 'очень просто'. Нам достаточно добавить несколько зависимостей в проект, добавить конфигурацию и уже мы будем иметь нужную документацию, хоть и не настолько описанной какою мы хотели.<br>Код проекта становится не очень читабельным от обилия аннотаций и описания в них.<br>Вся документация будет вписана в нашем коде (все контроллеры и модели превращаются в некий Java Swagger Code)<br>Подход не советуют использовать, если есть возможности, но его очень просто интегрировать.Документация пишется отдельно от кода.Данный подход требует знать синтаксис Swagger Specification.<br>Документация пишется либо в YAML/JSON файле, либо в редакторе Swagger Editor."
}
,{
  question: "Swagger Tools",
  answer: "Swagger или OpenAPI framework состоит из 4 основных компонентов:<br>Swagger Core - позволяет генерировать документацию на основе существующего кода основываясь на Java Annotation.<br>Swagger Codegen - позволит генерировать клиентов для существующей документации.<br>Swagger UI - красивый интерфейс, который представляет документацию. Дает возможность просмотреть какие типы запросов есть, описание моделей и их типов данных.<br>Swagger Editor - Позволяет писать документацию в YAML или JSON формата."
}
,{
  question: "Swagger Core",
  answer: "Swagger Code - это Java-реализация спецификации OpenAPI"
}
,{
  question: "Swagger Codegen",
  answer: "Swagger Codegen - это проект, который позволяет автоматически создавать клиентские библиотеки API (создание SDK), заглушки сервера и документацию с учетом спецификации OpenAPI."
}
,{
  question: "Swagger UI",
  answer: "Swagger UI - позволяет визуализировать ресурсы API и взаимодействовать с ними без какой-либо логики реализации. Он автоматически генерируется из вашей спецификации OpenAPI (ранее известной как Swagger), а визуальная документация упрощает внутреннюю реализацию и использование на стороне клиента."
}
,{
  question: "Swagger Editor",
  answer: "Swagger Editor - позволяет редактировать спецификации Swagger API в YAML внутри вашего браузера и просматривать документацию в режиме реального времени. Затем можно сгенерировать допустимые описания Swagger JSON и использовать их с полным набором инструментов Swagger (генерация кода, документация и т. Д.)."
}
,
    ];

    const questionText = document.getElementById('question-text');
    const answerText = document.getElementById('answer-text');
    const modal = document.getElementById('modal');
    const modalAnswer = document.getElementById('modal-answer');

    function toggleAnswer() {
        const answer = questions[currentQuestionIndex].answer;
        if (answer.length > MAX_ANSWER_LENGTH) {
            showModal(answer);
        } else {
            if (answerText.classList.contains('hidden')) {
                answerText.innerHTML = answer;
                answerText.classList.remove('hidden');
                questionText.classList.add('hidden');
            } else {
                answerText.classList.add('hidden');
                questionText.classList.remove('hidden');
            }
        }
    }

    function showModal(answer) {
        modalAnswer.innerHTML = answer;
        modal.classList.remove('hidden');
    }

    function showQuestion(index) {
        questionText.textContent = questions[index].question;
        answerText.innerHTML = ""; // Скрываем ответ при смене вопроса
        questionText.classList.remove('hidden');
        answerText.classList.add('hidden');
    }

    function nextQuestion() {
        if (currentQuestionIndex < questions.length - 1) {
            currentQuestionIndex++;
            showQuestion(currentQuestionIndex);
        }
    }

    function prevQuestion() {
        if (currentQuestionIndex > 0) {
            currentQuestionIndex--;
            showQuestion(currentQuestionIndex);
        }
    }

    function closeModal() {
        modal.classList.add('hidden');
    }

    showQuestion(currentQuestionIndex);
</script>

</body>
</html>
