<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Вопросы по собеседованию</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .question-block {
            cursor: pointer;
            transition: background-color 0.3s ease;
            word-break: break-word;
        }
        .question-block:hover {
            background-color: #f3f4f6;
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen">

<!-- Контейнер с вопросом -->
<div id="question-container" class="bg-white shadow-lg rounded-lg p-6 w-[800px] h-[750px] flex items-center justify-center text-center relative">
    <div id="question-block" class="question-block p-4 border-b w-full h-full flex items-center justify-center text-center relative" onclick="toggleAnswer()">
        <strong class="text-lg block" id="question-text"></strong>
        <div id="answer-text" class="text-gray-700 hidden" onclick="toggleAnswer()"></div>
    </div>
</div>

<!-- Навигация -->
<div class="absolute bottom-10 flex justify-center gap-4">
    <button onclick="prevQuestion()" class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600">Назад</button>
    <button onclick="location.href='main.html'" class="bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600">На главную</button>
    <button onclick="nextQuestion()" class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600">Вперед</button>
</div>

<!-- Модальное окно -->
<div id="modal" class="fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 hidden">
    <div class="bg-white p-6 rounded-lg shadow-lg w-[900px] h-[800px] overflow-y-auto">
        <h2 class="text-lg font-semibold mb-4">Ответ</h2>
        <p id="modal-answer" class="text-gray-700"></p>
        <button onclick="closeModal()" class="mt-4 bg-red-500 text-white px-4 py-2 rounded hover:bg-red-600 w-full">Закрыть</button>
    </div>
</div>

<script>
    let currentQuestionIndex = 0;
    const MAX_ANSWER_LENGTH = 2000; // Максимальная длина ответа для отображения без модального окна

    const questions = [
        {
  question: "Что собой представляет система отслеживания ошибок?",
  answer: "Инструменты отслеживания ошибок (системы баг-трекинга) предназначены для систематической регистрации багов и прочих проблем и удобного управления жизненным циклом бага.Среднестатистическая баг-трекинговая система имеет следующий функционал:создание тикетов с подробным описанием баговклассификация и расстановка приоритетов в тикетахназначение тикетов конкретным специалистамотслеживание статуса бага на разных этапахудобный поиск, сортировка и составление баг-репортованалитика и автоматическое формирование репортов."
}
,{
  question: "Зачем нужна система отслеживания ошибок?",
  answer: "Баг-трекинговые системы упрощают отслеживание, классификацию и приоритизацию багов. Также они полезны для аналитики: с их помощью можно получить информацию, которая позволит повысить общую эффективность команды и потенциально оптимизировать затраты на разработку. К тому же баг-трекинговые системы упрощают коммуникацию между тестировщиками и разработчиками."
}
,{
  question: "JIRA",
  answer: "Инструмент отслеживания ошибок Jira был запущен в 2003 году. Со временем он превратился в систему управления проектами, широко используемую в agile-разработке. В частности, в Jira есть доски Scrum и Kanban, дорожные карты и многое другое.<br>Что касается баг-трекинга, Jira предоставляет полный набор необходимых функций.<br>Плюсы:<br>Пользователи могут создавать собственные фильтры и настраивать рабочие процессы<br>Есть удобная система тикетов, позволяющая легко следить за ходом выполнения задач<br>Доступ к отчетам с полезной информацией в режиме реального времени<br>Интеграция с более чем 3000 приложений обеспечивает прозрачность конвейера разработки<br>Jira идеально подходит для больших и удаленных команд<br>Есть мобильное приложение, позволяющее получить доступ к системе в любое время<br>Минусы:<br>Пользователи отмечают, что UI сбивает с толку и порой сложен для понимания<br>Функции репортов не учитывают все параметры, которые было бы полезно отслеживать<br>Jira может оказаться дорогой для небольших команд<br>Регистрация, настройка и устранение неполадок сложны"
}
,{
  question: "TRELLO",
  answer: "Как и Jira, Trello — это продукт Atlassian. Он хорошо подходит и для отслеживания ошибок, и для управления продуктами в целом.<br>Изюминкой Trello является упор на визуализацию. Пользователи могут создавать доски для отдельных проектов. На этих досках они создают списки — с задачами, статусами и т. д. В каждом списке есть карточки для отдельных маленьких задач или, как в нашем случае, для багов.<br>По своей сути Trello — это способ организации заметок на стене в цифровом пространстве.<br>Плюсы:<br>Интуитивно понятный интерфейс позволяет легко настроить инструмент<br>Благодаря визуализации досок всем членам команды удобно отслеживать прогресс<br>Каждая карточка может содержать много разной информации, включая подробные описания багов, мультимедийные файлы, комментарии и обсуждения и т. д.<br>Пользователи могут назначать и переназначать задачи и управлять сроками их выполнения<br>Также можно отслеживать показатели производительности, просматривать историю и активность для каждой карточки<br>Trello поддерживает более 100 интеграций с другими инструментами, включая Confluence, Slack, Google Drive и Dropbox<br>Доступно мобильное приложение<br>Минусы:<br>Иногда в Trello невозможно загрузить изображения с высоким разрешением<br>Десктопные приложения работают только при подключении к Интернету<br>Техническая документация непонятна, поэтому процесс настройки многим кажется сложным<br>При использовании для крупных проектов доска становится сложной для навигации"
}
,{
  question: "Описать flow bug-а",
  answer: "1)Open/Backlog<br>2)In Progress<br>3)On Review<br>4)Resolved<br>5)In Shot / In Shot — OK<br>6)In Build / In Build — OK<br>7)On Production / On Production — OK / Closed"
}
,{
  question: "Open/Backlog",
  answer: "Итак, сначала тикет попадает в беклог новых тикетов со статусом Open. Далее лид компонента, увидев новый тикет на своём дашборде, принимает решение: назначить тикет прямо сейчас разработчику либо отправить его в беклог известных тикетов (статус Backlog), чтобы назначить его позже, когда появится свободный разработчик и более приоритетные тикеты будут закрыты. Это может показаться странным, так как кажется логичным делать наоборот: создавать тикеты в статусе Backlog, а потом переводить в статус Open. Но у нас прижилась именно эта схема. Она позволяет легко настроить фильтры, чтобы сократить время принятия решения по новым тикетам."
}
,{
  question: "In Progress",
  answer: "Работа над каждой задачей ведётся в отдельной Git-ветке. Насчёт этого у нас есть соглашение, что имя ветки в начале должно содержать номер тикета. Например, SRV-123_new_super_feature. Также комментари к каждому коммиту в ветку должны содержать номер тикета в формате [SRV-123]: {comment}. Такой формат необходим нам, например, для корректного удаления «плохой» задачи из билда.Когда тикет попадает на разработчика, первым делом он декомпозируется. Результатом декомпозиции является представление разработчика о способах решения задачи и о том, сколько времени займёт решение. После того как все основные детали выяснены, тикет переводится в статус In Progress, а разработчик начинает писать код."
}
,{
  question: "On Review",
  answer: "Написав код и самостоятельно убедившись, что все требования к задаче выполнены, а тесты не сломаны, разработчик назначает тикет ревьюверу (статус On Review). Обычно разработчик сам решает, кто будет ревьювить его тикет. Скорее всего, это будет другой разработчик, который отлично разбирается в нужной части кода. Ревью происходит с помощью инструмента Codeisok, который открывается сразу с нужным diff по клику на ссылку branchdiff в поле тикета Commits или на ссылку в виде хеша коммита в комментариях."
}
,{
  question: "Resolved",
  answer: "Далее, если ревью прошло успешно, тикет отправляется в беклог QA-инженеров в статусе Resolved. Но вместе с этим с помощью webhook на событие resolved в фоне запускаются автоматические тесты на коде ветки. Спустя несколько минут в тикете появится новый комментарий, который сообщит о результатах тестов."
}
,{
  question: "In Shot / In Shot — OK",
  answer: "Задача сначала тестируется в devel-окружении. Если всё хорошо, создаётся шот (например, кликом по ссылке Create shot в поле Commits) — директория на выделенном сервере, в которую копируются изменения из тикета, смёрженные с текущим master. Сервер работает с продакшен-данными: базы и сервисы те же, что обслуживают реальных пользователей. Таким образом, тестировщик может открыть web-сайт или подключиться к шоту с помощью мобильного клиента и «изолированно» проверить фичу в продакшен-окружении. «Изолированно» значит, что никакой другой код/функционал, кроме нового из ветки и текущего master, не исполняется. Поэтому этот этап тестирования является, пожалуй, основным, так как позволяет QA-инженеру максимально достоверно найти проблему непосредственно в тестируемой задаче.<br>Доступ к ресурсам шота осуществляется по специальным URL, которые генерируются в скрипте создания шота и с помощью API Jira помещаются в шапку тикета."
}
,{
  question: "In Build / In Build — OK",
  answer: "Мы выкладываем код два раза в день — утром и вечером. Для этого создаётся специальная build-ветка, которая в итоге будет слита с master и выложена «в бой».<br>В момент сборки build-ветки специальный скрипт с помощью JQL-запроса получает список тикетов в статусе In Shot — OK и пытается замёржить их в ветку билда при выполнении всех перечисленных ниже условий:<br>перевод для тикета закончен или переводить ничего не нужно (Lexems in ('No', 'Done'));разработчик присутствует на рабочем месте (система автоматического слияния проверяет по внутренней базе, не находится ли разработчик в отпуске или на больничном, и если да, то тикет может быть замёржен только вручную релиз-инженерами или другим ответственным разработчиком, который указан в специальном поле Vice Developer; лид отсутствующего разработчика в этом случае получает уведомление о том, что тикет не может быть автоматически добавлен в билд);у тикета не установлен флажок Up in Build в значение by Developer (это специальное кастомное поле тикета, которое даёт возможность разработчику самому определять, когда тикет попадёт в билд);ветка тикета не зависит от другой ветки, которая ещё не попала в master или текущий билд. Мы всячески стараемся избегать подобной ситуации, но иногда такое происходит, когда разработчик создаёт свою ветку не от master, а от ветки другого тикета, либо когда вмёрживает к себе чужую ветку. Это можно сделать в том числе и случайно, поэтому мы решили, что дополнительная защита не помешает.Стоит отметить, что автоматическое слияние может не произойти по причине конфликта слияния. В этом случае тикет автоматически переводится в статус Reopen и назначается разработчику, о чём он немедленно получает оповещение в HipChat, а в комментарий тикета добавляется соответствующее сообщение. После разрешения конфликта тикет возвращается в билд.<br>Если же всё хорошо и ветка тикета замёржилась в билд, тикет автоматически переводится в статус In Build, а в кастомное поле тикета Build_Name пишется название билда.<br>Далее, используя это значение, легко получить список тикетов, которые были выложены с каждым билдом. Например, для поиска виноватого, если что-то пошло не так.<br>На следующем этапе QA-инженеры дополнительно проверяют, корректно ли работает код задачи совместно с другими задачами в билде. Если всё хорошо, тикету вручную выставляется статус In Build — OK."
}
,{
  question: "On Production / On Production — OK / Closed",
  answer: "Далее на билде прогоняется весь наш набор тестов (Unit, интеграционные, Selenium- и т. д.). Если всё хорошо, билд мёржится в master, а код выкладывается на продакшен. Тикет переводится в статус On Production.<br>Далее разработчик (или заказчик) убеждается, что на продакшене фича работает корректно, и выставляет тикету статус On Production — OK.<br>Спустя две недели тикеты в статусе On Production — OK автоматически переводятся в статус Closed, если кто-то ранее не сделал это вручную.<br>Также стоит упомянуть дополнительные статусы, в которых может находится тикет:Requirements — когда не получается оперативно получить от заказчика необходимые уточнения по задаче, а без них дальнейшая работа по тикету невозможна, тикет переводится в этот статус и назначается тому, кто должен дать разъяснения;Suspended — если работа по тикету приостановлена, например, если разработчик заблокирован задачами смежной команды или был вынужден переключиться на более срочную задачу;Reopened — задача может быть переоткрыта на разработчика после ревью, после тестирования, после неудачной попытки слияния ветки с master."
}
,
    ];

    const questionText = document.getElementById('question-text');
    const answerText = document.getElementById('answer-text');
    const modal = document.getElementById('modal');
    const modalAnswer = document.getElementById('modal-answer');

    function toggleAnswer() {
        const answer = questions[currentQuestionIndex].answer;
        if (answer.length > MAX_ANSWER_LENGTH) {
            showModal(answer);
        } else {
            if (answerText.classList.contains('hidden')) {
                answerText.innerHTML = answer;
                answerText.classList.remove('hidden');
                questionText.classList.add('hidden');
            } else {
                answerText.classList.add('hidden');
                questionText.classList.remove('hidden');
            }
        }
    }

    function showModal(answer) {
        modalAnswer.innerHTML = answer;
        modal.classList.remove('hidden');
    }

    function showQuestion(index) {
        questionText.textContent = questions[index].question;
        answerText.innerHTML = ""; // Скрываем ответ при смене вопроса
        questionText.classList.remove('hidden');
        answerText.classList.add('hidden');
    }

    function nextQuestion() {
        if (currentQuestionIndex < questions.length - 1) {
            currentQuestionIndex++;
            showQuestion(currentQuestionIndex);
        }
    }

    function prevQuestion() {
        if (currentQuestionIndex > 0) {
            currentQuestionIndex--;
            showQuestion(currentQuestionIndex);
        }
    }

    function closeModal() {
        modal.classList.add('hidden');
    }

    showQuestion(currentQuestionIndex);
</script>

</body>
</html>
