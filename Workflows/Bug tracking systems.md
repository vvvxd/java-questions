Что собой представляет система отслеживания ошибок?

Инструменты отслеживания ошибок (системы баг-трекинга) предназначены для систематической регистрации багов и прочих проблем и удобного управления жизненным циклом бага.

Среднестатистическая баг-трекинговая система имеет следующий функционал:

создание тикетов с подробным описанием багов

классификация и расстановка приоритетов в тикетах

назначение тикетов конкретным специалистам

отслеживание статуса бага на разных этапах

удобный поиск, сортировка и составление баг-репортов

аналитика и автоматическое формирование репортов.

--------------------------------------------------------------------------------------------------------------------
Зачем нужна система отслеживания ошибок?

Баг-трекинговые системы упрощают отслеживание, классификацию и приоритизацию багов. Также они полезны для аналитики: с их помощью можно получить информацию, которая позволит повысить общую эффективность команды и потенциально оптимизировать затраты на разработку. К тому же баг-трекинговые системы упрощают коммуникацию между тестировщиками и разработчиками.

--------------------------------------------------------------------------------------------------------------------
JIRA

Инструмент отслеживания ошибок Jira был запущен в 2003 году. Со временем он превратился в систему управления проектами, широко используемую в agile-разработке. В частности, в Jira есть доски Scrum и Kanban, дорожные карты и многое другое.
Что касается баг-трекинга, Jira предоставляет полный набор необходимых функций.
Плюсы:
Пользователи могут создавать собственные фильтры и настраивать рабочие процессы
Есть удобная система тикетов, позволяющая легко следить за ходом выполнения задач
Доступ к отчетам с полезной информацией в режиме реального времени
Интеграция с более чем 3000 приложений обеспечивает прозрачность конвейера разработки
Jira идеально подходит для больших и удаленных команд
Есть мобильное приложение, позволяющее получить доступ к системе в любое время
Минусы:
Пользователи отмечают, что UI сбивает с толку и порой сложен для понимания
Функции репортов не учитывают все параметры, которые было бы полезно отслеживать
Jira может оказаться дорогой для небольших команд
Регистрация, настройка и устранение неполадок сложны

--------------------------------------------------------------------------------------------------------------------
TRELLO

Как и Jira, Trello — это продукт Atlassian. Он хорошо подходит и для отслеживания ошибок, и для управления продуктами в целом.
Изюминкой Trello является упор на визуализацию. Пользователи могут создавать доски для отдельных проектов. На этих досках они создают списки — с задачами, статусами и т. д. В каждом списке есть карточки для отдельных маленьких задач или, как в нашем случае, для багов.
По своей сути Trello — это способ организации заметок на стене в цифровом пространстве.
Плюсы:
Интуитивно понятный интерфейс позволяет легко настроить инструмент
Благодаря визуализации досок всем членам команды удобно отслеживать прогресс
Каждая карточка может содержать много разной информации, включая подробные описания багов, мультимедийные файлы, комментарии и обсуждения и т. д.
Пользователи могут назначать и переназначать задачи и управлять сроками их выполнения
Также можно отслеживать показатели производительности, просматривать историю и активность для каждой карточки
Trello поддерживает более 100 интеграций с другими инструментами, включая Confluence, Slack, Google Drive и Dropbox
Доступно мобильное приложение
Минусы:
Иногда в Trello невозможно загрузить изображения с высоким разрешением
Десктопные приложения работают только при подключении к Интернету
Техническая документация непонятна, поэтому процесс настройки многим кажется сложным
При использовании для крупных проектов доска становится сложной для навигации

--------------------------------------------------------------------------------------------------------------------
Описать flow bug-а

1)Open/Backlog
2)In Progress
3)On Review
4)Resolved
5)In Shot / In Shot — OK
6)In Build / In Build — OK
7)On Production / On Production — OK / Closed

--------------------------------------------------------------------------------------------------------------------
Open/Backlog

Итак, сначала тикет попадает в беклог новых тикетов со статусом Open. Далее лид компонента, увидев новый тикет на своём дашборде, принимает решение: назначить тикет прямо сейчас разработчику либо отправить его в беклог известных тикетов (статус Backlog), чтобы назначить его позже, когда появится свободный разработчик и более приоритетные тикеты будут закрыты. Это может показаться странным, так как кажется логичным делать наоборот: создавать тикеты в статусе Backlog, а потом переводить в статус Open. Но у нас прижилась именно эта схема. Она позволяет легко настроить фильтры, чтобы сократить время принятия решения по новым тикетам.

--------------------------------------------------------------------------------------------------------------------
In Progress

Работа над каждой задачей ведётся в отдельной Git-ветке. Насчёт этого у нас есть соглашение, что имя ветки в начале должно содержать номер тикета. Например, SRV-123_new_super_feature. Также комментари к каждому коммиту в ветку должны содержать номер тикета в формате [SRV-123]: {comment}. Такой формат необходим нам, например, для корректного удаления «плохой» задачи из билда.

Когда тикет попадает на разработчика, первым делом он декомпозируется. Результатом декомпозиции является представление разработчика о способах решения задачи и о том, сколько времени займёт решение. После того как все основные детали выяснены, тикет переводится в статус In Progress, а разработчик начинает писать код.

--------------------------------------------------------------------------------------------------------------------
On Review

Написав код и самостоятельно убедившись, что все требования к задаче выполнены, а тесты не сломаны, разработчик назначает тикет ревьюверу (статус On Review). Обычно разработчик сам решает, кто будет ревьювить его тикет. Скорее всего, это будет другой разработчик, который отлично разбирается в нужной части кода. Ревью происходит с помощью инструмента Codeisok, который открывается сразу с нужным diff по клику на ссылку branchdiff в поле тикета Commits или на ссылку в виде хеша коммита в комментариях.

--------------------------------------------------------------------------------------------------------------------
Resolved

Далее, если ревью прошло успешно, тикет отправляется в беклог QA-инженеров в статусе Resolved. Но вместе с этим с помощью webhook на событие resolved в фоне запускаются автоматические тесты на коде ветки. Спустя несколько минут в тикете появится новый комментарий, который сообщит о результатах тестов.

--------------------------------------------------------------------------------------------------------------------
In Shot / In Shot — OK

Задача сначала тестируется в devel-окружении. Если всё хорошо, создаётся шот (например, кликом по ссылке Create shot в поле Commits) — директория на выделенном сервере, в которую копируются изменения из тикета, смёрженные с текущим master. Сервер работает с продакшен-данными: базы и сервисы те же, что обслуживают реальных пользователей. Таким образом, тестировщик может открыть web-сайт или подключиться к шоту с помощью мобильного клиента и «изолированно» проверить фичу в продакшен-окружении. «Изолированно» значит, что никакой другой код/функционал, кроме нового из ветки и текущего master, не исполняется. Поэтому этот этап тестирования является, пожалуй, основным, так как позволяет QA-инженеру максимально достоверно найти проблему непосредственно в тестируемой задаче.
Доступ к ресурсам шота осуществляется по специальным URL, которые генерируются в скрипте создания шота и с помощью API Jira помещаются в шапку тикета.

--------------------------------------------------------------------------------------------------------------------
In Build / In Build — OK

Мы выкладываем код два раза в день — утром и вечером. Для этого создаётся специальная build-ветка, которая в итоге будет слита с master и выложена «в бой».
В момент сборки build-ветки специальный скрипт с помощью JQL-запроса получает список тикетов в статусе In Shot — OK и пытается замёржить их в ветку билда при выполнении всех перечисленных ниже условий:
перевод для тикета закончен или переводить ничего не нужно (Lexems in ('No', 'Done'));

разработчик присутствует на рабочем месте (система автоматического слияния проверяет по внутренней базе, не находится ли разработчик в отпуске или на больничном, и если да, то тикет может быть замёржен только вручную релиз-инженерами или другим ответственным разработчиком, который указан в специальном поле Vice Developer; лид отсутствующего разработчика в этом случае получает уведомление о том, что тикет не может быть автоматически добавлен в билд);

у тикета не установлен флажок Up in Build в значение by Developer (это специальное кастомное поле тикета, которое даёт возможность разработчику самому определять, когда тикет попадёт в билд);

ветка тикета не зависит от другой ветки, которая ещё не попала в master или текущий билд. Мы всячески стараемся избегать подобной ситуации, но иногда такое происходит, когда разработчик создаёт свою ветку не от master, а от ветки другого тикета, либо когда вмёрживает к себе чужую ветку. Это можно сделать в том числе и случайно, поэтому мы решили, что дополнительная защита не помешает.

Стоит отметить, что автоматическое слияние может не произойти по причине конфликта слияния. В этом случае тикет автоматически переводится в статус Reopen и назначается разработчику, о чём он немедленно получает оповещение в HipChat, а в комментарий тикета добавляется соответствующее сообщение. После разрешения конфликта тикет возвращается в билд.
Если же всё хорошо и ветка тикета замёржилась в билд, тикет автоматически переводится в статус In Build, а в кастомное поле тикета Build_Name пишется название билда.
Далее, используя это значение, легко получить список тикетов, которые были выложены с каждым билдом. Например, для поиска виноватого, если что-то пошло не так.
На следующем этапе QA-инженеры дополнительно проверяют, корректно ли работает код задачи совместно с другими задачами в билде. Если всё хорошо, тикету вручную выставляется статус In Build — OK.

--------------------------------------------------------------------------------------------------------------------
On Production / On Production — OK / Closed

Далее на билде прогоняется весь наш набор тестов (Unit, интеграционные, Selenium- и т. д.). Если всё хорошо, билд мёржится в master, а код выкладывается на продакшен. Тикет переводится в статус On Production.
Далее разработчик (или заказчик) убеждается, что на продакшене фича работает корректно, и выставляет тикету статус On Production — OK.
Спустя две недели тикеты в статусе On Production — OK автоматически переводятся в статус Closed, если кто-то ранее не сделал это вручную.
Также стоит упомянуть дополнительные статусы, в которых может находится тикет:

Requirements — когда не получается оперативно получить от заказчика необходимые уточнения по задаче, а без них дальнейшая работа по тикету невозможна, тикет переводится в этот статус и назначается тому, кто должен дать разъяснения;

Suspended — если работа по тикету приостановлена, например, если разработчик заблокирован задачами смежной команды или был вынужден переключиться на более срочную задачу;

Reopened — задача может быть переоткрыта на разработчика после ревью, после тестирования, после неудачной попытки слияния ветки с master.

--------------------------------------------------------------------------------------------------------------------