### 1. Что такое JMS?

JMS — это API, входящий в состав платформы Java EE, который обеспечивает стандартный способ отправки, получения и обработки сообщений между приложениями. Он был разработан для упрощения интеграции распределённых систем, где компоненты могут работать асинхронно, то есть отправитель и получатель сообщений не обязаны быть активными одновременно.

#### Основные характеристики JMS:
- **Асинхронность**: Отправитель сообщения не ждёт немедленного ответа от получателя. Сообщения могут храниться в брокере до их обработки.
- **Надёжность**: JMS поддерживает гарантированную доставку сообщений, транзакции и обработку ошибок.
- **Гибкость**: JMS работает с различными брокерами сообщений, что делает его универсальным.
- **Интеграция**: Используется для связи между Java-приложениями и другими системами, включая не-Java платформы.

#### Асинхронный vs Синхронный обмен сообщениями:
- **Асинхронный**: Отправитель посылает сообщение в очередь или тему и продолжает работу, не дожидаясь обработки. Получатель обрабатывает сообщение позже. Пример: отправка email, где отправитель не ждёт, пока получатель прочтёт письмо.
- **Синхронный**: Отправитель ждёт ответа от получателя (например, как в HTTP-запросах). JMS ориентирован именно на асинхронный подход, хотя поддерживает и синхронное получение сообщений через методы `receive()`.

---

### 2. Модели обмена сообщениями

JMS поддерживает две основные модели обмена сообщениями: **Point-to-Point (P2P)** и **Publish/Subscribe (Pub/Sub)**.

#### 2.1. Point-to-Point (P2P)
- **Описание**: В этой модели сообщения отправляются в очередь (**Queue**), и каждое сообщение предназначено для одного получателя. Даже если на очередь подписано несколько потребителей, сообщение будет доставлено только одному из них.
- **Характеристики**:
  - Сообщения хранятся в очереди до тех пор, пока их не заберёт потребитель.
  - Гарантируется доставка сообщения ровно одному потребителю.
  - Подходит для задач, где требуется обработка сообщений по принципу "один отправитель — один получатель".
- **Пример использования**: Обработка заказов в интернет-магазине. Заказ отправляется в очередь, и один из обработчиков (например, складская система) забирает его для выполнения.

#### 2.2. Publish/Subscribe (Pub/Sub)
- **Описание**: В этой модели сообщения отправляются в тему (**Topic**), и все подписчики на эту тему получают копию сообщения. Это модель "один ко многим".
- **Характеристики**:
  - Сообщения доставляются всем активным подписчикам темы в момент отправки.
  - Если подписчик не активен, он может пропустить сообщение, если не настроена "прочная подписка" (Durable Subscription).
  - Подходит для сценариев, где нужно уведомить множество систем о событии.
- **Пример использования**: Рассылка новостей или обновлений о ценах акций. Все подписчики (например, трейдеры) получают одно и то же сообщение.

#### Прочная подписка (Durable Subscription)
- В модели Pub/Sub по умолчанию сообщения доставляются только активным подписчикам. Если подписчик временно отключён, он пропустит сообщения.
- Прочная подписка позволяет сохранять сообщения для подписчика, даже если он не активен. Когда подписчик подключается, он получает все пропущенные сообщения.

---

### 3. Основные компоненты JMS

JMS состоит из нескольких ключевых компонентов, которые взаимодействуют для реализации обмена сообщениями. Рассмотрим их подробно:

#### 3.1. JMS Provider
- **Описание**: Это сервер (брокер сообщений), который реализует спецификацию JMS и управляет доставкой сообщений. Примеры: Apache ActiveMQ, RabbitMQ (с JMS-адаптером), IBM MQ, Apache Kafka (с JMS-обёрткой).
- **Роль**: Хранит сообщения, маршрутизирует их между отправителями и получателями, обеспечивает транзакции и надёжность.
- **Примечание**: JMS — это только API, а провайдер — это конкретная реализация, которая может быть настроена для высокой доступности, кластеризации и т.д.

#### 3.2. Connection Factory
- **Описание**: Объект, используемый для создания соединения с JMS-провайдером. Обычно настраивается через JNDI (Java Naming and Directory Interface).
- **Пример**: `QueueConnectionFactory` для P2P или `TopicConnectionFactory` для Pub/Sub.
- **Роль**: Служит точкой входа для взаимодействия с брокером. Через неё создаются соединения (`Connection`).

#### 3.3. Destination
- **Описание**: Место, куда отправляются сообщения или откуда они получаются. Это может быть:
  - **Queue**: Для модели P2P.
  - **Topic**: Для модели Pub/Sub.
- **Пример**: Очередь с именем `orderQueue` или тема с именем `stockPriceTopic`.
- **Роль**: Определяет, куда отправлять сообщения и откуда их забирать.

#### 3.4. Message
- **Описание**: Основной объект, который передаётся между системами. Сообщение состоит из:
  - **Заголовок (Header)**: Содержит метаданные, такие как `JMSMessageID`, `JMSDestination`, `JMSPriority`, `JMSTimestamp`.
  - **Свойства (Properties)**: Пользовательские метаданные (ключ-значение), которые можно добавлять для фильтрации или дополнительной логики.
  - **Тело (Body)**: Полезная нагрузка сообщения.
- **Типы сообщений**:
  - `TextMessage`: Для текстовых данных (например, JSON, XML).
  - `ObjectMessage`: Для сериализуемых Java-объектов.
  - `BytesMessage`: Для передачи байтовых массивов.
  - `StreamMessage`: Для потока примитивных данных.
  - `MapMessage`: Для набора пар ключ-значение.
  - `Message`: Пустое сообщение, содержащее только заголовок и свойства.
- **Пример**: `TextMessage` может содержать JSON-строку с информацией о заказе.

#### 3.5. Connection
- **Описание**: Соединение между Java-приложением и JMS-провайдером. Создаётся через `ConnectionFactory`.
- **Роль**: Управляет физическим соединением с брокером. Обычно одно соединение используется для множества сессий.

#### 3.6. Session
- **Описание**: Объект, создаваемый через `Connection`, который предоставляет контекст для отправки и получения сообщений.
- **Характеристики**:
  - Поддерживает транзакции (если включены).
  - Может быть настроена на автоматическое подтверждение сообщений (`AUTO_ACKNOWLEDGE`), клиентское подтверждение (`CLIENT_ACKNOWLEDGE`) или дублированное подтверждение (`DUPS_OK_ACKNOWLEDGE`).
- **Роль**: Создаёт объекты `MessageProducer`, `MessageConsumer` и управляет транзакциями.

#### 3.7. MessageProducer
- **Описание**: Объект для отправки сообщений в `Destination` (очередь или тему).
- **Роль**: Настраивает параметры сообщения (например, приоритет, время жизни) и отправляет его в брокер.

#### 3.8. MessageConsumer
- **Описание**: Объект для получения сообщений из `Destination`.
- **Роль**: Может работать в синхронном режиме (через `receive()`) или асинхронном (через `MessageListener`).

---

### 4. Взаимодействие компонентов

Вот как компоненты JMS взаимодействуют в типичном сценарии:

1. **Инициализация**:
  - Приложение получает `ConnectionFactory` и `Destination` через JNDI.
  - Через `ConnectionFactory` создаётся `Connection`.

2. **Создание сессии**:
  - Через `Connection` создаётся `Session` с указанием, использовать ли транзакции и какой режим подтверждения.

3. **Отправка сообщения**:
  - Создаётся `MessageProducer` для конкретного `Destination`.
  - Формируется сообщение (например, `TextMessage`).
  - Сообщение отправляется через `MessageProducer`.

4. **Получение сообщения**:
  - Создаётся `MessageConsumer` для того же `Destination`.
  - Сообщение либо запрашивается синхронно (`receive()`), либо обрабатывается асинхронно через `MessageListener`.

5. **Закрытие соединений**:
  - После завершения работы закрываются `Session` и `Connection`.


---

### 1. JMS API

JMS API предоставляет набор интерфейсов и классов для взаимодействия с брокерами сообщений. Основные компоненты и методы API позволяют отправлять, получать и обрабатывать сообщения. Рассмотрим ключевые элементы:

#### 1.1. Основные интерфейсы и классы
JMS API включает следующие ключевые интерфейсы, определённые в пакете `javax.jms`:

- **Connection**:
  - Интерфейс для создания соединения с JMS-провайдером (брокером сообщений).
  - Создаётся через `ConnectionFactory`.
  - Основные методы:
    - `createSession(boolean transacted, int acknowledgeMode)`: Создаёт сессию.
    - `start()`: Запускает доставку сообщений.
    - `stop()`: Приостанавливает доставку.
    - `close()`: Закрывает соединение.
  - Пример: `Connection connection = connectionFactory.createConnection();`

- **Session**:
  - Контекст для отправки и получения сообщений.
  - Создаётся через `Connection`.
  - Основные методы:
    - `createProducer(Destination destination)`: Создаёт отправителя сообщений.
    - `createConsumer(Destination destination)`: Создаёт получателя сообщений.
    - `createQueue(String queueName)` / `createTopic(String topicName)`: Создаёт очередь или тему.
    - `commit()` / `rollback()`: Управление транзакциями (для транзакционных сессий).
    - `close()`: Закрывает сессию.
  - Пример: `Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);`

- **MessageProducer**:
  - Интерфейс для отправки сообщений в `Destination` (очередь или тему).
  - Основные методы:
    - `send(Message message)`: Отправляет сообщение.
    - `setDeliveryMode(int deliveryMode)`: Устанавливает режим доставки (PERSISTENT или NON_PERSISTENT).
    - `setPriority(int priority)`: Устанавливает приоритет сообщения (0–9).
    - `setTimeToLive(long timeToLive)`: Устанавливает время жизни сообщения (в миллисекундах).
  - Пример: `producer.send(session.createTextMessage("Hello, JMS!"));`

- **MessageConsumer**:
  - Интерфейс для получения сообщений из `Destination`.
  - Основные методы:
    - `receive()`: Синхронное получение сообщения (блокирует поток до получения).
    - `receive(long timeout)`: Ожидает сообщение с таймаутом.
    - `receiveNoWait()`: Немедленное получение (не блокирует).
    - `setMessageListener(MessageListener listener)`: Устанавливает асинхронный обработчик сообщений.
  - Пример: `Message message = consumer.receive(1000);`

- **Destination**:
  - Абстрактный интерфейс, представляющий цель сообщения (очередь или тему).
  - Реализуется через `Queue` (для P2P) или `Topic` (для Pub/Sub).
  - Пример: `Queue queue = session.createQueue("myQueue");`

- **Message**:
  - Интерфейс для сообщений, содержащих заголовок, свойства и тело.
  - Основные методы:
    - `getJMSMessageID()`: Возвращает уникальный идентификатор сообщения.
    - `setStringProperty(String name, String value)`: Устанавливает пользовательское свойство.
    - `getStringProperty(String name)`: Получает значение свойства.
  - Конкретные реализации зависят от типа сообщения (см. ниже).

#### 1.2. Ключевые методы для работы с сообщениями
- **send()**: Используется `MessageProducer` для отправки сообщения в `Destination`. Поддерживает настройку параметров, таких как приоритет или режим доставки:
  ```java
  producer.send(message, DeliveryMode.PERSISTENT, 4, 60000); // PERSISTENT, приоритет 4, TTL 60 сек
  ```

- **receive()**: Используется `MessageConsumer` для синхронного получения сообщений. Варианты:
  - `receive()`: Блокирует поток, пока не получит сообщение.
  - `receive(long timeout)`: Ждёт указанное время.
  - `receiveNoWait()`: Проверяет наличие сообщения без ожидания.

- **setMessageListener()**: Позволяет настроить асинхронную обработку сообщений. Реализуется через интерфейс `MessageListener`:
  ```java
  consumer.setMessageListener(message -> {
      try {
          System.out.println("Получено: " + ((TextMessage) message).getText());
      } catch (JMSException e) {
          e.printStackTrace();
      }
  });
  ```

---

### 3. Транзакции

JMS поддерживает транзакции для обеспечения атомарности операций отправки и получения сообщений.

#### 3.1. Транзакционная сессия
- Транзакционная сессия создаётся с параметром `transacted = true`:
  ```java
  Session session = connection.createSession(true, Session.SESSION_TRANSACTED);
  ```
- В транзакционной сессии все операции (отправка и получение) буферизируются до вызова `commit()`.

#### 3.2. Commit и Rollback
- **commit()**: Подтверждает все операции в сессии (например, отправленные сообщения становятся доступны, а полученные — подтверждены).
- **rollback()**: Отменяет все операции в сессии (отправленные сообщения не доставляются, а полученные остаются в очереди/теме).

Пример транзакционной отправки:
```java
Session session = connection.createSession(true, Session.SESSION_TRANSACTED);
MessageProducer producer = session.createProducer(queue);
TextMessage message = session.createTextMessage("Order 123");
try {
    producer.send(message);
    session.commit(); // Сообщение отправлено
} catch (JMSException e) {
    session.rollback(); // Откат при ошибке
}
```

#### 3.3. Транзакции в получении
- Если потребитель получает сообщение в транзакционной сессии, оно не считается обработанным, пока не вызван `commit()`. Если вызван `rollback()`, сообщение возвращается в очередь/тему.
- Пример:
  ```java
  MessageConsumer consumer = session.createConsumer(queue);
  Message message = consumer.receive();
  try {
      // Обработка сообщения
      session.commit(); // Подтверждение
  } catch (Exception e) {
      session.rollback(); // Сообщение остаётся в очереди
  }
  ```

---

### 4. Надёжность доставки

JMS предоставляет механизмы для управления надёжностью доставки сообщений.

#### 4.1. DeliveryMode
- **PERSISTENT**:
  - Сообщения сохраняются в постоянное хранилище брокера (например, на диск).
  - Гарантируется доставка даже при сбое брокера.
  - Более медленная отправка из-за записи на диск.
  - Пример: `producer.setDeliveryMode(DeliveryMode.PERSISTENT);`
- **NON_PERSISTENT**:
  - Сообщения хранятся в памяти и могут быть потеряны при сбое брокера.
  - Быстрее, но менее надёжно.
  - Пример: `producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);`

#### 4.2. Подтверждения (Acknowledgments)
JMS поддерживает три режима подтверждения в нетранзакционных сессиях:
- **AUTO_ACKNOWLEDGE**:
  - Брокер автоматически подтверждает получение сообщения после его доставки.
  - Используется по умолчанию для нетранзакционных сессий.
  - Пример: `Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);`
- **CLIENT_ACKNOWLEDGE**:
  - Клиент вручную подтверждает получение сообщения через `message.acknowledge()`.
  - Если подтверждение не вызвано, сообщение может быть доставлено повторно.
  - Пример:
    ```java
    Message message = consumer.receive();
    // Обработка
    message.acknowledge(); // Подтверждение
    ```
- **DUPS_OK_ACKNOWLEDGE**:
  - Подтверждение происходит автоматически, но с возможностью дублирования сообщений.
  - Оптимизирован для производительности, но менее строг в плане надёжности.

---

### 5. Селекторы сообщений

Селекторы сообщений позволяют фильтровать сообщения на основе их свойств или заголовков, используя SQL-подобный синтаксис.

#### 5.1. Как работают селекторы
- Селектор задаётся при создании `MessageConsumer`:
  ```java
  MessageConsumer consumer = session.createConsumer(queue, "priority > 5 AND category = 'urgent'");
  ```
- Селектор фильтрует сообщения на стороне брокера, что уменьшает нагрузку на клиент.

#### 5.2. Синтаксис селекторов
- Основан на подмножестве SQL-92.
- Используются свойства сообщения (`setStringProperty`, `setIntProperty` и т.д.) и заголовки (например, `JMSPriority`).
- Примеры условий:
  - `JMSPriority > 5`
  - `category = 'urgent'`
  - `price BETWEEN 100 AND 500`
  - `orderId IS NOT NULL`

#### 5.4. Преимущества селекторов
- **Эффективность**: Фильтрация происходит на стороне брокера, что снижает нагрузку на клиент.
- **Гибкость**: Позволяет обрабатывать только релевантные сообщения, игнорируя остальные.
- **Примеры сценариев**:
  - Фильтрация заказов по приоритету в системе обработки заказов.
  - Получение только определённых типов уведомлений в Pub/Sub-модели.

#### 5.5. Ограничения селекторов
- Селекторы увеличивают нагрузку на брокер, так как ему приходится анализировать свойства каждого сообщения.
- Сложные селекторы могут замедлить обработку, особенно при большом количестве сообщений.
- Поддерживаемые операторы ограничены стандартом SQL-92 (например, нет поддержки сложных регулярных выражений).

