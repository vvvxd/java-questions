Что такое AMQP?

AMQP (Advanced Message Queuing Protocol) — открытый протокол для обмена сообщениями между системами через брокер, обеспечивающий
маршрутизацию, доставку и подписку на сообщения.

Ключевые понятия:

- **Exchange (обменник)**: принимает сообщения и распределяет их в очереди по правилам привязки (binding).
- **Queue (очередь)**: хранит сообщения и передает их потребителям (consumers).
- **Binding (привязка)**: определяет, в какую очередь направлять сообщения от обменника.

Работает поверх TCP/IP.

--------------------------------------------------------------------------------------------------------------------

Что такое RabbitMQ?

**RabbitMQ** — это брокер сообщений с открытым исходным кодом, реализующий протокол AMQP и дополняющий его. Он обеспечивает маршрутизацию
сообщений от издателя (producer) к получателю через брокер. Издатель отправляет сообщения в обменник (exchange), который по правилам
привязки (binding) направляет их в очереди (queue) для последующей обработки потребителями (consumers).

- **Поддержка протоколов**: AMQP, MQTT, STOMP и др. для разных сценариев.
- **Гибкая маршрутизация**: несколько типов обменников для точной маршрутизации сообщений.
- **Хранение сообщений**: сообщения хранятся до получения и подтверждения клиентом, затем удаляются (в отличие от Kafka, где данные хранятся
  дольше).
- **Приоритезация очередей**: поддержка приоритетов сообщений.
- **Удобный интерфейс**: простой UI для управления брокером.

RabbitMQ подходит для задач, требующих гибкой маршрутизации и временного хранения сообщений.

--------------------------------------------------------------------------------------------------------------------

Какие проблемы решает система очередей?

Система очередей решает следующие проблемы в микросервисной архитектуре:

1. **Разделение компонентов (Decoupling)**:  
   Очереди минимизируют зависимости между микросервисами. Сообщения — это массивы байтов с метаданными, что позволяет компонентам на разных
   языках и платформах взаимодействовать через брокер, который лишь маршрутизирует данные.

2. **Масштабируемость**:  
   Очереди упрощают независимое масштабирование сервисов. Нагрузка распределяется, а новые экземпляры или сервисы подключаются к очередям с
   минимальным простоем. Однако очереди сами требуют масштабирования.

3. **Балансировка нагрузки**:  
   Брокер автоматически распределяет сообщения между потребителями очереди по заданной стратегии, выступая встроенным балансировщиком
   нагрузки.

4. **Надежность**:  
   Сбой одного компонента не ломает систему — сообщения остаются в очереди и обрабатываются после восстановления. Но очередь может стать
   единым местом отказа (SPoF), что требует резервирования.

5. **Безопасность**:  
   Брокеры поддерживают аутентификацию и шифрование сообщений (в сети и хранилище), снимая с сервисов задачу организации авторизации.

Очереди сообщений повышают автономность, гибкость и устойчивость системы, но требуют продуманного управления.

--------------------------------------------------------------------------------------------------------------------

Какие проблемы привносит система очередей?

Внедрение очередей сообщений, несмотря на их преимущества, связано с рядом сложностей:

1. **Дополнительная инфраструктура**:  
   Очереди — это отдельная система, требующая покупки/установки, настройки и обслуживания, что увеличивает потребность в ресурсах.

2. **Единая точка отказа (SPoF)**:  
   Сбой брокера может остановить взаимодействующие системы. Необходимы меры резервного копирования и отказоустойчивости.

3. **Сложность отладки**:  
   С ростом числа очередей усложняется трассировка ошибок. В отличие от синхронной обработки, где иерархия вызовов очевидна, в очередях
   требуется система трассировки для связи этапов обработки запроса.

4. **Стратегии доставки сообщений**:
    - **At-least-once**: риск дублирования сообщений.
    - **At-most-once**: риск потери сообщений.
    - **Exactly-once**: сложная реализация, требует дополнительных проверок на стороне получателя.  
      Выбор стратегии и мониторинг усложняют разработку и эксплуатацию.

Очереди требуют тщательного планирования, мониторинга и управления для минимизации этих проблем.

--------------------------------------------------------------------------------------------------------------------

В каких случаях очереди неэффективны?

Очереди сообщений не всегда эффективны. Их использование неоправданно в следующих случаях:

1. **Простая архитектура**:  
   Если приложение небольшое, не ожидается его роста, добавление очередей усложняет систему. Настройка, поддержка и мониторинг требуют
   ресурсов, а Managed-решения могут быть экономически нецелесообразны. Очереди должны упрощать архитектуру, а не усложнять её.

2. **Монолитное ПО**:  
   Если декомпозиция на микросервисы не планируется, а развязка не приоритетна, асинхронность проще реализовать через многопоточность.
   Очереди избыточны, пока нет необходимости в разделении на автономные компоненты.

--------------------------------------------------------------------------------------------------------------------

Опишите кратко работу RabbitMQ

1. **Publisher** отправляет сообщение в **Exchange**.
2. **Exchange** маршрутизирует сообщение в одну или несколько **очередей** согласно правилам **привязки** (binding).
3. **Queue** хранит **ссылку** на сообщение, само сообщение сохраняется в оперативной памяти или на диске.
4. Когда **потребитель** готов, сервер создает **копию** сообщения по ссылке и отправляет её.
5. **Publisher** получает сообщение и отправляет **подтверждение** брокеру.
6. **Брокер**, получив подтверждение, удаляет копию сообщения из очереди, а затем само сообщение из памяти или с диска.

--------------------------------------------------------------------------------------------------------------------

Что такое RPC?

Процесс **RPC (Remote Procedure Call)** является основой взаимодействия с ядром **RabbitMQ** в рамках протокола **AMQP**.

- **Начальная настройка**:  
  Процесс RPC используется, например, при установлении соединения клиента с RabbitMQ. Клиент и сервер обмениваются командами (
  например, `Connection.Start`), чтобы согласовать параметры взаимодействия. После завершения этой последовательности RabbitMQ готов
  принимать запросы от клиента.

- **Команды в AMQP**:  
  В спецификации AMQP и клиент, и сервер могут инициировать команды, представляющие собой вызовы методов определённых классов (
  например, `Connection.Start` — метод `Start` класса `Connection`). Это обеспечивает двустороннее взаимодействие, где клиент ожидает ответа
  сервера на свои команды, а сервер может инициировать команды для клиента.

Таким образом, RPC в RabbitMQ обеспечивает структурированное взаимодействие между клиентом и сервером через команды, организованные в классы
и методы.

--------------------------------------------------------------------------------------------------------------------

Подключение и каналы в RabbitMQ

Для обмена информацией между клиентом и сервером в рамках одного подключения используются изолированные каналы. Они позволяют выполнять
команды параллельно (мультиплексирование), так как в синхронном режиме один канал блокируется до получения ответа. Каждый канал является
отдельным процессом и потребляет память, поэтому большое их число увеличивает нагрузку на RabbitMQ.

--------------------------------------------------------------------------------------------------------------------

Где используется RabbitMQ?

*   **Фоновая обработка:** Выполнение долгих задач (обработка изображений, рассылка почты) без блокировки пользователя.
*   **Буферизация и пакетная обработка:** Временное хранение данных для эффективной массовой вставки (например, в БД), когда производитель данных работает быстрее потребителя.
*   **Отложенные задачи:** Возможность запланировать выполнение задачи на будущее (например, для льготных периодов отмены заказа).
*   **Сглаживание пиковых нагрузок:** Очередь выступает буфером при резком росте трафика, предотвращая потерю данных и позволяя обработать их позже.
*   **Гарантированная доставка:** Обеспечение доставки сообщений в нестабильных сетях, как только появляется соединение.
*   **Упорядочивание операций:** Использование FIFO-очередей для сохранения последовательности выполнения транзакций (например, заказов).
*   **Сбор аналитики:** Сбор некритичной информации (статистики) для последующей офлайн-обработки.
*   **Распараллеливание задач:** Разбиение одной большой задачи на множество мелких для одновременного выполнения на разных обработчиках.
* 
--------------------------------------------------------------------------------------------------------------------

Какие остовные сущности RabbitMQ?

Пробежимся по названиям слева направо:
Publisher — публикует (паблишит) сообщения в Rabbit.
Exchange — обменник. Сущность Rabbit, точка входа для публикации всех сообщений.
Binding — связь между Exchange и очередью.
Queue — очередь для хранения сообщений.
Messages — сообщение, атомарная сущность.
Consumer — подписывается на очередь и получает от Rabbit сообщения.

Также встречаются термины:
Publishing — процесс публикования сообщений в обменник.
Consuming — процесс подписывания consumer ***на очередь и получение им сообщений.
Routing Key — свойство Binding.
Persistent — свойство сохранения данных при перезагрузке сервиса (также известное как стейт).

--------------------------------------------------------------------------------------------------------------------

Что такое Exchange?

Exchange — обменник или точка обмена.Является точкой входа и маршрутизатором/роутером всех сообщений (как входящих от Publisher, так и перемещающихся от внутренних процессов в Rabbit). В него отправляются сообщения. Exchange распределяет сообщение в одну или несколько очередей. Он маршрутизирует сообщения в очередь на основе созданных связей (bindings) между ним и очередью.

Неизменяемая сущность: для изменения параметров Exchange нужно его удалять и декларировать заново.

Binding: не являются частью Exchange, можно менять отдельно.

Рассылает сообщение во все очереди с подходящими binding (но не более одного сообщения в одну очередь, если есть несколько подходящих binding).

Durable/Transient — признак персистентности Exchange. Durable означает, что exchange сохранится после перезагрузки Rabbit.

Exchange не подразумевает хранения! Это не очередь. Если маршрут для сообщения не будет найден, сообщение сразу будет отброшено без возможности его восстановления.

Exchange не является Erlang-процессом. Из соображений масштабируемости exchange — это строка (ссылка на модуль с кодом, где лежит логика маршрутизации) во встроенной базе данных mnesia. 1 тысяч обменников будут потреблять всего 1МБ памяти.

--------------------------------------------------------------------------------------------------------------------

Для чего используется Direct Exchange

Direct exchange — используется, когда нужно доставить сообщение в определенные очереди. 
Сообщение публикуется в обменник с определенным ключом маршрутизации и попадает во все очереди, которые связаны с этим обменником аналогичным ключом маршрутизации (в которых Routing Key binding полностью совпадает с Routing Key Messages).
Ключ маршрутизации — это строка. Поиск соответствия происходит при помощи проверки строк на эквивалентность.

В rabbitmq существует понятие обменник по умолчанию. Это direct exchange без имени. Если применяется обменник по умолчанию, то сообщение будет маршрутизироваться в очередь с именем равным ключу маршрутизации сообщения.

Наиболее популярный тип, по скорости сравнимый с fanout (на тестах не увидел разницы) и при этом обладающий необходимой гибкостью для большинства задач.

--------------------------------------------------------------------------------------------------------------------

Для чего используется Topic Exchange

Topic exchange - аналогично direct exchange дает возможность осуществления выборочной маршрутизации путем сравнения ключа маршрутизации. Но, в данном случае, ключ задается по шаблону. При создании шаблона используются 0 или более слов (буквы AZ и az и цифры 0-9), разделенных точкой, а также символы * и #.
* — может быть заменен на ровно 1 слово
# — может быть заменен на 0 или более слов

Начиная с версии RabbitMQ 2.4.0 алгоритм маршрутизации для topic exchange стал работать до 145 раз быстрее. Добились они этого путем внедрения подхода trie implementation, который подразумевает представление шаблонов в виде структуры дерева.
Поиск соответствия шаблону осуществляется, начиная с корня и следуя сверху вниз.

Особенности:
применение этого обменника может стать хорошим выбором для возможного будущего развития приложения, т.к. шаблоны всегда можно настроить так, чтобы сообщение публиковалось аналогично direct exchange или fanout exchange

шаблоны, которые используют * намного быстрее, чем шаблоны, которые используют #.

topic exchange медленнее direct exchange

Производительность топика на тестах показала скорости в три раза ниже fanaut/direct — не более 5000-10000mps

--------------------------------------------------------------------------------------------------------------------

Для чего используется Fanout Exchange

Fanout exchange - все сообщения доставляются во все очереди даже если в сообщении задан ключ маршрутизации.

Особенности:
RabbitMQ не работает с ключами маршрутизации и шаблонами что положительно влияет на
производительность. Это самый быстрый exchange;

все потребители должны иметь возможность обрабатывать все сообщения;

Самый простой тип и наименее функциональный. Редко бывает нужен. По скоростям выдает на тестах около 30000mps, но столько же выдает и тип Direct.

--------------------------------------------------------------------------------------------------------------------

Для чего используется Headers Exchange?

Headers exchange — направляет сообщения в связанные очереди на основе сравнения пар (ключ, значение) свойства headers привязки и аналогичного свойства сообщения. Наиболее гибкий, но наименее производительный тип. Скорости очень сильно зависят от сложности условий и поэтому трудно прогнозируемы. Оперирует не Routing key, а заголовками сообщений и binding. В binding указываются ожидаемые заголовки, а также признак x-match. headers представляет собой Dictionary<ключ, значение>.

Если в словарь добавить специальный ключ x-match со значением any, то сообщение маршрутизируется при частичном совпадении пар (ключ, значение). Данное поведение аналогично оператору or.
По умолчанию ключ x-match содержит значение all. Это означает, что сообщение маршрутизируется при полном совпадении пар (ключ, значение). Данное поведение аналогично оператору and.

Особенности:
дополнительная гибкость
дополнительные накладные расходы на вычисление. Все пары (ключ, значение) атрибута headers должны сортироваться по имени ключа перед вычислением значений маршрутизации сообщения. Медленнее, чем прочие типы exchange.

--------------------------------------------------------------------------------------------------------------------

Для чего используется Consistent-Hashing Exchange?

Данный обменник является плагином и не встроен в RabbitMQ.
Consistent-hashing exchange (exchange с согласованным хешированием) - используется, когда есть несколько очередей, являющихся потенциальными получателями сообщения, и когда нужно сбалансировать нагрузку между ними. Связь сообщения с очередью происходит по весу (условное строковое значение от 0 - n).

Эквивалентный вес очередей - говорит о том, что в каждую очередь придет примерно одинаковое количество сообщений (каждое сообщение будет помещено только в одну очередь). Полной гарантии равномерного распределения сообщений нет.

Hash вычисляется на основе ключа маршрутизации или свойства headers сообщения. Если все публикуемые сообщения имели разные ключи маршрутизации или headers, то распределение будет происходить по весу. Иначе будет использоваться ключ маршрутизации или headers.

Должен помогать, когда пропускная способность потребителя нуждается в росте более высоком чем решение с несколькими потребителями, использующими одну очередь.

--------------------------------------------------------------------------------------------------------------------

Можно ли комбинировать Exchange?

Поведение всех обменников можно комбинировать при помощи связи Exchange-to-Exchange (комбинирование обменников не входит в спецификацию AMQP. Это расширение протокола со стороны RabbitMQ).

За счет E2E мы можем найти правильную масштабируемую конфигурацию, которая отвечает как текущим, так и растущим требованиям.

--------------------------------------------------------------------------------------------------------------------

Какие у Exchange есть параметры?

exchange — название обменника, который мы хотим создать. Название должно быть уникальным

type — тип обменника

durable — если установить true, то exchange будет являться постоянным. Он будет храниться на диске и сможет пережить перезапуск сервера/брокера. Если значение false, то exchange является временным и будет удаляться, когда сервер/брокер будет перезагружен

autoDelete — автоматическое удаление. Exchange будет удален, когда будут удалены все связанные с ним очереди

arguments — необязательные аргументы. Чаще всего, через аргументы задают alternative exchange (альтернативный обменник). Если сообщение не может пройти по первоначальному маршруту, ее можно отправить в альтернативный обменник для маршрутизации по другому пути.

--------------------------------------------------------------------------------------------------------------------

Что такое Binding?

Binding - Базовая сущность Rabbit, статический маршрут от Exchange до Queue (от обменника до очереди). Правило, которое сообщает обменнику в какую из очередей должны попадать сообщения.

Неизменяемая сущность: если нужно изменить binding, его удаляют и декларируют заново.

Bindings между парой exchange-очередь может быть несколько, но только с разными параметрами.

Параметры binding — или routingkey, или headers — в зависимости от типа Exchange.

--------------------------------------------------------------------------------------------------------------------

Какие параметры есть у Binding

queue — имя очереди
exchange — имя обменника
routingKey — ключ маршрутизации
arguments — необязательные аргументы

--------------------------------------------------------------------------------------------------------------------

Расскажите про Queue в RabbitMQ

Queue - Базовая сущность RabbitMQ, представляет из себя последовательное хранилище для необработанных сообщений.

Хранение сообщений на диске (persistent) зависит от флага delivery_mode, назначаемым publisher для каждого сообщения.

Durable/Transient — признак персистентности очереди. Durable значит, что exchange сохранится после перезагрузки Rabbit.

Важно понимать, что даже если вы отправили сообщения с признаком delivery_mode=2 (persistent), но очередь задекларирована не как Durable, то при перезагрузке Rabbit очередь и все содержащиеся в ней сообщения будут безвозвратно утрачены

Есть три типа очередей:
Classic — обычная очередь, используется в большинстве случаев.
Quorum — аналог классической очереди, но с обеспечением гарантий консистентности, достигаемый кворумом в кластере.
Stream — новый вид очередей (начиная с версии Rabbimq 3.9), пока ещё мало кем используемый, аналог принципов Apache Kafka.

--------------------------------------------------------------------------------------------------------------------

Какие параметры есть у Queue

queue — название очереди, которую мы хотим создать. Название должно быть уникальным и не может совпадать с системным именем очереди

durable — если true, то очередь будет сохранять свое состояние и восстанавливается после перезапуска сервера/брокера

exclusive — если true, то очередь будет разрешать подключаться только одному потребителю

autoDelete — если true, то очередь обретает способность автоматически удалять себя

arguments — необязательные аргументы.

--------------------------------------------------------------------------------------------------------------------

Возможные аргументы для Queue?

x-message-ttl(x-message-time-to-live) — позволяет установить время истечения срока жизни сообщения в миллисекундах. Если создание очереди происходит с установленным значением аргумента x-message-ttl, то такая очередь будет автоматически исключать сообщения, у которых истек срок действия. Установка значения аргумента x-message-ttl задает максимальный возраст для всех сообщений в данной очереди. Создание такой очереди позволяет предотвратить получение устаревшей информации. Это можно использовать в системах реального времени. Если у очереди для которой задан обменник для отклоненных сообщений установить значение аргумента x-message-ttl, то отклоненные сообщения в данной очереди начнут обладать сроком жизни.

x-expires — задает значение в миллисекундах по истечению которого происходит удаление очереди. Очередь может израсходовать срок своего действия только если она не имеет никаких подписчиков. Если к очереди подключены подписчики, она сможет автоматически удалиться только тогда, когда все подписчики вызовут Basic.Cancel или отсоединятся. Срок жизни очереди может завершиться только в том случае, если к ней не было запроса Basic.Get. Иначе текущее значение установки времени жизни обнуляется, и очередь больше не будет автоматически удаляться. Также нет гарантий того, насколько быстро происходит удаление очереди после истечения её срока жизни.

x-max-length — задает максимальное число сообщений в очереди. Если число сообщений в очереди начинает превышать макимальное чило, то начинают удаляться самые старые

x-max-lenght-bytes — задает максимально допустимый суммарный размер полезной нагрузки сообщений в очереди. При превышении установленного значения (возникло переполнение очереди при очередной публикации сообщения) самые старые сообщения начнут удаляться

x-overflow — данный аргумент используется для настройки поведения в результате переполнения очереди. Доступны два значения: drop-head (значение по умолчанию) и reject-publish. Если выбрать drop-head, то самые старые сообщения будут удаляться. Если выбрать reject-publish, то прием сообщений будет приостановлен

x-dead-letter-exchange — задает exchange, в который направляются отвергнутые сообщения, которые не поставлены повторно в очередь

x-dead-letter-routing-key — задает не обязательный ключ маршрутизации для отвергнутых сообщений

x-max-priority — разрешает сортировку по приоритетам в очереди с максимальным значением приоритета 255 (RabbitMQ версий 3.5.0 и выше). Число указывает максимальный приоритет, который будет поддерживать очередь. Если аргумент не установлен, очередь не будет поддерживать приоритет сообщений

x-queue-mode — позволяет перевести очередь в ленивый режим. В таком режиме как можно больше сообщений будет храниться на диске. Использование оперативной памяти будет минимально. В случае, если он не установлен, очередь будет хранить сообщения в памяти, чтобы доставлять сообщения максимально быстро

x-queue-master-locator — если у нас кластер, то можно задать мастер очередь

x-ha-policy — используется при создании HA очередей и определяет как сообщение будет распространяться по узлам. Если установлено значение all, то сообщение будет сохраняться на всех узлах. Если установлено значение nodes, то сообщение будет сохраняться на определенных узлах кластера

x-ha-nodes — задает узлы, к которым будет относиться некая очередь HA

--------------------------------------------------------------------------------------------------------------------

Как создать временную очередь?

Если создание очереди происходит с установленным параметром autoDelete, то такая очередь обретает способность автоматически удалять себя. Такие очереди обычно создаются в момент подключения первого клиента и удаляются в момент, когда все клиенты отсоединились.

Если создание очереди происходит с установленным параметром exclusive, то такая очередь разрешает подключаться только одному потребителю и удаляется если закроется канал. До тех пор пока канал не закроется, клиент может отключаться/подключаться, но только в рамках того же самого соединения. Если параметр exclusive установлен, то параметр autoDelete не имеет никакого эффекта.

Особенности:
при кратковременном разрыве связи мы будем терять сообщения, которые ещё не успели дойти до потребителя

можно поймать феномен binding churn. Феномен возникает, когда количество операций по созданию/удалению очередей и привязок достигает очень больших значений. В кластерном режиме такой поток операций будет расползаться по всем узлам и создаст большую нагрузку. Данный процесс можно оптимизировать за счет контроля количества подписок

--------------------------------------------------------------------------------------------------------------------

Как создать постоянную очередь?

Если создание очереди происходит с установленным параметром durable, то такая очередь сохраняет свое состояние и восстанавливается после перезапуска сервера/брокера. Данная очередь будет существовать до тех пор пока не будет вызвана команду Queue.Delete.

--------------------------------------------------------------------------------------------------------------------

Расскажите про Message

Message - Базовая сущность RabbitMQ — само сообщение, несёт полезную нагрузку (payload), проходит весь путь от Publisher до Consumer.

Message состоит из 3 фреймов(сообщений) в каждом из которых передаётся разная информация.

Фрейм состоит из:

1) Типа фрейма

2) Номера канала

3) Размера фрейма в байтах

4) Полезной нагрузки фрейма

5) Маркера завершающего байта (ASCII значение 206)

Первый фрейм передаёт мета информацию для RabbitMq, чтобы он мог маршрутизировать это сообщение 
Второй фрейм передаёт headers нашего сообщения
Третий и последующие фреймы передают полезную нагрузку, одно сообщение может быть раздроблено на несколько фреймов в соответствии с настройками.

Важные поля:
app-id - Полезно для задания приложения, опубликовавшего данные сообщения

content-encoding - Определяет кодируется ли тело сообщения особым образом, например, с помощью zlib, deflate или Base64.

content-type - Определяет тип данного сообщения с использованием типа MIME.

correlation-id - Если данное сообщение ссылается на некое другое сообщение или уникально указываемое им, correlation-id является хорошим способом указания на то, на что ссылается данное сообщение.

delivery-mode - Значение 1 сообщает RabbitMQ, что тот может оставлять данное сообщение в оперативной памяти, 2 указывает что его также следует записать на диск.

expiration - Значение штампа времени эпохи Unix в виде текстовой строки, которое указывает когда истекает срок действия данного сообщения.

headers - Таблица ключ/ значение в произвольном виде, которую вы можете применять для добавления дополнительных метаданных о своём сообщении; RabbitMQ, может выполнять маршрутизацию на основании их при вашем желании на то.

message-id - Уникальный идентификатор, такой как UUID, который ваше приложение может применять для указания данного сообщения.

priority - Свойство для определения значения приоритета в очередях.

timestamp - Значение эпохи или временного штампа Unix, которое может применяться для указания того, когда это сообщение было создано.

type - Текстовая строка, которую ваше приложение иожет применять для описания типа самого сообщения или его полезной нагрузки.

user-id - Строка в произвольном виде, которую, если она используется, RabbitMQ будет проверять для сопоставления с подключённым сообщением и удалять данное сообщение в случае несоответствия.

--------------------------------------------------------------------------------------------------------------------
Расскажите про Publisher в RabbitMQ

Publisher - Внешнее приложение (крон/вебсервис/что угодно), генерирующее сообщения в RabbitMQ для дальнейшей обработки.
Создаёт соединение (connection) по протоколу AMQP, в рамках соединения создаёт канал (channel). В рамках одного соединения можно создать несколько каналов, но это не рекомендуется даже официальной документацией RabbitMQ.
«Флаппинг» каналов: если Publisher для каждого сообщения создаёт соединение, канал, отправляет сообщение, закрывает канал, закрывает соединение, это очень плохая история. Rabbit становится плохо уже на ~300 таких пересозданий каналов в секунду. Будьте внимательны. Если нет возможности изменить Publisher, можно использовать amqproxy.

Важное замечание: не следует использовать amqproxy для consumer, есть проблемы одностороннего разрушения соединений.

Publisher может декларировать практически все сущности — exchanges, queues, bindings и др. На практике лучше подходит стратегия декларирования всех нужных сущностей consumer, но решать нужно для каждого проекта индивидуально.

Publisher всегда пишет в exchange. Даже если вы думаете, что он пишет напрямую в очередь, это не так. Он пишет в служебный exchange с routing key, совпадающим с названием очереди.

Publisher определяет delivery_mode для каждого сообщения — так называемый «признак персистентности». Это значит, что сообщение будет сохранено на диске и не исчезнет в случае перезагрузки Rabbit.
delivery_mode=1 — не хранить сообщения, быстрее.
delivery_mode=2 — хранить сообщения на диске, медленнее, но надёжнее.

Также publisher определяет Routing Key для каждого сообщения — признак, по которому идёт дальнейшая маршрутизация в Rabbit.

Publisher может выставлять confirm флаг — отправлять указания Rabbitmq через отдельный канал подтверждения об успешной приёмке сообщений. Например, если у Rabbit закончится место на диске, то некоторое время он ещё будет принимать сообщения от Publisher. Publisher будет думать, что всё в порядке, хотя сообщения с высокой долей вероятности не дойдут до Consumer и не сохранятся в очереди для дальнейшей обработки. Полезная вещь, но ощутимо снижает скорость работы и сложно реализуема в однопоточных языках разработки.

Также есть флаг mandatory — указание Rabbit складировать сообщения, не имеющие маршрута в какую-либо очередь в отдельный Exchange. Редкий и мало используемый кейс.

--------------------------------------------------------------------------------------------------------------------
Как общается Publisher при публикации Message с RabbitMq?

При публикации сообщения в RabbitMQ отправляются три кадра: метод Basic.Publish, заголовок содержимого и тело сообщения. RabbitMQ проверяет информацию из кадра Basic.Publish перед выполнением следующих шагов. Этот кадр содержит название обмена и ключ маршрутизации. RabbitMQ ищет соответствие имени обмена в своей базе данных обменов.

После определения соответствующего обмена, RabbitMQ вычисляет связывание и находит соответствующие очереди по ключу маршрутизации. Если сообщение соответствует какой-либо очереди, оно помещается в очередь по правилу FIFO. Вместо помещения реального сообщения в структуру данных, в очередь добавляется ссылка на него. При доставке, RabbitMQ использует ссылку для формирования упорядоченного сообщения.

Это оптимизирует публикацию для множества получателей, уменьшая использование памяти.

--------------------------------------------------------------------------------------------------------------------
Расскажите про Consumer

Замыкает обработку Сonsumer — демон, получающий сообщения из Queue и выполняющий ту самую логику, ради которой сообщение проделало весь этот путь. Например, отправка уведомления, запись в базу данных, генерация оффлайн отчёта или отправка сообщения в другую Queue.

Так же, как и Publisher, Consumer создаёт соединение (connection) по протоколу AMQP. В рамках соединения создаёт канал (channel) и уже инициирует consuming в рамках этого канала.

Consumer может декларировать практически все сущности — exchanges, queues, bindings и тд. На практике мы стараемся декларировать все сущности именно Consumer, но решать нужно для каждого проекта индивидуально.

Consumer подписывается только на одну очередь. Если вы хотите получать сообщения из разных очередей, правильнее будет корректно смаршрутизировать их потоки в одну очередь, чем городить пулы Consumer внутри приложения.

Сообщения в Consumer попадают по push-модели — протакливаются Rabbit в канал по мере их появления и (или) освобождения Consumer. Никакой периодики, задержки — это жирный плюс.

Prefetch count — важный параметр Consumer, обозначающий количество неподтверждённых Consumer сообщений в один момент. По умолчанию во многих библиотеках он равен 0 (по сути отключен). В такой ситуации Rabbit проталкивает все сообщения из очереди в Consumer, а тот во многих случаях при достаточном количестве сообщений просто отъезжает.

Если нет понимания, какое значение ставить, лучше ставить «1» — пока Consumer не обработает одно сообщение, следующее к нему не поступит. Как только Rabbit подтвердит обработку, следующее сообщение будет получено незамедлительно.

Когда вы поймёте, что у вас есть мультитред, и вы можете обрабатывать большие нагрузки, вы поднимете этот параметр, но уже осознанно.

Consumer может подтвердить обработку сообщения — механизм Acknowledge (ack). Или вернуть сообщение в Queue при неудачной обработке — механизм Negative acknowledge (nack).

Механизм nack также срабатывает автоматически при разрушении канала к Consumer. Это удобно использовать: если на горячую выключить Consumer, сообщения, которые он обрабатывал, автоматически вернутся в очередь.

AutoAck — флаг автоматического подтверждения всех протакливаемых сообщений (не требует ack от Consumer). Работает быстро, но не даёт никаких гарантий успешной обработки сообщений.

--------------------------------------------------------------------------------------------------------------------

Как общается Consumer при получении Message?

После вызова Basic.Consume, потребитель остается активным, пока не произойдет одно из нескольких событий. Потребитель может остановить прием сообщений, вызвав команду Basic.Cancel. Важно отметить, что эта команда выполняется асинхронно, поэтому потребитель может продолжать получать сообщения, отправленные до получения кадра отклика Basic.CancelOk.

В процессе потребления сообщений есть настройки, позволяющие определить, каким образом они будут получены. Одна из таких настроек - аргумент no_ack для команды Basic.Consume. Если установлен в true, RabbitMQ будет отправлять сообщения до отмены потребителем или его отсоединения. При установке в false, потребитель должен подтверждать прием каждого сообщения с помощью запроса RPC Basic.Ack.

Кадр отклика Basic.Ack, отправляемый при успешной доставке сообщения, содержит маркер доставки (delivery tag) из кадра метода Basic.Deliver.
--------------------------------------------------------------------------------------------------------------------

Какие типы получения Message реализует RabbitMq?

В RabbitMq существует 2 типа получения: pushing и pulling

pushing - быстрый вариант общения с брокером, когда он сам пушит во все Consumer(публикация-подписка), могут быть проблемы, когда сервис "захлёбывается" в Message.

pulling - более медленный вариант, когда сервис сам выбирает количество Message, которое он хочет обработать.

--------------------------------------------------------------------------------------------------------------------
Как работают FIFO очереди в Rabbit

Основу Rabbit представляют собой именно такие очереди

Попадая в очередь, сообщения выходят из неё в той же последовательности, что и вошли. Последовательность определяется моментом попадания сообщения в очередь, не бывает «одновременных сообщений» в рамках одной очереди, у них всегда есть порядок.

После выстраивания очереди по порядку мы переходим к «обслуживанию» этой очереди. Для этого подключается Consumer (например, как открытие одного кабинета в очереди к врачу).

Если мы не укажем prefetch_count, его значение будет равным нулю. Это значит, что все сообщения протолкнутся в Consumer — ничего хорошего обычно в таком поведении нет. Аналогия: открылся кабинет, и все люди в очереди ввалились туда решать свои вопросы.

Поэтому мы явно укажем prefetch_count=1. Теперь без подтверждения более одного сообщения в Consumer находится не сможет.

Далее после успешной обработки Consumer выполняет «ack» для данного сообщения:

Получив ack, Rabbit удалит сообщение из очереди и незамедлительно протолкнёт в Consumer следующее сообщение (и так далее):

А если мы захотим увеличить скорость обработки? Можем поставить в «кабинете» ещё один «стол с врачом». Для этого укажем prefetch_count=2

Теперь будет идти обработка сразу двух сообщений. А если мы хотим быстрее? Добавляем ещё один сonsumer-кабинет (например с prefetch_count=1)

Общая концепция горизонтальной масштабируемости выглядит именно так.

--------------------------------------------------------------------------------------------------------------------

Устойчивость очереди В RabbitMQ

В RabbitMQ два типа очереди: длительные/устойчивые (durable) и неустойчивые (non-durable). Все очереди сохраняются в базе данных Mnesia. Устойчивые очереди повторно объявляются при запуске узла и, таким образом, переживают перезапуск, сбой системы или сбой сервера (до тех пор, пока сохраняются данные). Это означает, что пока вы декларируете маршрутизацию (exchange) и очередь устойчивыми, инфраструктура очередей/маршрутизации вернется в оперативный режим.Неустойчивые очереди и маршрутизация удаляются при перезапуске узла.

Одно то, что очередь долговечна, не означает, что все её сообщения переживут перезапуск узла. Будут восстановлены только сообщения, установленные паблишером как устойчивые (persistent). Устойчивые сообщения действительно создают дополнительную нагрузку на брокера, но если потеря сообщения неприемлема, то другого выхода нет.

--------------------------------------------------------------------------------------------------------------------

Как переживает потерю брокера RabbitMQ

Чтобы пережить потерю брокера, нам нужна избыточность. Можем объединить несколько узлов RabbitMQ в кластер, а затем добавить дополнительную избыточность путём репликации очередей между несколькими узлами. Таким образом, если падает один узел, мы не теряем данные и остаёмся доступными.

Зеркалирование очереди:
одна главная очередь (мастер), которая получает все команды на запись и чтение

одно или несколько зеркал, которые получают все сообщения и метаданные из главной очереди. Эти зеркала существуют не для масштабирования, а исключительно для избыточности.

Зеркалирование устанавливается соответствующей политикой. В ней можно выбрать коэффициент репликации и даже узлы, на которых должна размещаться очередь.

Примеры:
ha-mode: all
ha-mode: exactly, ha-params: 2 (один мастер и одно зеркало)
ha-mode: nodes, ha-params: rabbit@node1, rabbit@node2

--------------------------------------------------------------------------------------------------------------------

Как RabbitMQ уменьшает вероятность потери сообщения?

Для достижения последовательной записи необходимы подтверждения паблишеру (Publisher Confirms). Без них есть вероятность потери сообщений. Подтверждение отправляется паблишеру после записи сообщения на диск. RabbitMQ записывает сообщения на диск не при получении, а на периодической основе, в районе нескольких сотен миллисекунд. Когда очередь зеркалируется, подтверждение отправляется только после того, как все зеркала также записали свою копию сообщения на диск. Это означает, что использование подтверждений добавляет задержку, но если безопасность данных важна, то они необходимы.

--------------------------------------------------------------------------------------------------------------------

Что происходит когда брокер завершает работу или падает

Когда брокер завершает работу или падает, все ведущие очереди (мастера) на этом узле отваливаются вместе с ним. Затем кластер выбирает самое старое зеркало каждого мастера и продвигает его в качестве нового мастера.

У нас есть 3 брокера с распределенными между ними очередями.
Брокер 1 очереди:
Очереди А зеркало,
Очереди B мастер,
Очереди D мастер без зеркал,

Брокер 2 очереди:
Очереди А мастер,
Очереди B зеркало,
Очереди C зеркало,

Брокер 3 очереди:
Очереди А зеркало,
Очереди B зеркало,
Очереди C мастер,

Брокер 3 падает. Зеркало Очереди С на Брокере 2 повышается до мастера. Также для Очереди C создано новое зеркало на Брокере 1. RabbitMQ всегда пытается поддерживать коэффициент репликации, указанный в ваших политиках.

Падает следующий Брокер 1! У нас остался только один брокер. До мастера повышается зеркало Очереди B.

Мы вернули Брокера 1. Независимо от того, насколько успешно данные пережили потерю и восстановление брокера, все зеркалированные сообщения очереди отбрасываются при перезапуске. Это важно отметить, поскольку будут последствия. Мы скоро рассмотрим эти последствия. Таким образом, Брокер 1 теперь снова является членом кластера, а кластер пытается соблюдать политики и поэтому создает зеркала на Брокере 1.
В этом случае потеря Брокера 1 была полной, как и данных, поэтому незеркалированная Очередь D потеряна полностью.

Брокер 3 вернулся в строй, так что очереди A и B получают обратно созданные на нём зеркала, чтобы удовлетворить своим политикам HA. Но теперь все главные очереди на одном узле! Это не идеально, лучше равномерное распределение между узлами. К сожалению, здесь нет особых вариантов для перебалансировки мастеров. Вернемся к этой проблеме позже, так как сначала нужно рассмотреть синхронизацию очереди.

Таким образом, теперь у вас должно быть представление, как зеркала обеспечивают избыточность и отказоустойчивость. Это гарантирует доступность в случае отказа одного узла и защищает от потери данных. Но мы еще не закончили, потому что на самом деле всё гораздо сложнее.

--------------------------------------------------------------------------------------------------------------------

Синхронизация в RabbitMQ

При создании нового зеркала все новые сообщения всегда будут реплицироваться на это зеркало и любые другие. Что касается существующих данных в главной очереди, мы можем их реплицировать в новое зеркало, которое становится полной копией мастера. Мы также можем не реплицировать существующие сообщения и позволить главной очереди и новому зеркалу сходиться во времени, когда новые сообщения поступают в хвост, а существующие сообщения уходят из головы главной очереди.Такая синхронизация выполняется автоматически или вручную и управляется с помощью политики очередей. Рассмотрим пример.

У нас есть 3 брокера с распределенными между ними очередями.
Брокер 1 очереди:
Очереди А зеркало,
Очереди B мастер

Брокер 2 очереди:
Очереди А мастер,
Очереди B зеркало,

Брокер 3 очереди:
Очереди А зеркало,
Очереди B зеркало,

У нас две зеркалированные очереди. Очередь A синхронизируется автоматически, а Очередь B — вручную. В обеих очередях по десять сообщений.

Теперь мы теряем Брокера 3

Брокер 3 возвращается в строй. Кластер создает зеркало для каждой очереди на новом узле и автоматически синхронизирует новую Очередь А с мастером. Однако зеркало новой Очереди В остается пустым. Таким образом, у нас полная избыточность Очереди A и только одно зеркало для существующих сообщений Очереди B.

В обе очереди поступает ещё по десять сообщений. Затем Брокер 2 падает, а Очередь А откатывается к самому старому зеркалу, которое находится на Брокере 1. При сбое не происходит потери данных. В Очереди B двадцать сообщений в мастере и только десять в зеркале, поскольку эта очередь никогда не реплицировала исходные десять сообщений.

В обе очереди поступает еще по десять сообщений. Теперь падает Брокер 1. Очередь A без проблем переключается на зеркало без потери сообщений. Однако у Очереди В возникают проблемы. На этом этапе мы можем оптимизировать либо доступность, либо согласованность.Если мы хотим оптимизировать доступность, то политику ha-promote-on-failure следует установить в always. Это значение по умолчанию, поэтому можно просто не указывать политику вообще. В таком случае, по сути, мы допускаем сбои в несинхронизированных зеркалах. Это приведет к потере сообщений, но очередь остается доступной для чтения и записи.

Мы также можем установить ha-promote-on-failure в значение when-synced. В этом случае вместо отката на зеркало очередь будет дожидаться, пока Брокер 1 со своими данными вернётся в оперативный режим. После его возвращения главная очередь снова оказывается на Брокере 1 без потери данных. Доступность приносится в жертву безопасности данных. Но это рискованный режим, который может привести даже к полной потере данных, что мы рассмотрим в ближайшее время.

--------------------------------------------------------------------------------------------------------------------

Может, лучше никогда не использовать автоматическую синхронизацию?

Ответ заключается в том, что синхронизация является блокирующей операцией. Во время синхронизации главная очередь не может выполнять никаких операций чтения или записи!

Рассмотрим пример. Сейчас у нас очень большие очереди. Как они могут вырасти до такого размера?
По нескольким причинам:
Очереди не используются активно

Это высокоскоростные очереди, а прямо сейчас потребители работают медленно

Это высокоскоростные очереди, произошел сбой, и потребители догоняют

Имеем
У нас есть 3 брокера с распределенными между ними очередями.
Брокер 1 очереди:
Очереди А зеркало,
Очереди B мастер

Брокер 2 очереди:
Очереди А мастер,
Очереди B зеркало,

Брокер 3 очереди:
Очереди А зеркало,
Очереди B зеркало,

У нас две зеркалированные очереди. Очередь A синхронизируется автоматически, а Очередь B — вручную. В обеих очередях по 100 сообщений.


Теперь падает Брокер 3.

Брокер 3 возвращается в строй, и создаются новые зеркала. Главная Очередь А начинает реплицировать существующие сообщения на новое зеркало, и в течение этого времени Очередь недоступна. Для репликации данных требуется два часа, что приводит к двум часам простоя для этой Очереди!
Однако Очередь B остается доступной в течение всего периода. Она пожертвовала некоторой избыточностью ради доступности.

Через два часа Очередь A тоже становится доступной и может снова начать принимать операции чтения и записи.

--------------------------------------------------------------------------------------------------------------------

Правила поведения при отключении брокера

Блокирующее поведение во время синхронизации затрудняет обновление кластеров с очень большими очередями. В какой-то момент узел с мастером нужно перезапустить, что означает либо переход на зеркало, либо отключение очереди во время обновления сервера. Если мы выберем переход, то потеряем сообщения, если зеркала не синхронизированы. По умолчанию во время отключения брокера переход на несинхронизированное зеркало не выполняется. Это означает, что как только брокер возвращается, мы не теряем никаких сообщений, единственным ущербом стал только простой очереди. Правила поведения при отключении брокера задаются политикой ha-promote-on-shutdown.
Можно установить одно из двух значений:

always= включен переход на несинхронизированные зеркала
when-synced= переход только на синхронизированное зеркало, иначе очередь становится недоступной для чтения и записи. Очередь возвращается в строй, как только вернется брокер

Так или иначе, с большими очередями приходится выбирать между потерей данных и недоступностью.

--------------------------------------------------------------------------------------------------------------------

Проблемы с ha-promote-on-failure=when-synced

Идея ha-promote-on-failure= when-synced заключается в том, что мы предотвращаем переключение на несинхронизированное зеркало и тем самым избегаем потери данных. Очередь остается недоступной для чтения или записи. Вместо этого мы пытаемся вернуть упавший брокер с неповрежденными данными, чтобы он возобновил работу в качестве мастера без потери данных.
Но (и это большое но) если брокер потерял свои данные, то у нас большая проблема: очередь потеряна! Все данные пропали! Даже если у вас есть зеркала, которые в основном догоняют главную очередь, эти зеркала тоже отбрасываются.

Чтобы заново добавить узел с тем же именем, мы говорим кластеру забыть потерянный узел (командой rabbitmqctl forget_cluster_node) и запустить новый брокер с тем же именем хоста. Пока кластер помнит потерянный узел, он помнит старую очередь и несинхронизированные зеркала. Когда кластеру говорят забыть потерянный узел, эта очередь также забывается. Теперь нужно заново его объявить. Мы потеряли все данные, хотя у нас были зеркала с частичным набором данных. Лучше было бы перейти на несинхронизированное зеркало!

Поэтому ручная синхронизация (и невыполнение синхронизации) в сочетании с ha-promote-on-failure=when-synced, на мой взгляд, довольно рискованна. Документы говорят, что такой вариант существует для безопасности данных, но это обоюдоострый нож.

--------------------------------------------------------------------------------------------------------------------

Как происходит перебалансировка мастеров

Существует проблема скопления всех мастеров на одном или нескольких узлах. Это может произойти даже в результате «скользящего» (rolling) обновления кластера. В кластере с тремя узлами все главные очереди скопятся на одном или двух узлах.

Перебалансировка мастеров может оказаться проблематичной по двум причинам:

Нет хороших инструментов для выполнения перебалансировки
Синхронизация очередей

Для перебалансировки есть сторонний плагин, который не поддерживается официально. Относительно сторонних плагинов в руководстве RabbitMQ сказано: «Плагин предоставляет некоторые дополнительные инструменты настройки и отчётности, но не поддерживается и не проверен командой RabbitMQ. Используйте на свой страх и риск».

Есть еще один трюк, чтобы переместить главную очередь через политики HA. В руководстве упоминается скрипт для этого. Он работает следующим образом:

Удаляет все зеркала с помощью временной политики с более высоким приоритетом, чем существующая политика HA.

Изменяет временную политику HA для использования режима «узлы» с указанием узла, на который требуется перенести главную очередь.

Синхронизирует очередь для принудительной миграции.

После завершения миграции удаляет временную политику. Вступает в действие исходная политика HA и создается нужное количество зеркал.

Недостаток в том, что такой подход может не сработать, если у вас большие очереди или строгие требования к избыточности.

--------------------------------------------------------------------------------------------------------------------

Нарушение связности RabbitMQ

Узлы распределенной системы соединяются сетевыми связями, а сетевые связи могут и будут отключаться. Частота отключений зависит от локальной инфраструктуры или надежности выбранного облака. В любом случае, распределенные системы должны быть в состоянии справиться с ними. Снова перед нами выбор между доступностью и согласованностью, и снова хорошая новость в том, что RabbitMQ обеспечивает оба варианта (просто не одновременно).

С RabbitMQ у нас две основных опции:

Разрешить логическое разделение (split-brain). Это обеспечивает доступность, но может спровоцировать потерю данных.

Запретить логическое разделение. Может привести к краткосрочной потере доступности в зависимости от способа подключения клиентов к кластеру. Также может привести к полной недоступности в кластере из двух узлов.

Но что такое логическое разделение? Это когда кластер разделяется надвое из-за потери сетевых связей. На каждой стороне зеркала повышаются до мастера, так что в итоге на каждую очередь приходится несколько мастеров.

Если паблишеры отправляют данные в оба мастера, у нас получится две расходящиеся копии очереди.

--------------------------------------------------------------------------------------------------------------------

Какие существуют режимы в RabbitMQ которые обеспечивают либо доступность, либо согласованность.

Режим Ignore (по умолчанию)
Режим Autoheal
Режим Pause Minority

--------------------------------------------------------------------------------------------------------------------

Расскажите про режим Ignore

Этот режим обеспечивает доступность. После потери связности происходит логическое разделение. После восстановления связности администратор должен решить, какому разделу отдать предпочтение. Проигравшая сторона будет перезапущена, и все накопленные данные с этой стороны теряются.

Имеем Три паблишера связаны с тремя брокерами

Теперь мы теряем Брокера 3. Он видит, что другие брокеры отвалились, и продвигает свое зеркало до мастера. Так происходит логическое разделение

Связность восстанавливается, но логическое разделение остается. Администратор должен вручную выбрать проигравшую сторону. В приведенном ниже случае администратор перезагружает Брокера 3. Теряются все сообщения, которые тот не успел передать.

Во время потери связности и после её восстановления кластер и эта очередь были доступны для чтения и записи.

--------------------------------------------------------------------------------------------------------------------

Расскажите про режим Autoheal

Работает аналогично режиму Ignore, за исключением того, что сам кластер автоматически выбирает проигравшую сторону после разделения и восстановления связности. Проигравшая сторона возвращается в кластер пустой, а очередь теряет все сообщения, которые были отправлены только на ту сторону.

--------------------------------------------------------------------------------------------------------------------

Расскажите про режим Pause Minority

Если мы не хотим допустить логического разделения, то наш единственный вариант — отказаться от чтения и записи на меньшей стороне после раздела кластера. Когда брокер видит, что находится на меньшей стороне, то приостанавливает работу, то есть закрывает все существующие соединения и отказывается от любых новых. Один раз в секунду он проверяет восстановление связности. Как только связность восстановлена, он возобновляет работу и присоединяется к кластеру.

Имеем Три паблишера связаны с тремя брокерами.

Затем Брокеры 1 и 2 отделяются от Брокера 3. Вместо того, чтобы повышать свое зеркало до мастера, Брокер 3 приостанавливает работу и становится недоступным.

Как только связность восстановлена, он возвращается в кластер.

Посмотрим на другой пример, где главная очередь находится на Брокере 3.

Затем происходит та же потеря связности. Брокер 3 встаёт на паузу, поскольку находится на меньшей стороне. На другой стороне узлы видят, что Брокер 3 отвалился, так что более старое зеркало с Брокеров 1 и 2 повышается до мастера.

Когда связность восстановлена, Брокер 3 присоединится к кластеру.

Здесь важно понимать, что мы получаем согласованность, но также можем получить доступность, если успешно переведем клиентов на бóльшую часть раздела. Для большинства ситуаций лично я бы выбрал режим Pause Minority, но это реально зависит от конкретного случая.

Для обеспечения доступности важно убедиться, что клиенты успешно подключаются к узлу. Рассмотрим наши варианты.

--------------------------------------------------------------------------------------------------------------------

Паттерн Пайплайн

Пайплайн — базовый элемент архитектуры, когда нужна последовательная обработка различными сервисами. Например, сначала требуется проверить авторизацию, затем выполнить дедупликацию и только после произвести запись данных сообщения в базу данных.

За счёт использования очередей в пайплайне хорошо видны bottleneck'и — узкие места, перед которыми скапливаются сообщения на обработку. Также есть понятный механизм расшивания посредством увеличения количества консьюмеров (конечно, это не серебряная пуля, так как проблемы могут быть у другого сервиса типа БД).

Плюс такого подхода — возможность удобного траблшутинга. На любом этапе вы можете добавить дублирующую очередь и получать копии сообщений как для разбора, так и для отправки на непродовые окружения.

Типовой пример пайплайна обработки: Publisher отправляет сообщение, и затем оно передаётся от worker к worker по мере обработки. Worker 1 проверяет авторизацию, 2 — дедупликатор, 3 — пишет в БД.

Важно: worker 1 и worker 2 на данной схеме являются одновременно и consumer, и publisher. А что произойдёт, если worker 2 перестанет справляться с дедупликацией сообщений?

Представим, что код проверки написан не оптимально, и скорость проверки ниже, чем частота прихода новых сообщений.
В этом случае очередь сообщений перед worker 2 начнёт расти, о чём нам тут же сообщит система мониторинга.
Если есть возможность горизонтального масштабирования — запускаем ещё один инстанс worker 2:
И они вдвоём ускоряют обработку сообщений. Разумеется, ускорить обработку таким способом получится не всегда. Если worker'ы упираются в скорость используемой БД, надо расшивать её или оптимизировать их код. Однако узкое горлышко обработки вы будете видеть сразу.

--------------------------------------------------------------------------------------------------------------------

Паттерн Очередь повторных попыток

Очередь повторных попыток — один из базовых элементов архитектуры приложения. Используется, когда есть вероятность неуспешной обработки сообщения (как «временные трудности» в целом, так и проблемы с обработкой конкретного сообщения). Работает, если нет необходимости в строгой последовательности обработки, так как подразумевает возможность временного пропуска сообщения.

Существуют два основных алгоритма реализации:
ack+publish — когда consumer сам подтверждает сообщение из основной очереди и паблишит в очередь повторных попыток;

reject+dlx — через механизм dead letter exchange.

--------------------------------------------------------------------------------------------------------------------

Расскажите про Dead Letter eXchange

Dead Letter eXchange (DLX) — это явное или назначенное через Policy свойство очереди. Указывает RabbitMQ, куда необходимо отправлять сообщение при наступлении одного из событий:
x-mesage-ttl — превышение времени жизни;
x-max-length — превышение длины очереди;
reject — явный реджект сообщений со стороны консьюмера.
Для одной очереди можно указать только один DLX, что несколько снижает гибкость. Также вы можете указать dead-letter-routing-key, а можете не указывать — тогда сохраняется текущий для каждого сообщения.

Мы декларируем DLX = Fail, который ведёт в ту самую очередь повторных попыток.
При неуспешной обработке мы делаем reject(false) вместо ack и publish.
Принцип тот же, но работает проще: меньше кода — меньше возможных проблем. Результат ожидаемо аналогичный.
Но ведь нам нужно совершать повторные попытки обработки, а не просто складывать сообщения в отстойник. Для этого мы используем тот же самый механизм DLX + механизм TTL.
В результате плохое сообщение будет каждую минуту возвращаться в основную очередь. Будет происходить попытка его обработки и так до тех пор, пока сообщение не будет успешно обработано. Просто и без лишнего кода.
Для очередей без consumer, где возможно хранение сообщений, рекомендую также добавлять признак lazy-queue, чтобы RabbitMQ старался не держать эти сообщения в оперативке.

--------------------------------------------------------------------------------------------------------------------

Расскажите про ack+publish

Предположим, у нас есть обработка сообщений, использующая некий внешний сервис, находящийся вне нашей зоны ответственности. Так же есть сообщения 1 2 и 3. Пускай сообщение «2» в данный момент не может быть им успешно обработано.

Сообщения помещаются в очередь.

Worker берёт сообщение 1 в обработку.

После успешной обработки первого сообщения доходит дело до второго — проблемного.

Происходит ошибка его обработки. Если мы сделаем nack этому сообщению, оно вернётся в очередь на тоже самое место. И незамедлительно будет закинуто в worker. Но здесь его снова ждёт неуспешная обработка. И пока одно сообщение будет бегать туда-сюда, оно, как тромб, забьёт голову очереди. В результате все сообщения, которые могли бы быть обработаны, будут висеть в очереди и ждать своего часа.

Как раз для таких случаев нужен паттерн очереди повторных попыток. Суть в том что мы создаем дополнительную очередь «retry queue», куда складируем неуспешно обработанные сообщения.
В случае ошибки обработки worker должен сделать ACK из основной очереди и publish в новую очередь.

В результате для нашего примера 1 и 3 сообщения будут успешно обработаны, а 2 останется в выделенной очереди ожидать своего часа.
Это как раз подход ack+publish. Он наиболее часто используется в IT-системах, потому что разработчики не знают о некоторых возможностях RabitMQ.

--------------------------------------------------------------------------------------------------------------------

Мониторинг очередей

Если мы вводим в эксплуатацию новую систему, надо понимать, как ее правильно мониторить. Любая очередь лимитирована, даже если вы не выставили ей лимиты. Нормальное состояние очереди — пустое. Вы присылаете сообщения и они должны обрабатываться. Если очередь начала расти, значит в системе что-то не так.

Поэтому размер очереди — первый показатель, который нужно мониторить.

Второй показатель — время — пригодится, когда ваша очередь начнет расти. Можно измерять полную обработку сообщения (QoS) от момента, когда вы его положили, до момента, когда обработали. И время обработки между тем, когда консьюмер взял и вернул сообщение. Замеры покажут, где у вас проблема.

Третий показатель — количество повторов и потерь (отказов). За размером очереди и временем не всегда получается уследить. За секунду может пройти 10 тысяч сообщений, и вы обнаружите, что очередь начала расти. А почему — непонятно, так как размер очереди и время — моментальные показатели. Мониторинг количества повторов и потерь (отказов), а также самого потока сообщений помогает понимать, что с вашей очередью происходит.

Если вы можете логировать сообщение, когда кладете его в очередь, — делайте это. Логов будет много, но в случае аварии, лучше доставать и искать сообщения из логов, чем обнаружить, что сообщений нет.

--------------------------------------------------------------------------------------------------------------------

Throughput / Latency / Durability / Availability

Throughput - Пропускная способность
Latency - Задержка
Durability - Долговечность
Availability - Доступность

--------------------------------------------------------------------------------------------------------------------