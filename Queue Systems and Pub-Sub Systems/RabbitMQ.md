Что такое AMQP?

AMQP (Advanced Message Queuing Protocol) — открытый протокол для передачи сообщений между компонентами системы. Основная идея состоит в том, что отдельные подсистемы (или независимые приложения) могут обмениваться произвольным образом сообщениями через AMQP-брокер, который осуществляет маршрутизацию, возможно гарантирует доставку, распределение потоков данных, подписку на нужные типы сообщений.

Протокол AMQP вводит три понятия:

exchange (обменник или точка обмена) — в неё отправляются сообщения. Обменник распределяет сообщение в одну или несколько очередей. Он маршрутизирует сообщения в очередь на основе созданных связей (binding) между ним и очередью

queue (очередь) — структура данных на диске или в оперативной памяти, которая хранит ссылки на сообщения и отдает копии сообщений consumers (потребителям). Одна очередь может использоваться несколькими потребителями

binding (привязка) — правило, которое сообщает точке обмена в какую из очередей эти сообщения должны попадать. Обменник и очередь могут быть связаны несколькими привязками

Протокол работает поверх TCP/IP.

--------------------------------------------------------------------------------------------------------------------

Что такое RabbitMQ?

RabbitMQ - это брокер сообщений с открытым исходным кодом. Он маршрутизирует собщения по всем базовым принципам протокола AMQP описанным в спецификации. Отправитель передает сообщение брокеру а тот доставляет его получателю. RabbitMQ реализует и дополняет протокол AMQP.
Основная идея модели обмена сообщениями в RabbitMQ заключается в том, что producer (издатель) не отправляет сообщения непосредственно в очередь. На самом деле и довольно часто издатель даже не знает, будет ли сообщение вообще доставлено в какую-либо очередь.
Вместо этого издатель может отправлять сообщения только на обмен. С одной стороны, обмен получает сообщения от издателей, а с другой — отправляет их в очереди. Обмен должен точно знать, что делать с полученным сообщением.

--------------------------------------------------------------------------------------------------------------------

Почему выбирают RabbitMQ?

RabbitMQ поддерживает несколько протоколов: AMQP, MQTT, STOMP и др., что позволяет использовать его в разных сценариях.

RabbitMQ хранит сообщение до тех пор, пока принимающее приложение не подключится и не получит его из очереди. Клиент может подтвердить получение сообщения сразу или после того, как полностью обработает его. Как только такое подтверждение получено, сообщение удаляется из очереди. Для сравнения в Kafka очередь сообщений является постоянной — данные хранятся, пока не истечёт указанный период или не будет достигнуто ограничение по размеру. Поэтому важно убедиться, что событие, которое должно произойти один раз, не воспроизводится многократно.

Основное преимущество RabbitMQ — гибкая маршрутизация. Сообщения маршрутизируются через exchange (обменник) перед попаданием в очереди. RabbitMQ предлагает несколько встроенных типов обмена для типичной логики маршрутизации.

RabbitMQ поддерживает приоритезацию в очередях и позволяет настроить диапазон приоритетов. Приоритет каждого сообщения устанавливается при его публикации.

RabbitMQ предлагает простой пользовательский интерфейс управления. Он позволяет контролировать каждый аспект брокера сообщений. .

--------------------------------------------------------------------------------------------------------------------

Какие проблемы решает система очередей?

Используя очереди сообщений в качестве основного средства взаимодействия микросервисов (Microservices Communication), можно добиться следующих преимуществ:

Отделение логически независимых компонентов друг от друга (Decoupling)
Отличительная черта микросервисов — их автономность. И очереди во многом помогают уменьшить зависимости между ними. Каждое сообщение, передаваемое в очереди, — это всего лишь массив байтов с некоторыми метаданными. Метаданные нужны для направления в конкретную очередь, а информация, содержащаяся в основной части (теле) сообщения, может быть практически любой. Брокер не анализирует данные, он выступает лишь в качестве маршрутизатора. Это позволяет настроить взаимодействие между компонентами, работающими даже на разных языках и платформах.

Улучшение масштабируемости
Очереди сообщений упрощают независимое масштабирование микросервисов. Наблюдая за состоянием очередей, можно масштабировать те сервисы, на которые приходится большая часть нагрузки. Кроме этого, очереди легко позволяют не только увеличивать число экземпляров существующих сервисов, но и добавлять новые с минимальным временем простоя. Все, что для этого требуется, — добавить нового потребителя, прослушивающего события в очереди.
Однако сами очереди также необходимо масштабировать, и это может создать дополнительные сложности.

Балансировка нагрузки
Если один из сервисов не справляется с нагрузкой, требуется возможность запускать больше его экземпляров быстро и без дополнительных настроек. Обычно для этих целей используют балансировщик нагрузки, интегрированный с сервером обнаружения служб и предназначенный для распределения трафика. При использовании очередей сообщений сам брокер по умолчанию является балансировщиком нагрузки. Если несколько потребителей слушают очередь одновременно, сообщения будут распределяться между ними в соответствии с настроенной стратегией.

Повышение надежности
Выход из строя одного из компонентов не сказывается на работе всей системы: при восстановлении он обработает сообщение, находящееся в очереди. Ваш веб-сайт по-прежнему может работать, даже если задерживается часть обработки заказа, например, из-за проблем с сервером БД или системой электронной почты.
Правда, при этом очередь сама приобретает статус SPoF (Single Point Of Failure), поэтому необходимо заранее предусмотреть действия на случай ее аварийного отключения.

Безопасность
Большинство брокеров выполняют аутентификацию приложений, которые пытаются получить доступ к очереди, и позволяют использовать шифрование сообщений как при их передаче по сети, так и при хранении в самой очереди. Таким образом, очередь снимает с ваших сервисов бремя организации авторизации запросов.

--------------------------------------------------------------------------------------------------------------------

Какие проблемы привносит система очередей?

Несмотря на многочисленные преимущества очередей сообщений, самостоятельное их внедрение может оказаться довольно сложной задачей по нескольким причинам:

По сути, это еще одна система, которую необходимо купить/установить, правильно сконфигурировать и поддерживать. Также потребуются дополнительные мощности.

Если брокер когда-либо выйдет из строя, это может остановить работу многих систем, взаимодействующих с ним. Как минимум необходимо позаботиться о резервном копировании данных.

С ростом числа очередей усложняется и отладка. При синхронной обработке сразу очевидно, какой запрос вызвал сбой, например, благодаря иерархии вызовов в IDE. В очередях потребуется позаботиться о системе трассировки, чтобы быстро связать несколько этапов обработки одного запроса для обнаружения причины ошибки.

При использовании очередей вы неизбежно столкнетесь с выбором стратегии доставки сообщений. В идеале сообщения должны обрабатываться каждым потребителем однократно. Но на практике это сложно реализовать из-за несовершенства сетей и прочей инфраструктуры. Большинство брокеров поддерживают две стратегии: доставка хотя бы раз (At-least-once) или максимум раз (At-most-once). Первая может привести к дубликатам, вторая — к потере сообщений. Обе требуют тщательного мониторинга. Некоторые брокеры также гарантируют строго однократную доставку (Exactly-once) с использованием порядковых номеров пакетов данных, но даже в этом случае требуется дополнительная проверка на стороне получателя.

--------------------------------------------------------------------------------------------------------------------

В каких случаях очереди неэффективны?

Конечно, очереди не являются универсальным средством для любых приложений. Рассмотрим варианты, когда очереди не будут самым эффективным решением:

У вашего приложения простая архитектура и функции, и вы не ожидаете его роста. Важно понимать, что очереди сообщений — это дополнительная сложность. Эту систему также необходимо настраивать, поддерживать, осуществлять мониторинг ее работы и так далее. Да, можно использовать Managed-решение, но вряд ли это будет оправдано для небольших приложений. Добавление очередей должно упрощать архитектуру, а не усложнять ее.

Вы используете монолитное программное обеспечение, в котором развязка (Decoupling) невозможна или не приоритетна. Если вы не планируете разбивать монолит на микросервисы, но вам требуется асинхронность — для ее реализации обычно достаточно стандартной многопоточной модели. Очереди могут оказаться избыточным решением до тех пор, пока не возникнет явная необходимость в разделении приложения на автономные компоненты, способные независимо выполнять задачи.

--------------------------------------------------------------------------------------------------------------------

Опишите кратко работу RabbitMQ

Издатель отправляет сообщение определенному обменнику

Обменник, получив сообщение, маршрутизирует его в одну или несколько очередей в соответствии с правилами привязки между ним и очередью

Очередь хранит ссылку на это сообщение. Само сообщение хранится в оперативной памяти или на диске

Как только потребитель готов получить сообщение из очереди, сервер создает копию сообщения по ссылке и отправляет

Потребитель получает сообщение и отправляет брокеру подтверждение

Брокер, получив подтверждение, удаляет копию сообщения из очереди. Затем удаляет из оперативной памяти и с диска

--------------------------------------------------------------------------------------------------------------------

Что такое RPC?

Процесс RPC (remote procedure call) лежит в основе практически всех взаимодействий с ядром RabbitMQ. Например, начальные обсуждения условий клиента с RabbitMQ, демонстрирует определённый процесс RPC. Как только эта последовательность завершится, RabbitMQ будет готов принимать запросы от клиента

Также в спецификации AMQP и клиент и сервер могут вызывать команды. Это означает, что клиент ожидает взаимодействие с сервером. Команды — это классы и методы. Например, Connection.Start - вызов метода Start класса Connection.

--------------------------------------------------------------------------------------------------------------------

Подключение и каналы в RabbitMQ

Для такого обмена информацией между клиентом и сервером используются каналы. Каналы создаются в рамках определенного подключения. Каждый канал изолирован от других каналов. В синхронном случае не возможно выполнять следующую команду, пока не получен ответ.
Для того чтобы иметь возможность отправлять команды параллельно приходится открывать несколько каналов. Каждый канал создает отдельный Erlang процесс. Одно подключение может иметь множество каналов (multiplexing). Для каждого канала существуют некие структуры и объекты в памяти. Поэтому чем больше каналов имеется в рамках соединения, тем больше памяти использует RabbitMQ для управления таким соединением.

--------------------------------------------------------------------------------------------------------------------

Где используется RabbitMQ?

В контексте микросервисов протокол AMQP и его реализацию в RabbitMQ часто используют для асинхронного взаимодействия между сервисами.

Фоновая обработка долгосрочных задач на веб-сайтах
Сюда можно отнести задачи, которые не связаны напрямую с основным действием пользователя сайта и могут быть выполнены в фоновом режиме без необходимости ожидания с его стороны. Это обработка изображений, преобразование видео в различные форматы, создание отзывов, индексирование в поисковых системах после изменения данных, отправка электронной почты, формирование файлов и так далее.

Буферизация при пакетной обработке данных
Очереди можно использовать в качестве буфера для некоторой массовой обработки, например пакетной вставки данных в БД или HDFS. Очевидно, что гораздо эффективнее добавлять сто записей за раз, чем по одной сто раз, так как сокращаются накладные расходы на инициализацию и завершение каждой операции. Но для стандартной архитектуры может стать проблемой генерация данных клиентской службой быстрее, чем их может обработать получатель. Очередь же предоставляет временное хранилище для пакетов с данными, где они будут храниться до завершения обработки принимающей стороной.

Отложенные задачи
Многие системы очередей позволяют производителю указать, что доставка сообщений должна быть отложена. Это может быть полезно при реализации льготных периодов. Например, вы разрешаете покупателю отказаться от размещения заказа в течение определенного времени и ставите отложенное задание в очередь. Если покупатель отменит операцию в указанный срок, сообщение можно удалить из очереди.

Сглаживание пиковых нагрузок
Помещая данные в очередь, вы можете быть уверены, что данные будут сохранены и в конечном итоге обработаны, даже если это займет немного больше времени, чем обычно, из-за большого скачка трафика. Увеличить скорость обработки в таких случаях также возможно — за счет масштабирования нужных обработчиков.

Гарантированная доставка при нестабильной инфраструктуре
Нестабильная сеть в сочетании с очередью сообщений создает надежный системный ландшафт: каждое сообщение будет отправлено, как только это будет технически возможно.

Упорядочение транзакций
Многие брокеры поддерживают очереди FIFO, полезные в системах, где важно сохранить порядок транзакций. Если 1000 человек размещают заказ на вашем веб-сайте одновременно, это может создать некоторые проблемы с параллелизмом и не будет гарантировать, что первый заказ будет выполнен первым. С помощью очереди можно определить порядок их обработки.

Сбор аналитической информации
Очереди часто применяют для сбора некоторой статистики, например использования определенной системы и ее функций. Как правило, моментальная обработка такой информации не требуется. Когда сообщения поступают в веб-службу, они помещаются в очередь, а затем при помощи дополнительных серверов приложений обрабатываются и отправляются в базу данных.

Разбиение трудоемких задач на множество маленьких частей
Если у вас есть некоторая задача для группы серверов, то вам необходимо выполнить ее на каждом сервере. Например, при редактировании шаблона мониторинга потребуется обновить мониторы на каждом сервере, использующем этот шаблон. Вы можете поставить сообщение в очередь для каждого сервера и выполнять их одновременно в виде небольших операций.

--------------------------------------------------------------------------------------------------------------------

Какие остовные сущности RabbitMQ?

Пробежимся по названиям слева направо:
Publisher — публикует (паблишит) сообщения в Rabbit.
Exchange — обменник. Сущность Rabbit, точка входа для публикации всех сообщений.
Binding — связь между Exchange и очередью.
Queue — очередь для хранения сообщений.
Messages — сообщение, атомарная сущность.
Consumer — подписывается на очередь и получает от Rabbit сообщения.

Также встречаются термины:
Publishing — процесс публикования сообщений в обменник.
Consuming — процесс подписывания consumer ***на очередь и получение им сообщений.
Routing Key — свойство Binding.
Persistent — свойство сохранения данных при перезагрузке сервиса (также известное как стейт).

--------------------------------------------------------------------------------------------------------------------

Что такое Exchange?

Exchange — обменник или точка обмена.Является точкой входа и маршрутизатором/роутером всех сообщений (как входящих от Publisher, так и перемещающихся от внутренних процессов в Rabbit). В него отправляются сообщения. Exchange распределяет сообщение в одну или несколько очередей. Он маршрутизирует сообщения в очередь на основе созданных связей (bindings) между ним и очередью.

Неизменяемая сущность: для изменения параметров Exchange нужно его удалять и декларировать заново.

Binding: не являются частью Exchange, можно менять отдельно.

Рассылает сообщение во все очереди с подходящими binding (но не более одного сообщения в одну очередь, если есть несколько подходящих binding).

Durable/Transient — признак персистентности Exchange. Durable означает, что exchange сохранится после перезагрузки Rabbit.

Exchange не подразумевает хранения! Это не очередь. Если маршрут для сообщения не будет найден, сообщение сразу будет отброшено без возможности его восстановления.

Exchange не является Erlang-процессом. Из соображений масштабируемости exchange — это строка (ссылка на модуль с кодом, где лежит логика маршрутизации) во встроенной базе данных mnesia. 1 тысяч обменников будут потреблять всего 1МБ памяти.

--------------------------------------------------------------------------------------------------------------------

Для чего используется Direct Exchange

Direct exchange — используется, когда нужно доставить сообщение в определенные очереди. Сообщение публикуется в обменник с определенным ключом маршрутизации и попадает во все очереди, которые связаны с этим обменником аналогичным ключом маршрутизации (в которых Routing Key binding полностью совпадает с Routing Key Messages). Ключ маршрутизации — это строка. Поиск соответствия происходит при помощи проверки строк на эквивалентность.

В rabbitmq существует понятие обменник по умолчанию. Это direct exchange без имени. Если применяется обменник по умолчанию, то сообщение будет маршрутизироваться в очередь с именем равным ключу маршрутизации сообщения.

Наиболее популярный тип, по скорости сравнимый с fanout (на тестах не увидел разницы) и при этом обладающий необходимой гибкостью для большинства задач.

--------------------------------------------------------------------------------------------------------------------

Для чего используется Topic Exchange

Topic exchange - аналогично direct exchange дает возможность осуществления выборочной маршрутизации путем сравнения ключа маршрутизации. Но, в данном случае, ключ задается по шаблону. При создании шаблона используются 0 или более слов (буквы AZ и az и цифры 0-9), разделенных точкой, а также символы * и #.
* — может быть заменен на ровно 1 слово
# — может быть заменен на 0 или более слов

Начиная с версии RabbitMQ 2.4.0 алгоритм маршрутизации для topic exchange стал работать до 145 раз быстрее. Добились они этого путем внедрения подхода trie implementation, который подразумевает представление шаблонов в виде структуры дерева.
Поиск соответствия шаблону осуществляется, начиная с корня и следуя сверху вниз.

Особенности:
применение этого обменника может стать хорошим выбором для возможного будущего развития приложения, т.к. шаблоны всегда можно настроить так, чтобы сообщение публиковалось аналогично direct exchange или fanout exchange

шаблоны, которые используют * намного быстрее, чем шаблоны, которые используют #.

topic exchange медленнее direct exchange

Производительность топика на тестах показала скорости в три раза ниже fanaut/direct — не более 5000-10000mps

--------------------------------------------------------------------------------------------------------------------

Для чего используется Fanout Exchange

Fanout exchange - все сообщения доставляются во все очереди даже если в сообщении задан ключ маршрутизации.

Особенности:
RabbitMQ не работает с ключами маршрутизации и шаблонами что положительно влияет на
производительность. Это самый быстрый exchange;

все потребители должны иметь возможность обрабатывать все сообщения;

Самый простой тип и наименее функциональный. Редко бывает нужен. По скоростям выдает на тестах около 30000mps, но столько же выдает и тип Direct.

--------------------------------------------------------------------------------------------------------------------

Для чего используется Headers Exchange?

Headers exchange — направляет сообщения в связанные очереди на основе сравнения пар (ключ, значение) свойства headers привязки и аналогичного свойства сообщения. Наиболее гибкий, но наименее производительный тип. Скорости очень сильно зависят от сложности условий и поэтому трудно прогнозируемы. Оперирует не Routing key, а заголовками сообщений и binding. В binding указываются ожидаемые заголовки, а также признак x-match. headers представляет собой Dictionary<ключ, значение>.

Если в словарь добавить специальный ключ x-match со значением any, то сообщение маршрутизируется при частичном совпадении пар (ключ, значение). Данное поведение аналогично оператору or.
По умолчанию ключ x-match содержит значение all. Это означает, что сообщение маршрутизируется при полном совпадении пар (ключ, значение). Данное поведение аналогично оператору and.

Особенности:
дополнительная гибкость
дополнительные накладные расходы на вычисление. Все пары (ключ, значение) атрибута headers должны сортироваться по имени ключа перед вычислением значений маршрутизации сообщения. Медленнее, чем прочие типы exchange.

--------------------------------------------------------------------------------------------------------------------

Для чего используется Consistent-Hashing Exchange?

Данный обменник является плагином и не встроен в RabbitMQ.
Consistent-hashing exchange (exchange с согласованным хешированием) - используется, когда есть несколько очередей, являющихся потенциальными получателями сообщения, и когда нужно сбалансировать нагрузку между ними. Связь сообщения с очередью происходит по весу (условное строковое значение от 0 - n).

Эквивалентный вес очередей - говорит о том, что в каждую очередь придет примерно одинаковое количество сообщений (каждое сообщение будет помещено только в одну очередь). Полной гарантии равномерного распределения сообщений нет.

Hash вычисляется на основе ключа маршрутизации или свойства headers сообщения. Если все публикуемые сообщения имели разные ключи маршрутизации или headers, то распределение будет происходить по весу. Иначе будет использоваться ключ маршрутизации или headers.

Должен помогать, когда пропускная способность потребителя нуждается в росте более высоком чем решение с несколькими потребителями, использующими одну очередь.

--------------------------------------------------------------------------------------------------------------------

Можно ли комбинировать Exchange?

Поведение всех обменников можно комбинировать при помощи связи Exchange-to-Exchange (комбинирование обменников не входит в спецификацию AMQP. Это расширение протокола со стороны RabbitMQ).

За счет E2E мы можем найти правильную масштабируемую конфигурацию, которая отвечает как текущим, так и растущим требованиям.

--------------------------------------------------------------------------------------------------------------------

Какие у Exchange есть параметры?

exchange — название обменника, который мы хотим создать. Название должно быть уникальным

type — тип обменника

durable — если установить true, то exchange будет являться постоянным. Он будет храниться на диске и сможет пережить перезапуск сервера/брокера. Если значение false, то exchange является временным и будет удаляться, когда сервер/брокер будет перезагружен

autoDelete — автоматическое удаление. Exchange будет удален, когда будут удалены все связанные с ним очереди

arguments — необязательные аргументы. Чаще всего, через аргументы задают alternative exchange (альтернативный обменник). Если сообщение не может пройти по первоначальному маршруту, ее можно отправить в альтернативный обменник для маршрутизации по другому пути.

--------------------------------------------------------------------------------------------------------------------

Что такое Binding?

Binding - Базовая сущность Rabbit, статический маршрут от Exchange до Queue (от обменника до очереди). Правило, которое сообщает обменнику в какую из очередей должны попадать сообщения.

Неизменяемая сущность: если нужно изменить binding, его удаляют и декларируют заново.

Bindings между парой exchange-очередь может быть несколько, но только с разными параметрами.

Параметры binding — или routingkey, или headers — в зависимости от типа Exchange.

--------------------------------------------------------------------------------------------------------------------

Какие параметры есть у Binding

queue — имя очереди
exchange — имя обменника
routingKey — ключ маршрутизации
arguments — необязательные аргументы

--------------------------------------------------------------------------------------------------------------------

Расскажите про Queue в RabbitMQ

Queue - Базовая сущность RabbitMQ, представляет из себя последовательное хранилище для необработанных сообщений.

Хранение сообщений на диске (persistent) зависит от флага delivery_mode, назначаемым publisher для каждого сообщения.

Durable/Transient — признак персистентности очереди. Durable значит, что exchange сохранится после перезагрузки Rabbit.

Важно понимать, что даже если вы отправили сообщения с признаком delivery_mode=2 (persistent), но очередь задекларирована не как Durable, то при перезагрузке Rabbit очередь и все содержащиеся в ней сообщения будут безвозвратно утрачены

Есть три типа очередей:
Classic — обычная очередь, используется в большинстве случаев.
Quorum — аналог классической очереди, но с обеспечением гарантий консистентности, достигаемый кворумом в кластере.
Stream — новый вид очередей (начиная с версии Rabbimq 3.9), пока ещё мало кем используемый, аналог принципов Apache Kafka.

--------------------------------------------------------------------------------------------------------------------

Какие параметры есть у Queue

queue — название очереди, которую мы хотим создать. Название должно быть уникальным и не может совпадать с системным именем очереди

durable — если true, то очередь будет сохранять свое состояние и восстанавливается после перезапуска сервера/брокера

exclusive — если true, то очередь будет разрешать подключаться только одному потребителю

autoDelete — если true, то очередь обретает способность автоматически удалять себя

arguments — необязательные аргументы.

--------------------------------------------------------------------------------------------------------------------

Возможные аргументы для Queue?

x-message-ttl(x-message-time-to-live) — позволяет установить время истечения срока жизни сообщения в миллисекундах. Если создание очереди происходит с установленным значением аргумента x-message-ttl, то такая очередь будет автоматически исключать сообщения, у которых истек срок действия. Установка значения аргумента x-message-ttl задает максимальный возраст для всех сообщений в данной очереди. Создание такой очереди позволяет предотвратить получение устаревшей информации. Это можно использовать в системах реального времени. Если у очереди для которой задан обменник для отклоненных сообщений установить значение аргумента x-message-ttl, то отклоненные сообщения в данной очереди начнут обладать сроком жизни.

x-expires — задает значение в миллисекундах по истечению которого происходит удаление очереди. Очередь может израсходовать срок своего действия только если она не имеет никаких подписчиков. Если к очереди подключены подписчики, она сможет автоматически удалиться только тогда, когда все подписчики вызовут Basic.Cancel или отсоединятся. Срок жизни очереди может завершиться только в том случае, если к ней не было запроса Basic.Get. Иначе текущее значение установки времени жизни обнуляется, и очередь больше не будет автоматически удаляться. Также нет гарантий того, насколько быстро происходит удаление очереди после истечения её срока жизни.

x-max-length — задает максимальное число сообщений в очереди. Если число сообщений в очереди начинает превышать макимальное чило, то начинают удаляться самые старые

x-max-lenght-bytes — задает максимально допустимый суммарный размер полезной нагрузки сообщений в очереди. При превышении установленного значения (возникло переполнение очереди при очередной публикации сообщения) самые старые сообщения начнут удаляться

x-overflow — данный аргумент используется для настройки поведения в результате переполнения очереди. Доступны два значения: drop-head (значение по умолчанию) и reject-publish. Если выбрать drop-head, то самые старые сообщения будут удаляться. Если выбрать reject-publish, то прием сообщений будет приостановлен

x-dead-letter-exchange — задает exchange, в который направляются отвергнутые сообщения, которые не поставлены повторно в очередь

x-dead-letter-routing-key — задает не обязательный ключ маршрутизации для отвергнутых сообщений

x-max-priority — разрешает сортировку по приоритетам в очереди с максимальным значением приоритета 255 (RabbitMQ версий 3.5.0 и выше). Число указывает максимальный приоритет, который будет поддерживать очередь. Если аргумент не установлен, очередь не будет поддерживать приоритет сообщений

x-queue-mode — позволяет перевести очередь в ленивый режим. В таком режиме как можно больше сообщений будет храниться на диске. Использование оперативной памяти будет минимально. В случае, если он не установлен, очередь будет хранить сообщения в памяти, чтобы доставлять сообщения максимально быстро

x-queue-master-locator — если у нас кластер, то можно задать мастер очередь

x-ha-policy — используется при создании HA очередей и определяет как сообщение будет распространяться по узлам. Если установлено значение all, то сообщение будет сохраняться на всех узлах. Если установлено значение nodes, то сообщение будет сохраняться на определенных узлах кластера

x-ha-nodes — задает узлы, к которым будет относиться некая очередь HA

--------------------------------------------------------------------------------------------------------------------

Как создать временную очередь?

Если создание очереди происходит с установленным параметром autoDelete, то такая очередь обретает способность автоматически удалять себя. Такие очереди обычно создаются в момент подключения первого клиента и удаляются в момент, когда все клиенты отсоединились.

Если создание очереди происходит с установленным параметром exclusive, то такая очередь разрешает подключаться только одному потребителю и удаляется если закроется канал. До тех пор пока канал не закроется, клиент может отключаться/подключаться, но только в рамках того же самого соединения. Если параметр exclusive установлен, то параметр autoDelete не имеет никакого эффекта.

Особенности:
при кратковременном разрыве связи мы будем терять сообщения, которые ещё не успели дойти до потребителя

можно поймать феномен binding churn. Феномен возникает, когда количество операций по созданию/удалению очередей и привязок достигает очень больших значений. В кластерном режиме такой поток операций будет расползаться по всем узлам и создаст большую нагрузку. Данный процесс можно оптимизировать за счет контроля количества подписок

--------------------------------------------------------------------------------------------------------------------

Как создать постоянную очередь?

Если создание очереди происходит с установленным параметром durable, то такая очередь сохраняет свое состояние и восстанавливается после перезапуска сервера/брокера. Данная очередь будет существовать до тех пор пока не будет вызвана команду Queue.Delete.

--------------------------------------------------------------------------------------------------------------------

Расскажите про Message

Message - Базовая сущность RabbitMQ — само сообщение, несёт полезную нагрузку (payload), проходит весь путь от Publisher до Consumer.

Message состоит из 3 фреймов(сообщений) в каждом из которых передаётся разная информация.

Фрейм состоит из:

1) Типа фрейма

2) Номера канала

3) Размера фрейма в байтах

4) Полезной нагрузки фрейма

5) Маркера завершающего байта (ASCII значение 206)

Первый фрейм передаёт мета информацию для RabbitMq, чтобы он мог маршрутизировать это сообщение 
Второй фрейм передаёт headers нашего сообщения
Третий и последующие фреймы передают полезную нагрузку, одно сообщение может быть раздроблено на несколько фреймов в соответствии с настройками.

Важные поля:
app-id - Полезно для задания приложения, опубликовавшего данные сообщения

content-encoding - Определяет кодируется ли тело сообщения особым образом, например, с помощью zlib, deflate или Base64.

content-type - Определяет тип данного сообщения с использованием типа MIME.

correlation-id - Если данное сообщение ссылается на некое другое сообщение или уникально указываемое им, correlation-id является хорошим способом указания на то, на что ссылается данное сообщение.

delivery-mode - Значение 1 сообщает RabbitMQ, что тот может оставлять данное сообщение в оперативной памяти, 2 указывает что его также следует записать на диск.

expiration - Значение штампа времени эпохи Unix в виде текстовой строки, которое указывает когда истекает срок действия данного сообщения.

headers - Таблица ключ/ значение в произвольном виде, которую вы можете применять для добавления дополнительных метаданных о своём сообщении; RabbitMQ, может выполнять маршрутизацию на основании их при вашем желании на то.

message-id - Уникальный идентификатор, такой как UUID, который ваше приложение может применять для указания данного сообщения.

priority - Свойство для определения значения приоритета в очередях.

timestamp - Значение эпохи или временного штампа Unix, которое может применяться для указания того, когда это сообщение было создано.

type - Текстовая строка, которую ваше приложение иожет применять для описания типа самого сообщения или его полезной нагрузки.

user-id - Строка в произвольном виде, которую, если она используется, RabbitMQ будет проверять для сопоставления с подключённым сообщением и удалять данное сообщение в случае несоответствия.

--------------------------------------------------------------------------------------------------------------------
Расскажите про Publisher в RabbitMQ

Publisher - Внешнее приложение (крон/вебсервис/что угодно), генерирующее сообщения в RabbitMQ для дальнейшей обработки.
Создаёт соединение (connection) по протоколу AMQP, в рамках соединения создаёт канал (channel). В рамках одного соединения можно создать несколько каналов, но это не рекомендуется даже официальной документацией RabbitMQ.
«Флаппинг» каналов: если Publisher для каждого сообщения создаёт соединение, канал, отправляет сообщение, закрывает канал, закрывает соединение, это очень плохая история. Rabbit становится плохо уже на ~300 таких пересозданий каналов в секунду. Будьте внимательны. Если нет возможности изменить Publisher, можно использовать amqproxy.

Важное замечание: не следует использовать amqproxy для consumer, есть проблемы одностороннего разрушения соединений.

Publisher может декларировать практически все сущности — exchanges, queues, bindings и др. На практике лучше подходит стратегия декларирования всех нужных сущностей consumer, но решать нужно для каждого проекта индивидуально.

Publisher всегда пишет в exchange. Даже если вы думаете, что он пишет напрямую в очередь, это не так. Он пишет в служебный exchange с routing key, совпадающим с названием очереди.

Publisher определяет delivery_mode для каждого сообщения — так называемый «признак персистентности». Это значит, что сообщение будет сохранено на диске и не исчезнет в случае перезагрузки Rabbit.
delivery_mode=1 — не хранить сообщения, быстрее.
delivery_mode=2 — хранить сообщения на диске, медленнее, но надёжнее.

Также publisher определяет Routing Key для каждого сообщения — признак, по которому идёт дальнейшая маршрутизация в Rabbit.

Publisher может выставлять confirm флаг — отправлять указания Rabbitmq через отдельный канал подтверждения об успешной приёмке сообщений. Например, если у Rabbit закончится место на диске, то некоторое время он ещё будет принимать сообщения от Publisher. Publisher будет думать, что всё в порядке, хотя сообщения с высокой долей вероятности не дойдут до Consumer и не сохранятся в очереди для дальнейшей обработки. Полезная вещь, но ощутимо снижает скорость работы и сложно реализуема в однопоточных языках разработки.

Также есть флаг mandatory — указание Rabbit складировать сообщения, не имеющие маршрута в какую-либо очередь в отдельный Exchange. Редкий и мало используемый кейс.

--------------------------------------------------------------------------------------------------------------------
Как общается Publisher при публикации Message с RabbitMq?

При публикации сообщения в RabbitMQ отправляются три кадра: метод Basic.Publish, заголовок содержимого и тело сообщения. RabbitMQ проверяет информацию из кадра Basic.Publish перед выполнением следующих шагов. Этот кадр содержит название обмена и ключ маршрутизации. RabbitMQ ищет соответствие имени обмена в своей базе данных обменов.

После определения соответствующего обмена, RabbitMQ вычисляет связывание и находит соответствующие очереди по ключу маршрутизации. Если сообщение соответствует какой-либо очереди, оно помещается в очередь по правилу FIFO. Вместо помещения реального сообщения в структуру данных, в очередь добавляется ссылка на него. При доставке, RabbitMQ использует ссылку для формирования упорядоченного сообщения.

Это оптимизирует публикацию для множества получателей, уменьшая использование памяти.

--------------------------------------------------------------------------------------------------------------------
Расскажите про Consumer

Замыкает обработку Сonsumer — демон, получающий сообщения из Queue и выполняющий ту самую логику, ради которой сообщение проделало весь этот путь. Например, отправка уведомления, запись в базу данных, генерация оффлайн отчёта или отправка сообщения в другую Queue.

Так же, как и Publisher, Consumer создаёт соединение (connection) по протоколу AMQP. В рамках соединения создаёт канал (channel) и уже инициирует consuming в рамках этого канала.

Consumer может декларировать практически все сущности — exchanges, queues, bindings и тд. На практике мы стараемся декларировать все сущности именно Consumer, но решать нужно для каждого проекта индивидуально.

Consumer подписывается только на одну очередь. Если вы хотите получать сообщения из разных очередей, правильнее будет корректно смаршрутизировать их потоки в одну очередь, чем городить пулы Consumer внутри приложения.

Сообщения в Consumer попадают по push-модели — протакливаются Rabbit в канал по мере их появления и (или) освобождения Consumer. Никакой периодики, задержки — это жирный плюс.

Prefetch count — важный параметр Consumer, обозначающий количество неподтверждённых Consumer сообщений в один момент. По умолчанию во многих библиотеках он равен 0 (по сути отключен). В такой ситуации Rabbit проталкивает все сообщения из очереди в Consumer, а тот во многих случаях при достаточном количестве сообщений просто отъезжает.

Если нет понимания, какое значение ставить, лучше ставить «1» — пока Consumer не обработает одно сообщение, следующее к нему не поступит. Как только Rabbit подтвердит обработку, следующее сообщение будет получено незамедлительно.

Когда вы поймёте, что у вас есть мультитред, и вы можете обрабатывать большие нагрузки, вы поднимете этот параметр, но уже осознанно.

Consumer может подтвердить обработку сообщения — механизм Acknowledge (ack). Или вернуть сообщение в Queue при неудачной обработке — механизм Negative acknowledge (nack).

Механизм nack также срабатывает автоматически при разрушении канала к Consumer. Это удобно использовать: если на горячую выключить Consumer, сообщения, которые он обрабатывал, автоматически вернутся в очередь.

AutoAck — флаг автоматического подтверждения всех протакливаемых сообщений (не требует ack от Consumer). Работает быстро, но не даёт никаких гарантий успешной обработки сообщений.

--------------------------------------------------------------------------------------------------------------------

Как общается Consumer при получении Message?

После вызова Basic.Consume, потребитель остается активным, пока не произойдет одно из нескольких событий. Потребитель может остановить прием сообщений, вызвав команду Basic.Cancel. Важно отметить, что эта команда выполняется асинхронно, поэтому потребитель может продолжать получать сообщения, отправленные до получения кадра отклика Basic.CancelOk.

В процессе потребления сообщений есть настройки, позволяющие определить, каким образом они будут получены. Одна из таких настроек - аргумент no_ack для команды Basic.Consume. Если установлен в true, RabbitMQ будет отправлять сообщения до отмены потребителем или его отсоединения. При установке в false, потребитель должен подтверждать прием каждого сообщения с помощью запроса RPC Basic.Ack.

Кадр отклика Basic.Ack, отправляемый при успешной доставке сообщения, содержит маркер доставки (delivery tag) из кадра метода Basic.Deliver.
--------------------------------------------------------------------------------------------------------------------

Какие типы получения Message реализует RabbitMq?

В RabbitMq существует 2 типа получения: pushing и pulling

pushing - быстрый вариант общения с брокером, когда он сам пушит во все Consumer(публикация-подписка), могут быть проблемы, когда сервис "захлёбывается" в Message.

pulling - более медленный вариант, когда сервис сам выбирает количество Message, которое он хочет обработать.

--------------------------------------------------------------------------------------------------------------------
Как работают FIFO очереди в Rabbit

Основу Rabbit представляют собой именно такие очереди

Попадая в очередь, сообщения выходят из неё в той же последовательности, что и вошли. Последовательность определяется моментом попадания сообщения в очередь, не бывает «одновременных сообщений» в рамках одной очереди, у них всегда есть порядок.

После выстраивания очереди по порядку мы переходим к «обслуживанию» этой очереди. Для этого подключается Consumer (например, как открытие одного кабинета в очереди к врачу).

Если мы не укажем prefetch_count, его значение будет равным нулю. Это значит, что все сообщения протолкнутся в Consumer — ничего хорошего обычно в таком поведении нет. Аналогия: открылся кабинет, и все люди в очереди ввалились туда решать свои вопросы.

Поэтому мы явно укажем prefetch_count=1. Теперь без подтверждения более одного сообщения в Consumer находится не сможет.

Далее после успешной обработки Consumer выполняет «ack» для данного сообщения:

Получив ack, Rabbit удалит сообщение из очереди и незамедлительно протолкнёт в Consumer следующее сообщение (и так далее):

А если мы захотим увеличить скорость обработки? Можем поставить в «кабинете» ещё один «стол с врачом». Для этого укажем prefetch_count=2

Теперь будет идти обработка сразу двух сообщений. А если мы хотим быстрее? Добавляем ещё один сonsumer-кабинет (например с prefetch_count=1)

Общая концепция горизонтальной масштабируемости выглядит именно так.

--------------------------------------------------------------------------------------------------------------------

Устойчивость очереди В RabbitMQ

В RabbitMQ два типа очереди: длительные/устойчивые (durable) и неустойчивые (non-durable). Все очереди сохраняются в базе данных Mnesia. Устойчивые очереди повторно объявляются при запуске узла и, таким образом, переживают перезапуск, сбой системы или сбой сервера (до тех пор, пока сохраняются данные). Это означает, что пока вы декларируете маршрутизацию (exchange) и очередь устойчивыми, инфраструктура очередей/маршрутизации вернется в оперативный режим.Неустойчивые очереди и маршрутизация удаляются при перезапуске узла.

Одно то, что очередь долговечна, не означает, что все её сообщения переживут перезапуск узла. Будут восстановлены только сообщения, установленные паблишером как устойчивые (persistent). Устойчивые сообщения действительно создают дополнительную нагрузку на брокера, но если потеря сообщения неприемлема, то другого выхода нет.

--------------------------------------------------------------------------------------------------------------------

Как переживает потерю брокера RabbitMQ

Чтобы пережить потерю брокера, нам нужна избыточность. Можем объединить несколько узлов RabbitMQ в кластер, а затем добавить дополнительную избыточность путём репликации очередей между несколькими узлами. Таким образом, если падает один узел, мы не теряем данные и остаёмся доступными.

Зеркалирование очереди:
одна главная очередь (мастер), которая получает все команды на запись и чтение

одно или несколько зеркал, которые получают все сообщения и метаданные из главной очереди. Эти зеркала существуют не для масштабирования, а исключительно для избыточности.

Зеркалирование устанавливается соответствующей политикой. В ней можно выбрать коэффициент репликации и даже узлы, на которых должна размещаться очередь.

Примеры:
ha-mode: all
ha-mode: exactly, ha-params: 2 (один мастер и одно зеркало)
ha-mode: nodes, ha-params: rabbit@node1, rabbit@node2

--------------------------------------------------------------------------------------------------------------------

Как RabbitMQ уменьшает вероятность потери сообщения?

Для достижения последовательной записи необходимы подтверждения паблишеру (Publisher Confirms). Без них есть вероятность потери сообщений. Подтверждение отправляется паблишеру после записи сообщения на диск. RabbitMQ записывает сообщения на диск не при получении, а на периодической основе, в районе нескольких сотен миллисекунд. Когда очередь зеркалируется, подтверждение отправляется только после того, как все зеркала также записали свою копию сообщения на диск. Это означает, что использование подтверждений добавляет задержку, но если безопасность данных важна, то они необходимы.

--------------------------------------------------------------------------------------------------------------------

Что происходит когда брокер завершает работу или падает

Когда брокер завершает работу или падает, все ведущие очереди (мастера) на этом узле отваливаются вместе с ним. Затем кластер выбирает самое старое зеркало каждого мастера и продвигает его в качестве нового мастера.

У нас есть 3 брокера с распределенными между ними очередями.
Брокер 1 очереди:
Очереди А зеркало,
Очереди B мастер,
Очереди D мастер без зеркал,

Брокер 2 очереди:
Очереди А мастер,
Очереди B зеркало,
Очереди C зеркало,

Брокер 3 очереди:
Очереди А зеркало,
Очереди B зеркало,
Очереди C мастер,

Брокер 3 падает. Зеркало Очереди С на Брокере 2 повышается до мастера. Также для Очереди C создано новое зеркало на Брокере 1. RabbitMQ всегда пытается поддерживать коэффициент репликации, указанный в ваших политиках.

Падает следующий Брокер 1! У нас остался только один брокер. До мастера повышается зеркало Очереди B.

Мы вернули Брокера 1. Независимо от того, насколько успешно данные пережили потерю и восстановление брокера, все зеркалированные сообщения очереди отбрасываются при перезапуске. Это важно отметить, поскольку будут последствия. Мы скоро рассмотрим эти последствия. Таким образом, Брокер 1 теперь снова является членом кластера, а кластер пытается соблюдать политики и поэтому создает зеркала на Брокере 1.
В этом случае потеря Брокера 1 была полной, как и данных, поэтому незеркалированная Очередь D потеряна полностью.

Брокер 3 вернулся в строй, так что очереди A и B получают обратно созданные на нём зеркала, чтобы удовлетворить своим политикам HA. Но теперь все главные очереди на одном узле! Это не идеально, лучше равномерное распределение между узлами. К сожалению, здесь нет особых вариантов для перебалансировки мастеров. Вернемся к этой проблеме позже, так как сначала нужно рассмотреть синхронизацию очереди.

Таким образом, теперь у вас должно быть представление, как зеркала обеспечивают избыточность и отказоустойчивость. Это гарантирует доступность в случае отказа одного узла и защищает от потери данных. Но мы еще не закончили, потому что на самом деле всё гораздо сложнее.

--------------------------------------------------------------------------------------------------------------------

Синхронизация в RabbitMQ

При создании нового зеркала все новые сообщения всегда будут реплицироваться на это зеркало и любые другие. Что касается существующих данных в главной очереди, мы можем их реплицировать в новое зеркало, которое становится полной копией мастера. Мы также можем не реплицировать существующие сообщения и позволить главной очереди и новому зеркалу сходиться во времени, когда новые сообщения поступают в хвост, а существующие сообщения уходят из головы главной очереди.Такая синхронизация выполняется автоматически или вручную и управляется с помощью политики очередей. Рассмотрим пример.

У нас есть 3 брокера с распределенными между ними очередями.
Брокер 1 очереди:
Очереди А зеркало,
Очереди B мастер

Брокер 2 очереди:
Очереди А мастер,
Очереди B зеркало,

Брокер 3 очереди:
Очереди А зеркало,
Очереди B зеркало,

У нас две зеркалированные очереди. Очередь A синхронизируется автоматически, а Очередь B — вручную. В обеих очередях по десять сообщений.

Теперь мы теряем Брокера 3

Брокер 3 возвращается в строй. Кластер создает зеркало для каждой очереди на новом узле и автоматически синхронизирует новую Очередь А с мастером. Однако зеркало новой Очереди В остается пустым. Таким образом, у нас полная избыточность Очереди A и только одно зеркало для существующих сообщений Очереди B.

В обе очереди поступает ещё по десять сообщений. Затем Брокер 2 падает, а Очередь А откатывается к самому старому зеркалу, которое находится на Брокере 1. При сбое не происходит потери данных. В Очереди B двадцать сообщений в мастере и только десять в зеркале, поскольку эта очередь никогда не реплицировала исходные десять сообщений.

В обе очереди поступает еще по десять сообщений. Теперь падает Брокер 1. Очередь A без проблем переключается на зеркало без потери сообщений. Однако у Очереди В возникают проблемы. На этом этапе мы можем оптимизировать либо доступность, либо согласованность.Если мы хотим оптимизировать доступность, то политику ha-promote-on-failure следует установить в always. Это значение по умолчанию, поэтому можно просто не указывать политику вообще. В таком случае, по сути, мы допускаем сбои в несинхронизированных зеркалах. Это приведет к потере сообщений, но очередь остается доступной для чтения и записи.

Мы также можем установить ha-promote-on-failure в значение when-synced. В этом случае вместо отката на зеркало очередь будет дожидаться, пока Брокер 1 со своими данными вернётся в оперативный режим. После его возвращения главная очередь снова оказывается на Брокере 1 без потери данных. Доступность приносится в жертву безопасности данных. Но это рискованный режим, который может привести даже к полной потере данных, что мы рассмотрим в ближайшее время.

--------------------------------------------------------------------------------------------------------------------

Может, лучше никогда не использовать автоматическую синхронизацию?

Ответ заключается в том, что синхронизация является блокирующей операцией. Во время синхронизации главная очередь не может выполнять никаких операций чтения или записи!

Рассмотрим пример. Сейчас у нас очень большие очереди. Как они могут вырасти до такого размера?
По нескольким причинам:
Очереди не используются активно

Это высокоскоростные очереди, а прямо сейчас потребители работают медленно

Это высокоскоростные очереди, произошел сбой, и потребители догоняют

Имеем
У нас есть 3 брокера с распределенными между ними очередями.
Брокер 1 очереди:
Очереди А зеркало,
Очереди B мастер

Брокер 2 очереди:
Очереди А мастер,
Очереди B зеркало,

Брокер 3 очереди:
Очереди А зеркало,
Очереди B зеркало,

У нас две зеркалированные очереди. Очередь A синхронизируется автоматически, а Очередь B — вручную. В обеих очередях по 100 сообщений.


Теперь падает Брокер 3.

Брокер 3 возвращается в строй, и создаются новые зеркала. Главная Очередь А начинает реплицировать существующие сообщения на новое зеркало, и в течение этого времени Очередь недоступна. Для репликации данных требуется два часа, что приводит к двум часам простоя для этой Очереди!
Однако Очередь B остается доступной в течение всего периода. Она пожертвовала некоторой избыточностью ради доступности.

Через два часа Очередь A тоже становится доступной и может снова начать принимать операции чтения и записи.

--------------------------------------------------------------------------------------------------------------------

Правила поведения при отключении брокера

Блокирующее поведение во время синхронизации затрудняет обновление кластеров с очень большими очередями. В какой-то момент узел с мастером нужно перезапустить, что означает либо переход на зеркало, либо отключение очереди во время обновления сервера. Если мы выберем переход, то потеряем сообщения, если зеркала не синхронизированы. По умолчанию во время отключения брокера переход на несинхронизированное зеркало не выполняется. Это означает, что как только брокер возвращается, мы не теряем никаких сообщений, единственным ущербом стал только простой очереди. Правила поведения при отключении брокера задаются политикой ha-promote-on-shutdown.
Можно установить одно из двух значений:

always= включен переход на несинхронизированные зеркала
when-synced= переход только на синхронизированное зеркало, иначе очередь становится недоступной для чтения и записи. Очередь возвращается в строй, как только вернется брокер

Так или иначе, с большими очередями приходится выбирать между потерей данных и недоступностью.

--------------------------------------------------------------------------------------------------------------------

Проблемы с ha-promote-on-failure=when-synced

Идея ha-promote-on-failure= when-synced заключается в том, что мы предотвращаем переключение на несинхронизированное зеркало и тем самым избегаем потери данных. Очередь остается недоступной для чтения или записи. Вместо этого мы пытаемся вернуть упавший брокер с неповрежденными данными, чтобы он возобновил работу в качестве мастера без потери данных.
Но (и это большое но) если брокер потерял свои данные, то у нас большая проблема: очередь потеряна! Все данные пропали! Даже если у вас есть зеркала, которые в основном догоняют главную очередь, эти зеркала тоже отбрасываются.

Чтобы заново добавить узел с тем же именем, мы говорим кластеру забыть потерянный узел (командой rabbitmqctl forget_cluster_node) и запустить новый брокер с тем же именем хоста. Пока кластер помнит потерянный узел, он помнит старую очередь и несинхронизированные зеркала. Когда кластеру говорят забыть потерянный узел, эта очередь также забывается. Теперь нужно заново его объявить. Мы потеряли все данные, хотя у нас были зеркала с частичным набором данных. Лучше было бы перейти на несинхронизированное зеркало!

Поэтому ручная синхронизация (и невыполнение синхронизации) в сочетании с ha-promote-on-failure=when-synced, на мой взгляд, довольно рискованна. Документы говорят, что такой вариант существует для безопасности данных, но это обоюдоострый нож.

--------------------------------------------------------------------------------------------------------------------

Как происходит перебалансировка мастеров

Существует проблема скопления всех мастеров на одном или нескольких узлах. Это может произойти даже в результате «скользящего» (rolling) обновления кластера. В кластере с тремя узлами все главные очереди скопятся на одном или двух узлах.

Перебалансировка мастеров может оказаться проблематичной по двум причинам:

Нет хороших инструментов для выполнения перебалансировки
Синхронизация очередей

Для перебалансировки есть сторонний плагин, который не поддерживается официально. Относительно сторонних плагинов в руководстве RabbitMQ сказано: «Плагин предоставляет некоторые дополнительные инструменты настройки и отчётности, но не поддерживается и не проверен командой RabbitMQ. Используйте на свой страх и риск».

Есть еще один трюк, чтобы переместить главную очередь через политики HA. В руководстве упоминается скрипт для этого. Он работает следующим образом:

Удаляет все зеркала с помощью временной политики с более высоким приоритетом, чем существующая политика HA.

Изменяет временную политику HA для использования режима «узлы» с указанием узла, на который требуется перенести главную очередь.

Синхронизирует очередь для принудительной миграции.

После завершения миграции удаляет временную политику. Вступает в действие исходная политика HA и создается нужное количество зеркал.

Недостаток в том, что такой подход может не сработать, если у вас большие очереди или строгие требования к избыточности.

--------------------------------------------------------------------------------------------------------------------

Нарушение связности RabbitMQ

Узлы распределенной системы соединяются сетевыми связями, а сетевые связи могут и будут отключаться. Частота отключений зависит от локальной инфраструктуры или надежности выбранного облака. В любом случае, распределенные системы должны быть в состоянии справиться с ними. Снова перед нами выбор между доступностью и согласованностью, и снова хорошая новость в том, что RabbitMQ обеспечивает оба варианта (просто не одновременно).

С RabbitMQ у нас две основных опции:

Разрешить логическое разделение (split-brain). Это обеспечивает доступность, но может спровоцировать потерю данных.

Запретить логическое разделение. Может привести к краткосрочной потере доступности в зависимости от способа подключения клиентов к кластеру. Также может привести к полной недоступности в кластере из двух узлов.

Но что такое логическое разделение? Это когда кластер разделяется надвое из-за потери сетевых связей. На каждой стороне зеркала повышаются до мастера, так что в итоге на каждую очередь приходится несколько мастеров.

Если паблишеры отправляют данные в оба мастера, у нас получится две расходящиеся копии очереди.

--------------------------------------------------------------------------------------------------------------------

Какие существуют режимы в RabbitMQ которые обеспечивают либо доступность, либо согласованность.

Режим Ignore (по умолчанию)
Режим Autoheal
Режим Pause Minority

--------------------------------------------------------------------------------------------------------------------

Расскажите про режим Ignore

Этот режим обеспечивает доступность. После потери связности происходит логическое разделение. После восстановления связности администратор должен решить, какому разделу отдать предпочтение. Проигравшая сторона будет перезапущена, и все накопленные данные с этой стороны теряются.

Имеем Три паблишера связаны с тремя брокерами

Теперь мы теряем Брокера 3. Он видит, что другие брокеры отвалились, и продвигает свое зеркало до мастера. Так происходит логическое разделение

Связность восстанавливается, но логическое разделение остается. Администратор должен вручную выбрать проигравшую сторону. В приведенном ниже случае администратор перезагружает Брокера 3. Теряются все сообщения, которые тот не успел передать.

Во время потери связности и после её восстановления кластер и эта очередь были доступны для чтения и записи.

--------------------------------------------------------------------------------------------------------------------

Расскажите про режим Autoheal

Работает аналогично режиму Ignore, за исключением того, что сам кластер автоматически выбирает проигравшую сторону после разделения и восстановления связности. Проигравшая сторона возвращается в кластер пустой, а очередь теряет все сообщения, которые были отправлены только на ту сторону.

--------------------------------------------------------------------------------------------------------------------

Расскажите про режим Pause Minority

Если мы не хотим допустить логического разделения, то наш единственный вариант — отказаться от чтения и записи на меньшей стороне после раздела кластера. Когда брокер видит, что находится на меньшей стороне, то приостанавливает работу, то есть закрывает все существующие соединения и отказывается от любых новых. Один раз в секунду он проверяет восстановление связности. Как только связность восстановлена, он возобновляет работу и присоединяется к кластеру.

Имеем Три паблишера связаны с тремя брокерами.

Затем Брокеры 1 и 2 отделяются от Брокера 3. Вместо того, чтобы повышать свое зеркало до мастера, Брокер 3 приостанавливает работу и становится недоступным.

Как только связность восстановлена, он возвращается в кластер.

Посмотрим на другой пример, где главная очередь находится на Брокере 3.

Затем происходит та же потеря связности. Брокер 3 встаёт на паузу, поскольку находится на меньшей стороне. На другой стороне узлы видят, что Брокер 3 отвалился, так что более старое зеркало с Брокеров 1 и 2 повышается до мастера.

Когда связность восстановлена, Брокер 3 присоединится к кластеру.

Здесь важно понимать, что мы получаем согласованность, но также можем получить доступность, если успешно переведем клиентов на бóльшую часть раздела. Для большинства ситуаций лично я бы выбрал режим Pause Minority, но это реально зависит от конкретного случая.

Для обеспечения доступности важно убедиться, что клиенты успешно подключаются к узлу. Рассмотрим наши варианты.

--------------------------------------------------------------------------------------------------------------------

Паттерн Пайплайн

Пайплайн — базовый элемент архитектуры, когда нужна последовательная обработка различными сервисами. Например, сначала требуется проверить авторизацию, затем выполнить дедупликацию и только после произвести запись данных сообщения в базу данных.

За счёт использования очередей в пайплайне хорошо видны bottleneck'и — узкие места, перед которыми скапливаются сообщения на обработку. Также есть понятный механизм расшивания посредством увеличения количества консьюмеров (конечно, это не серебряная пуля, так как проблемы могут быть у другого сервиса типа БД).

Плюс такого подхода — возможность удобного траблшутинга. На любом этапе вы можете добавить дублирующую очередь и получать копии сообщений как для разбора, так и для отправки на непродовые окружения.

Типовой пример пайплайна обработки: Publisher отправляет сообщение, и затем оно передаётся от worker к worker по мере обработки. Worker 1 проверяет авторизацию, 2 — дедупликатор, 3 — пишет в БД.

Важно: worker 1 и worker 2 на данной схеме являются одновременно и consumer, и publisher. А что произойдёт, если worker 2 перестанет справляться с дедупликацией сообщений?

Представим, что код проверки написан не оптимально, и скорость проверки ниже, чем частота прихода новых сообщений.
В этом случае очередь сообщений перед worker 2 начнёт расти, о чём нам тут же сообщит система мониторинга.
Если есть возможность горизонтального масштабирования — запускаем ещё один инстанс worker 2:
И они вдвоём ускоряют обработку сообщений. Разумеется, ускорить обработку таким способом получится не всегда. Если worker'ы упираются в скорость используемой БД, надо расшивать её или оптимизировать их код. Однако узкое горлышко обработки вы будете видеть сразу.

--------------------------------------------------------------------------------------------------------------------

Паттерн Очередь повторных попыток

Очередь повторных попыток — один из базовых элементов архитектуры приложения. Используется, когда есть вероятность неуспешной обработки сообщения (как «временные трудности» в целом, так и проблемы с обработкой конкретного сообщения). Работает, если нет необходимости в строгой последовательности обработки, так как подразумевает возможность временного пропуска сообщения.

Существуют два основных алгоритма реализации:
ack+publish — когда consumer сам подтверждает сообщение из основной очереди и паблишит в очередь повторных попыток;

reject+dlx — через механизм dead letter exchange.

--------------------------------------------------------------------------------------------------------------------

Расскажите про Dead Letter eXchange

Dead Letter eXchange (DLX) — это явное или назначенное через Policy свойство очереди. Указывает RabbitMQ, куда необходимо отправлять сообщение при наступлении одного из событий:
x-mesage-ttl — превышение времени жизни;
x-max-length — превышение длины очереди;
reject — явный реджект сообщений со стороны консьюмера.
Для одной очереди можно указать только один DLX, что несколько снижает гибкость. Также вы можете указать dead-letter-routing-key, а можете не указывать — тогда сохраняется текущий для каждого сообщения.

Мы декларируем DLX = Fail, который ведёт в ту самую очередь повторных попыток.
При неуспешной обработке мы делаем reject(false) вместо ack и publish.
Принцип тот же, но работает проще: меньше кода — меньше возможных проблем. Результат ожидаемо аналогичный.
Но ведь нам нужно совершать повторные попытки обработки, а не просто складывать сообщения в отстойник. Для этого мы используем тот же самый механизм DLX + механизм TTL.
В результате плохое сообщение будет каждую минуту возвращаться в основную очередь. Будет происходить попытка его обработки и так до тех пор, пока сообщение не будет успешно обработано. Просто и без лишнего кода.
Для очередей без consumer, где возможно хранение сообщений, рекомендую также добавлять признак lazy-queue, чтобы RabbitMQ старался не держать эти сообщения в оперативке.

--------------------------------------------------------------------------------------------------------------------

Расскажите про ack+publish

Предположим, у нас есть обработка сообщений, использующая некий внешний сервис, находящийся вне нашей зоны ответственности. Так же есть сообщения 1 2 и 3. Пускай сообщение «2» в данный момент не может быть им успешно обработано.

Сообщения помещаются в очередь.

Worker берёт сообщение 1 в обработку.

После успешной обработки первого сообщения доходит дело до второго — проблемного.

Происходит ошибка его обработки. Если мы сделаем nack этому сообщению, оно вернётся в очередь на тоже самое место. И незамедлительно будет закинуто в worker. Но здесь его снова ждёт неуспешная обработка. И пока одно сообщение будет бегать туда-сюда, оно, как тромб, забьёт голову очереди. В результате все сообщения, которые могли бы быть обработаны, будут висеть в очереди и ждать своего часа.

Как раз для таких случаев нужен паттерн очереди повторных попыток. Суть в том что мы создаем дополнительную очередь «retry queue», куда складируем неуспешно обработанные сообщения.
В случае ошибки обработки worker должен сделать ACK из основной очереди и publish в новую очередь.

В результате для нашего примера 1 и 3 сообщения будут успешно обработаны, а 2 останется в выделенной очереди ожидать своего часа.
Это как раз подход ack+publish. Он наиболее часто используется в IT-системах, потому что разработчики не знают о некоторых возможностях RabitMQ.

--------------------------------------------------------------------------------------------------------------------

Мониторинг очередей

Если мы вводим в эксплуатацию новую систему, надо понимать, как ее правильно мониторить. Любая очередь лимитирована, даже если вы не выставили ей лимиты. Нормальное состояние очереди — пустое. Вы присылаете сообщения и они должны обрабатываться. Если очередь начала расти, значит в системе что-то не так.

Поэтому размер очереди — первый показатель, который нужно мониторить.

Второй показатель — время — пригодится, когда ваша очередь начнет расти. Можно измерять полную обработку сообщения (QoS) от момента, когда вы его положили, до момента, когда обработали. И время обработки между тем, когда консьюмер взял и вернул сообщение. Замеры покажут, где у вас проблема.

Третий показатель — количество повторов и потерь (отказов). За размером очереди и временем не всегда получается уследить. За секунду может пройти 10 тысяч сообщений, и вы обнаружите, что очередь начала расти. А почему — непонятно, так как размер очереди и время — моментальные показатели. Мониторинг количества повторов и потерь (отказов), а также самого потока сообщений помогает понимать, что с вашей очередью происходит.

Если вы можете логировать сообщение, когда кладете его в очередь, — делайте это. Логов будет много, но в случае аварии, лучше доставать и искать сообщения из логов, чем обнаружить, что сообщений нет.

--------------------------------------------------------------------------------------------------------------------

Throughput / Latency / Durability / Availability

Throughput - Пропускная способность
Latency - Задержка
Durability - Долговечность
Availability - Доступность

--------------------------------------------------------------------------------------------------------------------