Что такое Redis?

Простыми словами Redis — система хранения данных в виде структур. Это нереляционная СУБД с открытым исходным кодом, организованная по принципу «ключ - значение». Она является вспомогательной и выполняет функцию хранилища (Redis storage) и кеша для основной, центральной базы данных. В качестве последних могут использоваться, например, PostgreSQL или MySQL.

Название СУБД произошло от аббревиатуры «Remote Dictionary Server» — ReDiS. Разработал продукт итальянский программист С. Санфилиппо, которого не устраивала производительность обычных баз данных при масштабировании. Первая версия вышла в 2009 году, и с тех пор система обновляется регулярно.

От реляционных баз Redis отличается:
более высокой производительностью (благодаря хранению данных в оперативной памяти сервера, значительно увеличивается число выполняемых операций);

отсутствием языка SQL (Lua-скрипты как альтернатива);

гибкостью (данные находятся не в жёстких структурах (таблицах), а в более удобных (строки, списки, хеши, множества, сортированные множества), что облегчает работу программисту;

лучшей масштабируемостью.

Однако Redis редко используется как основное хранилище в крупных системах, так как не удовлетворяет требованиям ACID, то есть не обеспечивает 100%-ной целостности данных.

--------------------------------------------------------------------------------------------------------------------

Какие типы данных поддерживает Redis

Redis хранит пары «ключ и значение». Ключ — строковый литерал, а в качестве значения могут выступать строки, списки, множества, упорядоченные множества, хеши и другие типы данных (битовые карты, гиперлоги и геопространственные индексы с радиус‑запросами и потоками). Чтобы разобраться, для каких сценариев подходит Redis, нужно понимать, для чего используются типы.

Строки — базовый тип данных, его используют все другие структуры данных. Сохраняйте числа, JSON, байты изображения или что‑нибудь ещё. Тем не менее набор операций для работы с этим типом данных ограничен, поэтому, например, извлечь нужное значение из JSON вам не удастся.

Списки — строки, отсортированные по порядку их вставки.

Множества — тип данных, который поддерживает операции пересечения, объединения и подобные. Множества никак не упорядочены и обычно используются, когда вы хотите выполнить аудит и увидеть взаимосвязи между переменными.

Упорядоченные множества — набор строк, в котором элементы упорядочены по номерам. это одна из самых продвинутых структур данных.

Хеши — это карты между строковыми полями и строковыми значениями, коллекция пар «ключ — значение». Они используются, когда нужно создать контейнер уникальных значений для представления объектов.

Битовый массив (Bitmap)
Битовое поле (Bitfield)
Геопространственные данные (Geospatial)
Структура HyperLogLog (HyperLogLog)
Поток (Stream)

--------------------------------------------------------------------------------------------------------------------

Для чего используют Redis

Redis обычно применяют:
для хранения пользовательских сессий (HTML-фрагменты веб-страниц или товары корзины интернет-магазина);

для хранения промежуточных данных (поток сообщений на стене, голосовалки, таблицы результатов);

как брокер сообщений (стратегия «издатель-подписчик» позволяет создавать новостные ленты, групповые чаты);

как СУБД для небольших приложений, блогов;

для кэширования данных из основного хранилища, что значительно снижает нагрузку на реляционную базу данных;

для хранения «быстрых» данных — когда важны скорость и критичны задержки передачи (аналитика и анализ данных, финансовые и торговые сервисы).

--------------------------------------------------------------------------------------------------------------------

Redis HA

Аббревиатура HA расшифровывается как High Availability, то есть повышенная доступность. В этой схеме задействуется два и более узлов: главный и подчиненные, а их синхронизация реализуется с помощью репликации. Такая система позволяет существенно повысить ее отказоустойчивость, поскольку здесь нет единой точки отказа, как в предыдущем варианте с единственной СУБД.
В результате сбои устраняются очень быстро, в том числе за счет их автоматического обнаружения и схемы восстановления системы. А благодаря надежным каналам связи исключена потеря данных.

--------------------------------------------------------------------------------------------------------------------

Redis Sentinel

Sentinel, добавленный в СУБД с версии 2.4, представляет собой сервис для создания распределенных систем и мониторинга состояния их узлов. Это решение можно выбрать, когда репликация выполняется при отсутствии полноценного кластера, элементы которого надежно связаны между собой. Sentinel как раз и выступает в роли такой связки.
Sentinel-процессы запускаются в момент потери связи между узлами. Кроме того, узлы Sentinel выполняют и такие функции, как восстановление сервиса после отказа, отправка уведомлений, а также конфигурирование системы: они сообщают, какой экземпляр Redis в данный момент является ведущим.

--------------------------------------------------------------------------------------------------------------------

Redis Cluster

Добавленный в Redis 3.0 Cluster предназначен для горизонтального масштабирования системы, когда нагрузка равномерно распределяется по всему хранилищу. Классическая схема на основе Cluster представляет собой несколько ведущих и несколько подчиненных узлов с распределением данных между всеми узлами системы. А для мониторинга состояния системы обычно используют протокол Gossip.
Одна из главных особенностей Redis Cluster заключается в его механизме работы: он радикально отличается от того, который используется в схемах HA и Sentinel. Если там это репликация, то здесь — шардирование, или шардинг. Шардинг — сегментирование данных, которые в таком виде равномерно распределяются по элементам кластера. Это позволяет существенно снизить нагрузку на хранилище.

--------------------------------------------------------------------------------------------------------------------

Протокол Gossip

При помощи протокола осуществляется мониторинг состояния узлов системы, работающих по механизму шардинга. Если какой-то из основных узлов перестает отвечать на запросы, Gossip передает его права одному из подчиненных узлов. За счет этого существенно повышается отказоустойчивость системы в целом.

--------------------------------------------------------------------------------------------------------------------

Постоянное хранение данных в Redis

СУБД Redis не рассчитана на постоянное хранение данных. Дело в том, что приоритетными задачами Redis являются не надежность хранения, а организация скоростного и бесперебойного доступа к данным. Поэтому для надежного хранения данных рассмотрите решения, совместимые с Redis. Это могут быть классические реляционные базы — PostgreSQL, MySQL или Oracle.

--------------------------------------------------------------------------------------------------------------------

Модели резервирования данных для Redis: файлы RDB и AOF

Пользователи Redis советуют использовать в production как бэкапы данных, так и встроенные инструменты/модели резервирования СУБД.
Таких моделей три:

Файлы RDB. Подразумевает использование снапшотов — регулярных снимков состояния хранилища (временные интервалы задаются в конфигурации). Главный недостаток этой схемы: если сбой Redis произошел в интервале между созданием снапшотов, то данные потеряются.

Файлы AOF (Append Only File). Более надежный способ организации хранения данных, поскольку файлы AOF представляют собой независимые журналы для записи команд на восстановление. По умолчанию Redis пишет данные на диск каждую секунду, что позволяет терять минимум информации в случае сбоев.

RDB и AOF. Комбинирование двух моделей — самое надежное решение, однако в качестве платы за стабильность здесь придется несколько пожертвовать скоростью. Также учтите, что при перезагрузке системы Redis будет использовать файлы AOF.

--------------------------------------------------------------------------------------------------------------------

Как устроено хранение данных в Redis: создание форков процессов

Форком называется создание нового процесса в системе путем копирования родительского. И эти процессы затем могут взаимодействовать между собой. Перегрузки системы удается избежать благодаря совместному использованию памяти по принципу Copy-On-Write. В результате дополнительная память выделяется только при каких-либо изменениях процесса, но объемы этой памяти незначительны.

--------------------------------------------------------------------------------------------------------------------

Сравнение Redis с хранилищем Memcached

Главным конкурентом Redis является СУБД Memcached, которая появилась на 6 лет раньше.
«Почтенный» возраст — основная причина ограничений Memcached. В отличие от Redis это хранилище не поддерживает продвинутые структуры данных, снапшоты, репликацию, некоторые типы данных (например, геоданных) и имеет ряд других ограничений.
С другой стороны, Memcached — многопоточное хранилище, а Redis — одопоточное, что дает первому некоторые преимущества в производительности. Тем не менее, наличие продвинутых инструментов работы с данными делает Redis предпочтительнее, чем использование Memcached, для большинства проектов.

Redis:

больше возможностей:
очереди, транзакции,
различные типы данных

практически не заметна
позволяет хранить до 512
Mb в значениях

поддерживает master-
slave репликацию,
кластеризация версии
3.0 (RC)

можно использовать как
постоянное хранилище
данных

производительность
сравнима с Memcached

Memcached :

быстрее, чем Redis, но на
практике эта разница

хорош в качестве кэша, но есть
множество задач с которыми
Redis справится не хуже, а для
некоторых задач и лучше чем
Memcached в силу своих
возможностей

--------------------------------------------------------------------------------------------------------------------

Основные команды Redis

HSET — сохраняет значение по ключу:

HSET person1 name "Aleksey"
(integer) 1
HSET person1 age 25
(integer) 1
В примере выше мы создали объект person1 с двумя полями (name и age) и соответствующими значениями.

HGET — получение значения по ключу (для определённого поля):
HGET person1 name
"Aleksey"
Выше мы получили значение поля name у ключа person1.

HGETALL — получение всех пар «ключ-значение»:
HGETALL person1
1) "name"
2) "Aleksey"
3) "age"
4) "25"
   Получили значения всех полей по ключу person1.

HKEYS и HVALS — получение всех ключей и соответствующих им значений:
HKEYS person1
1) "name"
2) "age"
   HVALS person1
1) "Aleksey"
2) "25"

--------------------------------------------------------------------------------------------------------------------

Транзакции

транзакции в Redis не сохраняют целостность данных (сбой одной операции при выполнении блока транзакции не мешает исполнить другие).

--------------------------------------------------------------------------------------------------------------------

Кэширование данных Redis

Один из самых популярных кейсов использования Redis — кэширование данных. Для того, чтобы снизить нагрузку на БД, иметь возможность запрашивать часто используемые данные максимально быстро, используется кэш. Redis — это in-memory хранилище, то есть данные хранятся в оперативной памяти. Ещё это key-value хранилище, где доступ к данным по их ключу имеет сложность O(1) — поэтому данные мы получаем очень быстро.

Таким образом, мы запишем данные в Redis и сможем их считать по тому же самому ключу в любой нужный нам момент. Но если мы будем все время писать в Redis, данные в нем будут занимать все больше и больше места в оперативной памяти. Нам нужно удалять нерелевантные данные, контролировать это вручную достаточно проблематично, поэтому пускай redis занимается этим самостоятельно.

По истечении времени ttl (в секундах) данные по этому ключу будут автоматически удалены.Как говорят, в программировании существует две самых сложных вещи: придумывание названий переменных и инвалидация кэша.

--------------------------------------------------------------------------------------------------------------------

Очереди

Используя имеющиеся в Redis структуры данных, мы можем запросто реализовать стандартные очереди FIFO или LIFO. Для этого используем структуру List и методы по работе с ней. Работа с очередями состоит из двух основных действий: отправить задачу в очередь, и взять задачу из очереди. Отправлять задачи в очередь мы можем из любой части системы. Получением задачи из очереди и ее обработкой обычно занимается выделенный процесс, который называется консьюмером (consumer).

Тем самым мы добавим в конец листа с названием $queueName некий $payload, который может представлять из себя JSON для инициализации нужной нам бизнес логики (например данные по денежной транзакции, данные для инициализации отправки письма пользователю, etc.). Если же в нашем хранилище не существует листа с именем $queueName, он будет автоматически создан, и туда попадет первый элемент $payload.Со стороны консьюмера нам необходимо обеспечить получение задач из очереди, это реализуется простой командой чтения из листа. Для реализации FIFO очереди мы используем чтение с обратной записи стороны (в нашем случае мы писали через RPUSH), то есть читать будем через LPOP

Для реализации LIFO очереди, нам нужно будет читать лист с той же стороны, с которой мы в него пишем, то есть через RPOP.Тем самым мы вычитываем по одному сообщению из очереди. В случае если листа не существует (он пустой), то мы получим NULL.

--------------------------------------------------------------------------------------------------------------------

Блокировки (Mutex)

Mutex (блокировка) — это механизм синхронизации доступа к shared ресурсу нескольких процессов, тем самым гарантируя, что только один процесс будет взаимодействовать с этим ресурсом в единицу времени. Этот механизм часто применяется в биллинге и других системах, где важно соблюдать потоковую безопасность (thread safety).Для реализации mutex на базе Redis прекрасно подойдет стандартный метод SET с дополнительными параметрами:

где параметрами для установки mutex являются:
$key — ключ идентифицирующий mutex;
$hash — генерируем некую подпись, которая идентифицирует того, кто поставил mutex. Мы же не хотим, чтобы кто-то в другом месте случайно снял блокировку и вся наша логика рассыпалась.
$ttl — время в секундах, которое мы отводим на блокировку (на тот случай, если что-то пойдет не так, например процесс, поставивший блокировку, по какой-то причине умер и не снял ее, чтобы это блокировка не висела бесконечно).

Основное отличие от метода SET, используемого в механизме кэширования — это параметр NX, который говорит Redis о том, что значение, которое уже хранится в Redis по ключу $key, не будет записано повторно. В результате, если в Redis нет значения по ключу $key, туда произведется запись и в ответе мы получим 'OK', если значение по ключу уже есть в Redis, оно не будет туда добавлено (обновлено) и в ответе мы получим NULL. Результат метода lock(): bool, где true - блокировка поставлена, false - уже есть активная блокировка, создать новую невозможно.Чаще всего, когда мы пишем код, который пытается работать с shared ресурсом, который заблокирован, мы хотим дождаться его разблокировки и продолжить работу с этим ресурсом.
Мы разобрались как ставить блокировку, теперь нам нужно научиться ее снимать. Для того, чтобы гарантировать снятие блокировки тем процессом, который ее установил, нам понадобится перед удалением значения из хранилища Redis, сверить хранимый хэш по этому ключу.

Мы пытаемся найти с помощью команды GET значение по ключу $key, если оно равно значению $hash, то удаляем его при помощи команды DEL, которая вернет нам количество удаленных ключей, если же значения по ключу $key не существует, или оно не равно значению $hash, то мы возвращаем 0, что значит блокировку снять не удалось.

--------------------------------------------------------------------------------------------------------------------

Rate limiter

Достаточно частая задача, когда мы хотим ограничить количество запросов к нашему апи. Например на один API endpoint от одного аккаунта мы хотим принимать не более 100 запросов в минуту. Эта задача легко решается с помощью нашего любимого Redis

--------------------------------------------------------------------------------------------------------------------

Pub/sub

Pub/sub — интересный механизм, который позволяет, с одной стороны, подписаться на канал и получать сообщения из него, с другой стороны — отправлять в этот канал сообщение, которое будет получено всеми подписчиками. Наверное у многих, кто работал с вебсокетами, возникла аналогия с этим механизмом, они действительно очень похожи. Механизм pub/sub не гарантирует доставки сообщений, он не гарантирует консистентности, поэтому не стоит его использовать в системах, для которых важны эти критерии. Однако рассмотрим этот механизм на практическом примере. Предположим, что у нас есть большое количество демонизированных команд, которыми мы хотим централизованно управлять. При инициализации нашей команды мы подписываемся на канал, через который будем получать сообщения с инструкциями. С другой стороны у нас есть управляющий скрипт, который отправляет сообщения с инструкциям в указанный канал.

--------------------------------------------------------------------------------------------------------------------

RedisTemplate

Чтобы установить соединение, мы используем Jedis, клиентскую реализацию Redis.


@Bean
JedisConnectionFactory
jedisConnectionFactory() {
return new JedisConnectionFactory(); }
@Bean
public RedisTemplate<String, Object> redisTemplate() { final RedisTemplate<String, Object> template = new RedisTemplate<String, Object>(); template.setConnectionFactory(jedisConnectionFactory()); template.setValueSerializer(new GenericToStringSerializer<Object>(Object.class));
return template;
}
JedisConnectionFactory представлен как bean-компонент, так что мы можем создать RedisTemplate для запроса данных.

--------------------------------------------------------------------------------------------------------------------

RedisRepository

В отличие от других проектов Spring Data, Spring Data Redis предоставляет все необходимое для работы поверх других интерфейсов Spring Data. Это может выглядеть странно для людей, имеющих опыт работы с другими проектами Spring Data.Часто нет необходимости писать реализацию интерфейса репозитория с проектами Spring Data. Мы просто взаимодействуем с интерфейсом. Spring Data JPA предоставляет многочисленные интерфейсы репозитория, которые могут быть расширены для получения таких функций, как CRUD операции, производные запросы и разбиение на страницы.

--------------------------------------------------------------------------------------------------------------------