Spring Cache это

Spring boot предоставляет API абстракции кэша, который позволяет нам использовать разные поставщики кэша для кэширования объектов.

Когда кэширование включено, приложение сначала ищет требуемый объект в кэше, а не извлекает его из базы данных. Если он не находит этот объект в кэше, тогда доступ к нему осуществляется только из базы данных.
Кэширование ускоряет доступ к данным, поскольку данные извлекаются из базы данных только в первый раз, когда это необходимо. Впоследствии он извлекается из кэша. Таким образом, кэширование повышает производительность приложения.
Абстракция кэша работает над двумя вещами :
Объявление кэша: оно определяет методы, которые должны быть
Конфигурация кэша: резервный кэш, в котором хранятся и считываются данные.

--------------------------------------------------------------------------------------------------------------------
Кэширование возвращаемого результата

Что делает Spring Cache? Spring Cache просто кэширует возвращаемый результат для определённых входных параметров. Давайте это проверим. Мы поставим аннотацию @Cacheable над сервисным методом get(), чтобы кэшировать возвращаемые данные. Дадим этой аннотации название «users» (далее мы разберём, зачем это делается, отдельно).

@Override
@Cacheable("users")
public User get(Long id) {
log.info("getting user by id: {}", id);
return repository.findById(id) .orElseThrow(() -> new EntityNotFoundException("User not found by id " + id));
}

--------------------------------------------------------------------------------------------------------------------
Объявление ключа для кэширования

Бывают ситуации, когда в кэшируемый метод приходит несколько параметров. В таком случае, бывает нужно определить параметр, по которому будет происходить кэширование. Добавим в пример метод, который будет сохранять в базу сущность, собранную по параметрам, но если сущность с таким именем уже есть, мы не будем её сохранять. Для этого мы определим параметр name как ключ для кэширования. Выглядеть это будет так:

@Override
@Cacheable(value = "users", key = "#name")
public User create(String name, String email) { log.info("creating user with parameters: {}, {}", name, email);
return repository.save(new User(name, email));
}

--------------------------------------------------------------------------------------------------------------------
Принудительное кэширование. @CachePut

Бывают ситуации, когда мы хотим кэшировать возвращаемое значение для какой-то сущности, но в то же время, нам нужно обновить кэш. Для таких нужд существует аннотация @CachePut. Оно пропускает приложение в метод, при этом, обновляя кэш для возвращаемого значения, даже если оно уже закэшировано.Добавим пару методов, в которых мы будем сохранять юзера. Один из них мы пометим обычной аннотацией @Cacheable, второй — @CachePut.

@Override
@Cacheable(value = "users", key = "#user.name")
public User createOrReturnCached(User user) { log.info("creating user: {}", user);
return repository.save(user);
}

@Override
@CachePut(value = "users", key = "#user.name")
public User createAndRefreshCache(User user) { log.info("creating user: {}", user);
return repository.save(user);
}

Первый метод будет просто возвращать закэшированные значения, второй — принудительно обновлять кэш. Кэширование будет осуществляться по ключу #user.name

--------------------------------------------------------------------------------------------------------------------
Удаление из кэша. @CacheEvict

Иногда возникает необходимость жёстко обновить какие-то данные в кэше. Например, сущность уже удалена из базы, но она по-прежнему доступна из кэша. Для сохранения консистентности данных, нам необходимо хотя бы не хранить в кэше удалённые данные.Добавим в сервис ещё пару методов.

@Override
public void delete(Long id) {
log.info("deleting user by id: {}", id); repository.deleteById(id);
}

@Override
@CacheEvict("users")
public void deleteAndEvict(Long id) {
log.info("deleting user by id: {}", id); repository.deleteById(id);
}

Первый будет просто удалять пользователя, второй тоже будет его удалять, но мы пометим его аннотацией @CacheEvict

--------------------------------------------------------------------------------------------------------------------
Группировка настроек. @Caching

Иногда один метод требует нескольких настроек кэширования. Для этих целей используется аннотация @Caching. Выглядеть это может приблизительно так:

@Caching(
cacheable = {
@Cacheable("users"),
@Cacheable("contacts")
},
put = {
@CachePut("tables"),
@CachePut("chairs"),
@CachePut(value = "meals", key = "#user.email")
},
evict = {
@CacheEvict(value = "services", key = "#user.name")
}
)
void cacheExample(User user) { }

--------------------------------------------------------------------------------------------------------------------
Гибкая настройка. CacheManager

CacheManager. Он существует везде, где есть Spring Cache. Когда мы добавили аннотацию @EnableCache, такой кэш менеджер автоматически будет создан Spring.
Типы:
SimpleCacheManager — самый простой кэш-менеджер, удобный для изучения и тестирования.

ConcurrentMapCacheManager — лениво инициализирует возвращаемые экземпляры для каждого запроса. Также рекомендуется для тестирования и изучения работы с кэшем, а также, для каких-то простых действий, вроде наших. Для серьёзной работы с кэшем рекомендуются имплементации ниже.

JCacheCacheManager, EhCacheCacheManager, CaffeineCacheManager — серьёзные кэш-менеджеры «от партнёров», гибко настраиваемые и выполняющие задачи очень широкого спектра действия.

--------------------------------------------------------------------------------------------------------------------
Настройка кэша.

maximumSize — максимальный размер значений, которые может содержать кэш. При помощи этого параметра можно найти попытаться найти компромисс между нагрузкой на базу данных и на оперативную память JVM.
refreshAfterWrite — время после записи значения в кэш, после которого оно автоматически обновится.
expireAfterAccess — время жизни значения после последнего обращения к нему.
expireAfterWrite — время жизни значения после записи в кэш. Именно этот параметр мы определим.

--------------------------------------------------------------------------------------------------------------------
JCacheCacheManager

JCache (JSR 107) — это стандартный API-интерфейс для Java. Он предоставляет API для приложений, чтобы иметь возможность создавать и работать с кэшем в памяти объектов. Преимущества очевидны — не нужно концентрироваться на более тонких деталях реализации кэширования, а время лучше тратить на основную бизнес-логику приложения.

JCache определяет интерфейсы, которые, конечно же, реализуются различными поставщиками, также называемыми провайдерами.
Oracle Coherence
Hazelcast
Infinispan
EHCache

--------------------------------------------------------------------------------------------------------------------
EhCacheCacheManager

Ehcache это универсальная система распределённого кэширования общего назначения с открытым исходным кодом для Java-приложений и сервлетов. Ehcache создана для повышения производительности, снижения нагрузки на базу данных и упрощения масштабирования. Ehcache является наиболее широко используемой системой кэширования на основе языка Java, потому что она надежная, проверенная, полнофункциональная и интегрируется со многими популярными библиотеками и фреймворками. Ehcache предоставляет как кэширование в пределах одного экземпляра приложения, так и распределенное кэширование с данными размером в ТБ.

--------------------------------------------------------------------------------------------------------------------
CaffeineCacheManager

Caffeine - это переписанный на Java 8 кэш Guava, которая заменяет поддержку Guava. Если Caffeine присутствует, CaffeineCacheManager (предоставленный стартером spring-boot-starter-cache) автоматически конфигурируется. Кэши можно создать при запуске, установив свойство spring.cache.cache-names, и их можно настроить одним из следующих способов (в указанном порядке):
Спецификация кэша, определенная в spring.cache.caffeine.spec
Определен компонент com.github.benmanes.caffeine.cache.CaffeineSpec
Определен bean-компонент com.github.benmanes.caffeine.cache.Caffeine
Например, следующая конфигурация создает кэши cache1 и cache2 с максимальным размером 500 и временем жизни 10 минут

spring.cache.cache-names=cache1,cache2 spring.cache.caffeine.spec=maximumSize=500,expireAfterAccess=600s

Если определен bean-компонент com.github.benmanes.caffeine.cache.CacheLoader, он автоматически связывается с CaffeineCacheManager. Поскольку CacheLoader будет связан со всеми кэшами, управляемыми менеджером кэша, он должен быть определен как CacheLoader<Object, Object>. Автоконфигурация игнорирует любой другой универсальный тип.

--------------------------------------------------------------------------------------------------------------------