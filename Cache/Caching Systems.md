Что такое кэширование?

В вычислительной технике кэш — это высокоскоростной уровень хранения данных, где хранится подмножество данных, обычно временных. Благодаря этому будущие запросы на эти данные обрабатываются быстрее, чем при запросе доступа к основному хранилищу. Кэширование позволяет эффективно переиспользовать ранее полученную или вычисленную информацию.

Системы кэширования хранятся на оборудовании с более быстрым доступом, таким как оперативная память (RAM). Оперативная память обеспечивает более быструю работу ввода-вывода и уменьшает задержку. Кэширование задействовано на всех уровнях технологий, например в операционных системах, CDN, DNS, во многих приложениях, таких как поиск, а также используется для повышения производительности медиаконтента в играх.

При реализации уровня кэша важно понимать, какое значение имеет достоверность кэшированных данных. Успешное кэширование приводит к повышению частоты обращений, а значит, данные присутствуют при запросе к ним. Промах кэша возникает, когда информации в кэше не оказалось. Для управления истечением срока действия данных могут применяться такие элементы управления, как TTL (Time to live).

--------------------------------------------------------------------------------------------------------------------
Для чего нужен кэш

В кэше сохраняются данные, к которым программа или устройство обращаются часто. Если бы кэша не было, эти данные пришлось бы читать из обычной памяти или, в случае веба, скачивать из сети. Как результат — более долгая загрузка, большая нагрузка на память или на сеть. Тем более, таких данных может быть много: без кэша скорость работы компьютеров и их приложений была бы намного меньше.
Поэтому кэшем пользуется большинство приложений, которые оперируют большим набором данных. Это браузеры, разнообразные мессенджеры, программы, работающие с сетью или информацией, СУБД и другие.
Аппаратный кэш есть практически во всех компьютерных устройствах: без него операционная система не сможет работать как надо.

--------------------------------------------------------------------------------------------------------------------
Как устроен кэш

Внутреннее устройство кэша похоже на базу данных с более простой структурой и своими особенностями. Это перечень записей с информацией. Данные в них — копии данных, которые есть в «обычной» памяти или на серверах. У каждой записи есть свой идентификатор, или тег, — он показывает, в каком участке «обычной» памяти расположена эта же информация.
Когда системе или программе нужны данные, она находит их по идентификатору. Сначала она проверяет кэш: если в памяти обнаружилась запись, имеющая соответствующий тег, информация берется оттуда. Это быстрее. Если в кэше таких данных нет, значит, нужно обратиться по этому же идентификатору в «обычную» память или на сервер, а затем поместить в кэш полученные оттуда данные. Так в следующий раз обращение к ним будет быстрее.

--------------------------------------------------------------------------------------------------------------------
Преимущества кэша

Повышение производительности. С кэшем приложения работают быстрее и эффективнее: им не приходится постоянно тратить время на подгрузку каких-то данных, ведь они могут просто взять их из кэша. Иначе все постоянно зависало бы, приходилось бы долго ждать.

Снижение нагрузки. Так как к основному хранилищу благодаря кэшу обращаются реже, на него снижается нагрузка. Это особенно важно в случае с серверами, так как помогает избежать отказов и резкого снижения производительности из-за нагрузки в пиковых ситуациях.

Повышение пропускной способности. Как следствие всего перечисленного, повышается пропускная способность операций. Дело в том, что чтение и запись данных — операции, которые занимают время и могут выполняться только в определенном количестве за момент времени. У кэша пропускная способность намного выше, чем у обычной памяти, поэтому операций за один момент может быть множество — намного больше, чем при работе с сервером, базой данным или другим хранилищем.

Оптимизация. Представьте себе, что к каким-то данным обращаются чаще, чем к другим. Это может быть определенная популярная страница сайта или какая-то информация из приложения, что-то еще. Если эти данные будут храниться в обычной памяти, это создаст лишнюю нагрузку и снизит скорость доступа. А их кэширование позволяет оптимизировать доступ и сделать нагрузку более равномерной.

Меньшие затраты. Это опять же преимущество, важное для веба. Использование серверного или сетевого кэша приводит к тому, что сервису нужно платить за меньшее количество ресурсов для базы данных или серверов. Несмотря на то что сам кэш тоже не бесплатный, выходит тем не менее дешевле, чем без него.

--------------------------------------------------------------------------------------------------------------------
Недостатки кэша

Аппаратный кэш — очень дорогая в производстве структура. К тому же он обычно энергозависим: стоит выключить устройство — все данные потеряются.

Программный кэш не решит всех вопросов, связанных с памятью. Он ограничен по размеру, а специфические алгоритмы не позволяют хранить в нем что-то неограниченное количество времени. Для долговременного хранения важной информации он не подходит.

Алгоритма кэширования, оптимального в любых ситуациях, не существует. Поэтому алгоритм выбирают разработчики в зависимости от целей конкретной программы: он обычно довольно узкоспециализированный и не подходит для широкого спектра задач.

Закэшировать «весь интернет» или всю память не получится — размер кэша довольно маленький.

--------------------------------------------------------------------------------------------------------------------
Виды кэша

Аппаратная реализация используется процессором, системой, различными низкоуровневыми, то есть близкими к «железу» процессами. Кэш-память отличается от обычного хранилища данных на физическом уровне, она принципиально другая.

Программная реализация используется программами и сервисами. У каждого приложения она своя. Это по сути код, который описывает, как размещать, кэшировать и хранить данные. При этом сама информация находится в обычных участках памяти: на жестком диске, SSD, сервере. На аппаратном, «железном» уровне такой кэш практически не отличается от простого хранилища данных.

--------------------------------------------------------------------------------------------------------------------
Устройство аппаратного кэша

Кэш процессора. У процессора есть понятие тактовой частоты — это то, с какой скоростью операции выполняются на физическом уровне. В современной технике тактовая частота очень высокая, но постоянные обращения к «обычной» памяти сводили бы эту скорость на нет. Чтобы работа была эффективнее, в процессорах предусматривают кэш. На этом уровне он еще называется сверхоперативной памятью и иначе устроен с точки зрения физики. Мы не будем углубляться в сложные технические детали, просто скажем, что доступ к любой ячейке данных в такой памяти обычно занимает одно и то же время.
Особенность сверхоперативной памяти — она энергозависима. Это значит, что такой кэш поддерживается, только пока устройство включено. Если выключить компьютер, содержимое этой памяти очистится, как и в случае с оперативной. После повторного включения содержимое кэша окажется непредсказуемым.

Процессорный кэш обычно разделен на уровни от первого, самого быстрого, до четвертого. Меньше уровней в конкретном процессоре может быть, больше — нет. У большинства устройств только три уровня.
Кэш внешних устройств. Аппаратный кэш также может быть у внешних хранилищ, например жестких дисков. Он опять же обеспечивает более быстрый доступ к памяти. Кроме того, сама система при работе с внешним накопителем может пользоваться частью оперативной памяти компьютера как «дисковым кэшем».

--------------------------------------------------------------------------------------------------------------------
Устройство программного кэша

Программный кэш какого-либо приложения описывается кодом. Кэшированные данные иначе записываются, хранятся в особых структурах данных, и доступ к ним происходит по определенным оптимизированным алгоритмам.
Особенности записи данных. Информацию в программный кэш записывают одним из двух способов:
сквозной — сначала полученные сведения оказываются в основной памяти, а потом оттуда дублируются в кэш;
отложенный — сначала данные кэшируются, а потом, по истечении определенного срока или при вытеснении, переносятся в основную память.
Структуры для хранения кэша. Для хранения закэшированных данных обычно используются программные структуры с более быстрым доступом, чем к стандартным файлам или переменным. Чаще всего это ассоциативные массивы или хэш-таблицы — о них вы подробнее можете прочитать в соответствующих статьях. В небольших программах они могут быть заданы как переменные, но чаще представляют собой нечто вроде простой базы данных в памяти устройства. Также это могут быть отдельные файлы и папки, где хранится информация.
Ассоциативные структуры данных используются потому, что позволяют хранить пары «ключ-значение», где ключ может быть числом, текстом, хэшем или чем-то еще. Доступ к ним производится по особым алгоритмам и благодаря этому оказывается быстрее.
Алгоритмы кэширования. Одна из особенностей кэша — это относительно небольшой участок памяти. Если он становится слишком объемным, то начинает занимать слишком много места, может ухудшиться и быстродействие. Так что размер программного кэша ограничивают. А если он оказывается заполнен, срабатывают алгоритмы вытеснения — какая-то информация «выбрасывается» из него, а новая записывается.
Алгоритмов, которые описывают добавление и вытеснение, несколько. Наиболее известных — четыре:
MRU — убираются данные, которые использовались последними;
LFU — вытесняются данные, которые используются реже всего;
LRU — вытесняются данные, к которым не обращались дольше всего;
ARC — комбинация двух предыдущих типов.
Существует теоретический алгоритм, который невозможно реализовать в общем виде: отбрасываться должна наименее полезная информация. Он называется алгоритмом Белади. Реализация невозможна, потому что компьютер не сможет предвидеть, какая информация более или менее полезна. Существующие алгоритмы приближают к теоретическому в зависимости от особенностей работы конкретной программы.

--------------------------------------------------------------------------------------------------------------------
MRU

Most Recently Used - этот алгоритм кэширования удаляет самые последние использованные элементы в первую очередь. LRU ориентируется на время: здесь чем старше элемент, тем он меньше используется и удаляется в первую очередь. MRU — наоборот, чем старше элемент, тем чаще к нему обращаются, и в первую очередь здесь удаляются последние использованные элементы, так как они меньше всего использовались. Таким образом, LRU удаляет самые неиспользуемые элементы — самые старые, а в MRU удаляет самые новые. Он наиболее полезен в случаях, когда чем старше элемент, тем больше обращений к нему происходит.

--------------------------------------------------------------------------------------------------------------------
LFU

LFU - алгоритм, который подсчитывает частоту использования каждого элемента и удаляет те, к которым обращаются реже всего.
В LFU каждому элементу присваивается counter - счётчик. При повторном обращении к элементу его счётчик увеличивается на единицу. Таким образом, когда кэш заполняется, необходимо найти элемент с наименьшим счётчиком и заменить его новым элементом. Если же все элементы в кэше имеют одинаковый счётчик, то в этом случае вытеснение осуществляется по методу FIFO: первым вошёл - первым вышел.

Недостатки:
много обращений к элементу за короткое время накручивает счётчик и в результате элемент зависает в кэше.
алгоритм не учитывает "возраст" элементов

--------------------------------------------------------------------------------------------------------------------
LRU

LRU - это алгоритм, при котором вытесняются элементы, которые дольше всего не запрашивались. Соответственно, необходимо хранить время последнего запроса к элементу. И как только кэш становится заполненным, необходимо вытеснить из него элемент, который дольше всего не запрашивался.
Общая реализация этого алгоритма требует сохранения «бита возраста» для элемента и за счет этого происходит отслеживание наименее используемых элементов. В подобной реализации, при каждом обращении к элементу меняется его «возраст».

LRU на самом деле является семейством алгоритмов кэширования, в которое входит 2Q, а также LRU/K.
Для реализации понадобятся две структуры данных:
Хеш-таблица, которая будет хранить закэшированные значения.
Очередь, которая будет хранить приоритеты элементов и выполнять следующие операции:Добавить пару значение и приоритет.Извлечь (удалить и вернуть) значение с наименьшим приоритетом.
Пошаговый алгоритм:
Проверяем, есть ли значение в кэше:
Если значение уже есть, то обновляем время последнего к нему запроса и возвращаем значение.
Если значения нет в кэше - вычисляем его.

Проверяем размер кэша:
Если кэш заполнен, то вытесняем самый старый элемент.
Добавляем значение в хеш-таблицу и в очередь.

Достоинства:
константное время выполнения и использование памяти.
Недостатки:
алгоритм не учитывает ситуации, когда к определенным элементам обращаются часто, но с периодом, превышающим размер кэша (т.е. элемент успевает покинуть кэш).

--------------------------------------------------------------------------------------------------------------------
Псевдо-LRU - PLRU

PLRU - это алгоритм, который улучшает производительность LRU тем, что использует приблизительный возраст, вместо поддержания точного возраста каждого элемента.

--------------------------------------------------------------------------------------------------------------------
ARC

постоянно балансирует между LRU и LFU, что улучшает итоговый результат.

--------------------------------------------------------------------------------------------------------------------
Шаблоны доступа к кэшу

Кэш сквозной записи. Всякий раз, когда приходит какой-либо запрос на "запись", он будет поступать в БД через кэш. Запись считается успешной только в том случае, если данные успешно записаны и в кэш, и в БД.

Кэш прямой записи. Запрос на запись идет напрямую в БД, минуя кэш, и подтверждение отправляется обратно. Данные не уходят в кэш, а записываются туда только при первом промахе кэша.

Кэш обратной записи. Обновленная запись отправляется в кэш, данные сохраняются в кэше, и подтверждение отправляется немедленно. Затем другой сервис передает данные в БД.

Структура данных для реализации кэша называется "хеш-таблицей". Все, что нам нужно, — это функция хеширования, ключ и значение.

--------------------------------------------------------------------------------------------------------------------
Внутренние части кэша

Теперь нам нужен сервис, который обслуживает запросы на получение/размещение/удаление (get/put /delete). Несмотря на высокую скорость работу, оперативная память все равно блокирует вызовы. Поэтому нужен эффективный способ удовлетворения этих запросов.
Для этого можно создать n потоков по мере получения запросов или расширить пул для обработки потоков. Еще один возможный вариант — это логика, основанная на событиях.
Как показано на рисунке выше, у нас есть очередь событий. Туда попадает любой запрос "get/put". Также есть цикл событий, который выполняется бесконечно и представляет собой однопоточную операцию. Помимо этого, доступен пул потоков, который выполняет только операции ввода-вывода в оперативную память.
Каждый раз, когда мы получаем запрос "get/put", он помещается в очередь событий. Цикл событий продолжает считывать очередь событий и передает запрос, который свободно располагается в ней. Как только происходит передача в пул потоков, он выполняет обратный вызов и снова считывает очередь событий.
Таким образом, очередь событий никогда не блокируется. Поток в пуле, который получает запрос, выполняет операцию, получает данные и возвращается к запросу через ответ обратного вызова, цикл событий или какой-либо другой механизм. Именно так можно более эффективно обрабатывать запрос.

--------------------------------------------------------------------------------------------------------------------
Отказоустойчивость

Как сделать систему кэширования отказоустойчивой? Мы знаем, что хеш-таблица и данные хранятся в оперативной памяти. А что, если произойдет потеря питания и все данные будут сброшены? Это означает, что система кэширования нестабильна, и это нужно исправить.
1. Снимок с регулярным интервалом. Синхронный сервис "S" работает в фоновом режиме. Он берет замороженную копию хеш-таблицы и помещает ее в файл дампа, который сохраняется на жестком диске.
2. Восстановление журнала. Сервис, отвечающий за чтение и запись в хеш-таблице, будет непрерывно восстанавливать файлы в журнале. Все операции в журнале выполняют асинхронный вызов, который продолжает обновлять его. Эти запросы можно поместить в промежуточную очередь, чтобы не влиять на возможность чтения/записи. Каждая операция регистрируется, и если оборудование выйдет из строя и снова включится, мы сможем восстановить хеш-таблицу через операции в файле журнала.

--------------------------------------------------------------------------------------------------------------------
Доступность

Как сделать систему доступной на 100%?
В кластере есть два узла, node1 и node2, и у обоих есть свой собственный кэш. Допустим, мы используем согласованное хеширование: узел 1 содержит ключи и значения, а узел 2 обрабатывает их. Что произойдет, если узел 1 выйдет из строя?
Все запросы, поступающие на узел 1, будут приводить к промаху кэша. Они будут попадать в БД, увеличивая нагрузку по чтению/записи. Чтобы избежать этого, можно сделать реплику узла 1, например RF = 2. Поэтому, какие бы данные ни были у узла 1, такие же будут на узле 1'.

Преимущество. Нагрузка снижается, потому что запросы, поступающие на узел 1, также будут отправляться на узел 1' и обрабатываться им. Таким образом, запросы на чтение распределяются и обеспечивают высокую производительность с меньшей задержкой.

Недостаток. Продолжительная синхронизация этих двух узлов может привести к непоследовательности.
Как это исправить? Вместо копии можно создать подчиненный узел из нескольких узлов. В этом случае обновления данных также поступают на подчиненные устройства, но чтение/запись всегда происходит на главных узлах. Ведомое устройство не задействуется, пока главное не отключится.

--------------------------------------------------------------------------------------------------------------------
Кэширование баз данных

Запросы к базам данных могут быть медленными и требовать серьёзных системных ресурсов, так как серверу баз данных, для формирования ответа, нужно выполнять некие вычисления. Если запросы повторяются, кэширование их средствами базы данных поможет уменьшить время её отклика. Кроме того, кэширование полезно в ситуациях, когда несколько компьютеров работают с базой данных, выполняя одинаковые запросы.
Большинство серверов баз данных по умолчанию настроены с учётом оптимальных параметров кэширования. Однако, существует множество настроек, которые могут быть модифицированы для того, чтобы подсистема баз данных лучше соответствовала особенностям конкретного приложения.

--------------------------------------------------------------------------------------------------------------------
Кэширование ответов веб-сервера

веб-сервер, раньше рассматриваемый как единая сущность, разбит на две части. Одна из них, собственно веб-сервер, теперь занимается взаимодействием с клиентами и с серверным приложением, которое уже работает с системами хранения данных. Веб-сервер можно настроить так, чтобы он кэшировал ответы, в результате ему не придётся постоянно отправлять серверному приложению похожие запросы. Похожим образом, основное приложение может кэшировать некоторые части собственных ответов на ресурсоёмкие запросы к базе данных или на часто встречающиеся запросы файлов.
Ответы веб-сервера кэшируются в оперативной памяти. Кэш приложения может храниться либо локально, в памяти, либо на специальном кэширующем сервере, который использует базу данных, вроде Redis, которая хранит данные в оперативной памяти.

--------------------------------------------------------------------------------------------------------------------
Мемоизация функций

Сейчас поговорим об оптимизации производительности серверного приложения за счёт мемоизации. Это — разновидность кэширования, применяемая для оптимизации работы с ресурсоёмкими функциями. Данная техника позволяет выполнять полный цикл вычислений для определённого набора входных данных лишь один раз, а при следующих обращениях к функции с теми же входными данными сразу выдавать найденный ранее результат. Мемоизация реализуется посредством так называемых «таблиц поиска» (lookup table), хранящих ключи и значения. Ключи соответствуют входным данным функции, значения — результатам, которые возвращает функция при передаче ей этих входных данных.
Мемоизация — это обычный приём, используемый для повышения производительности программ. Однако он может быть не особенно полезным при работе с ресурсоёмкими функциями, которые вызываются редко, или с функциями, которые, и без мемоизации, работают достаточно быстро.

--------------------------------------------------------------------------------------------------------------------
Кэширование в браузере

Теперь перейдём на сторону клиента и поговорим о кэшировании в браузерах. В каждом браузере имеется реализация HTTP-кэша (его ещё называют веб-кэшем), который предназначен для временного хранения материалов, полученных из интернета, таких, как HTML-страницы, JavaScript-файлы и изображения.Этот кэш используется, когда в ответе сервера содержатся правильно настроенные HTTP-заголовки, указывающие браузеру на то, когда и на какое время он может кэшировать ответ сервера.Перед нами весьма полезная технология, которая даёт следующие преимущества всем участникам обмена данными:

Улучшаются впечатления пользователя от работы с сайтом, так как ресурсы из локального кэша загружаются очень быстро. Во время получения ответа не входит время прохождения сигнала от клиента к серверу и обратно (RTT, Round Trip Time), так как запрос не уходит в сеть.

Уменьшается нагрузка на серверное приложение и на другие серверные компоненты, ответственные за обработку запросов.

Высвобождается некоторая часть сетевых ресурсов, которыми теперь могут воспользоваться другие пользователи интернета, экономятся средства на оплату трафика.

--------------------------------------------------------------------------------------------------------------------