Что такое ООП?

Объектно-ориентированное программирование (ООП) — методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определенного класса, а классы образуют иерархию наследования.

- объектно-ориентированное программирование использует в качестве основных логических конструктивных элементов объекты, а не алгоритмы;
- каждый объект является экземпляром определенного класса
- классы образуют иерархии.

Программа считается объектно-ориентированной, только если выполнены все три указанных требования. В частности, программирование, не использующее наследование, называется не объектно-ориентированным, а программированием с помощью абстрактных типов данных.
Согласно парадигме ООП программа состоит из объектов, обменивающихся сообщениями. Объекты могут обладать состоянием, единственный способ изменить состояние объекта - послать ему сообщение, в ответ на которое, объект может изменить собственное состояние.

--------------------------------------------------------------------------------------------------------------------
Назовите основные принципы ООП.

Инкапсуляция - сокрытие реализации.
Наследование - создание новой сущности на базе уже существующей.
Полиморфизм - возможность иметь разные формы для одной и той же сущности.
Абстракция - набор общих характеристик.

--------------------------------------------------------------------------------------------------------------------
Что такое «инкапсуляция»?

Инкапсуляция - это свойство системы, позволяющее объединить данные и методы, работающие с ними, в классе и скрыть детали реализации от пользователя, открыв только то, что необходимо при последующем использовании.
Цель инкапсуляции — уйти от зависимости внешнего интерфейса класса (то, что могут использовать другие классы) от реализации. Чтобы малейшее изменение в классе не влекло за собой изменение внешнего поведения класса.

--------------------------------------------------------------------------------------------------------------------
Что такое «наследование»?

Наследование - это свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью.
Класс, от которого производится наследование, называется предком, базовым или родительским. Новый класс - потомком, наследником или производным классом.

--------------------------------------------------------------------------------------------------------------------
Что такое «полиморфизм»?

Полиморфизм - это способность программы идентично использовать объекты с одинаковым интерфейсом без информации о конкретном типе этого объекта.
Преимуществом полиморфизма является то, что он помогает снижать сложность программ, разрешая использование одного и того же интерфейса для задания единого набора действий. Выбор же конкретного действия, в зависимости от ситуации, возлагается на компилятор языка программирования. Отсюда следует ключевая особенность полиморфизма - использование объекта производного класса, вместо объекта базового (потомки могут изменять родительское поведение, даже если обращение к ним будет производиться по ссылке родительского типа).
В более общем смысле, концепцией полиморфизма является идея "один интерфейс, множество методов". Это означает, что можно создать общий интерфейс для группы близких по смыслу действий.

Полиморфная переменная, это переменная, которая может принимать значения разных типов, а полиморфная функция, это функция, у которой хотя бы один аргумент является полиморфной переменной. Выделяют два вида полиморфных функций:

Полиморфизм используется, чтобы сделать приложения более модульными и расширяемыми. Вместо беспорядочных условных выражений, описывающих различные варианты действий, вы создаете взаимозаменяемые объекты, которые выбираете в зависимости от ваших потребностей. Это основная цель полиморфизма.

--------------------------------------------------------------------------------------------------------------------
Что такое «абстракция»?

Абстракция - это выделение общих характеристик объекта,исключая набор незначительных.
С помощью принципа абстракции данных, данные преобразуются в объекты. Данные обрабатываются в виде цепочки сообщений между отдельными объектами. Все объекты проявляют свои уникальные признаки поведения. Огромный плюс абстракции в том, что она отделяет реализацию объектов от их деталей, что в свою очередь позволяет управлять функциями высокого уровня через функции низкого уровня.

--------------------------------------------------------------------------------------------------------------------
Расскажите про основные понятия ООП: «класс», «объект», «интерфейс».

Класс - это способ описания сущности, определяющий состояние и поведение, зависящее от этого состояния, а также правила для взаимодействия с данной сущностью (контракт).
С точки зрения программирования класс можно рассматривать как набор данных (полей, атрибутов, членов класса) и функций для работы с ними (методов).
С точки зрения структуры программы, класс является сложным типом данных.
Объект (экземпляр) - это отдельный представитель класса, имеющий конкретное состояние и поведение, полностью определяемое классом. Каждый объект имеет конкретные значения атрибутов и методы, работающие с этими значениями на основе правил, заданных в классе.
Интерфейс - это набор методов класса, доступных для использования. Интерфейсом класса будет являться набор всех его публичных методов в совокупности с набором публичных атрибутов. По сути, интерфейс специфицирует класс, чётко определяя все возможные действия над ним.

--------------------------------------------------------------------------------------------------------------------
В чем заключаются преимущества и недостатки объектно-ориентированного подхода в программировании?

Преимущества:
Объектная модель вполне естественна, поскольку в первую очередь ориентирована на человеческое восприятие мира, а не на компьютерную реализацию.

Классы позволяют проводить конструирование из полезных компонентов, обладающих простыми инструментами, что позволяет абстрагироваться от деталей реализации.

Данные и операции над ними образуют определенную сущность, и они не разносятся по всей программе, как нередко бывает в случае процедурного программирования, а описываются вместе. Локализация кода и данных улучшает наглядность и удобство сопровождения программного обеспечения.

Инкапсуляция позволяет привнести свойство модульности, что облегчает распараллеливание выполнения задачи между несколькими исполнителями и обновление версий отдельных компонентов.
Возможность создавать расширяемые системы.

Использование полиморфизма оказывается полезным при:
- Обработке разнородных структур данных. Программы могут работать, не различая вида объектов, что существенно упрощает код. Новые виды могут быть добавлены в любой момент.
- Изменении поведения во время исполнения. На этапе исполнения один объект может быть заменен другим, что позволяет легко, без изменения кода, адаптировать алгоритм в зависимости от того, какой используется объект.
- Реализации работы с наследниками. Алгоритмы можно обобщить настолько, что они уже смогут работать более чем с одним видом объектов.
- Возможности описать независимые от приложения части предметной области в виде набора универсальных классов, или фреймворка, который в дальнейшем будет расширен за счет добавления частей, специфичных для конкретного приложения.

Повторное использование кода:
- Сокращается время на разработку, которое может быть отдано другим задачам.
- Компоненты многоразового использования обычно содержат гораздо меньше ошибок, чем вновь разработанные, ведь они уже не раз подвергались проверке.
- Когда некий компонент используется сразу несколькими клиентами, улучшения, вносимые в его код, одновременно оказывают положительное влияние и на множество работающих с ним программ.
- Если программа опирается на стандартные компоненты, ее структура и пользовательский интерфейс становятся более унифицированными, что облегчает ее понимание и упрощает использование.

Недостатки:
В сложных иерархиях классов поля и методы обычно наследуются с разных уровней. И не всегда легко определить, какие поля и методы фактически относятся к данному классу.

Код для обработки сообщения иногда «размазан» по многим методам (иначе говоря, обработка сообщения требует не одного, а многих методов, которые могут быть описаны в разных классах).

Документирование классов - задача более трудная, чем это было в случае процедур и модулей. Поскольку любой метод может быть переопределен, в
документации должно говориться не только о том, что делает данный метод, но и о том, в каком контексте он вызывается.

Неэффективность и неэкономное распределения памяти на этапе выполнения (по причине издержек на динамическое связывание и проверки типов на этапе выполнения).

Излишняя универсальность. Часто содержится больше методов, чем это реально необходимо текущей программе. А поскольку лишние методы не могут быть удалены, они становятся мертвым грузом.

--------------------------------------------------------------------------------------------------------------------
Что подразумевают в плане принципов ООП выражения «IS-A» и «HAS-A»?

Между классами в Java есть два вида отношений:
отношения IS-A
Принцип IS-A в ООП основан на наследовании классов или реализации интерфейсов. К примеру, если класс Lion наследует Cat, мы говорим, что Lion является Cat:
Lion IS-A Cat
(но не всякий Cat является Lion-ом) Точно такая же ситуация с интерфейсами. Если класс Lion реализует интерфейс WildAnimal, то они также находятся в отношении:
Lion IS-A WildAnimal

отношения HAS-A
Данный тип отношений основан на использовании классов другими классами, ещё называемый "ассоциация". Ассоциация — это один класс ссылается на другой класс (или даже друг на друга). Например, класс Car может ссылаться на класс Passenger, и это будет отношение:
Car HAS-A Passenger
И наоборот: если Passenger имеет ссылку на Car, то это будет отношение:
Passenger HAS-A Car

--------------------------------------------------------------------------------------------------------------------
В чем разница между композицией и агрегацией?

Агрегация и композиция — не что иное, как частные случаи ассоциации.

Агрегация — отношение, когда один объект является частью другого. Например, пассажир может находиться в машине. Также пассажиров может быть несколько или не быть вовсе (если мы говорим про теслу, то и водитель не обязателен). Например:

public class Car {
private List passengers = new ArrayList<>();
void setPassenger(Passenger passenger) { passengers.add(passenger);
}
void move() {
for (Passenger passenger : passengers) { System.out.println("Перевозка пассажира - " + passenger.toString());
}
passengers.clear();
} }

То есть нам не важно количество пассажиров (и есть ли они вообще): от этого функционал класса Car не зависит. Также агрегация подразумевает, что при использовании объекта другим объектом первый можно использовать еще в других объектах. Например, один и тот же студент может входить и в кружок вязания, и в музыкальную группу рокеров, и при этом ходить в группу изучающих английских. Как вы поняли, агрегация — это более свободные ассоциативные отношения классов.

Композиция — еще более жесткое отношение, когда объект не только является частью другого объекта, но и работа другого объекта очень зависит от первого. Например, двигатель у машины. Хоть двигатель и может быть без машины, но вне ее он бесполезен. Ну и машина не может работать без двигателя:

public class Car {
private Engine engine;
public Car(Engine engine) { this.engine = engine;
}
void startMoving() { engine.start(); ... }

Также композиция подразумевает, что при использовании объекта другим объектом первый не может принадлежать кому-либо другому. Если вернуться к нашему примеру, двигатель может принадлежать только одной машине, но никак не двум или более одновременно.

--------------------------------------------------------------------------------------------------------------------
Что такое статическое и динамическое связывание?

Присоединение вызова метода к телу метода называется связыванием. Если связывание проводится компилятором (компоновщиком) перед запуском программы, то оно называется статическим или ранним связыванием (early binding).
В свою очередь, позднее связывание (late binding) это связывание, проводимое непосредственно во время выполнения программы, в зависимости от типа объекта. Позднее связывание также называют динамическим (dynamic) или связыванием на стадии выполнения (runtime binding). В языках, реализующих позднее связывание, должен существовать механизм определения фактического типа объекта во время работы программы, для вызова подходящего метода. Иначе говоря, компилятор не знает тип объекта, но механизм вызова методов определяет его и вызывает соответствующее тело метода. Механизм позднего связывания зависит от конкретного языка, но нетрудно предположить, что для его реализации в объекты должна включаться какая-то дополнительная информация.
Для всех методов Java используется механизм позднего (динамического) связывания, если только метод не был объявлен как final (приватные методы являются final по умолчанию).

--------------------------------------------------------------------------------------------------------------------
Что такое перегрузка метода и переопределение метода?

Перегрузка метода:
При перегрузке методов методы одного класса имеют одно и то же имя, но каждый метод должен иметь разное количество параметров или параметров, имеющих разные типы и порядок.
Перегрузка метода - это «добавить» или «расширить» поведение метода.
Это полиморфизм времени компиляции.
У методов должна быть другая подпись.
Может потребоваться или не потребоваться наследование в перегрузке метода.

Переопределение метода:
При переопределении метода подкласс имеет тот же метод с тем же именем, точно такое же количество и тип параметров и тот же тип возвращаемого значения, что и суперкласс.
Переопределение метода заключается в «изменении» существующего поведения метода.
Это полиморфизм времени выполнения.
Методы должны иметь одинаковую подпись.
Это всегда требует наследования в переопределении метода.

--------------------------------------------------------------------------------------------------------------------
В чем разница между процедурным программированием и ООП?

Объектно-ориентированного программирования
На основе объектов
Важность состояний и поведения объекта
Поддерживает инкапсуляцию
Следует восходящему подходу
Лучшая возможность повторного использования кода
Менее сложный и простой в расширении и изменении кода

Процедурное программирование
На основе функций
Более важна последовательность выполняемых функций
Не поддерживает инкапсуляцию
Следует подходу сверху вниз
Меньше повторного использования кода
Более сложный для расширения и изменения кода

--------------------------------------------------------------------------------------------------------------------
Можно ли вызвать метод базового класса без создания экземпляра класса?

Да, это возможно при использовании статического метода или когда базовый класс наследуется каким-либо другим подклассом.

--------------------------------------------------------------------------------------------------------------------
Виды полиморфизма

В Java полиморфизм можно разделить на две категории:

Полиморфизм времени компиляции (Compile-time, статическое связывание)
Полиморфизм времени компиляции также известен как статическое связывание. Этот тип полиморфизма может быть достигнут путем перегрузки функций или перегрузки операторов. Но в Java это ограничено перегрузкой функций, поскольку Java не поддерживает перегрузку операторов. Перегрузка функций Когда есть по крайней мере две функции или метода с одинаковым именем функции, но либо число содержащихся в них параметров разное, либо хотя бы один тип данных соответствующего параметра отличается (или оба), тогда это называется функцией или методом перегрузки, и эти функции известны как перегруженные функции.

Полиморфизм времени выполнения (Runtime, динамическое связывание)
Этот вариант также известен как динамическое связывание. В этом процессе вызов функции, созданной для другой функции, разрешается только во время выполнения. Мы можем добиться динамического связывания в Java с помощью переопределения методов.
Переопределение метода в Java происходит, когда метод в базовом классе имеет определение в производном классе. Метод или функция базового класса называется переопределенным методом.

--------------------------------------------------------------------------------------------------------------------
Какие существуют типы наследования?

Java поддерживает четыре типа наследования:

Одиночное наследование: при одиночном наследовании один класс наследует свойства другого, то есть будет только один родительский и один дочерний класс.
Многоуровневое наследование: когда класс является производным от класса, который также является производным от другого класса, то есть класса, имеющего более одного родительского класса, но на разных уровнях, такой тип наследования называется многоуровневым наследованием.
Иерархическое наследование: когда класс имеет несколько дочерних классов (подклассов) или, другими словами, несколько дочерних классов имеют один и тот же родительский класс, тогда такой вид наследования называется иерархическим.
Гибридное наследование. Гибридное наследование - это комбинация двух или более типов наследования.

--------------------------------------------------------------------------------------------------------------------
Можете ли вы переопределить частный или статический метод?

Вы не можете переопределить частный или статический метод. Если вы создаете аналогичный метод с тем же возвращаемым типом и теми же аргументами метода в дочернем классе, он скроет метод суперкласса; это известно как метод сокрытия. Точно так же вы не можете переопределить частный метод в подклассе, потому что он там недоступен. Что вы можете сделать, так это создать другой частный метод с тем же именем в дочернем классе. Давайте посмотрим на пример ниже, чтобы лучше понять это.

--------------------------------------------------------------------------------------------------------------------
Расскажите о наследовании в Java. Каковы особенности использования ключевого слова super?

Возможно наследование лишь одного класса: множественное наследование в Java отсутствует (но с появлением дефолтных методов в Java 8 это утверждение станет весьма спорным).

Приватные методы и поля наследуются тоже, просто к ним не будет доступа с наследника (но если у нас, к примеру, приватное поле и к нему есть public или protected — геттеры и сеттеры, с полем можно работать через них).

final классы не наследуются.

final методы не переопределяются (но их можно наследовать и перегружать).

static методы и переменные не наследуются (т. к. они привязаны не к объектам, а к классам).

При наследовании от абстрактных классов, обязательна реализация их абстрактных методов, либо текущий класс тоже нужно объявить абстрактным.

При наличии не дефолтных конструкторов в родителе, в классе потомке их обязательно нужно переопределять (но @Override над ними не пишется).

Переопределенным методам в наследнике можно расширять модификатор доступа: private -> default -> protected -> public.

Переопределенным методам в наследнике можно сужать прописываемые исключения, например: Exception -> IOException -> FileNotFoundException.

--------------------------------------------------------------------------------------------------------------------
Почему запрещено множественное наследование java?

Множественное наследование — это возможность создания одного класса с несколькими суперклассами. Java не обеспечивает поддержку множественного наследования в классах . Java не поддерживает множественное наследование в классах, потому что это может привести к проблеме с бриллиантами, и вместо того, чтобы предоставлять какой-то сложный способ ее решения, существуют более эффективные способы, с помощью которых мы можем достичь того же результата, что и множественное наследование.

Допустим, SuperClass — это абстрактный класс, объявляющий некоторый метод, а ClassA, ClassB — это конкретные классы которые его реализуют.
Теперь предположим, что реализация ClassC она расширяет как ClassA, так и ClassB.
Обратите внимание, что метод test() вызывает метод суперкласса doSomething() , что приводит к неоднозначности, поскольку компилятор не знает, какой метод суперкласса следует выполнить, и из-за диаграммы классов в форме ромба он называется Diamond Problem, и это Основная причина, по которой Java не поддерживает множественное наследование в классах.

--------------------------------------------------------------------------------------------------------------------