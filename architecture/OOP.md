#### Что такое объектно-ориентированное программирование (ООП)?

Это методология, в которой программа строится не вокруг алгоритмов, а вокруг **объектов**. Каждый объект является экземпляром **класса**, а классы могут быть связаны иерархией **наследования**. Программа представляет собой систему взаимодействующих объектов, которые обмениваются сообщениями и изменяют свое состояние.

#### Четыре фундаментальных принципа ООП

1.  **Инкапсуляция**
    *   **Суть:** Объединение данных (полей) и методов для работы с ними в единое целое — класс. Детали реализации скрываются от внешнего мира, а наружу предоставляется только контролируемый интерфейс (публичные методы).
    *   **Цель:** Защитить данные от неконтролируемого изменения и сделать класс самодостаточным "черным ящиком". Это позволяет менять внутреннюю реализацию класса, не затрагивая код, который его использует.

2.  **Наследование**
    *   **Суть:** Механизм, позволяющий создать новый класс (потомок) на основе уже существующего (родитель), заимствуя его поля и методы.
    *   **Цель:** Повторное использование кода и построение иерархий "общее-частное" (например, `Транспорт` -> `Автомобиль` -> `Электромобиль`).

3.  **Полиморфизм**
    *   **Суть:** Способность программы использовать объекты с одинаковым интерфейсом без информации об их конкретном типе. Это идея "один интерфейс — множество реализаций".
    *   **Цель:** Создавать гибкий и расширяемый код. Например, можно написать метод, который работает с объектом типа `Фигура`, и передавать в него как `Круг`, так и `Квадрат`, если они оба являются наследниками `Фигуры` и реализуют метод `посчитатьПлощадь()`. Выбор конкретной реализации метода происходит автоматически во время выполнения программы (**динамическое связывание**).

4.  **Абстракция**
    *   **Суть:** Выделение наиболее значимых характеристик объекта и отвлечение от несущественных деталей.
    *   **Цель:** Упрощение сложных систем. Мы работаем с высокоуровневыми понятиями (например, "отправить сообщение"), не задумываясь о низкоуровневой реализации (как именно формируются и передаются пакеты по сети).

#### Основные понятия

*   **Класс:** Шаблон или чертеж, описывающий свойства (поля) и поведение (методы), общие для всех объектов определенного типа.
*   **Объект:** Конкретный экземпляр класса, существующий в памяти, со своим уникальным состоянием (значениями полей).
*   **Интерфейс:** Набор публичных методов, определяющий "контракт" поведения. Класс, реализующий интерфейс, обязуется предоставить реализацию всех его методов.

#### Отношения между классами

*   **Наследование (IS-A):** Отношение "является". `Собака` IS-A `Животное`.
*   **Ассоциация (HAS-A):** Отношение "имеет" или "использует". `Водитель` HAS-A `Машина`. Делится на два частных случая:
    *   **Агрегация:** Слабая связь, где "часть" может существовать без "целого". Пример: `Студент` и `Учебная группа`. Если группу расформируют, студент останется.
    *   **Композиция:** Жесткая связь, где "часть" не может существовать без "целого". Пример: `Двигатель` и `Машина`. Двигатель неотделим от конкретной машины.

#### Ключевые различия и механизмы

*   **Перегрузка vs Переопределение:**
    *   **Перегрузка (Overloading):** Методы в одном классе с одинаковым именем, но разными параметрами (типом, количеством). Это полиморфизм времени компиляции.
    *   **Переопределение (Overriding):** Замена реализации метода родительского класса в дочернем классе. Метод должен иметь ту же сигнатуру. Это полиморфизм времени выполнения.
*   **Статическое vs Динамическое связывание:**
    *   **Статическое (раннее):** Вызов метода связывается с его реализацией на этапе компиляции (например, для `private`, `final`, `static` методов).
    *   **Динамическое (позднее):** Связывание происходит во время выполнения программы, в зависимости от реального типа объекта. Это механизм, обеспечивающий полиморфизм.
*   **Множественное наследование в Java:** Запрещено для классов во избежание **"ромбовидной проблемы" (Diamond Problem)** — неоднозначности, когда класс наследует две разные реализации одного и того же метода от двух родительских классов. Проблема решается с помощью интерфейсов.

#### Основные принципы разработки

*   **DRY (Don't Repeat Yourself / Не повторяй себя):** Принцип, нацеленный на снижение повторения кода и другой информации. Вместо дублирования следует использовать абстракции, обобщая общую логику в одном месте.

*   **KISS (Keep it simple, stupid / Делай проще):** Принцип, призывающий выбирать самые простые решения и избегать неоправданной сложности в проектировании и программировании.

*   **YAGNI (You Ain't Gonna Need It / Вам это не понадобится):** Принцип, согласно которому следует реализовывать только ту функциональность, которая требуется прямо сейчас, отказываясь от избыточных возможностей, создаваемых "про запас".

*   **Yoda Conditions (Условия Йоды):** Стиль написания сравнений, при котором константа ставится слева (`5 == a`). Это помогает избежать случайных присваиваний (`a = 5`) вместо сравнений, так как попытка изменить константу вызовет ошибку компилятора.

*   **CRC Cards (Класс-Ответственность-Кооперация):** Метод ООП-проектирования, использующий карточки для определения классов, их обязанностей и взаимодействий. Это помогает сфокусироваться на высокоуровневой архитектуре.

#### Принципы SOLID

*   **SOLID:** Акроним для пяти основных принципов объектно-ориентированного проектирования:
    *   **S - Single Responsibility Principle (Принцип единственной ответственности):** У модуля (класса, метода) должна быть только одна причина для изменения. Он должен отвечать за одну «заинтересованную группу» (например, бизнес-логику одного отдела).
    *   **O - Open/Closed Principle (Принцип открытости/закрытости):** Сущности должны быть открыты для расширения (добавления новой функциональности), но закрыты для изменения (существующий код трогать не нужно). Это достигается через использование интерфейсов.
    *   **L - Liskov's Substitution Principle (Принцип подстановки Барбары Лисков):** Объекты дочерних классов должны быть способны заменять объекты родительского класса без изменения корректности работы программы. Если код работает с интерфейсом, он должен корректно работать с любой его реализацией.
    *   **I - Interface Segregation Principle (Принцип разделения интерфейса):** Нельзя заставлять класс реализовывать методы интерфейса, которые он не использует. Лучше создать несколько узкоспециализированных интерфейсов, чем один универсальный.
    *   **D - Dependency Inversion Principle (Принцип инверсии зависимостей):** Модули высокого уровня не должны зависеть от модулей низкого уровня; оба должны зависеть от абстракций (интерфейсов). Зависимости строятся на стабильных абстракциях, а не на изменчивых реализациях.