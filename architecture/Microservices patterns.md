# Микросервисные паттерны

Микросервисные паттерны — это проверенные временем решения для проектирования, разработки, взаимодействия, управления данными и обеспечения отказоустойчивости в микросервисной архитектуре. Они помогают решать типичные проблемы, такие как декомпозиция приложений, интеграция с устаревшими системами, управление транзакциями, коммуникация между сервисами и мониторинг. Цель — обеспечить автономность, масштабируемость и надежность микросервисов.

---

## Паттерны декомпозиции

Эти паттерны помогают разделить приложение на независимые микросервисы.

### 1. Разбиение по бизнес-возможностям (Decompose By Business Capability)

**Описание**: Приложение делится на микросервисы, каждый из которых отвечает за отдельную бизнес-функцию (например, управление заказами, доставка, уведомления). Бизнес-возможности определяются на основе функций, доступных пользователям.

**Пример**: В интернет-магазине создаются отдельные микросервисы для:
- Создания заказов (Orders Creation)
- Доставки заказов (Orders Delivery)
- Уведомлений о заказах (Orders Alerts)
- Управления предзаказами (Preorders)

**Преимущества**:
- Простота понимания и реализации.
- Соответствие бизнес-целям, что упрощает управление командами.

**Недостатки**:
- Может привести к появлению "божественных классов" (God Classes) — общих сущностей, используемых несколькими сервисами (например, объект "заказ"), что усложняет их разделение.

**Применение**: Подходит для новых приложений или проектов с четко определенными бизнес-функциями.

### 2. Разбиение по поддоменам (Decompose By Subdomain)

**Описание**: Основан на принципах предметно-ориентированного проектирования (Domain-Driven Design, DDD). Приложение делится на поддомены, каждый из которых имеет ограниченный контекст (Bounded Context) — независимую модель данных и логику. Микросервис создается для каждого поддомена.

**Пример**: Вместо четырех микросервисов для заказов (как в предыдущем паттерне) создается один микросервис "Orders Service" в поддомене "Заказы", охватывающий все аспекты заказов.

**Преимущества**:
- Уменьшает количество микросервисов, минимизируя дублирование.
- Избегает "божественных классов" за счет четкого разделения контекстов.
- Обеспечивает независимость сервисов.

**Недостатки**:
- Требует глубокого понимания домена и навыков DDD.
- Сложность в определении границ поддоменов.

**Применение**: Рекомендуется для сложных систем, где важна независимость сервисов и минимизация связей.

---

## Паттерны рефакторинга

Эти паттерны помогают перевести монолитные приложения на микросервисную архитектуру.

### 1. Душитель (Strangler)

**Описание**: Постепенная миграция монолита на микросервисы. Функции монолита переносятся в микросервисы, а фасад направляет запросы либо к монолиту, либо к новым сервисам. Новые функции реализуются только в микросервисах. После полного переноса монолит выводится из эксплуатации.

**Пример**: В банковском приложении фасад перенаправляет запросы на управление счетами в новый микросервис, пока монолит обрабатывает устаревшие функции.

**Преимущества**:
- Минимизирует риски, позволяя постепенно заменять монолит.
- Поддерживает непрерывную работу приложения.

**Недостатки**:
- Усложняет архитектуру из-за фасада.
- Не подходит для небольших монолитов, где проще выполнить полную замену.

**Применение**: Идеально для крупных монолитных приложений с длительным процессом миграции.

### 2. Уровень защиты от повреждений (Anti-Corruption Layer)

**Описание**: Создает промежуточный слой между микросервисами и устаревшими подсистемами, изолируя их. Этот слой переводит данные и запросы между разными моделями и API, сохраняя независимость.

**Пример**: В системе с устаревшим SOAP API для биллинга создается слой, преобразующий вызовы в REST для нового микросервиса.

**Преимущества**:
- Позволяет интегрировать устаревшие системы без их рефакторинга.
- Сохраняет независимость микросервисов.

**Недостатки**:
- Добавляет сложность и задержки из-за дополнительного слоя.
- Требует поддержки логики преобразования данных.

**Применение**: Используется, когда невозможно или слишком дорого рефакторить устаревшие подсистемы.

---

## Паттерны управления данными

Эти паттерны решают проблемы хранения и обмена данными в микросервисной архитектуре.

### 1. База данных на сервис (Database Per Service)

**Описание**: Каждый микросервис имеет собственное логическое хранилище данных (отдельная схема, таблица или коллекция). Физически сервисы могут использовать одну базу данных, но с изолированными данными.

**Пример**: Микросервис "Заказы" использует свою таблицу в PostgreSQL, а микросервис "Пользователи" — другую, даже если оба в одной базе.

**Преимущества**:
- Увеличивает автономность сервисов.
- Упрощает масштабирование и разработку.

**Недостатки**:
- Усложняет обмен данными между сервисами.
- Трудно обеспечить транзакционные гарантии ACID.

**Применение**: Подходит для крупных проектов с независимыми командами. Не рекомендуется для небольших приложений.

### 2. API-композиция (API Composition)

**Описание**: Создается API, которое собирает данные из нескольких микросервисов и объединяет их в памяти для клиента. Часто используется с паттерном API Gateway.

**Пример**: API для отображения профиля пользователя запрашивает данные из сервисов "Пользователи" и "Заказы", объединяя их в ответ.

**Преимущества**:
- Простота реализации.
- Удобен для клиентских запросов, требующих данных из нескольких источников.

**Недостатки**:
- Может быть неэффективным при больших объемах данных.
- Увеличивает нагрузку на API.

**Применение**: Подходит для приложений с умеренными требованиями к данным.

### 3. Разделение команд и запросов (CQRS)

**Описание**: Разделяет операции чтения (Query) и записи (Command). Простая форма использует разные ORM-модели, расширенная — отдельные хранилища для чтения и записи, синхронизируемые асинхронно.

**Пример**: Сервис заказов записывает данные в MongoDB (для записи), а читает из Elasticsearch (для чтения), синхронизируя их через события.

**Преимущества**:
- Оптимизирует производительность чтения и записи.
- Поддерживает независимое масштабирование.

**Недостатки**:
- Увеличивает сложность системы.
- Вводит слабую согласованность данных.

**Применение**: Используется в сложных системах с высокой нагрузкой на чтение или запись.

### 4. Поиск событий (Event Sourcing)

**Описание**: Вместо сохранения текущего состояния объекта сохраняются события, изменяющие его. Состояние воссоздается путем воспроизведения событий. Часто используется с CQRS.

**Пример**: В системе заказов сохраняются события "Заказ создан", "Заказ оплачен", а текущее состояние заказа вычисляется на основе этих событий.

**Преимущества**:
- Обеспечивает историю изменений.
- Подходит для высокомасштабируемых систем.

**Недостатки**:
- Усложняет разработку и отладку.
- Требует хранилища событий.

**Применение**: Рекомендуется для систем, управляемых событиями, например, финансовых транзакций.

### 5. Сага (Saga)

**Описание**: Управляет распределенными транзакциями через цепочку локальных транзакций, каждая из которых публикует событие для следующей. При ошибке выполняются компенсирующие транзакции. Поддерживает хореографию (децентрализованную) и оркестровку (централизованную).

**Пример**: При оформлении заказа микросервис "Оплата" подтверждает платеж и публикует событие для сервиса "Доставка". При сбое выполняется отмена.

**Преимущества**:
- Обеспечивает согласованность в распределенных системах.
- Подходит для NoSQL и систем без 2PC.

**Недостатки**:
- Сложность отладки и реализации компенсирующих транзакций.
- Не подходит для систем с циклическими зависимостями.

**Применение**: Используется в системах с асинхронной коммуникацией и NoSQL.

---

## Паттерны коммуникации

Эти паттерны регулируют взаимодействие микросервисов с клиентами и другими сервисами.

### 1. API-шлюз (API Gateway)

**Описание**: Единая точка входа между клиентами и микросервисами. Поддерживает маршрутизацию, агрегацию данных и сквозные функции (аутентификация, логирование).

**Пример**: В интернет-магазине API Gateway направляет запросы на профиль пользователя к сервису "Пользователи", а на заказы — к сервису "Заказы".

**Типы**:
- **Gateway Routing**: Перенаправляет запросы как обратный прокси.
- **Gateway Aggregation**: Объединяет данные из нескольких сервисов.
- **Gateway Offloading**: Выполняет сквозные задачи (SSL, аутентификация).

**Преимущества**:
- Упрощает клиентскую логику.
- Централизует сквозные функции.

**Недостатки**:
- Может стать единой точкой отказа.
- Требует тщательного мониторинга и масштабирования.

**Применение**: Рекомендуется для крупных систем с множеством микросервисов.

### 2. Бэкенды для фронтендов (Backends for Frontends, BFF)

**Описание**: Вариант API Gateway, где для каждого типа клиента (Web, Mobile, Desktop) создается отдельный шлюз, адаптированный под его потребности.

**Пример**: Мобильное приложение получает данные через BFF, оптимизированный для низкой пропускной способности, в отличие от Web-клиента.

**Преимущества**:
- Уменьшает избыточные настройки в шлюзе.
- Оптимизирует API для разных клиентов.

**Недостатки**:
- Увеличивает число компонентов.
- Не нужен, если клиенты имеют схожие требования.

**Применение**: Подходит для приложений с разнообразными клиентами.

---

## Паттерны пользовательского интерфейса

Эти паттерны решают задачу отображения данных из нескольких микросервисов в UI.

### 1. Сборка пользовательского интерфейса на стороне клиента (Client-Side UI Composition)

**Описание**: HTML создается и обновляется в браузере. Страница делится на фрагменты, каждый из которых обслуживается отдельным микросервисом. Используются SPA-фреймворки (ReactJS, AngularJS).

**Пример**: В интернет-магазине блок "Корзина" обновляется сервисом "Заказы", а блок "Рекомендации" — сервисом "Рекомендации".

**Преимущества**:
- Гибкость и независимость фрагментов.
- Поддержка динамического обновления.

**Недостатки**:
- Увеличивает нагрузку на клиент.
- Требует сложной клиентской логики.

**Применение**: Подходит для интерактивных веб-приложений.

### 2. Сборка фрагментов страниц на стороне сервера (Server-Side Page Fragment Composition)

**Описание**: Страница собирается на сервере, а клиент получает готовый HTML. Используются службы (Nginx, Varnish, CDN) для сборки.

**Пример**: Сервер собирает страницу профиля, запрашивая фрагменты у сервисов "Пользователи" и "Заказы".

**Преимущества**:
- Быстрая загрузка страниц.
- Меньшая нагрузка на клиент.

**Недостатки**:
- Усложняет серверную логику.
- Требует дополнительных ресурсов на сервере.

**Применение**: Используется для приложений, где важна скорость загрузки.

---

## Паттерны обнаружения сервисов

Эти паттерны помогают клиентам находить микросервисы в динамических средах.

### 1. Обнаружение сервисов на стороне клиента (Client-Side Service Discovery)

**Описание**: Клиент напрямую обращается к реестру сервисов (Service Registry) для получения адресов экземпляров сервиса, выбирая их с помощью балансировки нагрузки.

**Пример**: Клиент запрашивает у реестра адреса сервиса "Заказы" и кэширует их для последующих вызовов.

**Преимущества**:
- Независимость от платформы развертывания.
- Гибкость в выборе алгоритмов балансировки.

**Недостатки**:
- Требует клиентских библиотек для каждого языка.
- Увеличивает нагрузку на разработку реестра.

**Применение**: Подходит для смешанных сред (например, Kubernetes + устаревшие системы).

### 2. Обнаружение сервисов на стороне сервера (Server-Side Service Discovery)

**Описание**: Платформа развертывания (Kubernetes, Docker) управляет регистрацией и маршрутизацией. Клиент делает запрос по DNS, а маршрутизатор выбирает экземпляр.

**Пример**: В Kubernetes клиент запрашивает сервис "Заказы" по DNS, а платформа направляет запрос к доступному экземпляру.

**Преимущества**:
- Минимизирует клиентский код.
- Интегрировано в платформы развертывания.

**Недостатки**:
- Не работает для сервисов вне платформы.
- Зависимость от инфраструктуры.

**Применение**: Рекомендуется для однородных платформ.

---

## Паттерны развертывания

Эти паттерны определяют, как развертывать микросервисы.

### 1. Экземпляр сервиса на хост (Service Instance Per Host)

**Описание**: Каждый экземпляр сервиса развертывается на отдельном хосте (виртуальном или физическом). Варианты: Service Instance Per VM или Per Container.

**Пример**: Сервис "Заказы" развернут в отдельном Docker-контейнере на сервере.

**Преимущества**:
- Изолирует сервисы, минимизируя конфликты.
- Упрощает повторное развертывание.

**Недостатки**:
- Менее эффективное использование ресурсов.
- Требует больше хостов.

**Применение**: Подходит для систем, где важна изоляция.

### 2. Сине-зеленое развертывание (Blue-Green Deployment)

**Описание**: Две идентичные среды (синяя — активная, зеленая — новая) позволяют переключать трафик на новую версию после успешного тестирования.

**Пример**: Новая версия сервиса "Пользователи" разворачивается в зеленой среде, тестируется, затем трафик переключается с синей среды.

**Преимущества**:
- Минимизирует простои.
- Позволяет откат при ошибках.

**Недостатки**:
- Требует двойных ресурсов.
- Усложняет тестирование.

**Применение**: Используется для критически важных приложений.

---

## Паттерны отказоустойчивости

Эти паттерны повышают надежность микросервисов.

### 1. Автоматический выключатель (Circuit Breaker)

**Описание**: Прокси отслеживает сбои и прерывает запросы при превышении порога ошибок. Состояния: Closed (нормальная работа), Open (блокировка запросов), Half-Open (проверка восстановления).

**Пример**: Сервис "Оплата" перестает отвечать, прокси переходит в Open, возвращая ошибку без обращения к сервису.

**Преимущества**:
- Предотвращает каскадные сбои.
- Улучшает отказоустойчивость.

**Недостатки**:
- Требует настройки порогов и мониторинга.
- Усложняет архитектуру.

**Применение**: Подходит для систем с высокой нагрузкой и частыми сбоями.

### 2. Переборка (Bulkhead)

**Описание**: Изолирует ресурсы (например, пулы соединений) для каждого сервиса, предотвращая перегрузку системы.

**Пример**: Сервис "Заказы" имеет отдельный пул соединений к базе данных, не влияющий на сервис "Пользователи".

**Преимущества**:
- Защищает от каскадных сбоев.
- Обеспечивает независимость сервисов.

**Недостатки**:
- Увеличивает сложность управления ресурсами.
- Может снижать эффективность их использования.

**Применение**: Используется в критически важных системах.

---

## Паттерны мониторинга

Эти паттерны обеспечивают контроль работы микросервисов.

### 1. Агрегация логов (Log Aggregation)

**Описание**: Централизованная служба собирает логи от всех экземпляров сервисов для анализа и оповещений.

**Пример**: Логи всех микросервисов отправляются в ELK Stack для поиска и мониторинга.

**Преимущества**:
- Упрощает анализ и поиск ошибок.
- Поддерживает настройку оповещений.

**Недостатки**:
- Требует инфраструктуры для хранения логов.
- Может быть дорого при больших объемах.

**Применение**: Подходит для любых микросервисных систем.

### 2. Распределенная трассировка (Distributed Tracing)

**Описание**: Уникальный TraceId отслеживает запрос через все сервисы, фиксируясь в логах.

**Пример**: Запрос на оформление заказа проходит через сервисы "Оплата" и "Доставка", а TraceId помогает отследить задержки.

**Преимущества**:
- Упрощает диагностику ошибок.
- Показывает путь запроса.

**Недостатки**:
- Требует интеграции с системой логирования.
- Усложняет настройку.

**Применение**: Используется в сложных системах с множеством сервисов.

### 3. Проверки здоровья (Health Check)

**Описание**: Сервис предоставляет конечную точку (/health) для проверки работоспособности (статус хоста, подключение к базе данных).

**Пример**: Балансировщик нагрузки периодически запрашивает /health у сервиса "Заказы", исключая неработающие экземпляры.

**Преимущества**:
- Быстрое обнаружение сбоев.
- Упрощает управление инфраструктурой.

**Недостатки**:
- Требует реализации и мониторинга.
- Может быть недостаточно для сложной бизнес-логики.

**Применение**: Обязателен для всех микросервисных систем.

---

## Прочие паттерны

### 1. Посредник (Ambassador)

**Описание**: Прокси-сервис для периферийных задач (мониторинг, безопасность, логирование), унифицирующий доступ.

**Пример**: Ambassador обрабатывает аутентификацию для всех микросервисов, написанных на разных языках.

**Преимущества**:
- Упрощает интеграцию периферийных функций.
- Поддерживает legacy-системы.

**Недостатки**:
- Увеличивает сетевые задержки.
- Не нужен при простых задачах.

**Применение**: Используется для унификации функций в разнородных системах.

### 2. Коляска (Sidecar)

**Описание**: Вспомогательный компонент (в отдельном процессе или контейнере) для периферийных задач, связанный с основным сервисом.

**Пример**: Sidecar-контейнер в Kubernetes обрабатывает логирование для сервиса "Заказы".

**Преимущества**:
- Независимость от языка сервиса.
- Минимизирует задержки за счет близости.

**Недостатки**:
- Увеличивает ресурсоемкость.
- Не нужен для простых приложений.

**Применение**: Подходит для контейнеризированных сред.

### 3. Тестирование контрактов, ориентированных на потребителя (Consumer-Driven Contract Testing)

**Описание**: Потребители сервиса пишут тесты, проверяющие соответствие провайдера их ожиданиям.

**Пример**: Команда сервиса "Оплата" пишет тесты для API сервиса "Заказы", чтобы гарантировать совместимость.

**Преимущества**:
- Повышает автономность команд.
- Раннее обнаружение изменений.

**Недостатки**:
- Требует интеграции тестов.
- Усложняет тестирование.

**Применение**: Используется в крупных проектах с несколькими командами.

### 4. Внешняя конфигурация (External Configuration)

**Описание**: Конфигурации (адреса, учетные данные) хранятся во внешнем хранилище (облако, база данных), а не в коде.

**Пример**: Сервис "Заказы" получает строку подключения к базе данных из Vault.

**Преимущества**:
- Уменьшает риски безопасности.
- Упрощает изменение конфигураций.

**Недостатки**:
- Требует внешнего хранилища.
- Усложняет настройку.

**Применение**: Обязателен для корпоративных приложений.

---

## Resilience4j

**Описание**: Resilience4j — это легковесная библиотека для реализации паттернов отказоустойчивости, вдохновленная Hystrix, но более модульная и интегрируемая с современными фреймворками (Spring Boot, Micronaut). Она предоставляет инструменты для управления сбоями в микросервисах.

**Поддерживаемые паттерны**:
1. **Circuit Breaker**:
    - Прекращает запросы к сервису при превышении порога сбоев.
    - Состояния: Closed (нормальная работа), Open (блокировка), Half-Open (проверка восстановления).
    - **Пример**: Если сервис "Оплата" падает 5 раз за минуту, Circuit Breaker переходит в Open, возвращая ошибку без обращения.
    - **Настройка**: Порог сбоев, тайм-аут, интервал Half-Open.

2. **Retry**:
    - Повторяет запросы при сбоях, чтобы дождаться восстановления сервиса.
    - **Пример**: При сбое сервиса "Доставка" запрос повторяется 3 раза с интервалом 1 сек.
    - **Настройка**: Количество попыток, интервал, условия повтора.

3. **Bulkhead**:
    - Ограничивает количество одновременных запросов к сервису.
    - **Пример**: Сервис "Заказы" ограничивает 10 одновременных подключений к базе данных.
    - **Настройка**: Максимальное число потоков, размер очереди.

4. **Rate Limit**:
    - Ограничивает частоту запросов к сервису.
    - **Пример**: API позволяет 100 запросов в минуту на пользователя.
    - **Настройка**: Предел запросов, временное окно.

5. **Fallback**:
    - Предоставляет альтернативный путь при сбое.
    - **Пример**: Если сервис "Рекомендации" недоступен, возвращается кэшированный список товаров.
    - **Настройка**: Логика отката, условия активации.

**Преимущества**:
- Легковесность и модульность.
- Интеграция с современными фреймворками.
- Гибкая настройка каждого паттерна.

**Недостатки**:
- Требует ручной настройки и тестирования.
- Может усложнить код при избыточном использовании.

**Применение**: Используется в микросервисах для защиты от сбоев, особенно в распределенных системах с высокой нагрузкой.

---

## Алгоритмы Rate Limiting

Эти алгоритмы ограничивают частоту запросов к сервису, предотвращая перегрузку.

### 1. Leaky Bucket (Протекающее ведро)

**Описание**: Запросы помещаются в очередь (ведро) фиксированного размера. Запросы обрабатываются с постоянной скоростью (FIFO). Если очередь полна, новые запросы отбрасываются.

**Пример**: API обрабатывает 10 запросов в секунду. Новые запросы добавляются в очередь, а лишние отбрасываются, если очередь на 50 запросов заполнена.

**Преимущества**:
- Сглаживает всплески трафика.
- Эффективен по памяти (фиксированный размер очереди).
- Прост в реализации.

**Недостатки**:
- Может задерживать свежие запросы из-за старых в очереди.
- Нет гарантии обработки в фиксированное время.

**Применение**: Подходит для систем, где важна стабильная скорость обработки (например, API для отправки сообщений).

### 2. Fixed Window (Фиксированное окно)

**Описание**: Считает запросы в фиксированном временном окне (например, 60 секунд). Если счетчик превышает лимит, запросы отбрасываются. Окно сбрасывается в начале нового интервала.

**Пример**: API позволяет 100 запросов в минуту. Запрос в 12:00:03 попадает в окно 12:00:00–12:01:00.

**Преимущества**:
- Простота реализации.
- Обрабатывает свежие запросы.

**Недостатки**:
- Всплески на границах окна могут удвоить нагрузку.
- Пик нагрузки при сбросе счетчика (например, в начале часа).

**Применение**: Подходит для простых систем с умеренными всплесками.

### 3. Sliding Log (Скользящий журнал)

**Описание**: Сохраняет временные метки всех запросов в отсортированном хранилище (hash set). При новом запросе проверяется количество запросов в заданном интервале. Устаревшие записи удаляются.

**Пример**: API ограничивает 100 запросов в час. Для каждого запроса сохраняется метка времени, а старые (старше часа) удаляются.

**Преимущества**:
- Точное соблюдение лимита.
- Избегает проблем границ Fixed Window.

**Недостатки**:
- Высокая ресурсоемкость (хранение всех меток).
- Плохо масштабируется при больших объемах.

**Применение**: Используется в системах, где важна точность ограничений (например, финансовые API).

### 4. Sliding Window (Скользящее окно)

**Описание**: Гибрид Fixed Window и Sliding Log. Считает запросы в текущем окне и учитывает взвешенное количество запросов из предыдущего окна на основе времени.

**Пример**: Если окно — 60 секунд, а прошло 25% текущего окна, учитывается 75% запросов предыдущего окна и 25% текущего.

**Преимущества**:
- Сглаживает всплески на границах.
- Эффективен по памяти и масштабируем.
- Прост для объяснения клиентам.

**Недостатки**:
- Сложнее в реализации, чем Fixed Window.
- Требует точной синхронизации времени.

**Применение**: Рекомендуется для высоконагруженных систем с распределенными кластерами.

---

Если вам нужно углубиться в конкретный паттерн, Resilience4j или алгоритм Rate Limiting, дайте знать! Также могу предоставить примеры кода или визуализации (например, диаграмму для какого-либо паттерна).