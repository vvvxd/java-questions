Шаблоны проектирования

Что такое «шаблон проектирования»?
Шаблон (паттерн) проектирования (design pattern) — это проверенное и готовое к использованию решение. Это не класс и не библиотека, которую можно подключить к проекту, это нечто большее - он не зависит от языка программирования, не является законченным образцом, который может быть прямо преобразован в код и может быть реализован по-разному в разных языках программирования.

Плюсы использования шаблонов:
снижение сложности разработки за счёт готовых абстракций для решения целого класса проблем.

облегчение коммуникации между разработчиками, позволяя ссылаться на известные шаблоны.

унификация деталей решений: модулей и элементов проекта.

возможность отыскав удачное решение, пользоваться им снова и снова.

помощь в выборе выбрать наиболее подходящего варианта проектирования.

Минусы:
слепое следование некоторому выбранному шаблону может привести к усложнению программы.

желание попробовать некоторый шаблон в деле без особых на то оснований.

--------------------------------------------------------------------------------------------------------------------
Назовите основные характеристики шаблонов.

Имя - все шаблоны имеют уникальное имя, служащее для их идентификации;
Назначение назначение данного шаблона;
Задача - задача, которую шаблон позволяет решить;
Способ решения - способ, предлагаемый в шаблоне для решения задачи в том контексте, где этот шаблон был найден;
Участники - сущности, принимающие участие в решении задачи;
Следствия - последствия от использования шаблона как результат действий, выполняемых в шаблоне;
Реализация - возможный вариант реализации шаблона.

--------------------------------------------------------------------------------------------------------------------
Типы шаблонов проектирования.

Основные (Fundamental) - основные строительные блоки других шаблонов. Большинство других шаблонов использует эти шаблоны в той или иной форме.

Порождающие шаблоны (Creational) — шаблоны проектирования, которые абстрагируют процесс создание экземпляра. Они позволяют сделать систему независимой от способа создания, композиции и представления объектов. Шаблон, порождающий классы, использует наследование, чтобы изменять созданный объект, а шаблон, порождающий объекты, делегирует создание объектов другому объекту.

Структурные шаблоны (Structural) определяют различные сложные структуры, которые изменяют интерфейс уже существующих объектов или его реализацию, позволяя облегчить разработку и оптимизировать программу.

Поведенческие шаблоны (Behavioral) определяют взаимодействие между объектами, увеличивая таким образом его гибкость.

--------------------------------------------------------------------------------------------------------------------
Приведите примеры основных шаблонов проектирования.

Делегирование (Delegation pattern) - Сущность внешне выражает некоторое поведение, но в реальности передаёт ответственность за выполнение этого поведения связанному объекту.

Функциональный дизайн (Functional design) - Гарантирует, что каждая сущность имеет только одну обязанность и исполняет её с минимумом побочных эффектов на другие.

Неизменяемый интерфейс (Immutable interface) - Создание неизменяемого объекта.

Интерфейс (Interface) - Общий метод структурирования сущностей, облегчающий их понимание.

Интерфейс-маркер (Marker interface) - В качестве атрибута (как пометки объектной сущности) применяется наличие или отсутствие реализации интерфейса-маркера. В современных языках программирования вместо этого применяются атрибуты или аннотации.

Контейнер свойств (Property container) - Позволяет добавлять дополнительные свойства сущности в контейнер внутри себя, вместо расширения новыми свойствами.

Канал событий (Event channel) - Создаёт централизованный канал для событий. Использует сущность-представитель для подписки и сущность-представитель для публикации события в канале. Представитель существует отдельно от реального издателя или подписчика. Подписчик может получать опубликованные события от более чем одной сущности, даже если он зарегистрирован только на одном канале.

--------------------------------------------------------------------------------------------------------------------
Приведите примеры порождающих шаблонов проектирования.

Абстрактная фабрика (Abstract factory) - Класс, который представляет собой интерфейс для создания других классов.

Строитель (Builder) - Класс, который представляет собой интерфейс для создания сложного объекта.

Фабричный метод (Factory method) - Делегирует создание объектов наследникам родительского класса. Это позволяет использовать в коде программы не специфические классы, а манипулировать абстрактными объектами на более высоком уровне.

Прототип (Prototype) - Определяет интерфейс создания объекта через клонирование другого объекта вместо создания через конструктор.

Одиночка (Singleton) - Класс, который может иметь только один экземпляр.

--------------------------------------------------------------------------------------------------------------------
Приведите примеры структурных шаблонов проектирования.

Адаптер (Adapter) - Объект, обеспечивающий взаимодействие двух других объектов, один из которых использует, а другой предоставляет несовместимый с первым интерфейс.

Мост (Bridge) - Структура, позволяющая изменять интерфейс обращения и интерфейс реализации класса независимо.

Компоновщик (Composite) - Объект, который объединяет в себе объекты, подобные ему самому.

Декоратор (Decorator) - Класс, расширяющий функциональность другого класса без использования наследования.

Фасад (Facade) - Объект, который абстрагирует работу с несколькими классами, объединяя их в единое целое.

Приспособленец (Flyweight) - Это объект, представляющий себя как уникальный экземпляр в разных местах программы, но по факту не являющийся таковым.

Заместитель (Proxy) - Объект, который является посредником между двумя другими объектами, и который реализует/ограничивает доступ к объекту, к которому обращаются через него.

--------------------------------------------------------------------------------------------------------------------
Приведите примеры поведенческих шаблонов проектирования.

Цепочка обязанностей (Chain of responsibility) - Предназначен для организации в системе уровней ответственности.

Команда (Command) - Представляет действие. Объект команды заключает в себе само действие и его параметры.

Интерпретатор (Interpreter) - Решает часто встречающуюся, но подверженную изменениям, задачу.

Итератор (Iterator) - Представляет собой объект, позволяющий получить последовательный доступ к элементам объекта-агрегата без использования описаний каждого + __из объектов, входящих в состав агрегации.

Посредник (Mediator) - Обеспечивает взаимодействие множества объектов, формируя при этом слабую связанность и избавляя объекты от необходимости явно ссылаться друг на друга.

Хранитель (Memento) - Позволяет, не нарушая инкапсуляцию зафиксировать и сохранить внутренние состояния объекта так, чтобы позднее восстановить его в этих состояниях.

Наблюдатель (Observer) - Определяет зависимость типа «один ко многим» между объектами таким образом, что при изменении состояния одного объекта все зависящие от него оповещаются об этом событии.

Состояние (State) - Используется в тех случаях, когда во время выполнения программы объект должен менять своё поведение в зависимости от своего состояния.

Стратегия (Strategy) - Предназначен для определения семейства алгоритмов, инкапсуляции каждого из них и обеспечения их взаимозаменяемости.

Шаблонный метод (Template method) - Определяет основу алгоритма и позволяет наследникам переопределять некоторые шаги алгоритма, не изменяя его структуру в целом.

Посетитель (Visitor) - Описывает операцию, которая выполняется над объектами других классов. При изменении класса Visitor нет необходимости изменять обслуживаемые классы.

--------------------------------------------------------------------------------------------------------------------
Что такое «антипаттерн»? Какие антипаттерны вы знаете?

Антипаттерн (anti-pattern) — это распространённый подход к решению класса часто встречающихся проблем, являющийся неэффективным, рискованным или непродуктивным.
Poltergeists (полтергейсты) - это классы с ограниченной ответственностью и ролью в системе, чьё единственное предназначение — передавать информацию в другие классы. Их эффективный жизненный цикл непродолжителен. Полтергейсты нарушают стройность архитектуры программного обеспечения, создавая избыточные (лишние) абстракции, они чрезмерно запутанны, сложны для понимания и трудны в сопровождении. Обычно такие классы задумываются как классы-контроллеры, которые существуют только для вызова методов других классов, зачастую в предопределенной последовательности.
Признаки появления и последствия антипаттерна
Избыточные межклассовые связи.
Временные ассоциации.
Классы без состояния (содержащие только методы и константы).
Временные объекты и классы (с непродолжительным временем жизни).
Классы с единственным методом, который предназначен только для создания или вызова других классов посредством временной ассоциации.
Классы с именами методов в стиле «управления», такие как startProcess.
Типичные причины
Отсутствие объектно-ориентированной архитектуры (архитектор не понимает объектно-ориентированной парадигмы).
Неправильный выбор пути решения задачи.
Предположения об архитектуре приложения на этапе анализа требований (до объектно-ориентированного анализа) могут также вести к проблемам на подобии этого антипаттерна.
Внесенная сложность (Introduced complexity): Необязательная сложность дизайна. Вместо одного простого класса выстраивается целая иерархия интерфейсов и классов. Типичный пример «Интерфейс - Абстрактный класс - Единственный класс реализующий интерфейс на основе абстрактного».
Инверсия абстракции (Abstraction inversion): Сокрытие части функциональности от внешнего использования, в надежде на то, что никто не будет его использовать.
Неопределённая точка зрения (Ambiguous viewpoint): Представление модели без спецификации её точки рассмотрения.
Большой комок грязи (Big ball of mud): Система с нераспознаваемой структурой.
Божественный объект (God object): Концентрация слишком большого количества функций в одной части системы (классе).
Затычка на ввод данных (Input kludge): Забывчивость в спецификации и выполнении поддержки возможного неверного ввода.
Раздувание интерфейса (Interface bloat): Разработка интерфейса очень мощным и очень сложным для реализации.
Волшебная кнопка (Magic pushbutton): Выполнение результатов действий пользователя в виде неподходящего (недостаточно абстрактного) интерфейса. Например, написание прикладной логики в обработчиках нажатий на кнопку.
Перестыковка (Re-Coupling): Процесс внедрения ненужной зависимости.
Дымоход (Stovepipe System): Редко поддерживаемая сборка плохо связанных компонентов.
Состояние гонки (Race hazard): непредвидение возможности наступления событий в порядке, отличном от ожидаемого.
Членовредительство (Mutilation): Излишнее «затачивание» объекта под определенную очень узкую задачу таким образом, что он не способен будет работать с никакими иными, пусть и очень схожими задачами.
Сохранение или смерть (Save or die): Сохранение изменений лишь при завершении приложения.

--------------------------------------------------------------------------------------------------------------------
Что такое Dependency Injection?

Dependency Injection (внедрение зависимости) - это набор паттернов и принципов разработки програмного обеспечения, которые позволяют писать слабосвязный код. В полном соответствии с принципом единой обязанности объект отдаёт заботу о построении требуемых ему зависимостей внешнему, специально предназначенному для этого общему механизму.

--------------------------------------------------------------------------------------------------------------------
Шаблон: Фабрика (Factory Method)

Цель: Создание интерфейса, который создаёт объект. При этом, выбор того, экземпляр какого класса создавать остаётся за классами, которые имплементируют данный интерфейс.

Для чего используется: Для делигирования создания экземпляров, другому классу.

Пример использования:
- заранее неизвестно, экземпляры, какого класса нужно будет создавать;
- класс спроектирован таким образом, что создаваемые им объекты имеют свойства определённого класса.

--------------------------------------------------------------------------------------------------------------------
Шаблон: Абстрактная фабрика (Abstract Factory)

Цель: Создание интерфейса, для создания множества взаимосвязанных или взаимозависимых объектов, без жёсткой привязке к конкретным классам.

Для чего используется: Для создания множеств взаимосвязанных объектов.

Пример использования:
- система не должна зависеть от метода создания, компоновки и представления входящих в неё объектов;
- входящие взаимосвязанные объекты должны использоваться вместе;
- система должна конфигурироваться одним из множеств объектов, из которых она состоит; - нам необходимо предоставить множество объектов, раскрывая только их интерфейсы но не реализацию.

--------------------------------------------------------------------------------------------------------------------
Шаблон: Одиночка (Singleton)

Цель: Гарантировать, что у класса будет только один единственный экземпляр и к нему будет предоставлена
глобальная точка доступа.

Для чего используется: Для создания единственного экземпляра опредлённого класса.

Пример использования:
- необходим только один экземпляр конкретного класса, который доступен для всех клиентов;
- единственный экземпляр должен наследоваться путём порождения подклассов, при этом, клиенты
  имеют возможность работать с классом-неследником без модификации своего кода.

--------------------------------------------------------------------------------------------------------------------
Шаблон: Строитель (Builder)

Шаблон: Строитель (Builder)
Цель: Отделить конструирование сложного объекта от его представления таким образом, чтобы в результате
одного и того же конструирования мы могли получить разные представления.

Для чего используется: Для создания различных объектов из одного набора данных.

Пример использования:
- порядок создания сложного объекта не должен зависеть от того, из каких частей состоит объект и
  того, как эти объекты взаимосвязаны;
- процесс конструирования объекта должен предоставлять различные представления объекта, который мы
  конструируем.

--------------------------------------------------------------------------------------------------------------------
Шаблон: Прототип (Prototype)

Цель: Определить вид создаваемых объектов с помощью экземпляра - прототипа и создавать новые объекты, копируя этот прототип.

Для чего используется:
Для создания копий заданного объекта.

Пример использования:
- классы, экземпляры которых необходимо создать определяются во время выполнения программы;
- для избежания построения иерархии классов, фабрик или параллельных иерархий классов;
- экземпляры класса могут находиться в одном из немногих возможных состояний.

--------------------------------------------------------------------------------------------------------------------
Шаблон: Адаптер (Adapter)

Цель: Преобразование интерфейса одного класса в интерфейс того класса, который необходим клиенту.

Для чего используется:
Для обеспечения совместной работы классов, интерфейсы которых не совместимы.

Пример использования:
- интерфейс класса, который мы хотим использовать не соответствует нашим потребностям;
- необходим класс, который должен взаимодействовать с классами, которые ему неизвестны
  или не связаны с ним;
- необходимо использовать несколько существующих подклассов, но нецелесообразно использовать
  методы этих классов создавая их новые подклассы.

--------------------------------------------------------------------------------------------------------------------
Шаблон: Мост (Bridge)

Цель: Отделить абстракцию от её реализации таким образом, чтобы мы могли изменять независимо друг от друга и то и другое.

Для чего используется:
Для получения преимуществ наследования без потери гибкости.

Пример использования:
- предотвращения жёсткого привязки абстракции к реализации (например, реализацию необходимо выбрать
  во время выполнения программы);
- в будущем мы хотим расширять с помощью подклассов и реализацию и абстракцию;
- если изменения в реализации не должны отражаться на клиентах абстракции;
- для разделения одной реализации между несколькими оъектами и не показывать это клиенту.

--------------------------------------------------------------------------------------------------------------------
Шаблон: Компоновщик (Composite)

Цель: Скомпонировать объекты в структуры по типу "дерева", позволяя клиентам единообразно трактовать
отдельные и составные объекты.

Для чего используется:
Для группировки мелких компонентов в более крупные, которые, в свою очередь, могут стать основой для
ещё более крупных стуктур.

Пример использования:
- для представления иерархии "часть-целое";
- мы хотим, чтобы клиенты одним способом трактовали как отдельные, так и составные объекты.

--------------------------------------------------------------------------------------------------------------------
Шаблон: Декоратор(Decorator)

Цель: Динамическое добавление новых обязанностей объекту.

Для чего используется:
Используется в качестве альтернативы порождению подклассов для расширения функциональности.

Пример использования:
- динамическое и понятное клиентам добавления обязанностей объектам;
- реализация обязанностей, которые могут быть сняты с объекта;
- расширение класса путём порождения подклассов невозможно по каким-либо причинам.

--------------------------------------------------------------------------------------------------------------------
Шаблон: Фасад (Facade)

Цель: Предоставить унифицированный интерфейс вместо нескольких интерфейсов подститсемы.

Для чего используется:
Используется для опредления интерфейса высокого уровня, который упрощает использование подсистемы.

Пример использования:
- изолирование клиентов от компонентов подсистемы, упрощая работу с ней;
- необходимость ослабления связанности подсистемы с клиентами;

--------------------------------------------------------------------------------------------------------------------
Шаблон: Приспособленец (Flyweight)

Цель: Поддержка множества мелких объектов.

Для чего используется:
Использует разделение для того, чтобы поддерживать много мелких объектов.

Пример использования:
- когда используется большое число объектов;
- большую часть состояния объектов можно вынести наружу;
- приложение не зависит от идентичности объекта.

--------------------------------------------------------------------------------------------------------------------
Шаблон: Прокси (Proxy)

Цель: Для замещения другого объекта и контроля доступа к нему.

Для чего используется:
Для обеспечения контроля доступа к определенному объекту.

Пример использования:
- когда есть необходимость ссылаться на объект способом отличным от обычного указателя
* удалённое замещение -
  локальный представитель вместо объекта в другом
  адресном пространстве.
* виртуальное замещение -
  создание "тяжёлых объектов" при необходимости.
* защищённое замещение -
  контроль доступа к указанному объекту
* "умная" ссылка
  замена обычного указателя
  (подсчёт числа ссылок, установка блокировки ит.д.)

--------------------------------------------------------------------------------------------------------------------
Шаблон: Цепочка ответственности (Chain Of Responsibility)

Цель: Связывание объектов-получателей в цепочку и передача запроса по ней.

Для чего используется:
Помогает избежать привязки отправителя запроса к его получателю, что даёт возможность обработать
данный запрос нескольким объектам.

Пример использования:
- ослабление привязанности (объект не должен знать, кто именно обработает его запрос);
- дополнительная гибкость при распределении обязанностей между объектами;

--------------------------------------------------------------------------------------------------------------------
Шаблон: Команда (Command)

Цель: Инкапсулирование запроса в объект.

Для чего используется:
Чтобы задать параметры клиентов для обработки определённых запросов, создание очереди из этих запросов
или их контроля и поддержки отмены операций.

Пример использования:
- параметризация объектов выполняемым дейтствием;
- определять запрос, ставить его в очередь или выполнять его в разное время

--------------------------------------------------------------------------------------------------------------------
Шаблон: Интерпретатор (Interpreter)

Цель: Определение представления грамматики объекта

Для чего используется:
Используется для определения представления грамматики заданного языка и интерпретации его предложений

Пример использования:
- упрощение иерархии классов с помощью интерпретирования.

--------------------------------------------------------------------------------------------------------------------
Шаблон: Итератор (Iterator)

Цель: Получение последовательного доступа ко всем элементам составного объекта.

Для чего используется:
Для получения последовательного доступа ко всем элементам составного объекта, скрывая его
внутреннее представление.

Пример использования:
- различные виды обхода составного объекта;
- упрощённый доступ к составному объекту.

--------------------------------------------------------------------------------------------------------------------
Шаблон: Посредник (Mediator)

Цель: Инкапсуляция способа взаимодействия множества объектов

Для чего используется:
Для определения объекта, который инкапсулирует способ взаимодействия множества объектов и обеспечения слабой связи между этими объектами.

Пример использования:
- связи между объектами сложны и чётко определены;
- нельзя повторно использовать объект, так как он обменивается информацией с другими объектами;
- поведение, распределённое между несколькими классами должно легко настраиваться без создания
  подклассов.

--------------------------------------------------------------------------------------------------------------------
Шаблон: Хранитель (Memento)

Цель: Сохранить внутренне состояние объекта за его пределы.

Для чего используется:
Фиксирование внутреннего состояния объекта за его пределами не нарушая инкапсуляцию и восстановления объекта в случае необходимости.

Пример использования:
- необходимо сохранить текущее состояние объекта или его части и восстановление в будущем, но
  прямое получение состояния раскрывает детали реализации и нарушает инкапсуляцию объекта.

--------------------------------------------------------------------------------------------------------------------
Шаблон: Наблюдатель (Observer)

Цель: Определение зависимости "один ко многим" между объектами.

Для чего используется: Определение зависимости "один ко многим" между объектами таким образом, что при изменении состояния одного объекта все зависящие от него объекты были уведомлены
об этом и обновились.

Пример использования:
- когда у модели имеются два аспекта, один из которых зависит от другого. Инкапсулирование
  этих аспектов в разные классы позволяют использовать их независимо друг от друга;
- когда один объект должен оповещать другие и не делать предположений об этих объектах;
- ослабление связи между объектами.

--------------------------------------------------------------------------------------------------------------------
Шаблон: Состояние (State)

Цель:
Управление поведение объекта в зависимости от состояния.

Для чего используется:
Позволяет нам управлять поведение объекта в зависимости от внутреннего состояние объекта.

Пример использования:
- поведение объекта зависит от его состояние и изменяется во время выполнения;
- когда встречается большое количество условных операторов, когда выбор ветви
  зависит от состояния объекта.

--------------------------------------------------------------------------------------------------------------------
Шаблон: Стратегия (Strategy)

Цель:
Взаимозаменяемость семейства классов

Для чего используется:
Определение семейства классов, инкапсулирование каждого из них и организация
их взаимозаменяемости.

Пример использования:
- есть несколько родственных классов, которые отличаются поведением;
- необходимо иметь несколько вариантов поведения;
- в классе есть данные, о которых не должен знать клиент;
- с помощью условных операторов в классе определено большое количество возможных поведений.

--------------------------------------------------------------------------------------------------------------------
Шаблон: Шаблонный метод (Template method)

Цель:
Определение основы класса и создание возможности подклассам переопределять его части.

Для чего используется:
Определяет основу класса и позволяет подклассам переопределять некоторые его части
не изменяя его структуру в целом.

Пример использования:
- однократное использование различных частей класса, оставляя реализацию изменяющегося
  поведения на усмотрение подклассов;
- вычленение и локализация общего для всех подклассов поведения в родительском;
- управление расширениями подклассов.

--------------------------------------------------------------------------------------------------------------------
Шаблон: Посетитель (Visitor)

Цель:
Описание действий, которые выполняются с каждым объектом в некоторой структуре

Для чего используется:
Описание операций, которые выполняются с каждым объектом из некоторой структуры.
Позволяет определить новую операцию без изменения классов этих объектов.

Пример использования:
- в структуре присутствуют объекты многих классов с различными интерфейсами и нам
  необходимо выполнить над ними операции, которые зависят от конкретных классов;
- необходимо выполнять не связанные между собой операции над объектами, которые
  входят в состав структуры и мы не хотим добавлять эти операции в классы;
- классы, которые устанавливают структуру объектов редко изменяются, но часто
  добавляются новые операции над этой структурой.

--------------------------------------------------------------------------------------------------------------------
Кратко опишите шаблоны GRAPS.

GRASP выделяет следующие 9 принципов-шаблонов:
Information Expert (Информационные эксперт) - информационный эксперт описывает основополагающие принципы назначения обязанностей классам и объектам. Согласно описанию, информационным экспертом (объектом наделенным некоторыми обязанностями) является объект, обладающий максимумом информацией, необходимой для выполнения назначенных обязанностей.
Creator (Создатель) - суть ответственности такого объекта в том, что он создает другие объекты. Сразу напрашивается аналогия с фабриками. Так оно и есть. Фабрики тоже имеют именно ответственность - Создатель.
Controller (Контроллер) - отвечает за обработку входных системных событий, делегируя обязанности по их обработке компетентным классам. В общем случае, контроллер реализует один или несколько вариантов использования. Использование контроллеров позволяет отделить логику от представления, тем самым повышая возможность повторного использования кода.
Low Coupling (Слабая связанность) - если объекты в приложении сильно связаны, то любой их изменение приводит к изменениям во всех связанных объектах. А это неудобно и порождает баги. Вот по-этому везде пишут, что необходимо, чтобы код был слабо связан и зависел только от абстракций.
High Cohesion (Высокая сцепленность) - этот принцип тесно соотносится с слабой связанностью, и они идут в паре, когда одно всегда приводит к другому, это как мера того, что мы не нарушаем single resposibility principle. Вернее сказать, высокая сцепленность получается в результате соблюдения такого принципа из SOLID, как single resposibility principle (SRP).
Pure Fabrication (Чистая выдумка или чистое синтезирование) - это класс, не отражающий никакого реального объекта предметной области, но специально придуманный для усиления связности, ослабления связанности или увеличения степени повторного использования. Pure Fabrication отражает концепцию сервисов в модели Программирование от предметной области.
Indirection (Посредник) - шаблон перенаправление реализует низкую связность между классами, путем назначения обязанностей по их взаимодействию дополнительному объекту - посреднику.
Protected Variations (Сокрытие реализации или защищенные изменения) - защищает элементы от изменения других элементов (объектов или подсистем) с помощью вынесения взаимодействия в фиксированный интерфейс. Всё взвимодействие между элементами должно происходить через него. Поведение может варьироваться лишь с помощью создания другой реализации интерфейса.
Polymorphism (Полиморфизм) - позволяет обрабатывать альтернативные варианты поведения на основе типа и заменять подключаемые компоненты системы. Обязанности распределяются для различных вариантов поведения с помощью полиморфных операций для этого класса. Все альтернативные реализации приводятся к общему интерфейсу.

--------------------------------------------------------------------------------------------------------------------