Шаблоны проектирования

Что такое «шаблон проектирования»?
Шаблон (паттерн) проектирования (design pattern) — это проверенное и готовое к использованию решение. Это не класс и не библиотека, которую можно подключить к проекту, это нечто большее - он не зависит от языка программирования, не является законченным образцом, который может быть прямо преобразован в код и может быть реализован по-разному в разных языках программирования.

Плюсы использования шаблонов:
снижение сложности разработки за счёт готовых абстракций для решения целого класса проблем.

облегчение коммуникации между разработчиками, позволяя ссылаться на известные шаблоны.

унификация деталей решений: модулей и элементов проекта.

возможность отыскав удачное решение, пользоваться им снова и снова.

помощь в выборе выбрать наиболее подходящего варианта проектирования.

Минусы:
слепое следование некоторому выбранному шаблону может привести к усложнению программы.

желание попробовать некоторый шаблон в деле без особых на то оснований.

--------------------------------------------------------------------------------------------------------------------
Назовите основные характеристики шаблонов.

Имя - все шаблоны имеют уникальное имя, служащее для их идентификации;
Назначение назначение данного шаблона;
Задача - задача, которую шаблон позволяет решить;
Способ решения - способ, предлагаемый в шаблоне для решения задачи в том контексте, где этот шаблон был найден;
Участники - сущности, принимающие участие в решении задачи;
Следствия - последствия от использования шаблона как результат действий, выполняемых в шаблоне;
Реализация - возможный вариант реализации шаблона.

--------------------------------------------------------------------------------------------------------------------
Типы шаблонов проектирования.

Основные (Fundamental) - основные строительные блоки других шаблонов. Большинство других шаблонов использует эти шаблоны в той или иной форме.

Порождающие шаблоны (Creational) — шаблоны проектирования, которые абстрагируют процесс создание экземпляра. Они позволяют сделать систему независимой от способа создания, композиции и представления объектов. Шаблон, порождающий классы, использует наследование, чтобы изменять созданный объект, а шаблон, порождающий объекты, делегирует создание объектов другому объекту.

Структурные шаблоны (Structural) определяют различные сложные структуры, которые изменяют интерфейс уже существующих объектов или его реализацию, позволяя облегчить разработку и оптимизировать программу.

Поведенческие шаблоны (Behavioral) определяют взаимодействие между объектами, увеличивая таким образом его гибкость.

--------------------------------------------------------------------------------------------------------------------
Приведите примеры основных шаблонов проектирования.

Делегирование (Delegation pattern) - Сущность внешне выражает некоторое поведение, но в реальности передаёт ответственность за выполнение этого поведения связанному объекту.

Функциональный дизайн (Functional design) - Гарантирует, что каждая сущность имеет только одну обязанность и исполняет её с минимумом побочных эффектов на другие.

Неизменяемый интерфейс (Immutable interface) - Создание неизменяемого объекта.

Интерфейс (Interface) - Общий метод структурирования сущностей, облегчающий их понимание.

Интерфейс-маркер (Marker interface) - В качестве атрибута (как пометки объектной сущности) применяется наличие или отсутствие реализации интерфейса-маркера. В современных языках программирования вместо этого применяются атрибуты или аннотации.

Контейнер свойств (Property container) - Позволяет добавлять дополнительные свойства сущности в контейнер внутри себя, вместо расширения новыми свойствами.

Канал событий (Event channel) - Создаёт централизованный канал для событий. Использует сущность-представитель для подписки и сущность-представитель для публикации события в канале. Представитель существует отдельно от реального издателя или подписчика. Подписчик может получать опубликованные события от более чем одной сущности, даже если он зарегистрирован только на одном канале.

--------------------------------------------------------------------------------------------------------------------
Приведите примеры порождающих шаблонов проектирования.

Абстрактная фабрика (Abstract factory) - Класс, который представляет собой интерфейс для создания других классов.

Строитель (Builder) - Класс, который представляет собой интерфейс для создания сложного объекта.

Фабричный метод (Factory method) - Делегирует создание объектов наследникам родительского класса. Это позволяет использовать в коде программы не специфические классы, а манипулировать абстрактными объектами на более высоком уровне.

Прототип (Prototype) - Определяет интерфейс создания объекта через клонирование другого объекта вместо создания через конструктор.

Одиночка (Singleton) - Класс, который может иметь только один экземпляр.

--------------------------------------------------------------------------------------------------------------------
Приведите примеры структурных шаблонов проектирования.

Адаптер (Adapter) - Объект, обеспечивающий взаимодействие двух других объектов, один из которых использует, а другой предоставляет несовместимый с первым интерфейс.

Мост (Bridge) - Структура, позволяющая изменять интерфейс обращения и интерфейс реализации класса независимо.

Компоновщик (Composite) - Объект, который объединяет в себе объекты, подобные ему самому.

Декоратор (Decorator) - Класс, расширяющий функциональность другого класса без использования наследования.

Фасад (Facade) - Объект, который абстрагирует работу с несколькими классами, объединяя их в единое целое.

Приспособленец (Flyweight) - Это объект, представляющий себя как уникальный экземпляр в разных местах программы, но по факту не являющийся таковым.

Заместитель (Proxy) - Объект, который является посредником между двумя другими объектами, и который реализует/ограничивает доступ к объекту, к которому обращаются через него.

--------------------------------------------------------------------------------------------------------------------
Приведите примеры поведенческих шаблонов проектирования.

Цепочка обязанностей (Chain of responsibility) - Предназначен для организации в системе уровней ответственности.

Команда (Command) - Представляет действие. Объект команды заключает в себе само действие и его параметры.

Интерпретатор (Interpreter) - Решает часто встречающуюся, но подверженную изменениям, задачу.

Итератор (Iterator) - Представляет собой объект, позволяющий получить последовательный доступ к элементам объекта-агрегата без использования описаний каждого + __из объектов, входящих в состав агрегации.

Посредник (Mediator) - Обеспечивает взаимодействие множества объектов, формируя при этом слабую связанность и избавляя объекты от необходимости явно ссылаться друг на друга.

Хранитель (Memento) - Позволяет, не нарушая инкапсуляцию зафиксировать и сохранить внутренние состояния объекта так, чтобы позднее восстановить его в этих состояниях.

Наблюдатель (Observer) - Определяет зависимость типа «один ко многим» между объектами таким образом, что при изменении состояния одного объекта все зависящие от него оповещаются об этом событии.

Состояние (State) - Используется в тех случаях, когда во время выполнения программы объект должен менять своё поведение в зависимости от своего состояния.

Стратегия (Strategy) - Предназначен для определения семейства алгоритмов, инкапсуляции каждого из них и обеспечения их взаимозаменяемости.

Шаблонный метод (Template method) - Определяет основу алгоритма и позволяет наследникам переопределять некоторые шаги алгоритма, не изменяя его структуру в целом.

Посетитель (Visitor) - Описывает операцию, которая выполняется над объектами других классов. При изменении класса Visitor нет необходимости изменять обслуживаемые классы.

--------------------------------------------------------------------------------------------------------------------
Что такое «антипаттерн»? Какие антипаттерны вы знаете?

Антипаттерн (anti-pattern) — это распространённый подход к решению класса часто встречающихся проблем, являющийся неэффективным, рискованным или непродуктивным.
Poltergeists (полтергейсты) - это классы с ограниченной ответственностью и ролью в системе, чьё единственное предназначение — передавать информацию в другие классы. Их эффективный жизненный цикл непродолжителен. Полтергейсты нарушают стройность архитектуры программного обеспечения, создавая избыточные (лишние) абстракции, они чрезмерно запутанны, сложны для понимания и трудны в сопровождении. Обычно такие классы задумываются как классы-контроллеры, которые существуют только для вызова методов других классов, зачастую в предопределенной последовательности.
Признаки появления и последствия антипаттерна
Избыточные межклассовые связи.
Временные ассоциации.
Классы без состояния (содержащие только методы и константы).
Временные объекты и классы (с непродолжительным временем жизни).
Классы с единственным методом, который предназначен только для создания или вызова других классов посредством временной ассоциации.
Классы с именами методов в стиле «управления», такие как startProcess.
Типичные причины
Отсутствие объектно-ориентированной архитектуры (архитектор не понимает объектно-ориентированной парадигмы).
Неправильный выбор пути решения задачи.
Предположения об архитектуре приложения на этапе анализа требований (до объектно-ориентированного анализа) могут также вести к проблемам на подобии этого антипаттерна.
Внесенная сложность (Introduced complexity): Необязательная сложность дизайна. Вместо одного простого класса выстраивается целая иерархия интерфейсов и классов. Типичный пример «Интерфейс - Абстрактный класс - Единственный класс реализующий интерфейс на основе абстрактного».
Инверсия абстракции (Abstraction inversion): Сокрытие части функциональности от внешнего использования, в надежде на то, что никто не будет его использовать.
Неопределённая точка зрения (Ambiguous viewpoint): Представление модели без спецификации её точки рассмотрения.
Большой комок грязи (Big ball of mud): Система с нераспознаваемой структурой.
Божественный объект (God object): Концентрация слишком большого количества функций в одной части системы (классе).
Затычка на ввод данных (Input kludge): Забывчивость в спецификации и выполнении поддержки возможного неверного ввода.
Раздувание интерфейса (Interface bloat): Разработка интерфейса очень мощным и очень сложным для реализации.
Волшебная кнопка (Magic pushbutton): Выполнение результатов действий пользователя в виде неподходящего (недостаточно абстрактного) интерфейса. Например, написание прикладной логики в обработчиках нажатий на кнопку.
Перестыковка (Re-Coupling): Процесс внедрения ненужной зависимости.
Дымоход (Stovepipe System): Редко поддерживаемая сборка плохо связанных компонентов.
Состояние гонки (Race hazard): непредвидение возможности наступления событий в порядке, отличном от ожидаемого.
Членовредительство (Mutilation): Излишнее «затачивание» объекта под определенную очень узкую задачу таким образом, что он не способен будет работать с никакими иными, пусть и очень схожими задачами.
Сохранение или смерть (Save or die): Сохранение изменений лишь при завершении приложения.

--------------------------------------------------------------------------------------------------------------------
Что такое Dependency Injection?

Dependency Injection (внедрение зависимости) - это набор паттернов и принципов разработки програмного обеспечения, которые позволяют писать слабосвязный код. В полном соответствии с принципом единой обязанности объект отдаёт заботу о построении требуемых ему зависимостей внешнему, специально предназначенному для этого общему механизму.

--------------------------------------------------------------------------------------------------------------------
### Шаблон проектирования Factory Method

**Factory Method** — это порождающий шаблон проектирования, который определяет общий интерфейс для создания объектов в суперклассе, позволяя подклассам изменять тип создаваемых объектов. Основная идея — делегировать создание объектов подклассам, чтобы обеспечить гибкость и расширяемость.

#### Основные компоненты:
1. **Creator (Создатель)** — абстрактный класс или интерфейс, который объявляет фабричный метод, возвращающий объект типа Product. Может содержать логику, зависящую от создаваемых объектов.
2. **ConcreteCreator (Конкретный создатель)** — класс, реализующий фабричный метод, создающий конкретные продукты.
3. **Product (Продукт)** — интерфейс или абстрактный класс, описывающий создаваемые объекты.
4. **ConcreteProduct (Конкретный продукт)** — реализация интерфейса Product, представляющая конкретный объект.

#### Преимущества:
- Упрощает добавление новых типов продуктов без изменения существующего кода (принцип открытости/закрытости).
- Инкапсулирует логику создания объектов.
- Улучшает тестируемость и гибкость кода.

#### Недостатки:
- Может привести к увеличению количества классов в системе.
- Усложняет код для небольших проектов.

### Пример на Java

```java
// Интерфейс продукта
interface Product {
    void use();
}

// Конкретные продукты
class ConcreteProductA implements Product {
    public void use() {
        System.out.println("Using Product A");
    }
}

class ConcreteProductB implements Product {
    public void use() {
        System.out.println("Using Product B");
    }
}

// Абстрактный создатель
abstract class Creator {
    // Фабричный метод
    abstract Product createProduct();

    void someOperation() {
        Product product = createProduct();
        product.use();
    }
}

// Конкретные создатели
class ConcreteCreatorA extends Creator {
    Product createProduct() {
        return new ConcreteProductA();
    }
}

class ConcreteCreatorB extends Creator {
    Product createProduct() {
        return new ConcreteProductB();
    }
}

// Использование
public class FactoryMethodDemo {
    public static void main(String[] args) {
        Creator creatorA = new ConcreteCreatorA();
        creatorA.someOperation(); // Вывод: Using Product A

        Creator creatorB = new ConcreteCreatorB();
        creatorB.someOperation(); // Вывод: Using Product B
    }
}
```

В этом примере `Creator` определяет фабричный метод `createProduct()`, а подклассы `ConcreteCreatorA` и `ConcreteCreatorB` реализуют его, создавая разные продукты (`ConcreteProductA` и `ConcreteProductB`).

--------------------------------------------------------------------------------------------------------------------
### Шаблон проектирования Abstract Factory

**Abstract Factory** — это порождающий шаблон проектирования, который предоставляет интерфейс для создания семейств взаимосвязанных или взаимозависимых объектов без указания их конкретных классов. Он позволяет создавать группы объектов, которые предназначены для совместной работы, обеспечивая их согласованность.

#### Основные компоненты:
1. **AbstractFactory (Абстрактная фабрика)** — интерфейс или абстрактный класс, объявляющий методы для создания абстрактных продуктов.
2. **ConcreteFactory (Конкретная фабрика)** — реализация абстрактной фабрики, создающая конкретные продукты, принадлежащие одному семейству.
3. **AbstractProduct (Абстрактный продукт)** — интерфейс или абстрактный класс, описывающий продукты, создаваемые фабрикой.
4. **ConcreteProduct (Конкретный продукт)** — реализация абстрактного продукта, созданная конкретной фабрикой.
5. **Client (Клиент)** — код, использующий абстрактную фабрику и продукты через их абстрактные интерфейсы.

#### Отличие от Factory Method:
- **Factory Method** создаёт один продукт через один метод, а **Abstract Factory** создаёт семейство продуктов через несколько методов.
- Abstract Factory часто использует Factory Method внутри для реализации создания отдельных продуктов.

#### Преимущества:
- Гарантирует совместимость создаваемых объектов (все продукты принадлежат одному семейству).
- Упрощает добавление новых семейств продуктов.
- Скрывает детали реализации конкретных классов от клиента.

#### Недостатки:
- Усложняет код из-за большого количества классов и интерфейсов.
- Добавление нового типа продукта требует изменения всех фабрик.


### Пример на Java

Предположим, мы создаём UI-компоненты (кнопки и текстовые поля) для разных операционных систем (Windows и Mac).

```java
// Абстрактные продукты
interface Button {
    void render();
}

interface TextField {
    void display();
}

// Конкретные продукты для Windows
class WindowsButton implements Button {
    public void render() {
        System.out.println("Rendering Windows Button");
    }
}

class WindowsTextField implements TextField {
    public void display() {
        System.out.println("Displaying Windows TextField");
    }
}

// Конкретные продукты для Mac
class MacButton implements Button {
    public void render() {
        System.out.println("Rendering Mac Button");
    }
}

class MacTextField implements TextField {
    public void display() {
        System.out.println("Displaying Mac TextField");
    }
}

// Абстрактная фабрика
interface UIFactory {
    Button createButton();
    TextField createTextField();
}

// Конкретные фабрики
class WindowsFactory implements UIFactory {
    public Button createButton() {
        return new WindowsButton();
    }

    public TextField createTextField() {
        return new WindowsTextField();
    }
}

class MacFactory implements UIFactory {
    public Button createButton() {
        return new MacButton();
    }

    public TextField createTextField() {
        return new MacTextField();
    }
}

// Клиентский код
public class AbstractFactoryDemo {
    public static void main(String[] args) {
        // Создаём фабрику для Windows
        UIFactory windowsFactory = new WindowsFactory();
        Button windowsButton = windowsFactory.createButton();
        TextField windowsTextField = windowsFactory.createTextField();
        windowsButton.render();    // Вывод: Rendering Windows Button
        windowsTextField.display(); // Вывод: Displaying Windows TextField

        // Создаём фабрику для Mac
        UIFactory macFactory = new MacFactory();
        Button macButton = macFactory.createButton();
        TextField macTextField = macFactory.createTextField();
        macButton.render();    // Вывод: Rendering Mac Button
        macTextField.display(); // Вывод: Displaying Mac TextField
    }
}
```

В этом примере `UIFactory` создаёт семейство UI-компонентов (`Button` и `TextField`), а конкретные фабрики (`WindowsFactory` и `MacFactory`) обеспечивают создание компонентов для соответствующих платформ.

--------------------------------------------------------------------------------------------------------------------
Шаблон: Одиночка (Singleton)

### Шаблон проектирования Singleton

**Singleton** — это порождающий шаблон проектирования, который гарантирует, что класс имеет только один экземпляр, и предоставляет глобальную точку доступа к этому экземпляру. Он используется, когда нужен ровно один объект для координации действий в системе, например, для управления конфигурацией, пулом соединений или логгером.

#### Основные характеристики:
- **Единственный экземпляр**: Класс создаёт и поддерживает только один объект.
- **Глобальный доступ**: Предоставляет статический метод для получения экземпляра.
- **Ленивая или жадная инициализация**: Экземпляр может создаваться при первом обращении (lazy) или при загрузке класса (eager).

#### Преимущества:
- Контролирует создание единственного экземпляра.
- Экономит ресурсы, избегая создания лишних объектов.
- Упрощает доступ к общему ресурсу.

#### Недостатки:
- Может усложнить тестирование из-за глобального состояния.
- Нарушает принцип единственной ответственности, так как класс управляет и своей логикой, и жизненным циклом экземпляра.
- В многопоточной среде требует синхронизации для безопасной инициализации.


### Пример на Java

#### Реализация Singleton с ленивой инициализацией и потокобезопасностью:

```java
public class Singleton {
    // Приватное статическое поле для хранения единственного экземпляра
    private static volatile Singleton instance;

    // Приватный конструктор, чтобы предотвратить создание экземпляров извне
    private Singleton() {
        // Защита от создания экземпляра через рефлексию
        if (instance != null) {
            throw new RuntimeException("Use getInstance() method to get the single instance.");
        }
    }

    // Потокобезопасный метод для получения экземпляра
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }

    // Пример метода
    public void doSomething() {
        System.out.println("Singleton is working!");
    }
}

// Клиентский код
public class SingletonDemo {
    public static void main(String[] args) {
        Singleton singleton1 = Singleton.getInstance();
        Singleton singleton2 = Singleton.getInstance();

        singleton1.doSomething(); // Вывод: Singleton is working!
        System.out.println(singleton1 == singleton2); // Вывод: true (один и тот же экземпляр)
    }
}
```

В этом примере:
- `volatile` предотвращает проблемы с видимостью в многопоточной среде.
- Двойная проверка (`double-checked locking`) минимизирует накладные расходы на синхронизацию.
- Приватный конструктор защищает от создания новых экземпляров.

#### Альтернативный вариант (жадная инициализация):

```java
public class EagerSingleton {
    // Экземпляр создаётся при загрузке класса
    private static final EagerSingleton instance = new EagerSingleton();

    private EagerSingleton() {}

    public static EagerSingleton getInstance() {
        return instance;
    }
}
```

#### Ещё один вариант (с использованием `enum`):

```java
public enum EnumSingleton {
    INSTANCE;

    public void doSomething() {
        System.out.println("Enum Singleton is working!");
    }
}
```

`Enum`-реализация является потокобезопасной, лаконичной и защищённой от рефлексии и сериализации.

--------------------------------------------------------------------------------------------------------------------
### Шаблон проектирования Builder

**Builder** — это порождающий шаблон проектирования, который позволяет пошагово создавать сложные объекты, отделяя процесс конструирования от представления объекта. Он используется, когда объект имеет много параметров или сложную логику инициализации, чтобы сделать создание более читаемым и гибким.

#### Основные компоненты:
1. **Product (Продукт)** — объект, который нужно создать. Обычно содержит множество полей.
2. **Builder (Строитель)** — интерфейс или абстрактный класс, определяющий методы для пошагового создания продукта.
3. **ConcreteBuilder (Конкретный строитель)** — реализация строителя, создающая конкретный продукт и хранящая промежуточное состояние.
4. **Director (Директор)** — необязательный класс, управляющий процессом сборки, используя строитель. Может отсутствовать, если клиент сам управляет строительством.

#### Преимущества:
- Упрощает создание объектов с большим количеством параметров.
- Позволяет создавать объект пошагово, делая процесс более читаемым.
- Обеспечивает неизменяемость объекта после создания.
- Позволяет создавать разные конфигурации одного продукта.

#### Недостатки:
- Увеличивает количество кода из-за дополнительных классов.
- Требует создания нового строителя для каждого типа продукта.


### Пример на Java

Создадим объект `House` с использованием шаблона Builder.

```java
// Продукт
public class House {
    private final String foundation;
    private final String walls;
    private final String roof;
    private final boolean hasGarage;

    // Приватный конструктор, доступный только через Builder
    private House(Builder builder) {
        this.foundation = builder.foundation;
        this.walls = builder.walls;
        this.roof = builder.roof;
        this.hasGarage = builder.hasGarage;
    }

    @Override
    public String toString() {
        return "House [foundation=" + foundation + ", walls=" + walls + ", roof=" + roof + ", hasGarage=" + hasGarage + "]";
    }

    // Внутренний класс Builder
    public static class Builder {
        private String foundation;
        private String walls;
        private String roof;
        private boolean hasGarage;

        // Методы для установки значений
        public Builder setFoundation(String foundation) {
            this.foundation = foundation;
            return this;
        }

        public Builder setWalls(String walls) {
            this.walls = walls;
            return this;
        }

        public Builder setRoof(String roof) {
            this.roof = roof;
            return this;
        }

        public Builder setHasGarage(boolean hasGarage) {
            this.hasGarage = hasGarage;
            return this;
        }

        // Метод для создания объекта
        public House build() {
            // Можно добавить валидацию
            if (foundation == null || walls == null || roof == null) {
                throw new IllegalStateException("Foundation, walls, and roof are required!");
            }
            return new House(this);
        }
    }
}

// Клиентский код
public class BuilderDemo {
    public static void main(String[] args) {
        // Пошаговое создание объекта
        House house = new House.Builder()
                .setFoundation("Concrete")
                .setWalls("Brick")
                .setRoof("Tile")
                .setHasGarage(true)
                .build();

        System.out.println(house); // Вывод: House [foundation=Concrete, walls=Brick, roof=Tile, hasGarage=true]

        // Создание другого объекта с минимальными параметрами
        House simpleHouse = new House.Builder()
                .setFoundation("Wood")
                .setWalls("Wood")
                .setRoof("Metal")
                .build();

        System.out.println(simpleHouse); // Вывод: House [foundation=Wood, walls=Wood, roof=Metal, hasGarage=false]
    }
}
```

В этом примере:
- `House` — продукт с неизменяемыми полями.
- `Builder` — внутренний класс, который позволяет задавать параметры пошагово и возвращает готовый объект через метод `build()`.
- Клиентский код демонстрирует гибкость создания объектов с разными конфигурациями.


--------------------------------------------------------------------------------------------------------------------
### Шаблон проектирования Prototype

**Prototype** — это порождающий шаблон проектирования, который позволяет создавать новые объекты путём копирования (клонирования) существующего объекта, называемого прототипом. Это полезно, когда создание объекта с нуля дорогостоящее или когда нужно создать объект с аналогичными свойствами, но с небольшими изменениями.

#### Основные компоненты:
1. **Prototype (Прототип)** — интерфейс или абстрактный класс, определяющий метод для клонирования объекта (обычно `clone()`).
2. **ConcretePrototype (Конкретный прототип)** — класс, реализующий метод клонирования и содержащий данные, которые нужно скопировать.
3. **Client (Клиент)** — код, который использует прототип для создания новых объектов через клонирование.

#### Преимущества:
- Уменьшает затраты на создание сложных объектов.
- Позволяет создавать копии объектов с минимальными изменениями.
- Упрощает добавление новых типов объектов без изменения клиентского кода.

#### Недостатки:
- Глубокое копирование может быть сложным, особенно если объект содержит ссылки на другие объекты.
- Требует реализации метода клонирования, что может усложнить код.


### Пример на Java

В Java шаблон Prototype часто реализуется через интерфейс `Cloneable` и метод `clone()`.

```java
// Интерфейс прототипа
interface Prototype extends Cloneable {
    Prototype clone() throws CloneNotSupportedException;
}

// Конкретный прототип
class Car implements Prototype {
    private String model;
    private int year;
    private Engine engine; // Сложный объект для демонстрации глубокого копирования

    public Car(String model, int year, Engine engine) {
        this.model = model;
        this.year = year;
        this.engine = engine;
    }

    // Глубокое копирование
    @Override
    public Car clone() throws CloneNotSupportedException {
        // Копируем примитивы и создаём новый объект Engine
        Engine clonedEngine = new Engine(this.engine.getPower());
        return new Car(this.model, this.year, clonedEngine);
    }

    public void setModel(String model) {
        this.model = model;
    }

    @Override
    public String toString() {
        return "Car [model=" + model + ", year=" + year + ", engine=" + engine + "]";
    }
}

// Вспомогательный класс для демонстрации глубокого копирования
class Engine {
    private int power;

    public Engine(int power) {
        this.power = power;
    }

    public int getPower() {
        return power;
    }

    @Override
    public String toString() {
        return "Engine [power=" + power + "]";
    }
}

// Клиентский код
public class PrototypeDemo {
    public static void main(String[] args) throws CloneNotSupportedException {
        Car originalCar = new Car("Toyota", 2020, new Engine(150));
        System.out.println("Original: " + originalCar);

        // Клонируем объект
        Car clonedCar = originalCar.clone();
        clonedCar.setModel("Honda"); // Изменяем модель клонированного объекта

        System.out.println("Cloned: " + clonedCar);
        System.out.println("Original after cloning: " + originalCar); // Оригинал не изменился
    }
}
```

**Вывод:**
```
Original: Car [model=Toyota, year=2020, engine=Engine [power=150]]
Cloned: Car [model=Honda, year=2020, engine=Engine [power=150]]
Original after cloning: Car [model=Toyota, year=2020, engine=Engine [power=150]]
```

В примере:
- `Car` реализует глубокое копирование, создавая новый объект `Engine` при клонировании.
- Изменение клонированного объекта не влияет на оригинал.


--------------------------------------------------------------------------------------------------------------------
### Шаблон проектирования Adapter

**Adapter** — это структурный шаблон проектирования, который позволяет объектам с несовместимыми интерфейсами работать вместе. Он преобразует интерфейс одного класса в интерфейс, ожидаемый клиентом, выступая в роли "переходника".

#### Основные компоненты:
1. **Target (Целевой интерфейс)** — интерфейс, который ожидает клиент.
2. **Adapter (Адаптер)** — класс, реализующий целевой интерфейс и содержащий логику для взаимодействия с адаптируемым объектом.
3. **Adaptee (Адаптируемый объект)** — класс с несовместимым интерфейсом, который нужно интегрировать.
4. **Client (Клиент)** — код, работающий с объектами через целевой интерфейс.

#### Типы адаптеров:
- **Объектный адаптер**: Использует композицию, включая адаптируемый объект как поле.
- **Классовый адаптер**: Использует множественное наследование (в Java не применимо, так как поддерживается только одиночное наследование классов).

#### Преимущества:
- Позволяет использовать существующие классы без изменения их кода.
- Упрощает интеграцию сторонних библиотек.
- Повышает гибкость системы.

#### Недостатки:
- Увеличивает сложность кода из-за дополнительных классов.
- Может добавить небольшую накладную стоимость по производительности.

### Пример на Java

Предположим, у нас есть старый класс `LegacyPrinter` с несовместимым интерфейсом, и мы хотим использовать его с новым интерфейсом `Printer`.

```java
// Целевой интерфейс
interface Printer {
    void print(String message);
}

// Адаптируемый объект (старый класс)
class LegacyPrinter {
    public void printOld(String text) {
        System.out.println("Legacy Printer: " + text);
    }
}

// Адаптер (объектный)
class PrinterAdapter implements Printer {
    private final LegacyPrinter legacyPrinter;

    public PrinterAdapter(LegacyPrinter legacyPrinter) {
        this.legacyPrinter = legacyPrinter;
    }

    @Override
    public void print(String message) {
        // Преобразуем вызов нового интерфейса в старый
        legacyPrinter.printOld(message);
    }
}

// Клиентский код
public class AdapterDemo {
    public static void main(String[] args) {
        // Создаём адаптируемый объект
        LegacyPrinter legacyPrinter = new LegacyPrinter();

        // Создаём адаптер
        Printer printer = new PrinterAdapter(legacyPrinter);

        // Клиент работает с адаптером через целевой интерфейс
        printer.print("Hello, World!"); // Вывод: Legacy Printer: Hello, World!
    }
}
```

В примере:
- `Printer` — целевой интерфейс, который ожидает клиент.
- `LegacyPrinter` — старый класс с несовместимым методом `printOld`.
- `PrinterAdapter` преобразует вызов `print` в вызов `printOld`.

--------------------------------------------------------------------------------------------------------------------
### Шаблон проектирования Bridge

**Bridge** — это структурный шаблон проектирования, который разделяет абстракцию и реализацию, позволяя изменять их независимо друг от друга. Он используется для разделения высокоуровневой логики (абстракции) от низкоуровневой реализации, что упрощает расширение системы и повышает её гибкость.

#### Основные компоненты:
1. **Abstraction (Абстракция)** — определяет интерфейс для клиентского кода и содержит ссылку на объект реализации.
2. **RefinedAbstraction (Уточнённая абстракция)** — расширяет абстракцию, добавляя дополнительную функциональность.
3. **Implementor (Интерфейс реализации)** — определяет интерфейс для классов реализации.
4. **ConcreteImplementor (Конкретная реализация)** — реализует интерфейс Implementor, предоставляя конкретную функциональность.
5. **Client (Клиент)** — взаимодействует с абстракцией, не зная о деталях реализации.

#### Преимущества:
- Разделяет абстракцию и реализацию, позволяя изменять их независимо.
- Упрощает добавление новых абстракций или реализаций.
- Снижает связанность между компонентами.
- Соответствует принципу открытости/закрытости.

#### Недостатки:
- Увеличивает сложность кода из-за дополнительных классов и интерфейсов.
- Может быть избыточным для простых систем.


### Пример на Java

Рассмотрим пример, где мы рисуем фигуры (абстракция) с использованием разных API для отрисовки (реализация).

```java
// Интерфейс реализации
interface DrawingAPI {
    void drawCircle(int x, int y, int radius);
}

// Конкретная реализация 1
class OpenGLDrawingAPI implements DrawingAPI {
    @Override
    public void drawCircle(int x, int y, int radius) {
        System.out.println("Drawing circle with OpenGL at (" + x + ", " + y + ") with radius " + radius);
    }
}

// Конкретная реализация 2
class DirectXDrawingAPI implements DrawingAPI {
    @Override
    public void drawCircle(int x, int y, int radius) {
        System.out.println("Drawing circle with DirectX at (" + x + ", " + y + ") with radius " + radius);
    }
}

// Абстракция
abstract class Shape {
    protected DrawingAPI drawingAPI;

    protected Shape(DrawingAPI drawingAPI) {
        this.drawingAPI = drawingAPI;
    }

    abstract void draw();
}

// Уточнённая абстракция
class Circle extends Shape {
    private int x, y, radius;

    public Circle(int x, int y, int radius, DrawingAPI drawingAPI) {
        super(drawingAPI);
        this.x = x;
        this.y = y;
        this.radius = radius;
    }

    @Override
    void draw() {
        drawingAPI.drawCircle(x, y, radius);
    }
}

// Клиентский код
public class BridgeDemo {
    public static void main(String[] args) {
        // Используем OpenGL для отрисовки
        Shape circle1 = new Circle(10, 20, 30, new OpenGLDrawingAPI());
        circle1.draw(); // Вывод: Drawing circle with OpenGL at (10, 20) with radius 30

        // Используем DirectX для отрисовки
        Shape circle2 = new Circle(40, 50, 60, new DirectXDrawingAPI());
        circle2.draw(); // Вывод: Drawing circle with DirectX at (40, 50) with radius 60
    }
}
```

В примере:
- `DrawingAPI` — интерфейс реализации, определяющий метод отрисовки.
- `OpenGLDrawingAPI` и `DirectXDrawingAPI` — конкретные реализации.
- `Shape` — абстракция, содержащая ссылку на `DrawingAPI`.
- `Circle` — уточнённая абстракция, использующая реализацию для отрисовки круга.

--------------------------------------------------------------------------------------------------------------------
### Шаблон проектирования Composite

**Компоновщик** — это структурный шаблон проектирования, который позволяет работать с группами объектов так же, как с отдельными объектами, формируя древовидную структуру. Он используется для представления иерархий "часть-целое", где клиенты могут обрабатывать составные и одиночные объекты единообразно.

#### Основные компоненты:
1. **Component (Компонент)** — интерфейс или абстрактный класс, определяющий общие методы для листьев и композитов.
2. **Leaf (Лист)** — класс, представляющий конечный элемент в иерархии, который не имеет дочерних элементов.
3. **Composite (Композит)** — класс, содержащий коллекцию дочерних компонентов и реализующий методы для работы с ними.
4. **Client (Клиент)** — код, взаимодействующий с компонентами через общий интерфейс.

#### Преимущества:
- Упрощает работу с древовидными структурами.
- Позволяет клиентам обрабатывать листья и композиты единообразно.
- Соответствует принципу открытости/закрытости.

#### Недостатки:
- Может усложнить систему, если иерархия слишком проста.
- Некоторые операции могут быть не применимы к листьям или композитам, что требует дополнительных проверок.

---

### Пример на Java

Рассмотрим пример файловой системы, где файлы (листья) и директории (композиты) обрабатываются единообразно.

```java
import java.util.ArrayList;
import java.util.List;

// Интерфейс компонента
interface FileSystemComponent {
    void display(String indent);
    int getSize();
}

// Лист (файл)
class File implements FileSystemComponent {
    private String name;
    private int size;

    public File(String name, int size) {
        this.name = name;
        this.size = size;
    }

    @Override
    public void display(String indent) {
        System.out.println(indent + "File: " + name + " (" + size + " bytes)");
    }

    @Override
    public int getSize() {
        return size;
    }
}

// Композит (директория)
class Directory implements FileSystemComponent {
    private String name;
    private List<FileSystemComponent> components = new ArrayList<>();

    public Directory(String name) {
        this.name = name;
    }

    public void addComponent(FileSystemComponent component) {
        components.add(component);
    }

    @Override
    public void display(String indent) {
        System.out.println(indent + "Directory: " + name);
        for (FileSystemComponent component : components) {
            component.display(indent + "  ");
        }
    }

    @Override
    public int getSize() {
        int totalSize = 0;
        for (FileSystemComponent component : components) {
            totalSize += component.getSize();
        }
        return totalSize;
    }
}

// Клиентский код
public class CompositeDemo {
    public static void main(String[] args) {
        // Создаём файлы (листья)
        FileSystemComponent file1 = new File("document.txt", 100);
        FileSystemComponent file2 = new File("image.jpg", 200);

        // Создаём директории (композиты)
        Directory root = new Directory("root");
        Directory subDir = new Directory("subdir");

        // Формируем иерархию
        subDir.addComponent(file2);
        root.addComponent(file1);
        root.addComponent(subDir);

        // Отображаем структуру
        root.display("");
        System.out.println("Total size: " + root.getSize() + " bytes");
    }
}
```

**Вывод:**
```
Directory: root
  File: document.txt (100 bytes)
  Directory: subdir
    File: image.jpg (200 bytes)
Total size: 300 bytes
```


--------------------------------------------------------------------------------------------------------------------
### Шаблон проектирования Decorator

**Decorator** — это структурный шаблон проектирования, который позволяет динамически добавлять новую функциональность к объектам, не изменяя их код. Он оборачивает исходный объект, предоставляя расширенное поведение, сохраняя при этом совместимость с его интерфейсом.

#### Основные компоненты:
1. **Component (Компонент)** — интерфейс или абстрактный класс, определяющий общий интерфейс для объектов и их декораторов.
2. **ConcreteComponent (Конкретный компонент)** — класс, реализующий компонент, к которому добавляется новая функциональность.
3. **Decorator (Декоратор)** — абстрактный класс, реализующий интерфейс компонента и содержащий ссылку на объект компонента.
4. **ConcreteDecorator (Конкретный декоратор)** — класс, добавляющий новую функциональность, переопределяя методы компонента.
5. **Client (Клиент)** — код, взаимодействующий с компонентами через общий интерфейс.

#### Преимущества:
- Позволяет добавлять функциональность без изменения исходного кода (принцип открытости/закрытости).
- Поддерживает гибкую комбинацию декораторов.
- Упрощает расширение функциональности по сравнению с наследованием.

#### Недостатки:
- Может привести к созданию множества мелких классов.
- Усложняет отладку из-за цепочки обёрток.
- Может увеличить накладные расходы при чрезмерном использовании.

### Пример на Java

Рассмотрим пример добавления функциональности к объекту, представляющему напиток, с помощью декораторов для добавления ингредиентов.

```java
// Интерфейс компонента
interface Beverage {
    String getDescription();
    double getCost();
}

// Конкретный компонент
class Coffee implements Beverage {
    @Override
    public String getDescription() {
        return "Coffee";
    }

    @Override
    public double getCost() {
        return 2.0;
    }
}

// Абстрактный декоратор
abstract class BeverageDecorator implements Beverage {
    protected Beverage beverage;

    public BeverageDecorator(Beverage beverage) {
        this.beverage = beverage;
    }

    @Override
    public String getDescription() {
        return beverage.getDescription();
    }

    @Override
    public double getCost() {
        return beverage.getCost();
    }
}

// Конкретный декоратор 1
class MilkDecorator extends BeverageDecorator {
    public MilkDecorator(Beverage beverage) {
        super(beverage);
    }

    @Override
    public String getDescription() {
        return beverage.getDescription() + ", Milk";
    }

    @Override
    public double getCost() {
        return beverage.getCost() + 0.5;
    }
}

// Конкретный декоратор 2
class SugarDecorator extends BeverageDecorator {
    public SugarDecorator(Beverage beverage) {
        super(beverage);
    }

    @Override
    public String getDescription() {
        return beverage.getDescription() + ", Sugar";
    }

    @Override
    public double getCost() {
        return beverage.getCost() + 0.2;
    }
}

// Клиентский код
public class DecoratorDemo {
    public static void main(String[] args) {
        // Создаём базовый напиток
        Beverage coffee = new Coffee();
        System.out.println(coffee.getDescription() + " $" + coffee.getCost()); // Coffee $2.0

        // Добавляем молоко
        Beverage coffeeWithMilk = new MilkDecorator(coffee);
        System.out.println(coffeeWithMilk.getDescription() + " $" + coffeeWithMilk.getCost()); // Coffee, Milk $2.5

        // Добавляем молоко и сахар
        Beverage coffeeWithMilkAndSugar = new SugarDecorator(new MilkDecorator(coffee));
        System.out.println(coffeeWithMilkAndSugar.getDescription() + " $" + coffeeWithMilkAndSugar.getCost()); // Coffee, Milk, Sugar $2.7
    }
}
```

**Вывод:**
```
Coffee $2.0
Coffee, Milk $2.5
Coffee, Milk, Sugar $2.7
```

В примере:
- `Beverage` — общий интерфейс для напитков и декораторов.
- `Coffee` — конкретный компонент.
- `BeverageDecorator` — абстрактный декоратор, содержащий ссылку на компонент.
- `MilkDecorator` и `SugarDecorator` — добавляют новые ингредиенты и стоимость.

--------------------------------------------------------------------------------------------------------------------
### Шаблон проектирования Facade

**Facade** — это структурный шаблон проектирования, который предоставляет упрощённый интерфейс к сложной подсистеме, скрывая её внутренние детали. Он используется для упрощения взаимодействия с набором классов, библиотек или API, предоставляя клиенту удобный и высокоуровневый доступ к функциональности.

#### Основные компоненты:
1. **Facade (Фасад)** — класс, предоставляющий упрощённый интерфейс для взаимодействия с подсистемой.
2. **Subsystem (Подсистема)** — набор классов, реализующих сложную функциональность, с которой клиент не должен взаимодействовать напрямую.
3. **Client (Клиент)** — код, использующий фасад для работы с подсистемой.

#### Преимущества:
- Упрощает использование сложных систем.
- Снижает связанность между клиентом и подсистемой.
- Улучшает читаемость и поддерживаемость кода.
- Может служить точкой входа для подсистемы.

#### Недостатки:
- Может стать "божественным объектом", если в фасад добавляется слишком много логики.
- Скрывает детали подсистемы, что может затруднить доступ к специфической функциональности.
- Может добавить дополнительный слой, увеличивая сложность в простых случаях.


### Пример на Java

Рассмотрим пример подсистемы домашнего кинотеатра, где фасад упрощает управление различными устройствами (проектор, аудиосистема, плеер).

```java
// Подсистема: Проектор
class Projector {
    public void on() {
        System.out.println("Projector is ON");
    }

    public void off() {
        System.out.println("Projector is OFF");
    }

    public void setInput(String input) {
        System.out.println("Projector input set to " + input);
    }
}

// Подсистема: Аудиосистема
class AudioSystem {
    public void on() {
        System.out.println("Audio System is ON");
    }

    public void off() {
        System.out.println("Audio System is OFF");
    }

    public void setVolume(int level) {
        System.out.println("Audio System volume set to " + level);
    }
}

// Подсистема: Плеер
class MediaPlayer {
    public void on() {
        System.out.println("Media Player is ON");
    }

    public void off() {
        System.out.println("Media Player is OFF");
    }

    public void play(String movie) {
        System.out.println("Playing movie: " + movie);
    }
}

// Фасад
class HomeTheaterFacade {
    private Projector projector;
    private AudioSystem audioSystem;
    private MediaPlayer mediaPlayer;

    public HomeTheaterFacade(Projector projector, AudioSystem audioSystem, MediaPlayer mediaPlayer) {
        this.projector = projector;
        this.audioSystem = audioSystem;
        this.mediaPlayer = mediaPlayer;
    }

    public void watchMovie(String movie) {
        System.out.println("Preparing to watch movie...");
        projector.on();
        projector.setInput("HDMI");
        audioSystem.on();
        audioSystem.setVolume(5);
        mediaPlayer.on();
        mediaPlayer.play(movie);
        System.out.println("Enjoy the movie!");
    }

    public void endMovie() {
        System.out.println("Shutting down...");
        mediaPlayer.off();
        audioSystem.off();
        projector.off();
    }
}

// Клиентский код
public class FacadeDemo {
    public static void main(String[] args) {
        Projector projector = new Projector();
        AudioSystem audioSystem = new AudioSystem();
        MediaPlayer mediaPlayer = new MediaPlayer();

        HomeTheaterFacade homeTheater = new HomeTheaterFacade(projector, audioSystem, mediaPlayer);

        homeTheater.watchMovie("Inception"); // Запускаем фильм
        System.out.println("---");
        homeTheater.endMovie(); // Завершаем просмотр
    }
}
```

**Вывод:**
```
Preparing to watch movie...
Projector is ON
Projector input set to HDMI
Audio System is ON
Audio System volume set to 5
Media Player is ON
Playing movie: Inception
Enjoy the movie!
---
Shutting down...
Media Player is OFF
Audio System is OFF
Projector is OFF
```

В примере:
- `HomeTheaterFacade` предоставляет два простых метода (`watchMovie` и `endMovie`), скрывая сложную последовательность вызовов подсистемы.
- Клиент взаимодействует только с фасадом, не зная о деталях работы устройств.


--------------------------------------------------------------------------------------------------------------------
### Шаблон проектирования Flyweight

**Flyweight** — это структурный шаблон проектирования, который позволяет эффективно использовать память, разделяя общее состояние объектов между множеством экземпляров. Он используется для минимизации потребления ресурсов, когда создаётся большое количество однотипных объектов с общими характеристиками.

#### Основные компоненты:
1. **Flyweight (Приспособленец)** — интерфейс или абстрактный класс, определяющий методы для работы с объектами.
2. **ConcreteFlyweight (Конкретный приспособленец)** — класс, реализующий Flyweight, хранящий **внутреннее состояние** (общее для всех объектов).
3. **FlyweightFactory (Фабрика приспособленцев)** — класс, управляющий созданием и повторным использованием Flyweight-объектов.
4. **Client (Клиент)** — код, использующий Flyweight-объекты и передающий **внешнее состояние** (уникальное для каждого использования).
5. **Внутреннее состояние** — данные, общие для множества объектов, хранятся в Flyweight.
6. **Внешнее состояние** — данные, уникальные для каждого использования, передаются клиентом.

#### Преимущества:
- Существенно снижает потребление памяти при работе с большим количеством объектов.
- Упрощает управление общим состоянием.
- Улучшает производительность в системах с множеством однотипных объектов.

#### Недостатки:
- Усложняет код из-за разделения состояния на внутреннее и внешнее.
- Может увеличить время выполнения из-за поиска и управления объектами в фабрике.
- Требует тщательного проектирования для определения внутреннего и внешнего состояния.


### Пример на Java

Рассмотрим пример, где мы создаём множество деревьев в игре, используя Flyweight для хранения общего состояния (тип дерева), а координаты (внешнее состояние) передаём отдельно.

```java
import java.util.HashMap;
import java.util.Map;

// Интерфейс приспособленца
interface Tree {
    void display(int x, int y); // Внешнее состояние (координаты)
}

// Конкретный приспособленец
class TreeType implements Tree {
    private String name; // Внутреннее состояние
    private String color;

    public TreeType(String name, String color) {
        this.name = name;
        this.color = color;
    }

    @Override
    public void display(int x, int y) {
        System.out.println("Tree: " + name + ", Color: " + color + " at (" + x + ", " + y + ")");
    }
}

// Фабрика приспособленцев
class TreeFactory {
    private static Map<String, TreeType> treeTypes = new HashMap<>();

    public static TreeType getTreeType(String name, String color) {
        String key = name + "-" + color;
        TreeType treeType = treeTypes.get(key);
        if (treeType == null) {
            treeType = new TreeType(name, color);
            treeTypes.put(key, treeType);
            System.out.println("Created new TreeType: " + key);
        }
        return treeType;
    }
}

// Клиентский код
public class FlyweightDemo {
    public static void main(String[] args) {
        // Создаём несколько деревьев
        Tree oak1 = TreeFactory.getTreeType("Oak", "Green");
        oak1.display(1, 2); // Внешнее состояние: координаты

        Tree oak2 = TreeFactory.getTreeType("Oak", "Green"); // Повторное использование
        oak2.display(3, 4);

        Tree pine = TreeFactory.getTreeType("Pine", "DarkGreen");
        pine.display(5, 6);

        // Проверяем, что используется один и тот же объект для одинакового типа
        System.out.println("Same Oak instance: " + (oak1 == oak2)); // true
    }
}
```

**Вывод:**
```
Created new TreeType: Oak-Green
Tree: Oak, Color: Green at (1, 2)
Tree: Oak, Color: Green at (3, 4)
Created new TreeType: Pine-DarkGreen
Tree: Pine, Color: DarkGreen at (5, 6)
Same Oak instance: true
```

В примере:
- `TreeType` хранит внутреннее состояние (название и цвет дерева).
- `TreeFactory` управляет созданием и повторным использованием `TreeType`.
- Координаты (x, y) — внешнее состояние, передаваемое клиентом.

--------------------------------------------------------------------------------------------------------------------
Шаблон: Прокси (Proxy)

### Шаблон проектирования Proxy

**Proxy** — это структурный шаблон проектирования, который предоставляет объект-заместитель (прокси) для контроля доступа к другому объекту. Прокси действует как посредник, добавляя дополнительную логику, такую как ленивая инициализация, контроль доступа, логирование или кэширование, без изменения основного объекта.

#### Основные компоненты:
1. **Subject (Субъект)** — интерфейс, общий для прокси и реального объекта, определяющий методы, которые клиент может вызывать.
2. **RealSubject (Реальный субъект)** — класс, содержащий основную бизнес-логику.
3. **Proxy (Прокси)** — класс, реализующий интерфейс Subject, содержащий ссылку на RealSubject и управляющий доступом к нему.
4. **Client (Клиент)** — код, взаимодействующий с объектами через интерфейс Subject.

#### Типы прокси:
- **Виртуальный прокси**: Откладывает создание объекта до его необходимости.
- **Защитный прокси**: Контролирует доступ на основе прав.
- **Удалённый прокси**: Управляет взаимодействием с объектом в другом адресном пространстве.
- **Кэширующий прокси**: Сохраняет результаты для повышения производительности.

#### Преимущества:
- Контролирует доступ к объекту.
- Добавляет функциональность (например, логирование, кэширование).
- Поддерживает ленивую инициализацию.

#### Недостатки:
- Усложняет код из-за дополнительного слоя.
- Может добавить накладные расходы.
- Требует синхронизации в многопоточных системах.

---

### Сравнение Proxy и Decorator

| **Характеристика**         | **Proxy**                                                                 | **Decorator**                                                             |
|----------------------------|---------------------------------------------------------------------------|---------------------------------------------------------------------------|
| **Назначение**             | Контролирует доступ к объекту, добавляя логику (например, ленивая инициализация, безопасность). | Динамически добавляет новую функциональность к объекту, расширяя его поведение. |
| **Фокус**                  | Управление доступом или оптимизация (например, кэширование, защита).       | Расширение функциональности (например, добавление новых возможностей).     |
| **Интерфейс**              | Прокси и реальный объект реализуют один интерфейс, прокси делегирует вызовы. | Декоратор и компонент реализуют один интерфейс, декоратор может добавлять свои действия. |
| **Прозрачность**           | Клиент может не знать, что работает с прокси, но прокси может ограничить доступ. | Клиент обычно знает, что использует декоратор, так как он добавляет новое поведение. |
| **Пример использования**   | Ленивая загрузка изображения, транзакции в Spring.                        | Добавление ингредиентов к напитку, логирование времени выполнения.        |
| **Комбинируемость**        | Прокси обычно используется один, так как фокусируется на контроле.         | Декораторы можно комбинировать, создавая цепочки (например, молоко + сахар). |
| **Пример в Spring**        | Прокси для `@Transactional` или `@Lazy`.                                  | AOP-аспекты для логирования или кэширования с `@Cacheable`.               |

**Ключевое различие**:
- **Proxy** управляет доступом или поведением объекта, часто скрывая его создание или защищая его (например, ленивая инициализация в Spring).
- **Decorator** добавляет новое поведение, сохраняя исходный объект нетронутым (например, добавление логирования через AOP).

**Сходство**:
- Оба используют общий интерфейс и обёртывание объекта.
- Могут добавлять дополнительную логику.
- Используются в Spring через AOP и прокси.

---

### Пример на Java (Proxy)

Пример виртуального прокси для ленивой загрузки изображения.

```java
// Интерфейс субъекта
interface Image {
    void display();
}

// Реальный субъект
class RealImage implements Image {
    private String filename;

    public RealImage(String filename) {
        this.filename = filename;
        loadFromDisk();
    }

    private void loadFromDisk() {
        System.out.println("Loading image: " + filename);
    }

    @Override
    public void display() {
        System.out.println("Displaying image: " + filename);
    }
}

// Прокси
class ProxyImage implements Image {
    private RealImage realImage;
    private String filename;

    public ProxyImage(String filename) {
        this.filename = filename;
    }

    @Override
    public void display() {
        if (realImage == null) {
            realImage = new RealImage(filename); // Ленивая инициализация
        }
        realImage.display();
    }
}

// Клиентский код
public class ProxyDemo {
    public static void main(String[] args) {
        Image image = new ProxyImage("test.jpg");
        image.display(); // Загружает и отображает
        image.display(); // Только отображает
    }
}
```

**Вывод:**
```
Loading image: test.jpg
Displaying image: test.jpg
Displaying image: test.jpg
```

--------------------------------------------------------------------------------------------------------------------
### Шаблон проектирования Chain of Responsibility

**Chain of Responsibility** — это поведенческий шаблон проектирования, который позволяет передавать запрос по цепочке обработчиков, пока один из них не обработает его или цепочка не закончится. Каждый обработчик решает, обработать запрос или передать его следующему в цепочке.

#### Основные компоненты:
1. **Handler (Обработчик)** — интерфейс или абстрактный класс, определяющий метод для обработки запроса и ссылку на следующий обработчик.
2. **ConcreteHandler (Конкретный обработчик)** — класс, реализующий логику обработки запроса и, при необходимости, передающий его дальше по цепочке.
3. **Client (Клиент)** — код, создающий цепочку обработчиков и отправляющий запрос первому из них.

#### Преимущества:
- Снижает связанность между отправителем запроса и его обработчиками.
- Позволяет гибко настраивать порядок обработки.
- Соответствует принципу единственной ответственности.

#### Недостатки:
- Запрос может остаться необработанным, если ни один обработчик не возьмёт его на себя.
- Может снизить производительность из-за последовательного прохода по цепочке.
- Усложняет отладку, если цепочка длинная.

### Пример на Java

Рассмотрим пример обработки запросов на утверждение расходов, где разные уровни менеджеров имеют свои лимиты одобрения.

```java
// Абстрактный обработчик
abstract class Approver {
    protected Approver nextApprover;

    public void setNext(Approver nextApprover) {
        this.nextApprover = nextApprover;
    }

    public abstract void approveRequest(int amount);
}

// Конкретный обработчик: Менеджер
class Manager extends Approver {
    @Override
    public void approveRequest(int amount) {
        if (amount <= 1000) {
            System.out.println("Manager approved request of $" + amount);
        } else if (nextApprover != null) {
            nextApprover.approveRequest(amount);
        } else {
            System.out.println("Request of $" + amount + " cannot be approved");
        }
    }
}

// Конкретный обработчик: Директор
class Director extends Approver {
    @Override
    public void approveRequest(int amount) {
        if (amount <= 5000) {
            System.out.println("Director approved request of $" + amount);
        } else if (nextApprover != null) {
            nextApprover.approveRequest(amount);
        } else {
            System.out.println("Request of $" + amount + " cannot be approved");
        }
    }
}

// Конкретный обработчик: Президент
class President extends Approver {
    @Override
    public void approveRequest(int amount) {
        if (amount <= 10000) {
            System.out.println("President approved request of $" + amount);
        } else {
            System.out.println("Request of $" + amount + " cannot be approved");
        }
    }
}

// Клиентский код
public class ChainOfResponsibilityDemo {
    public static void main(String[] args) {
        // Формируем цепочку
        Approver manager = new Manager();
        Approver director = new Director();
        Approver president = new President();

        manager.setNext(director);
        director.setNext(president);

        // Тестируем запросы
        manager.approveRequest(500);   // Manager approved
        manager.approveRequest(2000);  // Director approved
        manager.approveRequest(7000);  // President approved
        manager.approveRequest(15000); // Cannot be approved
    }
}
```

**Вывод:**
```
Manager approved request of $500
Director approved request of $2000
President approved request of $7000
Request of $15000 cannot be approved
```

В примере:
- `Approver` — абстрактный обработчик с методом обработки и ссылкой на следующий обработчик.
- `Manager`, `Director`, `President` — конкретные обработчики с разными лимитами.
- Клиент формирует цепочку и отправляет запросы, которые проходят по ней.

--------------------------------------------------------------------------------------------------------------------
### Шаблон проектирования Command

**Command** — это поведенческий шаблон проектирования, который инкапсулирует запрос в виде объекта, позволяя параметризовать клиентов с различными запросами, ставить запросы в очередь, логировать их или поддерживать отмену операций.

#### Основные компоненты:
1. **Command (Команда)** — интерфейс или абстрактный класс, определяющий метод выполнения команды (обычно `execute()`).
2. **ConcreteCommand (Конкретная команда)** — класс, реализующий команду, связывая действие с получателем.
3. **Receiver (Получатель)** — класс, содержащий бизнес-логику для выполнения действия.
4. **Invoker (Инициатор)** — класс, который вызывает команду, не зная о её реализации.
5. **Client (Клиент)** — код, создающий команды и связывающий их с получателями.

#### Преимущества:
- Разделяет отправителя запроса и его исполнителя.
- Поддерживает отмену операций и постановку в очередь.
- Упрощает добавление новых команд (принцип открытости/закрытости).
- Позволяет логировать или повторять операции.

#### Недостатки:
- Увеличивает количество классов, усложняя код.
- Может быть избыточным для простых операций.
- Требует дополнительной памяти для хранения команд.



### Пример на Java

Рассмотрим пример управления текстом в редакторе, где команды позволяют выполнять и отменять операции.

```java
// Интерфейс команды
interface Command {
    void execute();
    void undo();
}

// Получатель
class TextEditor {
    private StringBuilder text = new StringBuilder();

    public void addText(String newText) {
        text.append(newText);
        System.out.println("Text added: " + newText + ", Current text: " + text);
    }

    public void removeText(int length) {
        if (length <= text.length()) {
            text.delete(text.length() - length, text.length());
            System.out.println("Text removed, Current text: " + text);
        }
    }

    public String getText() {
        return text.toString();
    }
}

// Конкретная команда: Добавление текста
class AddTextCommand implements Command {
    private TextEditor editor;
    private String text;

    public AddTextCommand(TextEditor editor, String text) {
        this.editor = editor;
        this.text = text;
    }

    @Override
    public void execute() {
        editor.addText(text);
    }

    @Override
    public void undo() {
        editor.removeText(text.length());
    }
}

// Конкретная команда: Удаление текста
class RemoveTextCommand implements Command {
    private TextEditor editor;
    private String removedText;

    public RemoveTextCommand(TextEditor editor, int length) {
        this.editor = editor;
        this.removedText = editor.getText().substring(Math.max(0, editor.getText().length() - length));
    }

    @Override
    public void execute() {
        editor.removeText(removedText.length());
    }

    @Override
    public void undo() {
        editor.addText(removedText);
    }
}

// Инициатор
class EditorInvoker {
    private Command command;

    public void setCommand(Command command) {
        this.command = command;
    }

    public void executeCommand() {
        command.execute();
    }

    public void undoCommand() {
        command.undo();
    }
}

// Клиентский код
public class CommandDemo {
    public static void main(String[] args) {
        TextEditor editor = new TextEditor();
        EditorInvoker invoker = new EditorInvoker();

        // Добавляем текст
        Command addCommand = new AddTextCommand(editor, "Hello");
        invoker.setCommand(addCommand);
        invoker.executeCommand(); // Text added: Hello, Current text: Hello

        // Добавляем ещё текст
        addCommand = new AddTextCommand(editor, ", World!");
        invoker.setCommand(addCommand);
        invoker.executeCommand(); // Text added: , World!, Current text: Hello, World!

        // Отменяем последнюю операцию
        invoker.undoCommand(); // Text removed, Current text: Hello

        // Удаляем текст
        Command removeCommand = new RemoveTextCommand(editor, 5);
        invoker.setCommand(removeCommand);
        invoker.executeCommand(); // Text removed, Current text: 

        // Отменяем удаление
        invoker.undoCommand(); // Text added: Hello, Current text: Hello
    }
}
```

**Вывод:**
```
Text added: Hello, Current text: Hello
Text added: , World!, Current text: Hello, World!
Text removed, Current text: Hello
Text removed, Current text: 
Text added: Hello, Current text: Hello
```

В примере:
- `Command` — интерфейс с методами `execute()` и `undo()`.
- `TextEditor` — получатель, выполняющий операции с текстом.
- `AddTextCommand` и `RemoveTextCommand` — конкретные команды.
- `EditorInvoker` — инициатор, управляющий выполнением и отменой команд.


--------------------------------------------------------------------------------------------------------------------
### Шаблон проектирования Interpreter

**Interpreter** — это поведенческий шаблон проектирования, который используется для определения грамматики языка и интерпретации выражений этого языка. Он позволяет преобразовывать выражения, заданные в определённом формате (например, математические выражения, запросы или команды), в действия или результаты.

#### Основные компоненты:
1. **AbstractExpression (Абстрактное выражение)** — интерфейс или абстрактный класс, определяющий метод интерпретации (`interpret()`).
2. **TerminalExpression (Терминальное выражение)** — класс, представляющий конечные элементы языка (например, числа или переменные), реализующий метод интерпретации.
3. **NonTerminalExpression (Нетерминальное выражение)** — класс, представляющий составные выражения (например, операции сложения, умножения), которые содержат другие выражения.
4. **Context (Контекст)** — объект, содержащий информацию, необходимую для интерпретации (например, значения переменных).
5. **Client (Клиент)** — код, создающий выражения и вызывающий их интерпретацию.

#### Преимущества:
- Упрощает обработку языков с чётко определённой грамматикой.
- Позволяет легко добавлять новые выражения (принцип открытости/закрытости).
- Подходит для построения парсеров и интерпретаторов.

#### Недостатки:
- Может быть сложным для реализации при сложной грамматике.
- Производительность может снижаться при обработке больших или сложных выражений.
- Требует создания множества классов для каждого правила грамматики.


### Пример на Java

Рассмотрим пример интерпретации простых арифметических выражений (например, "2 + 3" или "5 - 1").

```java
// Контекст
class Context {
    private final Map<String, Integer> variables = new HashMap<>();

    public void setVariable(String name, int value) {
        variables.put(name, value);
    }

    public int getVariable(String name) {
        return variables.getOrDefault(name, 0);
    }
}

// Интерфейс выражения
interface Expression {
    int interpret(Context context);
}

// Терминальное выражение: Число
class NumberExpression implements Expression {
    private final int number;

    public NumberExpression(int number) {
        this.number = number;
    }

    @Override
    public int interpret(Context context) {
        return number;
    }
}

// Терминальное выражение: Переменная
class VariableExpression implements Expression {
    private final String name;

    public VariableExpression(String name) {
        this.name = name;
    }

    @Override
    public int interpret(Context context) {
        return context.getVariable(name);
    }
}

// Нетерминальное выражение: Сложение
class PlusExpression implements Expression {
    private final Expression left;
    private final Expression right;

    public PlusExpression(Expression left, Expression right) {
        this.left = left;
        this.right = right;
    }

    @Override
    public int interpret(Context context) {
        return left.interpret(context) + right.interpret(context);
    }
}

// Нетерминальное выражение: Вычитание
class MinusExpression implements Expression {
    private final Expression left;
    private final Expression right;

    public MinusExpression(Expression left, Expression right) {
        this.left = left;
        this.right = right;
    }

    @Override
    public int interpret(Context context) {
        return left.interpret(context) - right.interpret(context);
    }
}

// Клиентский код
public class InterpreterDemo {
    public static void main(String[] args) {
        // Создаём контекст
        Context context = new Context();
        context.setVariable("x", 10);
        context.setVariable("y", 5);

        // Выражение: (x + 3) - y
        Expression expression = new MinusExpression(
            new PlusExpression(
                new VariableExpression("x"),
                new NumberExpression(3)
            ),
            new VariableExpression("y")
        );

        // Интерпретируем
        int result = expression.interpret(context);
        System.out.println("Result of (x + 3) - y = " + result); // Вывод: 8 (10 + 3 - 5)
    }
}
```

**Вывод:**
```
Result of (x + 3) - y = 8
```

В примере:
- `Context` хранит значения переменных.
- `NumberExpression` и `VariableExpression` — терминальные выражения, возвращающие числа или значения переменных.
- `PlusExpression` и `MinusExpression` — нетерминальные выражения, выполняющие операции.
- Клиент создаёт выражение `(x + 3) - y` и интерпретирует его.

--------------------------------------------------------------------------------------------------------------------
Шаблон: Итератор (Iterator)

### Шаблон проектирования Iterator

**Iterator** — это поведенческий шаблон проектирования, который предоставляет способ последовательного доступа к элементам коллекции без раскрытия её внутренней структуры. Он позволяет обходить элементы, абстрагируясь от того, как коллекция организована (например, список, массив, дерево).

#### Основные компоненты:
1. **Iterator (Итератор)** — интерфейс, определяющий методы для обхода коллекции (например, `hasNext()`, `next()`).
2. **ConcreteIterator (Конкретный итератор)** — класс, реализующий интерфейс итератора для конкретной коллекции.
3. **Aggregate (Агрегат)** — интерфейс или абстрактный класс, представляющий коллекцию и предоставляющий метод для создания итератора.
4. **ConcreteAggregate (Конкретный агрегат)** — класс, реализующий коллекцию и возвращающий соответствующий итератор.
5. **Client (Клиент)** — код, использующий итератор для обхода элементов.

#### Преимущества:
- Скрывает внутреннюю структуру коллекции.
- Упрощает добавление новых способов обхода.
- Поддерживает принцип единственной ответственности.
- Позволяет одновременно использовать несколько итераторов для одной коллекции.

#### Недостатки:
- Может быть избыточным для простых коллекций.
- Усложняет код, если требуется поддержка сложных обходов.
- Не всегда эффективен для коллекций с динамическим изменением во время итерации.

---

### Пример на Java

Java предоставляет встроенную поддержку Iterator через интерфейсы `Iterator` и `Iterable` в пакете `java.util`. Рассмотрим пример реализации кастомного итератора для коллекции книг.

```java
import java.util.ArrayList;
import java.util.List;

// Интерфейс итератора
interface Iterator<T> {
    boolean hasNext();
    T next();
}

// Интерфейс агрегата
interface BookCollection {
    Iterator<Book> createIterator();
}

// Класс книги
class Book {
    private String title;

    public Book(String title) {
        this.title = title;
    }

    @Override
    public String toString() {
        return title;
    }
}

// Конкретный итератор
class BookIterator implements Iterator<Book> {
    private List<Book> books;
    private int position;

    public BookIterator(List<Book> books) {
        this.books = books;
        this.position = 0;
    }

    @Override
    public boolean hasNext() {
        return position < books.size();
    }

    @Override
    public Book next() {
        if (hasNext()) {
            return books.get(position++);
        }
        throw new IndexOutOfBoundsException("No more elements");
    }
}

// Конкретный агрегат
class Library implements BookCollection {
    private List<Book> books = new ArrayList<>();

    public void addBook(Book book) {
        books.add(book);
    }

    @Override
    public Iterator<Book> createIterator() {
        return new BookIterator(books);
    }
}

// Клиентский код
public class IteratorDemo {
    public static void main(String[] args) {
        Library library = new Library();
        library.addBook(new Book("Java Programming"));
        library.addBook(new Book("Design Patterns"));
        library.addBook(new Book("Spring in Action"));

        Iterator<Book> iterator = library.createIterator();
        while (iterator.hasNext()) {
            System.out.println("Book: " + iterator.next());
        }
    }
}
```

**Вывод:**
```
Book: Java Programming
Book: Design Patterns
Book: Spring in Action
```

В примере:
- `Iterator` — интерфейс с методами `hasNext()` и `next()`.
- `BookIterator` — конкретный итератор для обхода списка книг.
- `BookCollection` — интерфейс агрегата, предоставляющий итератор.
- `Library` — коллекция, создающая итератор для своих книг.

**Примечание**: В реальных Java-приложениях обычно используется `java.util.Iterator` и `Iterable`, а коллекции (например, `ArrayList`, `HashSet`) уже реализуют `Iterable`, позволяя использовать цикл `for-each`.


--------------------------------------------------------------------------------------------------------------------
### Шаблон проектирования Mediator

**Mediator** — это поведенческий шаблон проектирования, который уменьшает связанность между объектами, заставляя их взаимодействовать через посредника. Вместо прямого общения объекты отправляют сообщения посреднику, который координирует их взаимодействие.

#### Основные компоненты:
1. **Mediator (Посредник)** — интерфейс или абстрактный класс, определяющий метод для взаимодействия между объектами.
2. **ConcreteMediator (Конкретный посредник)** — класс, реализующий логику координации между объектами.
3. **Colleague (Коллега)** — классы, взаимодействующие через посредника. Каждый коллега знает о посреднике, но не о других коллегах.
4. **Client (Клиент)** — код, создающий посредника и коллег, настраивающий их взаимодействие.

#### Преимущества:
- Уменьшает связанность между объектами, упрощая их повторное использование.
- Централизует логику взаимодействия в одном месте.
- Упрощает добавление новых коллег (принцип открытости/закрытости).

#### Недостатки:
- Посредник может стать "божественным объектом", если в нём сосредоточится слишком много логики.
- Может добавить накладные расходы из-за дополнительного слоя.
- Усложняет отладку при сложных взаимодействиях.


### Пример на Java

Рассмотрим пример чата, где пользователи (коллеги) общаются через посредника (чат).

```java
// Интерфейс посредника
interface ChatMediator {
    void sendMessage(String message, User user);
}

// Конкретный посредник
class ChatRoom implements ChatMediator {
    private List<User> users = new ArrayList<>();

    public void addUser(User user) {
        users.add(user);
    }

    @Override
    public void sendMessage(String message, User sender) {
        for (User user : users) {
            if (user != sender) { // Не отправляем сообщение отправителю
                user.receiveMessage(message);
            }
        }
    }
}

// Абстрактный коллега
abstract class User {
    protected ChatMediator mediator;
    protected String name;

    public User(ChatMediator mediator, String name) {
        this.mediator = mediator;
        this.name = name;
    }

    public abstract void sendMessage(String message);
    public abstract void receiveMessage(String message);
}

// Конкретный коллега
class ChatUser extends User {
    public ChatUser(ChatMediator mediator, String name) {
        super(mediator, name);
    }

    @Override
    public void sendMessage(String message) {
        System.out.println(name + " sends: " + message);
        mediator.sendMessage(message, this);
    }

    @Override
    public void receiveMessage(String message) {
        System.out.println(name + " receives: " + message);
    }
}

// Клиентский код
public class MediatorDemo {
    public static void main(String[] args) {
        ChatRoom chatRoom = new ChatRoom();

        User alice = new ChatUser(chatRoom, "Alice");
        User bob = new ChatUser(chatRoom, "Bob");
        User charlie = new ChatUser(chatRoom, "Charlie");

        chatRoom.addUser(alice);
        chatRoom.addUser(bob);
        chatRoom.addUser(charlie);

        alice.sendMessage("Hi everyone!");
        bob.sendMessage("Hello, Alice!");
    }
}
```

**Вывод:**
```
Alice sends: Hi everyone!
Bob receives: Hi everyone!
Charlie receives: Hi everyone!
Bob sends: Hello, Alice!
Alice receives: Hello, Alice!
Charlie receives: Hello, Alice!
```

В примере:
- `ChatMediator` — интерфейс посредника.
- `ChatRoom` — конкретный посредник, распределяющий сообщения.
- `User` и `ChatUser` — коллеги, отправляющие и получающие сообщения через посредника.
- Клиент настраивает чат, добавляя пользователей и инициируя общение.

--------------------------------------------------------------------------------------------------------------------
### Шаблон проектирования Memento

**Memento** — это поведенческий шаблон проектирования, который позволяет сохранять и восстанавливать состояние объекта без раскрытия его внутренней структуры. Он используется для реализации функционала "отмена/повтор" или сохранения снимков состояния.

#### Основные компоненты:
1. **Originator (Создатель)** — класс, чьё состояние нужно сохранять. Он создаёт и восстанавливает объект Memento.
2. **Memento (Хранитель)** — класс, хранящий состояние Originator. Обычно имеет ограниченный доступ к данным (например, только Originator может читать/записывать).
3. **Caretaker (Опекун)** — класс, управляющий хранением и передачей объектов Memento (например, для undo/redo).
4. **Client (Клиент)** — код, использующий Originator и Caretaker для работы с состояниями.

#### Преимущества:
- Сохраняет инкапсуляцию, скрывая внутреннее состояние объекта.
- Упрощает реализацию отмены операций.
- Позволяет хранить историю изменений.

#### Недостатки:
- Может потребовать много памяти при хранении большого количества снимков.
- Усложняет код из-за дополнительных классов.
- Требует осторожности при управлении жизненным циклом Memento.

### Пример на Java

Рассмотрим пример текстового редактора, где мы сохраняем и восстанавливаем состояние текста.

```java
// Хранитель
class EditorMemento {
    private final String text;

    public EditorMemento(String text) {
        this.text = text;
    }

    // Только Originator имеет доступ
    private String getText() {
        return text;
    }
}

// Создатель
class TextEditor {
    private String text = "";

    public void setText(String text) {
        this.text = text;
        System.out.println("Text set to: " + text);
    }

    public String getText() {
        return text;
    }

    // Создаём снимок состояния
    public EditorMemento save() {
        return new EditorMemento(text);
    }

    // Восстанавливаем состояние
    public void restore(EditorMemento memento) {
        text = memento.getText();
        System.out.println("Text restored to: " + text);
    }
}

// Опекун
class History {
    private final List<EditorMemento> mementos = new ArrayList<>();

    public void save(EditorMemento memento) {
        mementos.add(memento);
    }

    public EditorMemento undo() {
        if (!mementos.isEmpty()) {
            EditorMemento memento = mementos.remove(mementos.size() - 1);
            return memento;
        }
        return null;
    }
}

// Клиентский код
public class MementoDemo {
    public static void main(String[] args) {
        TextEditor editor = new TextEditor();
        History history = new History();

        // Изменяем текст и сохраняем состояния
        editor.setText("Hello");
        history.save(editor.save());

        editor.setText("Hello, World!");
        history.save(editor.save());

        editor.setText("Hello, World! How are you?");
        history.save(editor.save());

        // Отменяем изменения
        editor.restore(history.undo()); // Восстанавливаем: Hello, World!
        editor.restore(history.undo()); // Восстанавливаем: Hello
    }
}
```

**Вывод:**
```
Text set to: Hello
Text set to: Hello, World!
Text set to: Hello, World! How are you?
Text restored to: Hello, World!
Text restored to: Hello
```

В примере:
- `EditorMemento` — хранит состояние текста.
- `TextEditor` — создаёт и восстанавливает снимки.
- `History` — управляет списком снимков для отмены.
- Клиент изменяет текст и использует историю для восстановления.

--------------------------------------------------------------------------------------------------------------------
### Шаблон проектирования Observer

**Observer** — это поведенческий шаблон проектирования, который устанавливает механизм подписки, позволяющий объектам (наблюдателям) автоматически получать уведомления об изменениях состояния другого объекта (субъекта). Он реализует отношение "один ко многим", где изменение субъекта приводит к уведомлению всех его наблюдателей.

#### Основные компоненты:
1. **Subject (Субъект)** — объект, за состоянием которого следят. Хранит список наблюдателей и методы для их управления (добавление, удаление, уведомление).
2. **Observer (Наблюдатель)** — интерфейс или абстрактный класс, определяющий метод обновления (`update()`), вызываемый субъектом.
3. **ConcreteSubject (Конкретный субъект)** — реализует логику субъекта, хранит состояние и уведомляет наблюдателей об изменениях.
4. **ConcreteObserver (Конкретный наблюдатель)** — реализует логику обработки уведомлений от субъекта.
5. **Client (Клиент)** — код, создающий субъект и наблюдателей, настраивающий их взаимодействие.

#### Преимущества:
- Поддерживает слабую связанность между субъектом и наблюдателями.
- Позволяет динамически добавлять и удалять наблюдателей.
- Поддерживает широковещательное обновление (уведомление всех наблюдателей).
- Соответствует принципу открытости/закрытости.

#### Недостатки:
- Может привести к утечкам памяти, если наблюдатели не удаляются из списка.
- Уведомление большого количества наблюдателей может снизить производительность.
- Сложно отлаживать при большом числе наблюдателей или сложной логике.

### Пример на Java

Рассмотрим пример новостного агентства, где подписчики (наблюдатели) получают уведомления о новых новостях (субъект).

```java
import java.util.ArrayList;
import java.util.List;

// Интерфейс наблюдателя
interface Observer {
    void update(String news);
}

// Интерфейс субъекта
interface NewsAgency {
    void addObserver(Observer observer);
    void removeObserver(Observer observer);
    void notifyObservers();
}

// Конкретный субъект
class ConcreteNewsAgency implements NewsAgency {
    private List<Observer> observers = new ArrayList<>();
    private String news;

    @Override
    public void addObserver(Observer observer) {
        observers.add(observer);
    }

    @Override
    public void removeObserver(Observer observer) {
        observers.remove(observer);
    }

    @Override
    public void notifyObservers() {
        for (Observer observer : observers) {
            observer.update(news);
        }
    }

    public void setNews(String news) {
        this.news = news;
        System.out.println("New news published: " + news);
        notifyObservers();
    }
}

// Конкретный наблюдатель
class NewsSubscriber implements Observer {
    private String name;

    public NewsSubscriber(String name) {
        this.name = name;
    }

    @Override
    public void update(String news) {
        System.out.println(name + " received news: " + news);
    }
}

// Клиентский код
public class ObserverDemo {
    public static void main(String[] args) {
        ConcreteNewsAgency agency = new ConcreteNewsAgency();

        // Создаём наблюдателей
        Observer subscriber1 = new NewsSubscriber("Alice");
        Observer subscriber2 = new NewsSubscriber("Bob");

        // Подписываем наблюдателей
        agency.addObserver(subscriber1);
        agency.addObserver(subscriber2);

        // Публикуем новости
        agency.setNews("Breaking News: Event X happened!");

        // Отписываем одного наблюдателя
        agency.removeObserver(subscriber1);

        // Публикуем ещё новости
        agency.setNews("Update: Event Y occurred!");
    }
}
```

**Вывод:**
```
New news published: Breaking News: Event X happened!
Alice received news: Breaking News: Event X happened!
Bob received news: Breaking News: Event X happened!
New news published: Update: Event Y occurred!
Bob received news: Update: Event Y occurred!
```

В примере:
- `Observer` — интерфейс наблюдателя с методом `update()`.
- `NewsAgency` — интерфейс субъекта.
- `ConcreteNewsAgency` — субъект, хранящий новости и уведомляющий подписчиков.
- `NewsSubscriber` — наблюдатель, реагирующий на новости.
- Клиент настраивает подписку и публикует новости.


--------------------------------------------------------------------------------------------------------------------
### Шаблон проектирования State

**State** — это поведенческий шаблон проектирования, который позволяет объекту изменять своё поведение в зависимости от внутреннего состояния, создавая впечатление, что объект меняет свой класс. Он инкапсулирует поведение, связанное с конкретным состоянием, в отдельные классы и делегирует выполнение действий текущему состоянию.

#### Основные компоненты:
1. **Context (Контекст)** — класс, который содержит состояние и предоставляет интерфейс для взаимодействия с клиентом.
2. **State (Состояние)** — интерфейс или абстрактный класс, определяющий методы для поведения в конкретных состояниях.
3. **ConcreteState (Конкретное состояние)** — классы, реализующие поведение для каждого состояния.
4. **Client (Клиент)** — код, взаимодействующий с контекстом, вызывая его методы.

#### Преимущества:
- Устраняет сложные условные операторы, связанные с состоянием.
- Инкапсулирует поведение, связанное с состоянием, в отдельных классах.
- Упрощает добавление новых состояний (принцип открытости/закрытости).
- Делает код более читаемым и поддерживаемым.

#### Недостатки:
- Увеличивает количество классов, что может усложнить структуру.
- Может быть избыточным для систем с небольшим количеством состояний.
- Требует управления переходами между состояниями.

---

### Пример на Java

Рассмотрим пример автомата по продаже кофе, который меняет поведение в зависимости от состояния (например, ожидание оплаты, приготовление кофе).

```java
// Интерфейс состояния
interface CoffeeMachineState {
    void insertMoney(CoffeeMachine machine);
    void selectDrink(CoffeeMachine machine);
    void dispense(CoffeeMachine machine);
}

// Контекст
class CoffeeMachine {
    private CoffeeMachineState state;
    private int money;

    public CoffeeMachine() {
        this.state = new WaitingForMoneyState();
        this.money = 0;
    }

    public void setState(CoffeeMachineState state) {
        this.state = state;
    }

    public void insertMoney(int amount) {
        money += amount;
        state.insertMoney(this);
    }

    public void selectDrink() {
        state.selectDrink(this);
    }

    public void dispense() {
        state.dispense(this);
    }

    public int getMoney() {
        return money;
    }

    public void setMoney(int money) {
        this.money = money;
    }
}

// Конкретное состояние: Ожидание денег
class WaitingForMoneyState implements CoffeeMachineState {
    @Override
    public void insertMoney(CoffeeMachine machine) {
        System.out.println("Money inserted: $" + machine.getMoney());
        machine.setState(new ReadyToSelectState());
    }

    @Override
    public void selectDrink(CoffeeMachine machine) {
        System.out.println("Please insert money first");
    }

    @Override
    public void dispense(CoffeeMachine machine) {
        System.out.println("Please insert money and select a drink");
    }
}

// Конкретное состояние: Готов к выбору напитка
class ReadyToSelectState implements CoffeeMachineState {
    @Override
    public void insertMoney(CoffeeMachine machine) {
        System.out.println("Additional money inserted: $" + machine.getMoney());
    }

    @Override
    public void selectDrink(CoffeeMachine machine) {
        if (machine.getMoney() >= 2) {
            System.out.println("Drink selected");
            machine.setState(new DispensingState());
        } else {
            System.out.println("Not enough money");
        }
    }

    @Override
    public void dispense(CoffeeMachine machine) {
        System.out.println("Please select a drink first");
    }
}

// Конкретное состояние: Выдача напитка
class DispensingState implements CoffeeMachineState {
    @Override
    public void insertMoney(CoffeeMachine machine) {
        System.out.println("Dispensing in progress, cannot accept money");
    }

    @Override
    public void selectDrink(CoffeeMachine machine) {
        System.out.println("Dispensing in progress, cannot select another drink");
    }

    @Override
    public void dispense(CoffeeMachine machine) {
        System.out.println("Dispensing coffee...");
        machine.setMoney(0);
        machine.setState(new WaitingForMoneyState());
    }
}

// Клиентский код
public class StateDemo {
    public static void main(String[] args) {
        CoffeeMachine machine = new CoffeeMachine();

        machine.insertMoney(1);
        machine.selectDrink(); // Not enough money
        machine.insertMoney(2);
        machine.selectDrink(); // Drink selected
        machine.dispense(); // Dispensing coffee...
        machine.selectDrink(); // Please insert money first
    }
}
```

**Вывод:**
```
Money inserted: $1
Not enough money
Additional money inserted: $3
Drink selected
Dispensing coffee...
Please insert money first
```

В примере:
- `CoffeeMachineState` — интерфейс состояния.
- `WaitingForMoneyState`, `ReadyToSelectState`, `DispensingState` — конкретные состояния с разным поведением.
- `CoffeeMachine` — контекст, делегирующий действия текущему состоянию.
- Клиент взаимодействует с машиной, вызывая методы в разных состояниях.

--------------------------------------------------------------------------------------------------------------------
### Шаблон проектирования Strategy

**Strategy** — это поведенческий шаблон проектирования, который позволяет определять семейство алгоритмов, инкапсулировать каждый из них и делать их взаимозаменяемыми. Он позволяет изменять поведение объекта во время выполнения, выбирая подходящий алгоритм.

#### Основные компоненты:
1. **Strategy (Стратегия)** — интерфейс или абстрактный класс, определяющий метод для выполнения алгоритма.
2. **ConcreteStrategy (Конкретная стратегия)** — классы, реализующие различные алгоритмы.
3. **Context (Контекст)** — класс, который использует стратегию и предоставляет интерфейс для клиента.
4. **Client (Клиент)** — код, создающий контекст и выбирающий стратегию.

#### Преимущества:
- Устраняет условные операторы, связанные с выбором алгоритма.
- Упрощает добавление новых алгоритмов (принцип открытости/закрытости).
- Снижает связанность между контекстом и алгоритмами.
- Позволяет динамически менять поведение.

#### Недостатки:
- Увеличивает количество классов.
- Клиент должен знать о доступных стратегиях.
- Может быть избыточным для простых сценариев.

### Пример на Java

Рассмотрим пример обработки платежей, где разные стратегии (кредитная карта, PayPal) используются для оплаты.

```java
// Интерфейс стратегии
interface PaymentStrategy {
    void pay(double amount);
}

// Конкретная стратегия: Кредитная карта
class CreditCardPayment implements PaymentStrategy {
    private String cardNumber;

    public CreditCardPayment(String cardNumber) {
        this.cardNumber = cardNumber;
    }

    @Override
    public void pay(double amount) {
        System.out.println("Paid $" + amount + " using Credit Card ending in " + cardNumber.substring(cardNumber.length() - 4));
    }
}

// Конкретная стратегия: PayPal
class PayPalPayment implements PaymentStrategy {
    private String email;

    public PayPalPayment(String email) {
        this.email = email;
    }

    @Override
    public void pay(double amount) {
        System.out.println("Paid $" + amount + " using PayPal account " + email);
    }
}

// Контекст
class PaymentContext {
    private PaymentStrategy strategy;

    public void setStrategy(PaymentStrategy strategy) {
        this.strategy = strategy;
    }

    public void processPayment(double amount) {
        if (strategy == null) {
            throw new IllegalStateException("Payment strategy not set");
        }
        strategy.pay(amount);
    }
}

// Клиентский код
public class StrategyDemo {
    public static void main(String[] args) {
        PaymentContext context = new PaymentContext();

        // Используем кредитную карту
        context.setStrategy(new CreditCardPayment("1234567890123456"));
        context.processPayment(100.0);

        // Переключаемся на PayPal
        context.setStrategy(new PayPalPayment("user@example.com"));
        context.processPayment(50.0);
    }
}
```

**Вывод:**
```
Paid $100.0 using Credit Card ending in 3456
Paid $50.0 using PayPal account user@example.com
```

В примере:
- `PaymentStrategy` — интерфейс стратегии.
- `CreditCardPayment` и `PayPalPayment` — конкретные стратегии.
- `PaymentContext` — контекст, использующий выбранную стратегию.
- Клиент переключает стратегии для обработки платежей.


--------------------------------------------------------------------------------------------------------------------
### Шаблон проектирования Template Method

**Template Method** — это поведенческий шаблон проектирования, который определяет общий алгоритм в базовом классе, позволяя подклассам переопределять отдельные шаги алгоритма без изменения его структуры. Он используется для создания шаблона выполнения задачи, где общая логика фиксирована, а детали реализации варьируются.

#### Основные компоненты:
1. **AbstractClass (Абстрактный класс)** — содержит шаблонный метод, определяющий скелет алгоритма, и абстрактные методы (или методы с реализацией по умолчанию), которые подклассы могут переопределять.
2. **ConcreteClass (Конкретный класс)** — подклассы, реализующие или переопределяющие абстрактные методы для выполнения специфичных шагов.
3. **Client (Клиент)** — код, использующий экземпляры конкретных классов для выполнения алгоритма.

#### Преимущества:
- Устраняет дублирование кода, вынося общую логику в базовый класс.
- Поддерживает принцип открытости/закрытости: новые подклассы могут изменять поведение без изменения шаблона.
- Обеспечивает единообразие выполнения алгоритма.

#### Недостатки:
- Ограничивает гибкость, так как структура алгоритма фиксирована.
- Может привести к созданию сложной иерархии классов.
- Зависимость от наследования может усложнить тестирование и поддержку.

### Пример на Java

Рассмотрим пример обработки данных, где разные классы используют общий алгоритм, но реализуют конкретные шаги обработки.

```java
// Абстрактный класс
abstract class DataProcessor {
    // Шаблонный метод
    public final void processData() {
        loadData();
        transformData();
        saveData();
    }

    // Общие шаги с реализацией по умолчанию
    protected void loadData() {
        System.out.println("Loading data...");
    }

    // Абстрактные шаги, которые должны быть реализованы подклассами
    protected abstract void transformData();

    // Шаг с реализацией по умолчанию, может быть переопределён
    protected void saveData() {
        System.out.println("Saving data...");
    }
}

// Конкретный класс: Обработка CSV
class CSVProcessor extends DataProcessor {
    @Override
    protected void transformData() {
        System.out.println("Transforming CSV data...");
    }

    @Override
    protected void saveData() {
        System.out.println("Saving CSV data to file...");
    }
}

// Конкретный класс: Обработка JSON
class JSONProcessor extends DataProcessor {
    @Override
    protected void transformData() {
        System.out.println("Transforming JSON data...");
    }
}

// Клиентский код
public class TemplateMethodDemo {
    public static void main(String[] args) {
        DataProcessor csvProcessor = new CSVProcessor();
        System.out.println("Processing CSV:");
        csvProcessor.processData();

        System.out.println("\nProcessing JSON:");
        DataProcessor jsonProcessor = new JSONProcessor();
        jsonProcessor.processData();
    }
}
```

**Вывод:**
```
Processing CSV:
Loading data...
Transforming CSV data...
Saving CSV data to file...

Processing JSON:
Loading data...
Transforming JSON data...
Saving data...
```

В примере:
- `DataProcessor` — абстрактный класс с шаблонным методом `processData()`, определяющим алгоритм.
- `loadData()` и `saveData()` — шаги с реализацией по умолчанию.
- `transformData()` — абстрактный метод, реализуемый подклассами.
- `CSVProcessor` и `JSONProcessor` — конкретные классы, реализующие или переопределяющие шаги.



--------------------------------------------------------------------------------------------------------------------
### Шаблон проектирования Visitor

**Visitor** — это поведенческий шаблон проектирования, который позволяет добавлять новые операции к объектам без изменения их классов. Он отделяет алгоритм от структуры данных, позволяя применять различные действия к элементам сложной структуры (например, дереву или коллекции).

#### Основные компоненты:
1. **Visitor (Посетитель)** — интерфейс, определяющий методы `visit` для каждого типа элемента в структуре.
2. **ConcreteVisitor (Конкретный посетитель)** — класс, реализующий методы `visit`, содержащий логику конкретной операции.
3. **Element (Элемент)** — интерфейс, определяющий метод `accept`, который принимает посетителя.
4. **ConcreteElement (Конкретный элемент)** — класс, реализующий метод `accept`, вызывающий соответствующий метод посетителя.
5. **ObjectStructure (Структура объектов)** — класс, содержащий коллекцию элементов, которые могут быть посещены.
6. **Client (Клиент)** — код, создающий структуру и применяющий посетителя.

#### Преимущества:
- Упрощает добавление новых операций без изменения классов элементов.
- Собирает связанные операции в одном классе (принцип единой ответственности).
- Поддерживает принцип открытости/закрытости.

#### Недостатки:
- Требует добавления нового метода в Visitor при добавлении нового типа элемента (нарушение открытости/закрытости для элементов).
- Усложняет код из-за дополнительных классов и интерфейсов.
- Может нарушить инкапсуляцию элементов, если посетителю нужен доступ к их внутренним данным.

### Пример на Java

Рассмотрим пример обработки фигур (круг, прямоугольник), где посетитель выполняет операции, такие как вычисление площади или периметра.

```java
// Интерфейс посетителя
interface ShapeVisitor {
    void visit(Circle circle);
    void visit(Rectangle rectangle);
}

// Интерфейс элемента
interface Shape {
    void accept(ShapeVisitor visitor);
}

// Конкретный элемент: Круг
class Circle implements Shape {
    private double radius;

    public Circle(double radius) {
        this.radius = radius;
    }

    public double getRadius() {
        return radius;
    }

    @Override
    public void accept(ShapeVisitor visitor) {
        visitor.visit(this);
    }
}

// Конкретный элемент: Прямоугольник
class Rectangle implements Shape {
    private double width;
    private double height;

    public Rectangle(double width, double height) {
        this.width = width;
        this.height = height;
    }

    public double getWidth() {
        return width;
    }

    public double getHeight() {
        return height;
    }

    @Override
    public void accept(ShapeVisitor visitor) {
        visitor.visit(this);
    }
}

// Конкретный посетитель: Вычисление площади
class AreaVisitor implements ShapeVisitor {
    private double totalArea;

    public double getTotalArea() {
        return totalArea;
    }

    @Override
    public void visit(Circle circle) {
        totalArea += Math.PI * circle.getRadius() * circle.getRadius();
        System.out.println("Circle area: " + (Math.PI * circle.getRadius() * circle.getRadius()));
    }

    @Override
    public void visit(Rectangle rectangle) {
        totalArea += rectangle.getWidth() * rectangle.getHeight();
        System.out.println("Rectangle area: " + (rectangle.getWidth() * rectangle.getHeight()));
    }
}

// Конкретный посетитель: Вычисление периметра
class PerimeterVisitor implements ShapeVisitor {
    private double totalPerimeter;

    public double getTotalPerimeter() {
        return totalPerimeter;
    }

    @Override
    public void visit(Circle circle) {
        totalPerimeter += 2 * Math.PI * circle.getRadius();
        System.out.println("Circle perimeter: " + (2 * Math.PI * circle.getRadius()));
    }

    @Override
    public void visit(Rectangle rectangle) {
        totalPerimeter += 2 * (rectangle.getWidth() + rectangle.getHeight());
        System.out.println("Rectangle perimeter: " + (2 * (rectangle.getWidth() + rectangle.getHeight())));
    }
}

// Структура объектов
class ShapeCollection {
    private List<Shape> shapes = new ArrayList<>();

    public void addShape(Shape shape) {
        shapes.add(shape);
    }

    public void accept(ShapeVisitor visitor) {
        for (Shape shape : shapes) {
            shape.accept(visitor);
        }
    }
}

// Клиентский код
public class VisitorDemo {
    public static void main(String[] args) {
        ShapeCollection collection = new ShapeCollection();
        collection.addShape(new Circle(5));
        collection.addShape(new Rectangle(4, 6));

        // Применяем посетителя для вычисления площади
        AreaVisitor areaVisitor = new AreaVisitor();
        System.out.println("Calculating areas:");
        collection.accept(areaVisitor);
        System.out.println("Total area: " + areaVisitor.getTotalArea());

        // Применяем посетителя для вычисления периметра
        PerimeterVisitor perimeterVisitor = new PerimeterVisitor();
        System.out.println("\nCalculating perimeters:");
        collection.accept(perimeterVisitor);
        System.out.println("Total perimeter: " + perimeterVisitor.getTotalPerimeter());
    }
}
```

**Вывод:**
```
Calculating areas:
Circle area: 78.53981633974483
Rectangle area: 24.0
Total area: 102.53981633974483

Calculating perimeters:
Circle perimeter: 31.41592653589793
Rectangle perimeter: 20.0
Total perimeter: 51.41592653589793
```

В примере:
- `ShapeVisitor` — интерфейс посетителя с методами для каждого типа фигуры.
- `Shape` — интерфейс элемента с методом `accept`.
- `Circle` и `Rectangle` — конкретные элементы.
- `AreaVisitor` и `PerimeterVisitor` — посетители, выполняющие разные операции.
- `ShapeCollection` — структура, содержащая элементы.
- Клиент применяет посетителей к коллекции фигур.


--------------------------------------------------------------------------------------------------------------------
### Какие есть Порождающие шаблоны проектирования в Spring Framework

### 1. Singleton (Одиночка)

**Описание**: Гарантирует единственный экземпляр класса с глобальной точкой доступа.

**Применение в Spring**:
Spring по умолчанию управляет бинами как синглтонами через `@Scope("singleton")`. Контейнер (`ApplicationContext`) создаёт и кэширует один экземпляр бина, возвращая его при каждом запросе.

**Как Spring реализует**:
- Контейнер хранит единственный экземпляр бина для повторного использования.

### 2. Factory Method (Фабричный метод)

**Описание**: Определяет интерфейс для создания объектов, позволяя подклассам выбирать конкретную реализацию.

**Применение в Spring**:
Spring использует `FactoryBean` для создания бинов с кастомной логикой. Например, `ProxyFactoryBean` генерирует прокси для AOP, а `DataSource` создаётся через фабричные методы.

**Как Spring реализует**:
- `FactoryBean` предоставляет метод `getObject()` для создания объектов с пользовательской логикой.


### 3. Abstract Factory (Абстрактная фабрика)

**Описание**: Создаёт семейства связанных объектов без указания их конкретных классов.

**Применение в Spring**:
`ApplicationContext` действует как абстрактная фабрика, создавая семейства связанных бинов. Например, Spring Data использует `JpaRepositoryFactory` для создания репозиториев.

**Как Spring реализует**:
- `BeanFactory` и `ApplicationContext` управляют созданием взаимосвязанных бинов.


### 4. Builder (Строитель)

**Описание**: Отделяет создание сложного объекта от его представления, позволяя настраивать объект пошагово.

**Применение в Spring**:
Spring использует Builder для конфигурации объектов, таких как `RestTemplate`, `WebClient` или `DataSource`. Например, `RestTemplateBuilder` позволяет задавать таймауты, перехватчики и другие параметры.

**Как Spring реализует**:
- Классы-строители (например, `RestTemplateBuilder`) предоставляют методы для пошаговой настройки.


### 5. Prototype (Прототип)

**Описание**: Создаёт новые объекты путём копирования существующего экземпляра.

**Применение в Spring**:
Spring поддерживает область видимости `@Scope("prototype")`, при которой каждый запрос бина создаёт новый экземпляр.

**Как Spring реализует**:
- Контейнер создаёт новый экземпляр бина при каждом вызове `getBean` для `prototype`-бин.


--------------------------------------------------------------------------------------------------------------------
### Структурные шаблоны проектирования в Spring Framework

Структурные шаблоны проектирования (Structural Patterns) решают задачи организации классов и объектов для формирования более сложных структур, обеспечивая гибкость и эффективность. В Spring Framework активно используются идеи структурных шаблонов, таких как **Adapter**, **Bridge**, **Composite**, **Decorator**, **Facade**, **Flyweight** и **Proxy**. Ниже приведены описания их применения в Spring с акцентом на механизмы фреймворка, без конкретных примеров кода, как указано.


### 1. Adapter (Адаптер)

**Описание**: Преобразует интерфейс одного класса в интерфейс, ожидаемый клиентом, позволяя несовместимым классам работать вместе.

**Применение в Spring**:
Spring использует Adapter для интеграции различных API и библиотек. Например, в Spring MVC адаптеры (`HandlerAdapter`) преобразуют разные типы контроллеров (например, `@Controller`, `HttpRequestHandler`) в единый интерфейс для обработки запросов.

**Как Spring реализует**:
- `HandlerAdapter` адаптирует контроллеры к внутренней логике `DispatcherServlet`.
- Spring Data адаптирует различные источники данных (JPA, MongoDB) к общему интерфейсу репозитория.


### 2. Bridge (Мост)

**Описание**: Отделяет абстракцию от её реализации, позволяя изменять их независимо.

**Применение в Spring**:
Spring применяет Bridge в таких механизмах, как `DataSource` и `TransactionManager`, где абстракция (например, интерфейс транзакций) отделена от конкретной реализации (JDBC, Hibernate).

**Как Spring реализует**:
- `PlatformTransactionManager` предоставляет абстракцию для управления транзакциями, а конкретные реализации (например, `JpaTransactionManager`, `DataSourceTransactionManager`) определяют детали.


### 3. Composite (Компоновщик)

**Описание**: Позволяет работать с группой объектов так же, как с единичным объектом, формируя древовидные структуры.

**Применение в Spring**:
Spring использует Composite в обработке конфигураций и контекстов. Например, `ApplicationContext` может быть иерархическим, где родительский и дочерние контексты образуют древовидную структуру.

**Как Spring реализует**:
- `HierarchicalBeanFactory` и `ApplicationContext` позволяют работать с бинами в родительских и дочерних контекстах как с единой структурой.


### 4. Decorator (Декоратор)

**Описание**: Динамически добавляет новое поведение или обязанности объекту, оборачивая его.

**Применение в Spring**:
Spring широко использует Decorator в AOP и кэшировании. Например, аннотация `@Cacheable` оборачивает методы дополнительной логикой кэширования, не изменяя их код.

**Как Spring реализует**:
- AOP-прокси (через CGLIB или JDK Dynamic Proxy) оборачивают целевые объекты для добавления аспектов (логирование, транзакции).
- `CacheInterceptor` добавляет поведение кэширования к методам.


### 5. Facade (Фасад)

**Описание**: Предоставляет упрощённый интерфейс к сложной подсистеме.

**Применение в Spring**:
Spring использует Facade для упрощения взаимодействия с подсистемами. Например, `DispatcherServlet` в Spring MVC выступает как фасад, скрывая детали обработки HTTP-запросов (маршрутизация, обработка контроллеров, рендеринг).

**Как Spring реализует**:
- `DispatcherServlet` координирует работу множества компонентов (HandlerMapping, HandlerAdapter, ViewResolver).
- `JdbcTemplate` предоставляет упрощённый интерфейс для работы с JDBC.


### 6. Flyweight (Легковес)

**Описание**: Разделяет неизменяемое состояние объектов, чтобы минимизировать использование памяти при работе с большим количеством объектов.

**Применение в Spring**:
Spring использует Flyweight в управлении бинами и их конфигурациями. Например, бины-синглтоны разделяют состояние, а аннотации и метаданные кэшируются для повторного использования.

**Как Spring реализует**:
- Метаданные бинов (например, `BeanDefinition`) хранятся в компактной форме и переиспользуются.
- `MessageSource` кэширует сообщения для интернационализации.


### 7. Proxy (Прокси)

**Описание**: Предоставляет суррогатный объект для контроля доступа к другому объекту.

**Применение в Spring**:
Spring активно использует Proxy для реализации AOP, транзакций и ленивой инициализации. Например, аннотация `@Transactional` создаёт прокси для управления транзакциями.

**Как Spring реализует**:
- JDK Dynamic Proxy и CGLIB создают прокси-объекты для добавления функциональности (транзакции, логирование).
- `@Lazy` создаёт прокси для откладывания инициализации бина.


--------------------------------------------------------------------------------------------------------------------
### Поведенческие шаблоны проектирования в Spring Framework

Поведенческие шаблоны проектирования (Behavioral Patterns) определяют взаимодействие между объектами, улучшая коммуникацию и разделение обязанностей. Spring Framework активно использует такие шаблоны, как **Chain of Responsibility**, **Command**, **Interpreter**, **Iterator**, **Mediator**, **Memento**, **Observer**, **State**, **Strategy**, **Template Method** и **Visitor**. Ниже приведены описания их применения в Spring с акцентом на механизмы фреймворка, без конкретных примеров кода, как указано.


### 1. Chain of Responsibility (Цепочка ответственности)

**Описание**: Передаёт запрос по цепочке обработчиков, пока один из них не обработает его.

**Применение в Spring**:
- В Spring Security цепочка фильтров (`SecurityFilterChain`) обрабатывает запросы последовательно, проверяя аутентификацию, авторизацию и другие аспекты.
- В Spring MVC `HandlerInterceptor` формирует цепочку для обработки запросов до и после выполнения контроллера.

**Как Spring реализует**:
- Фильтры вызывают `chain.doFilter()` для передачи управления следующему фильтру.
- Интерсепторы используют методы `preHandle`, `postHandle` и `afterCompletion`.



### 2. Command (Команда)

**Описание**: Инкапсулирует запрос в объект, поддерживая выполнение, отмену или очередь операций.

**Применение в Spring**:
- В Spring Batch шаги (`Step`) и задания (`Job`) инкапсулируют действия как команды.
- REST-контроллеры обрабатывают HTTP-запросы как команды, преобразуя их в DTO для выполнения бизнес-логики.

**Как Spring реализует**:
- `Job` в Spring Batch определяет последовательность выполнения шагов.
- DTO в REST API передают данные как команды для сервисного слоя.



### 3. Interpreter (Интерпретатор)

**Описание**: Определяет грамматику языка и интерпретирует выражения.

**Применение в Spring**:
- Spring Expression Language (SpEL) интерпретирует выражения, используемые в конфигурациях, аннотациях (`@Value`) и проверках безопасности (`@PreAuthorize`).

**Как Spring реализует**:
- `ExpressionParser` в SpEL разбирает и вычисляет выражения, такие как `#{bean.name}`.


### 4. Iterator (Итератор)

**Описание**: Предоставляет последовательный доступ к элементам коллекции, скрывая её реализацию.

**Применение в Spring**:
- Spring Data возвращает `Iterable` или `List` из репозиториев (например, `findAll()`).
- `ApplicationContext` позволяет обходить бины через `getBeansOfType`.

**Как Spring реализует**:
- Репозитории и методы контекста возвращают коллекции, поддерживающие `Iterator` и цикл `for-each`.


### 5. Mediator (Посредник)

**Описание**: Централизует взаимодействие между объектами через посредника.

**Применение в Spring**:
- `ApplicationEventPublisher` выступает как посредник, координируя события между публикатором и слушателями (`@EventListener`).
- В Spring Integration каналы (`MessageChannel`) управляют взаимодействием компонентов.

**Как Spring реализует**:
- События передаются через `publishEvent`, а каналы рассылают сообщения подписчикам.

### 6. Memento (Хранитель)

**Описание**: Сохраняет и восстанавливает состояние объекта без нарушения инкапсуляции.

**Применение в Spring**:
- Транзакции в Spring сохраняют состояние базы данных и откатывают его при сбоях.
- В Spring Batch состояние выполнения заданий (`JobExecution`) сохраняется для возобновления.

**Как Spring реализует**:
- `PlatformTransactionManager` управляет откатом транзакций.
- `JobRepository` хранит состояние заданий.

### 7. Observer (Наблюдатель)

**Описание**: Устанавливает подписку, где наблюдатели получают уведомления об изменениях субъекта.

**Применение в Spring**:
- Механизм событий (`ApplicationEvent` и `@EventListener`) позволяет компонентам реагировать на изменения.
- В Spring WebFlux реактивные потоки (`Flux`, `Mono`) используют модель подписки.

**Как Spring реализует**:
- `ApplicationEventPublisher` уведомляет слушателей о событиях.
- Реактивные операторы обрабатывают данные по подписке.


### 8. State (Состояние)

**Описание**: Позволяет объекту изменять поведение в зависимости от состояния.

**Применение в Spring**:
- Spring State Machine управляет состояниями и переходами в бизнес-процессах (например, заказы, оплаты).
- Spring Batch использует состояния для управления выполнением заданий.

**Как Spring реализует**:
- `StateMachine` определяет состояния и события для переходов.
- `JobExecution` отслеживает состояния заданий.


### 9. Strategy (Стратегия)

**Описание**: Определяет семейство алгоритмов, позволяя переключать их во время выполнения.

**Применение в Spring**:
- Spring Security использует разные стратегии аутентификации через `AuthenticationProvider`.
- Spring Data переключает реализации репозиториев (JPA, MongoDB) через конфигурацию.

**Как Spring реализует**:
- Инъекция зависимостей (`@Autowired` с `@Qualifier`) позволяет выбирать конкретную реализацию интерфейса.


### 10. Template Method (Шаблонный метод)

**Описание**: Определяет скелет алгоритма, позволяя подклассам переопределять шаги.

**Применение в Spring**:
- `JdbcTemplate` предоставляет общий алгоритм для SQL-запросов, где пользователь задаёт параметры.
- `RestTemplate` определяет шаблон для HTTP-запросов с кастомными обработчиками.

**Как Spring реализует**:
- Абстрактные классы (`AbstractController`, `AbstractStep`) фиксируют общую логику, позволяя переопределять детали.



### 11. Visitor (Посетитель)

**Описание**: Отделяет алгоритм от структуры данных, позволяя добавлять операции без изменения объектов.

**Применение в Spring**:
- Spring Expression Language (SpEL) использует Visitor для обхода AST-деревьев выражений.
- `BeanPostProcessor` "посещает" бины для выполнения дополнительных операций.

**Как Spring реализует**:
- SpEL применяет Visitor для обработки узлов выражений.
- `BeanPostProcessor` выполняет действия над бинами во время их инициализации.


--------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------