Что такое DRY principles?

DRY, Don't repeat yourself (не повторяй себя) - этот принцип настолько важен, что не требует повторения! Это принцип разработки программного обеспечения, нацеленный на снижение повторения информации различного рода, особенно в системах со множеством слоёв абстрагирования, простими словами НЕ пишите повторяющегося кода, используйте принцип абстракции, обобщая простые вещи в одном месте.

--------------------------------------------------------------------------------------------------------------------
Что такое KISS?

KISS, Keep it short and simple или Keep it simple, stupid (делайте вещи проще) - это принцип проектирования и программирования, запрещающий использование более сложных средств, чем необходимо. Принцип декларирует простоту системы в качестве основной цели и/или ценности.

--------------------------------------------------------------------------------------------------------------------
Что такое YAGNI?

YAGNI, You ain't gonna need it (Вам это не понадобится) - процесс и принцип проектирования ПО, при котором в качестве основной цели и/или ценности декларируется отказ от избыточной функциональности. Суть в том, чтобы реализовать только поставленные задачи и отказаться от избыточного функционала.

--------------------------------------------------------------------------------------------------------------------
Что такое Yoda conditions?

Yoda conditions (Условия Йоды в жаргоне программистов) - "безопасный" стиль записи выражений сравнения при программировании на языках с Си-синтаксисом, заключающийся в написании константного члена выражения (константы или вызова функции) слева от оператора сравнения (то есть 5 == a вместо привычного а == 5). Такой стиль призван предотвратить свойственную данным языкам ошибку - использование оператора присваивания "=" вместо сравнения "==". Ошибочное использование присваивания превращает нотацию Йоды в попытку изменить константу, вызывая ошибку на этапе компиляции, что исключает возможность появления в готовой программе ошибок данного вида, а также облегчает их поиск и исправление в новом коде.

--------------------------------------------------------------------------------------------------------------------
Что такое CRC cards?

CRC cards, Class-responsibility-collaboration card (Класс-Ответственность-Кооперация) - метод мозгового штурма, предназначенный для проектирования объектно-ориентированного программного обеспечения. Как правило, CRC-карты используются в тех случаях, когда сначала в процессе проектирования ПО определяются классы и способы их взаимодействий. CRC-карты акцентируют внимание дизайнера на сущности класса и скрывают от него детали, рассмотрение которых на данном этапе будет контрпродуктивным. CRC-карты также заставляют дизайнера воздержаться от назначения классу слишком многих обязанностей.

--------------------------------------------------------------------------------------------------------------------
Что такое SOLID?

SOLID — это акроним, образованный из заглавных букв первых пяти принципов ООП и проектирования. Принципы придумал Роберт Мартин в начале двухтысячных, а аббревиатуру позже ввел в обиход Майкл Фэзерс. Вот что входит в принципы SOLID:
Single Responsibility Principle (Принцип единственной ответственности).
Open Closed Principle (Принцип открытости/закрытости).
Liskov's Substitution Principle (Принцип подстановки Барбары Лисков).
Interface Segregation Principle (Принцип разделения интерфейса).
Dependency Inversion Principle (Принцип инверсии зависимостей).

--------------------------------------------------------------------------------------------------------------------
Расскажите про Single Responsibility Principle (Принцип единственной ответственности) и приведите пример.

Этот принцип кажется очень лёгким, но, как правило, его неправильно понимают. Казалось бы, всё понятно — каждый модуль, будь то класс, поле или микросервис — должен отвечать за что-то одно. Тут и кроется крамола. Такой принцип тоже есть, но непосредственно Принцип единственной ответственности — совсем о другом.

Сформулировать его можно так:
Модуль должен иметь только одну причину для изменения. Или: модуль должен отвечать только за одну заинтересованную группу.

Вот тут становится непонятно, поэтому мы обратимся к признанному первоисточнику — книге Роберта Мартина, у которого есть отличный пример на этот счёт. Воспользуемся им.

Предположим, что существует какая-то система, в которой ведётся учёт сотрудников. Сотрудники интересны как отделу кадров, так и бухгалтерии. Для их нужд, в числе прочих, в сервисе EmployeeService есть 2 метода:

fun calculateSalary(employeeId: Long): Double //рассчитывает зарплату сотрудника

fun calculateOvertimeHours(employeeId: Long): Double //рассчитывает сверхурочные часы

Методом расчёта зарплаты пользуется бухгалтерия. Методом расчёта сверхурочных часов пользуется отдел кадров.

Логично, что для расчёта зарплаты бухгалтерии может потребоваться учесть сверхурочные часы сотрудника. В таком случае, метод calculateSalary() может вызвать calculateOvertimeHours() и применить его результаты в своих формулах.

Окей, прошло полгода, и в отделе кадров решили поменять алгоритм расчёта сверхурочных. Предположим, раньше один сверхурочный час рассчитывается не по коэффициенту * 2, а стал — по коэффициенту * 2,5. Разработчик получил задание, изменил формулу, проверил, что всё работает, и успокоился. Город засыпает, просыпается бухгалтерия. А у бухгалтерии ничего не поменялось, они считают зарплаты по тем же формулам, вот только в этой формуле теперь будут другие цифры, потому что calculateSalary() ходит в calculateOvertimeHours(), а там теперь по просьбе отдела кадров сверхурочные не * 2, а * 2,5. Упс...

Теперь, если мы вернёмся к описанию принципа, всё станет намного понятнее.

Модуль должен иметь только одну причину для изменения. Эта причина, в нашем случае — потребности только отдела кадров, но не бухгалтерии. Модуль должен отвечать только за одну заинтересованную группу. calculateOvertimeHours() должен обрабатывать только одну группу — отдел кадров, несмотря на то, что он может показаться универсальным. Работа этого метода никаким образом не должна касаться бухгалтерии.

Теперь, я надеюсь, стало понятнее.

Каким может быть решение проблемы выше?Решений проблемы может быть несколько. Но что Вам точно будет необходимо сделать — это разделить функциональность в разные методы — например, calculateOvertimeHoursForAccounting() и calculateOvertimeHoursForHumanRelations(). Каждый из этих методов будет отвечать за свою заинтересованную группу и принцип единой ответственности не будет нарушен.

--------------------------------------------------------------------------------------------------------------------
Расскажите про Open Closed Principle (Принцип открытости/закрытости) и приведите пример.

Программные сущности должны быть открыты для расширения и закрыты для изменения.

Возьмём пример из суровой реальности.

У нас есть приложение, и, предположим, довольно неплохое. В нём есть сервис, который пользуется внешним сервисом. Предположим, это сервис котировок ЦБ РФ. В простой реализации архитектура этого сервиса будет выглядеть следующим образом:

Financial Quotes Controller
(запрашивает котировки)
|
\/
Financial Quotes Service
(обрабатывает котировки)
|
\/
Financial Quotes Rest Service
(ходит в ЦБ РФ по API)

Вроде всё неплохо, но проект пора отдавать на интеграционное тестирование, и нам нужно отключить запросы в ЦБ. Как бы мы ни попытались решить эту проблему, нам будет необходимо изменить текущую реализацию FinancialQuotesRestService так, чтобы она не отправляла больше запросы. Но в чистой архитектуре такой подход недопустим, поскольку нарушается Принцип открытости-закрытости — старый код не должен меняться.

Как решить проблему и сделать так, чтобы при добавлении новой реализации не трогать старый код?

Конечно же, через интерфейсы. Стоит нам разделить объявление функциональности и её реализацию, как эта проблема будет решена. Теперь мы можем реализовать интерфейс FinancialQuotesRestService сколько угодно раз; в нашем случае, это будет FinancialQuotesRestServiceImpl и FinancialQuotesRestServiceMock. На тестовом стенде приложение будет запускаться по Mock-профилю, на продакшене оно будет запускаться в обычном режиме.

Financial Quotes Controller
(запрашивает котировки)
|
\/
Financial Quotes Service
(обрабатывает котировки)
|
\/
Financial Quotes Rest Service<I>
|
\/
FinancialQuotesRestServicelmpl FinancialQuotesRestServiceMock


Далее, если мы захотим добавить ещё одну реализацию, нам не придётся менять существующий код. Например, мы хотим добавить получение котировок не ЦБ, а в некоторых случаях Сбербанка. Нет ничего проще:


Financial Quotes Controller
(запрашивает котировки)
|
\/
Financial Quotes Service
(обрабатывает котировки)
|
\/
Financial Quotes Rest Service<I>
|
\/
FinancialQuotesRestServicelmpl FinancialQuotesRestServiceMock
FinancialQuotesRestServiceSber

Мы добавили новую функциональность, но прежние две затронуты не были. Даже если команда разработчиков полностью обновится и приложение будут разрабатывать совсем другие программисты, им не придётся трогать старый код. Таким образом, достигается главная цель Принципа Открытости-Закрытости — сделать систему легко расширяемой и обезопасить её от влияния изменений.

--------------------------------------------------------------------------------------------------------------------
Расскажите про Liskov's Substitution Principle (Принцип подстановки Барбары Лисков) и приведите пример.

Принцип подстановки Барбары Лисков можно сформулировать так:Для создания взаимозаменяемых частей эти части должны соответствовать контракту, который позволяет заменять эти части друг другом.

В той реализации, которую мы разбирали, интерфейс FinancialQuotesRestService как раз и является таким контрактом, который декларирует функциональность всех своих реализаций. Предположим, интерфейс выглядит так:

public interface FinancialQuotesRestService {
List<Quote> getQuotes();
}

В данном контракте прописано, что в используемом интерфейсе используется метод getQuotes, который не принимает аргументы, возвращая при этом список котировок. И это всё, что нужно знать классам, которые будут его использовать.В нашем случае, контроллер будет выглядеть так:

@RestController("/quotes")
@RequiredArgsConstructor
public class FinancialQuotesController {
private final FinancialQuotesRestService service;

@GetMapping public ResponseEntity<List<Quote>> getQuotes() {
return ResponseEntity.ok(service.getQuotes());
}
}

Как мы видим, контроллер не знает, какая именно реализация будет реализована далее. Получит ли он котировки ЦБ, Сбербанка или просто моковые данные. Мы можем запустить приложение в любом режиме, и от этого работа контроллера не изменится.В этом и есть смысл Принципа подстановки Барбары Лисков. Любой компонент системы должен работать с компонентами, от которых он зависит, через неизменяемый контракт.

--------------------------------------------------------------------------------------------------------------------
Расскажите про Interface Segregation Principle (Принцип разделения интерфейса) и приведите пример.

Необходимо избегать зависимости от того, что не используется.Например, мы решили реализовать CRUD-интерфейс, который будет поддерживать операции CRUD. И реализовать его во всех сервисах. Выглядеть интерфейс может так:

public interface CrudService<T> {
T create(T t);
T update(T t);
T get(Long id);
void delete(Long id);
}

Окей, мы реализовали его в сервисе UserService
Далее, нам потребовалось реализовать класс PersonService, который мы тоже наследуем от CrudService. Но проблема в том, что сущности Person — не удаляемые, и нам не нужна реализация метода delete(). Как быть?

Выделить реализацию CRUD без удаления в отдельный интерфейс. Например, так:

public interface CruService<T> {
T create(T t);
T update(T t);
T get(Long id);
}

Теперь сущность Person нельзя удалить! PersonService реализует интерфейс, в котором не объявлено ничего лишнего. В этом и есть соблюдение Принципа разделения интерфейсов.

--------------------------------------------------------------------------------------------------------------------
Расскажите про Dependency Inversion Principle (Принцип инверсии зависимостей) и приведите пример.

Код, реализующий высокоуровневую политику, не должен зависеть от кода, реализующего низкоуровневые детали. Зависимости должны быть направлены на абстракции, а не на реализации.

Связи должны строиться на основе абстракций. Если вы вызываете какой-то сервис (например, автовайрите его), Вы должны вызывать его интерфейс, а не реализацию.

Не ссылайтесь на изменчивые конкретные классы. Не наследуйте изменчивые конкретные классы. Не переопределяйте конкретные методы. Это методы часто сами зависят от других классов. Переопределяя такие методы, вы фактически наследуете эти зависимости. Вместо этого, реализуйте абатрактный метод в интерфейсе и переопределите его. Всё, что уже имеет реализацию, не должно быть переопределено. Иными словами, не стройте зависимостей от всего, что может измениться.

В общем, Принцип инверсии зависимости можно постулировать так:
Абстракции стабильны. Реализации нестабильны. Строить зависимости необходимо на основе стабильных компонентов. Стройте зависимости от абстракций. Не стройте их от реализаций.

--------------------------------------------------------------------------------------------------------------------