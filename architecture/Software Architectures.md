Зачем нужна архитектура ПО?

Первые разработчики создавали программное обеспечение без архитектуры. Сначала это казалось удобным: никаких издержек, связанных с планированием, и ускоренное прототипирование. Но мере усложнения ПО теряло гибкость и управляемость, а каждое новое изменение обходилось все дороже. Это мешало развивать проект за границы, определенные изначально. Такая система получила название Большой комок грязи (Big Ball of Mud).
За годы развития ПО разработчикам удалось придумать надежные подходы, чтобы устранить недостатки проектирования без архитектуры.
Ниже представлены некоторые из самых известных.

Многослойная архитектура (Layered Architecture).
Многоуровневая архитектура (Tiered Architecture).
Сервис-ориентированная архитектура (Service Oriented Architecture — SOA).
Микросервисная архитектура (Microservice Architecture).

--------------------------------------------------------------------------------------------------------------------
Что такое Трёхуровневая архитектура?

Трёхуровневая архитектура (3-Tier) разбивает приложение на 3 логических уровня (слоя).
Чаще всего используется для клиент-серверных приложений.

Трёхуровневая архитектура позволяет разрабатывать и размещать каждый уровень отдельно от остальных. Это делает приложение более масштабируемым, поскольку каждый уровень развивается и функционирует относительно независимо от других. Разбиение на уровни позволяет также нанимать узкоспециализированных специалистов (дизайнеры, верстальщики, бэкендеры, тестировщики бэкенда, DevOps), которые будут быстро и качественно выполнять свою часть работы.

Уровни
Уровень представления (Presentation Tier) содержит пользовательский интерфейс (UI). Соответствует фронтенд (HTML, JS, CSS, фреймворки и прочее).

Уровень приложения (Application Tier) содержит бизнес-логику приложения. Соответствует бэкенду (Node.js, .NET, Java и прочее).

Уровень данных (Data Tier) включает в себя базу данных или другую систему хранения данных, а также уровень доступа к данным (data access layer). Примеры: MySQL, MongoDB, DynamoDB и прочие.

Уровни общаются между собой при помощи API-запросов.

--------------------------------------------------------------------------------------------------------------------
Что такое монолитная архитектура?

Монолитная архитектура — это традиционная модель программного обеспечения, которая представляет собой единый модуль, работающий автономно и независимо от других приложений. Монолитом часто называют нечто большое и неповоротливое, и эти два слова хорошо описывают монолитную архитектуру для проектирования ПО. Монолитная архитектура — это отдельная большая вычислительная сеть с единой базой кода, в которой объединены все бизнес-задачи. Чтобы внести изменения в такое приложение, необходимо обновить весь стек через базу кода, а также создать и развернуть обновленную версию интерфейса, находящегося на стороне службы. Это ограничивает работу с обновлениями и требует много времени.

--------------------------------------------------------------------------------------------------------------------
Преимущества монолитной архитектуры

Организации могут извлечь выгоду как из монолитной архитектуры, так и из микросервисной в зависимости от ряда различных факторов. При использовании монолитной архитектуры удобно создавать приложения на основе одной базы кода, поэтому ее основное преимущество заключается в быстроте разработки.
К преимуществам монолитной архитектуры можно отнести следующие особенности.

Простое развертывание. Использование одного исполняемого файла или каталога упрощает развертывание.

Разработка. Приложение легче разрабатывать, когда оно создано с использованием одной базы кода.

Производительность. В централизованной базе кода и репозитории один интерфейс API часто может выполнять ту функцию, которую при работе с микросервисами выполняют многочисленные API.

Упрощенное тестирование. Монолитное приложение представляет собой единый централизованный модуль, поэтому сквозное тестирование можно проводить быстрее, чем при использовании распределенного приложения.

Удобная отладка. Весь код находится в одном месте, благодаря чему становится легче выполнять запросы и находить проблемы.

--------------------------------------------------------------------------------------------------------------------
Недостатки монолитной архитектуры

Как и в случае с Netflix, монолитные приложения работают достаточно эффективно до тех пор, пока они не становятся слишком большими и не вызывают проблем с масштабированием. Чтобы внести небольшое изменение в одну функцию, необходимо выполнить компиляцию и тестирование всей платформы, что противоречит agile-подходу, которому отдают предпочтение современные разработчики.
К недостаткам монолитной архитектуры можно отнести следующие особенности.

Снижение скорости разработки. Большое монолитное приложение усложняет и замедляет разработку.

Масштабируемость. Невозможно масштабировать отдельные компоненты.

Надежность. Ошибка в одном модуле может повлиять на доступность всего приложения.

Препятствия для внедрения технологий. Любые изменения в инфраструктуре или языке разработки влияют на приложение целиком, что зачастую приводит к увеличению стоимости и временных затрат.

Недостаточная гибкость. Возможности монолитных приложений ограничены используемыми технологиями.

Развертывание. При внесении небольшого изменения потребуется повторное развертывание всего монолитного приложения.

--------------------------------------------------------------------------------------------------------------------
Что такое микросервисы?

Микросервисная архитектура (или просто «микросервисы») представляет собой метод организации архитектуры, основанный на ряде независимо развертываемых служб. У этих служб есть собственная бизнес-логика и база данных с конкретной целью. Обновление, тестирование, развертывание и масштабирование выполняются внутри каждой службы. Микросервисы разбивают крупные задачи, характерные для конкретного бизнеса, на несколько независимых баз кода. Микросервисы не снижают сложность, но они делают любую сложность видимой и более управляемой, разделяя задачи на более мелкие процессы, которые функционируют независимо друг от друга и вносят вклад в общее целое.

--------------------------------------------------------------------------------------------------------------------
Каковы преимущества и недостатки архитектуры микросервисов?

Преимущества микросервисов:
Гибкость: Архитектура микросервисов обеспечивает гибкость с точки зрения выбора технологии, поскольку каждая служба может быть реализована с
использованием различных языков, фреймворков и баз данных. Например, вы можете реализовать одни микросервисы на Java, а другие - на C++ или Python.

Масштабируемость: Микросервисы могут масштабироваться независимо, что позволяет лучше использовать ресурсы и быстрее масштабировать систему в целом. Благодаря облачным вычислениям Kubernetes может очень легко масштабировать микросервисы в зависимости от нагрузки.

Устойчивость: Архитектура микросервисов позволяет создавать более отказоустойчивые системы, поскольку сбой в одной службе может быть изолирован и обработан без ущерба для всей системы.

Гибкость: Архитектура микросервисов обеспечивает более быстрые циклы разработки и развёртывания, поскольку изменения могут быть внесены в одну службу без ущерба для всей системы.

Возможность повторного использования: Микросервисы можно повторно использовать в нескольких приложениях, что может привести к экономии средств и повышению эффективности.

Недостатки микросервисов:
Сложность: Архитектура микросервисов может увеличить сложность системы, поскольку в ней больше движущихся частей и больше взаимодействий между службами.

Тестирование и отладка: Тестирование и отладка архитектуры микросервисов может быть более сложной задачей, поскольку для этого требуется тестирование каждой службы в отдельности, а также тестирование их взаимодействия.

Мониторинг и управление: Архитектура микросервисов требует большего мониторинга и управления, поскольку существует больше сервисов для отслеживания и управления ими.

Межсервисная связь: Архитектура микросервисов увеличивает количество сетевых вызовов между службами, что может привести к увеличению задержки, а при неправильной обработке - к каскадным сбоям.

Безопасность: Архитектура микросервисов может усложнить внедрение мер безопасности, поскольку каждая служба может нуждаться в индивидуальной защите.

--------------------------------------------------------------------------------------------------------------------
Каковы ключевые характеристики хорошо спроектированного микросервиса?

Хорошо спроектированные микросервисы имеют чёткие, единые обязанности; обладают высокой связностью; взаимодействуют через API; имеют ограниченный контекст и могут независимо развёртываться, тестироваться и масштабироваться.

--------------------------------------------------------------------------------------------------------------------
Как спроектировать и внедрить микросервисы?

Вы можете использовать любой фреймворк для разработки микросервисов на любом языке программирования, но в Java вы можете использовать фреймворки Spring Boot и Spring Cloud.

--------------------------------------------------------------------------------------------------------------------
Что такое архитектурный шаблон?

Архитектурный шаблон — это общее и повторяющееся решение часто возникающей проблемы архитектуры приложений в пределах заданного контекста. Архитектурные шаблоны схожи с шаблонами программного дизайна, однако имеют более широкий охват.

--------------------------------------------------------------------------------------------------------------------
Расскажите про Многоуровневый шаблон

Данный шаблон используется для структурирования программ, которые можно разложить на группы неких подзадач, находящихся на определенных уровнях абстракции. Каждый слой предоставляет службы для следующего, более высокого слоя.
Чаще всего в общих информационных системах встречаются следующие 4 слоя:

· Слой представления (также известен как слой пользовательского интерфейса)

· Слой приложения (также известен как слой сервиса)

· Слой бизнес-логики (также известен как уровень предметной области)

· Слой доступа к данным (также известен как уровень хранения данных)

Использование
· Общие десктопные приложения.
· Веб-приложения e-commerce.

Плюсы:
Одним низким слоем могут пользоваться разные слои более высокого ранга.
Слои упрощают стандартизацию, т.к. мы четко определяем уровни.
Изменения вносятся внутри какого-то одного слоя, при этом остальные слои остаются неизменными.

Минусы:
Не универсален.
В ряде ситуаций возможен пропуск некоторых слоев.

--------------------------------------------------------------------------------------------------------------------
Расскажите про Клиент-серверный шаблон

Данный шаблон состоит из двух частей: сервера и множества клиентов. Серверный компонент предоставляет службы клиентским компонентам. Клиенты запрашивают услуги у сервера, а он, в свою очередь, оказывает эти самые услуги клиентам. Более того, сервер продолжает «подслушивать» клиентские запросы.
Использование
· Онлайн приложения (электронная почта, совместный доступ к документам, банковские услуги).

Плюсы:
Подходит для моделирования набор служб, которые смогут запрашивать клиенты.

Минусы:
Запросы обычно выполняются в отдельных потоках на сервере.
Взаимодействие между процессами повышает ресурсозатратность, т.к. разные клиенты имеют разное представление.

--------------------------------------------------------------------------------------------------------------------
Расскажите про Ведущий-ведомый

В этом шаблоне также задействованы два участника — ведущий и ведомые. Ведущий компонент распределяет задачи среди идентичных ведомых компонентов и вычисляет итоговый результат на основании результатов, полученных от своих «подчиненных».
Использование
· В репликации баз данных. Там главная БД считается авторитетным источником, а подчиненные базы с ней синхронизируются.
· Периферийные устройства, подключенные к шине в компьютере (ведущие и ведомые устройства).

Плюсы:
Точность, т.к. выполнение службы делегируется разным ведомым с разной реализацией.

Минусы:
Все ведомые изолированы, у них отсутствует общее состояние.
Период ожидания в коммуникации «ведущий-ведомый» — это значительный минус. Например, в системах реального времени.
Подходит только для тех проблем, решение которых можно разложить на части.

--------------------------------------------------------------------------------------------------------------------
Расскажите про Каналы и фильтры

Этот шаблон подходит для систем, которые производят и обрабатывают потоки данных. Каждый этап обработки происходит внутри некоего компонента фильтра. Данные для обработки передаются через каналы. Эти каналы можно использовать для буферизации или синхронизации данных.
Использование
· Компиляторы. Последовательные фильтры выполняют лексический, синтаксический, семантический анализ и создание кода.
· Рабочие процессы в биоинформатике.

Плюсы:
Могут реализовывать параллельные процессы, когда вход и выход состоит из потоков, а фильтры начинают вычисления после получения данных.
Простое добавление фильтров. Систему можно легко расширить.
Фильтры подходят для повторного использования. Могут выстраивать различные конвейеры, создавая всевозможные комбинации существующего набора фильтров.

Минусы:
Эффективность снижается из-за самых медленных процессов фильтрации. При переходе от одного фильтра к другому выполняется трансформация данных, которая ведет к повышенному потреблению ресурсов.

--------------------------------------------------------------------------------------------------------------------
Расскажите про Шаблон посредника

Данный шаблон нужен для структуризации распределенных систем с несвязными компонентами. Эти компоненты могут взаимодействовать друг с другом через удаленный вызов службы. Компонент посредник отвечает за координацию взаимодействия компонентов.
Сервер размещает свои возможности (службы и характеристики) у посредника (брокера). Клиент запрашивает услугу у брокера. Затем брокер перенаправляет клиента к подходящей службе из своего реестра.
Использование
· Брокеры сообщений по типу Apache ActiveMQ, Apache Kafka, RabbitMQ и JBoss Messaging.

Плюсы:
Возможно динамическое изменение, добавление, удаление и перемещение объектов. Этот шаблон делает процесс распределения прозрачным для разработчика.

Минусы:
Необходима стандартизация описаний служб.

--------------------------------------------------------------------------------------------------------------------
Расскажите про Одноранговый шаблон

В данном шаблоне существуют отдельные компоненты, так называемые пиры. Пиры могут выступать в роли как клиента, запрашивающего услуги от других равноправных участников (пиров), так и сервера, предоставляющего услуги другим пирам. Пир может быть клиентом или сервером, или всем сразу, а также способен со временем динамически изменять свою роль.
Использование
· Файлообменные сети (Gnutella и G2)
· Мультимедийные протоколы (P2PTV и PDTP)
· Проприетарные мультимедийные приложения (как тот же Spotify).

Плюсы:
Поддерживает децентрализованные вычисления. Крайне устойчив к сбоям в любом узле.
Высокая масштабируемость по части ресурсной и вычислительной мощности.

Минусы:
Отсутствует гарантия качества служб, т.к. узлы кооперируются стихийно.
Трудно гарантировать защищенность.
Производительность зависит от количества узлов.

--------------------------------------------------------------------------------------------------------------------
Расскажите про Шина событий

Этот шаблон, в основном, взаимодействует с событиями и состоит из 4 главных компонентов: источник события, прослушиватель события, канал и шина событий. Источники размещают сообщения для определенных каналов на шине событий. Прослушиватели подписываются на определенные каналы. Прослушиватели получают уведомления о появлении сообщений, размещенных на каналах из их подписки.
Использование
· Разработки на Android
· Сервисы уведомлений

Плюсы:
Простое добавление новых подписчиков, издателей и связей. Хорошо зарекомендовал себя для сильно распределенных приложений.

Минусы:
Проблема с масштабируемостью, т.к. все сообщения проходят через одну шину событий.

--------------------------------------------------------------------------------------------------------------------
Расскажите про Модель-представление-контроллер

Этот шаблон также известен как MVC-шаблон. Он разделяет интерактивные прикладные программы на 3 части:
1. модель — содержит ключевые данные и функционал;
2. представление — показывает информацию пользователю (можно задавать более одного представления);
3. контроллер — занимается обработкой данных от пользователя.
   Это делается с целью разграничения внутреннего представления информации от способов ее представления и принятия от пользователя. Данная схема изолирует компоненты и позволяет эффективно реализовать повторное использование кода.
   Использование
   · Архитектура WWW-приложений, написанных на основных языках программирования.
   · Веб-фреймворки (например, Django и Rails)

Плюсы:
Упрощает создание различных представлений одной и той же модели; их можно включить или отключить на этапе выполнения.

Минусы:
Возрастает сложность алгоритма. Может привести ко многим ненужным корректировкам действий пользователей.

--------------------------------------------------------------------------------------------------------------------
Расскажите про шаблон Доска

Такой шаблон подходит для проблем, для которых отсутствуют четкие детерминированные решения. Шаблон «Доска» состоит из 3 главных компонентов:
· доска — это структурированная глобальная память, содержащая объекты из пространства возможных решений;
· источник знания — специализированные модули со своим собственным представлением;
· компоненты управления — выбирает, настраивает и исполняет модули.
Все компоненты имеют доступ к доске. Компоненты могут производить новые объекты данных, которые добавляются к доске. Компоненты ищут на доске конкретные виды данных. Одним из способов поиска является сопоставление шаблонов с существующим источником знаний.
Использование
· распознавание речи;
· идентификация и отслеживание транспортных средств;
· определение структур белка;
· интерпретация сигналов Sonar.

Плюсы:
Легкое добавление новых приложений.
Можно без труда расширять структуры пространства данных.

Минусы:
Редактировать структуры данных действительно трудно, т.к. такие изменения затрагивают все приложения.
Могут потребоваться синхронизация и управление доступом.

--------------------------------------------------------------------------------------------------------------------
Расскажите про шаблон Интерпретатор

Он подходит для разработки компонента, который должен интерпретировать программы, написанные на специальном языке программирования. В основном, там расписано, как вычислять строки (иначе говоря: «предложения» или «выражения»), написанные на каком-то определенном языке программирования. Суть в том, чтобы присвоить класс каждому символу языка.
Использование
· языки запросов к базе данных (SQL);
· языки, которые используются для описания протоколов передачи данных.

Плюсы:
Возможно высокодинамичное поведение.
Отличное решение для конечных пользователей с точки зрения удобства программирования.

Минусы:
Проблемы с производительностью, т.к. интерпретированный язык медленнее скомпилированного.

--------------------------------------------------------------------------------------------------------------------
Что такое Приложение двенадцати факторов?

это методология для создания SaaS-приложений, которые:

Используют декларативный формат для описания процесса установки и настройки, что сводит к минимуму затраты времени и ресурсов для новых разработчиков, подключенных к проекту;

Имеют соглашение с операционной системой, предполагающее максимальную переносимость между средами выполнения;

Подходят для развертывания на современных облачных платформах, устраняя необходимость в серверах и системном администрировании;

Сводят к минимуму расхождения между средой разработки и средой выполнения, что позволяет использовать непрерывное развертывание (continuous deployment) для максимальной гибкости;

И могут масштабироваться без существенных изменений в инструментах, архитектуре и практике разработки.

--------------------------------------------------------------------------------------------------------------------
Двенадцать факторов кратко?

I. Кодовая база. Одна кодовая база, отслеживаемая в системе контроля версий, - множество развертываний
II. Зависимости. Явно объявляйте и изолируйте зависимости
III. Конфигурация. Сохраняйте конфигурацию в среде выполнения
IV. Сторонние службы (Backing Services)Считайте сторонние службы (backing services) подключаемыми ресурсами
V. Сборка, релиз, выполнение. Строго разделяйте стадии сборки и выполнения
VI. Процессы. Запускайте приложение как один или несколько процессов не сохраняющих внутреннее состояние (stateless)
VII. Привязка портов (port binding)Экспортируйте сервисы через привязку портов
VIII. Параллелизм. Масштабируйте приложение с помощью процессов
IX. Одноразовость (Disposability). Максимизируйте надежность с помощью быстрого запуска и корректного завершения работы
X. Паритет разработки/работы приложения. Держите окружения разработки, промежуточного развёртывания (staging) и рабочего развёртывания (production) максимально похожими
XI. Журналирование (Logs). Рассматривайте журнал как поток событий
XII. Задачи администрирования. Выполняйте задачи администрирования/управления с помощью разовых процессов

--------------------------------------------------------------------------------------------------------------------
Расскажите про Кодовая база в приложении двенадцати факторов

Одна кодовая база, отслеживаемая в системе контроля версий, - множество развертываний

Приложение двенадцати факторов всегда отслеживается в системе контроля версий, такой как Git,Mercurial или Subversion. Копия базы данных отслеживаемых версий называется репозиторием кода (code repository), что часто сокращается до code repo или просто до репозиторий (repo)

Кодовая база- это один репозиторий (в централизованных системах контроля версий, как Subvertion) или множество репозиториев, имеющих общие начальные коммиты (в децентрализованных системах контроля версий, как Git).

Всегда есть однозначное соответствие между кодовой базой и приложением:

Если есть несколько кодовых баз, то это не приложение — это распределенная система. Каждый компонент в распределенной системе является приложением и каждый компонент может индивидуально соответствовать двенадцати факторам.

Факт того, что несколько приложений совместно используют тот же самый код, является нарушением двенадцати факторов. Решением в данной ситуации является выделение общего кода в библиотеки, которые могут быть подключены через менеджер зависимостей.

Существует только одна кодовая база для каждого приложения, но может быть множество развёртываний одного и того же приложения.Развёрнутым приложением (deploy)является запущенный экземпляр приложения. Как правило, это рабочее развёртывание сайта и одно или несколько промежуточных развёртываний сайта. Кроме того каждый разработчик имеет копию приложения, запущенного в его локальном окружении разработки, каждая из которых также квалифицируется как развёрнутое приложение (deploy).

Кодовая база обязана быть единой для всех развёртываний, однако разные версии одной кодовой базы могут выполняться в каждом из развертываний. Например разработчик может иметь некоторые изменения которые еще не добавлены в промежуточное развёртывание; промежуточное развёртывание может иметь некоторые изменения, которые еще не добавлены в рабочее развёртывание. Однако, все эти развёртывания используют одну и ту же кодовую базу, таким образом можно их идентифицировать как разные развертывания одного и того же приложения.

--------------------------------------------------------------------------------------------------------------------
Расскажите про Зависимости в приложении двенадцати факторов

Явно объявляйте и изолируйте зависимости

Большинство языков программирования поставляются вместе с менеджером пакетов для распространения библиотек, таким как CPAN в Perl или Rubygems в Ruby. Библиотеки, устанавливаемые менеджером пакетов, могут быть установлены доступными для всей системы (так называемые "системные пакеты") или доступными только приложению в директорию содержащую приложение (так называемые "vendoring" и "bundling").

Приложение двенадцати факторов никогда не зависит от неявно существующих, доступных всей системе пакетов.Приложение объявляет все свои зависимости полностью и точно с помощью манифеста декларации зависимостей. Кроме того, оно использует инструмент изоляции зависимостей во время выполнения для обеспечения того, что неявные зависимости не "просочились" из окружающей системы. Полная и явная спецификация зависимостей применяется равным образом как при разработке, так и при работе приложения.

Например,Gem Bundler в Ruby использует Gemfile как формат манифеста для объявления зависимостей иbundle exec- для изоляции зависимостей. Python имеет два различных инструмента для этих задач:Pip используется для объявления и Virtualenv- для изоляции. Даже C имеет Autoconf для объявления зависимостей, и статическое связывание может обеспечить изоляцию зависимостей. Независимо от того, какой набор инструментов используется, объявление и изоляция зависимостей должны всегда использоваться совместно - только одного из них недостаточно, чтобы удовлетворить двенадцати факторам.

Одним из преимуществ явного объявления зависимостей является то, что это упрощает настройку приложения для новых разработчиков. Новый разработчик может скопировать кодовую базу приложения на свою машину, необходимыми требованиями для которой являются только наличие среды выполнения языка и менеджера пакетов. Всё необходимое для запуска кода приложения может быть настроено с помощью определённой команды настройки. Например, для Ruby/Bundler командой настройки является bundle install, для Clojure/Leiningen это lein deps.

Приложение двенадцати факторов также не полагается на неявное существование любых инструментов системы.
Примером является запуск программ ImageMagick иcurl. Хотя эти инструменты могут присутствовать во многих или даже в большинстве систем, нет никакой гарантии, что они будут присутствовать на всех системах, где приложение может работать в будущем, или будет ли версия найденная в другой системе совместима с приложением. Если приложению необходимо запустить инструмент системы, то этот инструмент должен быть включен в приложение.

--------------------------------------------------------------------------------------------------------------------
Расскажите про Конфигурация в приложении двенадцати факторов

Сохраняйте конфигурацию в среде выполнения
Конфигурация приложения - это все, что может меняться между развёртываниями(среда разработки, промежуточное и рабочее развёртывание). Это включает в себя:

Идентификаторы подключения к ресурсам типа базы данных, кэш-памяти и другим сторонним службам

Регистрационные данные для подключения к внешним сервисам, например, к Amazon S3 или Twitter

Значения зависимые от среды развёртывания такие, как каноническое имя хоста

Иногда приложения хранят конфигурации как константы в коде. Это нарушение методологии двенадцати факторов, которая требует строгого разделения конфигурации и кода. Конфигурация может существенно различаться между развертываниями, код не должен различаться.

Лакмусовой бумажкой того, правильно ли разделены конфигурация и код приложения, является факт того, что кодовая база приложения может быть в любой момент открыта в свободный доступ без компрометации каких-либо приватных данных.

Обратите внимание, что это определение "конфигурации"не включает внутренние конфигурации приложения, например такие как 'config/routes.rb' в Rails, или того как основные модули будут связаны в Spring. Этот тип конфигурации не меняется между развёртываниями и поэтому лучше всего держать его в коде.

Другим подходом к конфигурации является использование конфигурационных файлов, которые не сохраняются в систему контроля версия, например 'config/database.yml' в Rails. Это огромное улучшение перед использованием констант, которые сохраняются в коде, но по-прежнему и у этого метода есть недостатки: легко по ошибке сохранить конфигурационный файл в репозиторий; существует тенденция когда конфигурационные файлы разбросаны в разных местах и в разных форматах, из за этого становится трудно просматривать и управлять всеми настройками в одном месте. Кроме того форматы этих файлов, как правило, специфичны для конкретного языка или фрэймворка.

Приложение двенадцати факторов хранит конфигурацию в переменных окружения(часто сокращается до env vars или env). Переменные окружения легко изменить между развертываниями, не изменяя код; в отличие от файлов конфигурации, менее вероятно случайно сохранить их в репозиторий кода; и в отличие от пользовательских конфигурационных файлов или других механизмов конфигурации, таких как Java System Properties, они являются независимым от языка и операционной системы стандартом.

Другим подходом к управлению конфигурациями является группировка. Иногда приложения группируют конфигурации в именованные группы (часто называемые "окружениями") названые по названию конкретного развертывания, например как development,test и production окружения в Rails. Этот метод не является достаточно масштабируемым: чем больше различных развертываий приложения создается, тем больше новых имён окружений необходимо, например staging и qa. При дальнейшем росте проекта, разработчики могут добавлять свои собственные специальные окружения, такие как joes-staging, в результате происходит комбинаторный взрыв конфигураций, который делает управление развертываниями приложения очень хрупким.

В приложении двенадцати факторов переменные окружения являются не связанными между собой средствами управления, где каждая переменная окружения полностью независима от других. Они никогда не группируются вместе в "окружения", а вместо этого управляются независимо для каждого развертывания. Эта модель которая масштабируется постепенно вместе с естественным появлением большего количества развёртываний приложения за время его жизни.

--------------------------------------------------------------------------------------------------------------------
Расскажите про Сторонние службы (Backing Services) в приложении двенадцати факторов

Сторонняя служба- это любая служба, которая доступна приложению по сети и необходима как часть его нормальной работы. Например, хранилища данных (например, MySQL и CouchDB), системы очередей сообщений (например, RabbitMQ и Beanstalkd), службы SMTP для исходящей электронной почты (например, Postfix) и кэширующие системы (например, Memcached).

Традиционно, сторонние службы, такие как базы данных, поддерживаются тем же самым системным администратором, который разворачивает приложение. Помимо локальных сервисов приложение может использовать сервисы, предоставленные и управляемые третьей стороной. Примеры включают в себя SMTP сервисы (например Postmark), сервисы сбора метрик (такие как New Relic и Loggly), хранилища бинарных данных (напрмер Amazon S3), а также использование API различных сервисов (таких как Twitter, Google Maps и Last.fm).

Код приложения двенадцати факторов не делает различий между локальными и сторонними сервисами. Для приложения каждый из них является подключаемым ресурсом, доступным по URL-адресу или по другой паре расположение/учётные данные, хранящимися в конфигурации. Каждое развертывание приложения двенадцати факторов должно иметь возможность заменить локальную базу данных MySQL на любую управляемую третьей стороной (например Amazon RDS) без каких либо изменений кода приложения. Аналогичным образом, локальный SMTP сервер может быть заменён сторонним (например Postmark) без изменения кода. В обоих случаях необходимо изменить только идентификатор ресурса в конфигурации.

Каждая различная сторонняя служба является ресурсом. Например, база данных MySQL является ресурсом, две базы данных MySQL (используются для фрагментации на уровне приложения) квалифицируются как два отдельных ресурса. Приложение двенадцати факторов считает эти базы данных подключенными ресурсами, что указывает на их слабое связывание с развертыванием, в котором они подключены.

Ресурсы можно по необходимости подключать к развёртыванию и отключать от развёртывания. Например, если база данных приложения функционирует некорректно из-за аппаратные проблемы, администратор может запустить новый сервер базы данных, восстановленный из последней резервной копии. Текущая рабочая база данных может быть отключена, а новая база данных подключена - всё это без каких-либо изменений кода.

--------------------------------------------------------------------------------------------------------------------
Расскажите про Сборка, релиз, выполнение в приложении двенадцати факторов

Строго разделяйте стадии сборки и выполнения

Кодовая база трансформируется в развёртывание (не учитывая развёртывание для разработки) за три этапа:

Этап сборки - это трансформация, которая преобразует репозиторий кода в исполняемый пакет, называемый сборка. Используя версию кода по указанному процессом развёртывания коммиту, этап сборки загружает сторонние зависимости и компилирует двоичные файлы и ресурсы (assets).

Этап релиза принимает сборку, полученную на этапе сборки, и объединяет её с текущей конфигурацией развёртывания. Полученный релиз содержит сборку и конфигурацию и готов к немедленному запуску в среде выполнения.

Этап выполнения (также известный как "runtime") запускает приложение в среде выполнения путём запуска некоторого набора процессов приложения из определённого релиза.

Приложение двенадцати факторов использует строгое разделение между этапами сборки, релиза и выполнения. Например, невозможно внести изменения в код во время выполнения, так как нет способа распространить эти изменения обратно на этап сборки

Инструменты развертывания, как правило,
представляют собой инструменты управления релизами, и что немаловажно, дают возможность отката к предыдущему релизу. Например инструмент развертывания Capistrano сохраняет релизы в подкаталогах каталога с именем releases, где текущий релиз является символической ссылкой на каталог текущего релиза. Команда Capistrano rollback даёт возможность быстро откатится к предыдущему релизу.

Каждый релиз должен иметь уникальный идентификатор, такой как отметка времени релиза (например 2015-04-06-15:42:17) или увеличивающееся число (например v100). Релизы могут только добавляться и каждый релиз невозможно изменить после его создания. Любые изменения обязаны создавать новый релиз.

Сборка инициируется разработчиком приложения всяких раз, когда разворачивается новый код. Запуск этапа выполнения, напротив, может происходить автоматически в таких случаях, как перезагрузка сервера, или перезапуск упавшего процесса менеджером процессов. Таким образом, этап выполнения должен быть как можно более технически простым, так как проблемы, которые могут помешать приложению запуститься могут возникнуть в середине ночи, когда нет доступных разработчиков. Этап сборки может быть более сложным, так как возможные ошибки всегда видимы разработчику, который запустил развёртывание.

--------------------------------------------------------------------------------------------------------------------
Расскажите про Процессы в приложении двенадцати факторов

Запускайте приложение как один или несколько процессов, не сохраняющих внутреннее состояние (stateless)

Приложение выполняется в среде выполнения как один или несколько процессов.

В простейшем случае код является независимым скриптом, среда выполнения - ноутбуком разработчика с установленной средой исполнения языка, а процесс запускается из командной строки (например, как python my_script.py). Другой крайний вариант - это рабочее развёртывание сложного приложения, которое может использовать много типов процессов, каждый из которых запущен в необходимом количестве экземпляров.

Процессы приложения двенадцати факторов не сохраняют внутреннее состояние (stateless) и не имеют разделяемых данных (share-nothing). Любые данные, которые требуется сохранить, должны быть сохранены в хранящей состояние сторонней службе, обычно, в базе данных.

Память и файловая система процесса может быть использована в качестве временного кэша для одной транзакции. Например, загрузка, обработка и сохранение большого файла в базе данных.

Приложение двенадцати факторов не предполагает, что что-либо закэшированное в памяти или на диске будет доступно следующим запросам или задачам - с большим количеством разноплановых процессов высока вероятность, что следующий запрос будет обработан другим процессом. Даже с одним запущенным процессом перезапуск (вызванный развёртыванием, изменением конфигураций или переносом процесса на другое физическое устройство) приведет к уничтожению всех локальных (памяти, файловой системы) состояний.

Упаковщики ресурсов (asset) (например, Jammit или django-compressor) используют файловую систему как кэш для скомпилированных ресурсов. Приложение двенадцати факторов предпочитает делать данную компиляцию во время этапа сборки, например, как в Rails asset pipeline, а не во время выполнения.

Некоторые веб-системы полагаются на "липкие сессий" - то есть кэшируют данные пользовательских сессии в памяти процесса приложения и ожидают того, что последующие запросы того же пользователя будут перенаправлены к тому же процессу. Липкие сессии являются нарушением двенадцати факторов и их никогда не следует использовать или полагаться на них. Данные пользовательской сессии являются хорошими кандидатами для хранилища данных, которое предоставляет функцию ограничения времени хранения, например, Memcached и Redis.

--------------------------------------------------------------------------------------------------------------------
Расскажите про Привязка портов (Port binding) в приложении двенадцати факторов

Экспортируйте сервисы через привязку портов

Иногда веб-приложения запускают внутри контейнера веб-сервера. Например, PHP-приложение может быть запущено как модуль внутри Apache HTTPD, или Java-приложение может быть запущено внутри Tomcat.

Приложение двенадцати факторов является полностью самодостаточным и не полагается на инъекцию веб-сервера во время выполнения для того, чтобы создать веб-сервис. Веб-приложение экспортирует HTTP-сервис путем привязки к порту и прослушивает запросы, поступающих на этот порт.

Во время локальной разработки разработчик переходит по URL-адресу вида localhost:5000/, чтобы получить доступ к сервису, предоставляемым его приложением. При развертывании слой маршрутизации обрабатывает запросы к общедоступному хосту и перенаправляет их к привязанному к порту веб приложению.

Это обычно реализуется с помощью объявления зависимости для добавления библиотеки веб-сервера к приложению такой, как Tornado в Python, Thin в Ruby, и Jetty в Java и других языках на основе JVM. Это происходит полностью в пространстве пользователя, то есть в коде приложения. Контрактом со средой исполнения является привязка приложения к порту для обработки запросов.

HTTP - это не единственный сервис, который может быть экспортирован посредством привязки порта. Почти любой тип серверного ПО может быть запущен как процесс, привязанный к порту и ожидающий входящих запросов. Примеры этого включают ejabberd (предоставляет XMPP протокол) и Redis (предоставляет Redis протокол).

Также обратите внимание, что подход привязки к порту означает, что одно приложение может выступать сторонней службой для другого приложения путём предоставления URL-адреса стороннего приложения как идентификатор ресурса в конфигурации потребляющего приложения.

--------------------------------------------------------------------------------------------------------------------
Расскажите про Параллелизм в приложении двенадцати факторов

Масштабируйте приложение с помошью процессов

Любая компьютерная программа после запуска представляет собой один или несколько работающих процессов. Исторически веб-приложения принимали различные формы выполнения процессов. К примеру, PHP-процессы выполнятся как дочерние процессы Apache и запускаются по требованию в необходимом для обслуживания поступивших запросов количестве. Java-процессы используют противоположный подход, JVM представляет собой один монолитный мета-процесс, который резервирует большой объем системных ресурсов (процессор и память) при запуске и управляет параллельностью внутри себя с помощью нитей исполнения (threads). В обоих случаях запущенные процессы лишь минимально видны для разработчика приложения.

В приложении двенадцати факторов процессы являются сущностями первого класса. Процессы в приложении двенадцати факторов взяли сильные стороны из модели процессов unix для запуска демонов. С помощью этой модели разработчик может спроектировать своё приложение таким образом, что для обработки различной рабочей нагрузки необходимо назначить каждому типу работы своего типа процесса. Например, HTTP-запросы могут быть обработаны веб-процессом, а длительные фоновые задачи обработаны рабочим процессом.

Это не исключает возможность использования внутреннего мультиплексирования для индивидуальных процессов через потоки выполнения виртуальной машины или асинхронные/событийные модели в инструментах таких, как EventMachine, Twisted и Node.js. Но каждая индивидуальная виртуальная машина может масштабироваться только ограничено (вертикальное масштабирование), поэтому приложение должно иметь возможность быть запущенным как несколько процессов на различных физических машинах.

Модель, построенная на процессах, действительно сияет, когда приходит время масштабирования. Отсутствие разделяемых данных и горизонтальное разделение процессов приложения двенадцати факторов означает, что добавление большего параллелизма является простой и надёжной операцией. Массив процессов различного типа и количество процессов каждого типа называются формированием процессов (process formation).

Процессы приложения двенадцати факторов никогда не должны демонизироваться и записывать PID файлы. Вместо этого они должны полагаться на менеджер процессов операционной системы (например, Upstart, распределенный менеджер процессов на облачной платформе, или инструмент как Foreman в процессе разработки) для управления потоком вывода, реагирования на падения процесса и обработки инициированных пользователем перезагрузки или завершения работы.

--------------------------------------------------------------------------------------------------------------------
Расскажите про Одноразовость (Disposability) в приложении двенадцати факторов

Максимизируйте надежность с помощью быстрого запуска и корректного завершение работы

Процессы приложения двенадцати факторов являются одноразовыми, это означает, что они могут быть запущены и остановлены любой в момент. Это способствует стабильному и гибкому масштабированию, быстрому развёртыванию изменений кода и конфигураций и надежности рабочего развёртывания.

Процессы должны стараться минимизировать время запуска. В идеале процесс должен затратить всего несколько секунд от момента времени, когда выполнена команда запуска, и до того момента, когда процесс запущен и готов принимать запросы или задачи. Короткое время запуска предоставляет большую гибкость для релиза и масштабирования. Кроме того, это более надежно, так как менеджер процессов может свободно перемещать процессы на новые физические машины при необходимости.

Процессы должны завершаться корректно, когда они получают SIGTERM сигнал от диспетчера процессов. Для веб-процесса корректное завершение работы достигается путем прекращения прослушивания порта сервиса (таким образом, отказаться от каких-либо новых запросов), что позволяет завершить текущие запросы и затем завершиться. В этой модели подразумевается, что HTTP-запросы короткие (не более чем на несколько секунд), в случае длинных запросов клиент должен плавно попытаться восстановить подключение при потере соединения.

Для процесса, выполняющего фоновые задачи (worker), корректное завершение работы достигается путем возвращения текущей задачи назад в очередь задач. Например, в RabbitMQ рабочий процесс может отправлять команду NACK; в Beanstalkd задача возвращается в очередь автоматически, когда рабочий процесс отключается. Системы, основанные на блокировках такие, как Delayed Job должны быть уведомлены, чтобы освободить блокировку задачи. В этой модели подразумевается, что все задачи являются повторно входимыми, что обычно достигается путем оборачивания результатов работы в транзакции или путем использования идемпотентных операций.

Процессы также должны быть устойчивыми к внезапной смерти в случае отказа аппаратного обеспечения. Хотя это менее вероятное событие, чем корректное завершение работы сигналом SIGTERM, оно все же может случиться. Рекомендуемым подходом является использование надежных очередей задач, таких как Beanstalkd, которые возвращают задачу в очередь когда клиент отключается или превышает лимит времени. В любом случае приложение двенадцати факторов должно проектироваться так, чтобы обрабатывать неожиданные и неизящные выключения. Архитектура только аварийного выключения (Crash-only design) доводит эту концепцию до её логического завершения.

--------------------------------------------------------------------------------------------------------------------
Расскажите про Паритет разработки/работы приложения в приложении двенадцати факторов

Держите окружения разработки, промежуточного развёртывания (staging) и рабочего развёртывания (production) максимально похожими
Исторически существуют значительные различия между разработкой (разработчик делает живые изменения на локальном развёртывании приложения) и работой приложения (развёртывание приложения с доступом к нему конечных пользователей). Эти различия проявляются в трех областях:

Различие во времени: разработчик может работать с кодом, который попадёт в рабочую версию приложения только через дни, недели или даже месяцы.

Различие персонала: разработчики пишут код, OPS инженеры разворачивают его.

Различие инструментов: разработчики могут использовать стек технологий, такой как Nginx, SQLite, и OS X, в то время как при рабочем развертывании используются Apache, MySQL и Linux.

Приложение двенадцати факторов спроектировано для непрерывного развертывания благодаря минимизации различий между разработкой и работой приложения. Рассмотрим три различия, описанных выше:

Сделать различие во времени небольшим: разработчик может написать код, и он будет развёрнут через несколько часов или даже минут.

Сделать небольшими различия персонала: разработчик который написал код, активно участвует в его развертывание и наблюдет за его поведением во время работы приложения.

Сделать различия инструментов небольшими: держать окружение разработки и работы приложения максимально похожими.

--------------------------------------------------------------------------------------------------------------------
Расскажите про Журналирование (Logs) в приложении двенадцати факторов

Рассматривайте журнал как поток событий

Журналирование обеспечивает наглядное представление поведения работающего приложения. Обычно в серверной среде журнал записывается в файл на диске ("logfile"), но это только один из форматов вывода.

Журнал - это поток агрегированных, упорядоченных по времени событий, собранных из потоков вывода всех запущенных процессов и вспомогательных сервисов. Журнал в своём сыром виде обычно представлен текстовым форматом с одним событием на строчку (хотя трассировки исключений могут занимать несколько строк). Журнал не имеет фиксированного начала и конца, поток сообщений непрерывен, пока работает приложение.

Приложение двенадцати факторов никогда не занимается маршрутизацией и хранением своего потока вывода. Приложение не должно записывать журнал в файл и управлять файлами журналов. Вместо этого каждый выполняющийся процесс записывает свой поток событий без буферизации в стандартный вывод stdout. Во время локальной разработки разработчик имеет возможность просматривать этот поток в терминале, чтобы наблюдать за поведением приложения.

При промежуточном и рабочем развертывании поток вывода каждого процесса будет захвачен средой выполнения, собран вместе со всеми другими потоками вывода приложения и перенаправлен к одному или нескольким конечным пунктам назначения для просмотра и долгосрочной архивации. Эти конечные пункты архивации не являются видимыми для приложения и настраиваемыми приложением, вместо этого они полностью управляются средой выполнения. Маршрутизаторы журналов с открытым исходным кодом (например, Logplex и Fluent) могут быть использованы для этой цели.

Поток событий приложения может быть перенаправлен в файл или просматриваться в терминале в режиме реального времени. Наиболее значимым является то, что поток событий может быть направлен в систему индексирования и анализа журналов, такую как Splunk, или систему хранения данных общего назначения, такую как Hadoop/Hive. Эти системы обладают большими возможностями и гибкостью для досконального анализа поведения приложение в течении времени, что включает в себя:

Поиск конкретных событий в прошлом.

Крупномасштабные графики трендов (например, запросов в минуту).

Активные оповещения согласно эвристическим правилам, определяемых пользователем (например, оповещение, когда количество ошибок в минуту превышает определенный порог).

--------------------------------------------------------------------------------------------------------------------
Расскажите про Задачи администрирования в приложении двенадцати факторов

Выполняйте задачи администрирования/управления с помощью разовых процессов

Формирование процессов является некоторым набором процессов, которые необходимы для выполнения регулярных задач приложения (таких как обработка веб-запросов), когда оно исполняется. В дополнение к этому, разработчикам периодически необходимо выполнять разовые задачи администрирования и обслуживания приложения, такие как:

Запуск миграции базы данных (например manage.py migrate в Django, rake db:migrate в Rails).

Запуск консоли (также известной как оболочка REPL), чтобы запустить произвольный код или проверить модели приложения с действующей базой данных. Большинство языков предоставляют REPL путем запуска интерпретатора без каких-либо аргументов (например, python or perl), а в некоторых случаях имеют отдельную команду (например irb в Ruby, rails console в Rails).

Запуск разовых скриптов, хранящихся в репозитории приложения (например, php scripts/fix_bad_records.php).

Разовые процессы администрирования следует запускать в среде идентичной регулярным длительным процессам приложения. Они запускаются на уровне релиза, используя те же кодовую базу и конфигурацию, как и любой другой процесс, выполняющий этот релиз. Код администрирования должен поставляться вместе с кодом приложения, чтобы избежать проблем синхронизации.

Те же самые методы изоляции зависимостей должны быть использованы для всех типов процессов. Например, если веб-процесс Ruby использует команду bundle exec thin start, то для миграции базы данных следует использовать bundle exec rake db:migrate. Аналогичным образом для программы на Python с использованием Virtualenv следует использовать поставляемый bin/python как для запуска веб-сервера Tornado, так и для запуска любых manage.py процессов администрирования.

Методология двенадцати факторов отдаёт предпочтение языкам, которые предоставляют REPL оболочки из коробки, и которые позволяют легко выполнять разовые скрипты. В локальном развертывании разработчики выполняют разовый процесс администрирования с помощью консольной команды внутри каталога с приложением. В рабочем развертывании разработчики могут использовать ssh или другой механизм выполнения удаленной команды, предоставленный средой выполнения, для запуска такого процесса.

--------------------------------------------------------------------------------------------------------------------