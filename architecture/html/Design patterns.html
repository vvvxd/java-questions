<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Вопросы по собеседованию</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .question-block {
            cursor: pointer;
            transition: background-color 0.3s ease;
            word-break: break-word;
        }
        .question-block:hover {
            background-color: #f3f4f6;
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen">

<!-- Контейнер с вопросом -->
<div id="question-container" class="bg-white shadow-lg rounded-lg p-6 w-[800px] h-[750px] flex items-center justify-center text-center relative">
    <div id="question-block" class="question-block p-4 border-b w-full h-full flex items-center justify-center text-center relative" onclick="toggleAnswer()">
        <strong class="text-lg block" id="question-text"></strong>
        <div id="answer-text" class="text-gray-700 hidden" onclick="toggleAnswer()"></div>
    </div>
</div>

<!-- Навигация -->
<div class="absolute bottom-10 flex justify-center gap-4">
    <button onclick="prevQuestion()" class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600">Назад</button>
    <button onclick="location.href='main.html'" class="bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600">На главную</button>
    <button onclick="nextQuestion()" class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600">Вперед</button>
</div>

<!-- Модальное окно -->
<div id="modal" class="fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 hidden">
    <div class="bg-white p-6 rounded-lg shadow-lg w-[900px] h-[800px] overflow-y-auto">
        <h2 class="text-lg font-semibold mb-4">Ответ</h2>
        <p id="modal-answer" class="text-gray-700"></p>
        <button onclick="closeModal()" class="mt-4 bg-red-500 text-white px-4 py-2 rounded hover:bg-red-600 w-full">Закрыть</button>
    </div>
</div>

<script>
    let currentQuestionIndex = 0;
    const MAX_ANSWER_LENGTH = 2000; // Максимальная длина ответа для отображения без модального окна

    const questions = [
        {
  question: "Шаблоны проектирования",
  answer: "Что такое «шаблон проектирования»?<br>Шаблон (паттерн) проектирования (design pattern) — это проверенное и готовое к использованию решение. Это не класс и не библиотека, которую можно подключить к проекту, это нечто большее - он не зависит от языка программирования, не является законченным образцом, который может быть прямо преобразован в код и может быть реализован по-разному в разных языках программирования.Плюсы использования шаблонов:<br>снижение сложности разработки за счёт готовых абстракций для решения целого класса проблем.облегчение коммуникации между разработчиками, позволяя ссылаться на известные шаблоны.унификация деталей решений: модулей и элементов проекта.возможность отыскав удачное решение, пользоваться им снова и снова.помощь в выборе выбрать наиболее подходящего варианта проектирования.Минусы:<br>слепое следование некоторому выбранному шаблону может привести к усложнению программы.желание попробовать некоторый шаблон в деле без особых на то оснований."
}
,{
  question: "Назовите основные характеристики шаблонов.",
  answer: "Имя - все шаблоны имеют уникальное имя, служащее для их идентификации;<br>Назначение назначение данного шаблона;<br>Задача - задача, которую шаблон позволяет решить;<br>Способ решения - способ, предлагаемый в шаблоне для решения задачи в том контексте, где этот шаблон был найден;<br>Участники - сущности, принимающие участие в решении задачи;<br>Следствия - последствия от использования шаблона как результат действий, выполняемых в шаблоне;<br>Реализация - возможный вариант реализации шаблона."
}
,{
  question: "Типы шаблонов проектирования.",
  answer: "Основные (Fundamental) - основные строительные блоки других шаблонов. Большинство других шаблонов использует эти шаблоны в той или иной форме.Порождающие шаблоны (Creational) — шаблоны проектирования, которые абстрагируют процесс создание экземпляра. Они позволяют сделать систему независимой от способа создания, композиции и представления объектов. Шаблон, порождающий классы, использует наследование, чтобы изменять созданный объект, а шаблон, порождающий объекты, делегирует создание объектов другому объекту.Структурные шаблоны (Structural) определяют различные сложные структуры, которые изменяют интерфейс уже существующих объектов или его реализацию, позволяя облегчить разработку и оптимизировать программу.Поведенческие шаблоны (Behavioral) определяют взаимодействие между объектами, увеличивая таким образом его гибкость."
}
,{
  question: "Приведите примеры основных шаблонов проектирования.",
  answer: "Делегирование (Delegation pattern) - Сущность внешне выражает некоторое поведение, но в реальности передаёт ответственность за выполнение этого поведения связанному объекту.Функциональный дизайн (Functional design) - Гарантирует, что каждая сущность имеет только одну обязанность и исполняет её с минимумом побочных эффектов на другие.Неизменяемый интерфейс (Immutable interface) - Создание неизменяемого объекта.Интерфейс (Interface) - Общий метод структурирования сущностей, облегчающий их понимание.Интерфейс-маркер (Marker interface) - В качестве атрибута (как пометки объектной сущности) применяется наличие или отсутствие реализации интерфейса-маркера. В современных языках программирования вместо этого применяются атрибуты или аннотации.Контейнер свойств (Property container) - Позволяет добавлять дополнительные свойства сущности в контейнер внутри себя, вместо расширения новыми свойствами.Канал событий (Event channel) - Создаёт централизованный канал для событий. Использует сущность-представитель для подписки и сущность-представитель для публикации события в канале. Представитель существует отдельно от реального издателя или подписчика. Подписчик может получать опубликованные события от более чем одной сущности, даже если он зарегистрирован только на одном канале."
}
,{
  question: "Приведите примеры порождающих шаблонов проектирования.",
  answer: "Абстрактная фабрика (Abstract factory) - Класс, который представляет собой интерфейс для создания других классов.Строитель (Builder) - Класс, который представляет собой интерфейс для создания сложного объекта.Фабричный метод (Factory method) - Делегирует создание объектов наследникам родительского класса. Это позволяет использовать в коде программы не специфические классы, а манипулировать абстрактными объектами на более высоком уровне.Прототип (Prototype) - Определяет интерфейс создания объекта через клонирование другого объекта вместо создания через конструктор.Одиночка (Singleton) - Класс, который может иметь только один экземпляр."
}
,{
  question: "Приведите примеры структурных шаблонов проектирования.",
  answer: "Адаптер (Adapter) - Объект, обеспечивающий взаимодействие двух других объектов, один из которых использует, а другой предоставляет несовместимый с первым интерфейс.Мост (Bridge) - Структура, позволяющая изменять интерфейс обращения и интерфейс реализации класса независимо.Компоновщик (Composite) - Объект, который объединяет в себе объекты, подобные ему самому.Декоратор (Decorator) - Класс, расширяющий функциональность другого класса без использования наследования.Фасад (Facade) - Объект, который абстрагирует работу с несколькими классами, объединяя их в единое целое.Приспособленец (Flyweight) - Это объект, представляющий себя как уникальный экземпляр в разных местах программы, но по факту не являющийся таковым.Заместитель (Proxy) - Объект, который является посредником между двумя другими объектами, и который реализует/ограничивает доступ к объекту, к которому обращаются через него."
}
,{
  question: "Приведите примеры поведенческих шаблонов проектирования.",
  answer: "Цепочка обязанностей (Chain of responsibility) - Предназначен для организации в системе уровней ответственности.Команда (Command) - Представляет действие. Объект команды заключает в себе само действие и его параметры.Интерпретатор (Interpreter) - Решает часто встречающуюся, но подверженную изменениям, задачу.Итератор (Iterator) - Представляет собой объект, позволяющий получить последовательный доступ к элементам объекта-агрегата без использования описаний каждого + __из объектов, входящих в состав агрегации.Посредник (Mediator) - Обеспечивает взаимодействие множества объектов, формируя при этом слабую связанность и избавляя объекты от необходимости явно ссылаться друг на друга.Хранитель (Memento) - Позволяет, не нарушая инкапсуляцию зафиксировать и сохранить внутренние состояния объекта так, чтобы позднее восстановить его в этих состояниях.Наблюдатель (Observer) - Определяет зависимость типа «один ко многим» между объектами таким образом, что при изменении состояния одного объекта все зависящие от него оповещаются об этом событии.Состояние (State) - Используется в тех случаях, когда во время выполнения программы объект должен менять своё поведение в зависимости от своего состояния.Стратегия (Strategy) - Предназначен для определения семейства алгоритмов, инкапсуляции каждого из них и обеспечения их взаимозаменяемости.Шаблонный метод (Template method) - Определяет основу алгоритма и позволяет наследникам переопределять некоторые шаги алгоритма, не изменяя его структуру в целом.Посетитель (Visitor) - Описывает операцию, которая выполняется над объектами других классов. При изменении класса Visitor нет необходимости изменять обслуживаемые классы."
}
,{
  question: "Что такое «антипаттерн»? Какие антипаттерны вы знаете?",
  answer: "Антипаттерн (anti-pattern) — это распространённый подход к решению класса часто встречающихся проблем, являющийся неэффективным, рискованным или непродуктивным.<br>Poltergeists (полтергейсты) - это классы с ограниченной ответственностью и ролью в системе, чьё единственное предназначение — передавать информацию в другие классы. Их эффективный жизненный цикл непродолжителен. Полтергейсты нарушают стройность архитектуры программного обеспечения, создавая избыточные (лишние) абстракции, они чрезмерно запутанны, сложны для понимания и трудны в сопровождении. Обычно такие классы задумываются как классы-контроллеры, которые существуют только для вызова методов других классов, зачастую в предопределенной последовательности.<br>Признаки появления и последствия антипаттерна<br>Избыточные межклассовые связи.<br>Временные ассоциации.<br>Классы без состояния (содержащие только методы и константы).<br>Временные объекты и классы (с непродолжительным временем жизни).<br>Классы с единственным методом, который предназначен только для создания или вызова других классов посредством временной ассоциации.<br>Классы с именами методов в стиле «управления», такие как startProcess.<br>Типичные причины<br>Отсутствие объектно-ориентированной архитектуры (архитектор не понимает объектно-ориентированной парадигмы).<br>Неправильный выбор пути решения задачи.<br>Предположения об архитектуре приложения на этапе анализа требований (до объектно-ориентированного анализа) могут также вести к проблемам на подобии этого антипаттерна.<br>Внесенная сложность (Introduced complexity): Необязательная сложность дизайна. Вместо одного простого класса выстраивается целая иерархия интерфейсов и классов. Типичный пример «Интерфейс - Абстрактный класс - Единственный класс реализующий интерфейс на основе абстрактного».<br>Инверсия абстракции (Abstraction inversion): Сокрытие части функциональности от внешнего использования, в надежде на то, что никто не будет его использовать.<br>Неопределённая точка зрения (Ambiguous viewpoint): Представление модели без спецификации её точки рассмотрения.<br>Большой комок грязи (Big ball of mud): Система с нераспознаваемой структурой.<br>Божественный объект (God object): Концентрация слишком большого количества функций в одной части системы (классе).<br>Затычка на ввод данных (Input kludge): Забывчивость в спецификации и выполнении поддержки возможного неверного ввода.<br>Раздувание интерфейса (Interface bloat): Разработка интерфейса очень мощным и очень сложным для реализации.<br>Волшебная кнопка (Magic pushbutton): Выполнение результатов действий пользователя в виде неподходящего (недостаточно абстрактного) интерфейса. Например, написание прикладной логики в обработчиках нажатий на кнопку.<br>Перестыковка (Re-Coupling): Процесс внедрения ненужной зависимости.<br>Дымоход (Stovepipe System): Редко поддерживаемая сборка плохо связанных компонентов.<br>Состояние гонки (Race hazard): непредвидение возможности наступления событий в порядке, отличном от ожидаемого.<br>Членовредительство (Mutilation): Излишнее «затачивание» объекта под определенную очень узкую задачу таким образом, что он не способен будет работать с никакими иными, пусть и очень схожими задачами.<br>Сохранение или смерть (Save or die): Сохранение изменений лишь при завершении приложения."
}
,{
  question: "Что такое Dependency Injection?",
  answer: "Dependency Injection (внедрение зависимости) - это набор паттернов и принципов разработки програмного обеспечения, которые позволяют писать слабосвязный код. В полном соответствии с принципом единой обязанности объект отдаёт заботу о построении требуемых ему зависимостей внешнему, специально предназначенному для этого общему механизму."
}
,{
  question: "Шаблон: Фабрика (Factory Method)",
  answer: "Цель: Создание интерфейса, который создаёт объект. При этом, выбор того, экземпляр какого класса создавать остаётся за классами, которые имплементируют данный интерфейс.Для чего используется: Для делигирования создания экземпляров, другому классу.Пример использования:<br>- заранее неизвестно, экземпляры, какого класса нужно будет создавать;<br>- класс спроектирован таким образом, что создаваемые им объекты имеют свойства определённого класса."
}
,{
  question: "Шаблон: Абстрактная фабрика (Abstract Factory)",
  answer: "Цель: Создание интерфейса, для создания множества взаимосвязанных или взаимозависимых объектов, без жёсткой привязке к конкретным классам.Для чего используется: Для создания множеств взаимосвязанных объектов.Пример использования:<br>- система не должна зависеть от метода создания, компоновки и представления входящих в неё объектов;<br>- входящие взаимосвязанные объекты должны использоваться вместе;<br>- система должна конфигурироваться одним из множеств объектов, из которых она состоит; - нам необходимо предоставить множество объектов, раскрывая только их интерфейсы но не реализацию."
}
,{
  question: "Шаблон: Одиночка (Singleton)",
  answer: "Цель: Гарантировать, что у класса будет только один единственный экземпляр и к нему будет предоставлена<br>глобальная точка доступа.Для чего используется: Для создания единственного экземпляра опредлённого класса.Пример использования:<br>- необходим только один экземпляр конкретного класса, который доступен для всех клиентов;<br>- единственный экземпляр должен наследоваться путём порождения подклассов, при этом, клиенты<br>  имеют возможность работать с классом-неследником без модификации своего кода."
}
,{
  question: "Шаблон: Строитель (Builder)",
  answer: "Шаблон: Строитель (Builder)<br>Цель: Отделить конструирование сложного объекта от его представления таким образом, чтобы в результате<br>одного и того же конструирования мы могли получить разные представления.Для чего используется: Для создания различных объектов из одного набора данных.Пример использования:<br>- порядок создания сложного объекта не должен зависеть от того, из каких частей состоит объект и<br>  того, как эти объекты взаимосвязаны;<br>- процесс конструирования объекта должен предоставлять различные представления объекта, который мы<br>  конструируем."
}
,{
  question: "Шаблон: Прототип (Prototype)",
  answer: "Цель: Определить вид создаваемых объектов с помощью экземпляра - прототипа и создавать новые объекты, копируя этот прототип.Для чего используется:<br>Для создания копий заданного объекта.Пример использования:<br>- классы, экземпляры которых необходимо создать определяются во время выполнения программы;<br>- для избежания построения иерархии классов, фабрик или параллельных иерархий классов;<br>- экземпляры класса могут находиться в одном из немногих возможных состояний."
}
,{
  question: "Шаблон: Адаптер (Adapter)",
  answer: "Цель: Преобразование интерфейса одного класса в интерфейс того класса, который необходим клиенту.Для чего используется:<br>Для обеспечения совместной работы классов, интерфейсы которых не совместимы.Пример использования:<br>- интерфейс класса, который мы хотим использовать не соответствует нашим потребностям;<br>- необходим класс, который должен взаимодействовать с классами, которые ему неизвестны<br>  или не связаны с ним;<br>- необходимо использовать несколько существующих подклассов, но нецелесообразно использовать<br>  методы этих классов создавая их новые подклассы."
}
,{
  question: "Шаблон: Мост (Bridge)",
  answer: "Цель: Отделить абстракцию от её реализации таким образом, чтобы мы могли изменять независимо друг от друга и то и другое.Для чего используется:<br>Для получения преимуществ наследования без потери гибкости.Пример использования:<br>- предотвращения жёсткого привязки абстракции к реализации (например, реализацию необходимо выбрать<br>  во время выполнения программы);<br>- в будущем мы хотим расширять с помощью подклассов и реализацию и абстракцию;<br>- если изменения в реализации не должны отражаться на клиентах абстракции;<br>- для разделения одной реализации между несколькими оъектами и не показывать это клиенту."
}
,{
  question: "Шаблон: Компоновщик (Composite)",
  answer: "Цель: Скомпонировать объекты в структуры по типу 'дерева', позволяя клиентам единообразно трактовать<br>отдельные и составные объекты.Для чего используется:<br>Для группировки мелких компонентов в более крупные, которые, в свою очередь, могут стать основой для<br>ещё более крупных стуктур.Пример использования:<br>- для представления иерархии 'часть-целое';<br>- мы хотим, чтобы клиенты одним способом трактовали как отдельные, так и составные объекты."
}
,{
  question: "Шаблон: Декоратор(Decorator)",
  answer: "Цель: Динамическое добавление новых обязанностей объекту.Для чего используется:<br>Используется в качестве альтернативы порождению подклассов для расширения функциональности.Пример использования:<br>- динамическое и понятное клиентам добавления обязанностей объектам;<br>- реализация обязанностей, которые могут быть сняты с объекта;<br>- расширение класса путём порождения подклассов невозможно по каким-либо причинам."
}
,{
  question: "Шаблон: Фасад (Facade)",
  answer: "Цель: Предоставить унифицированный интерфейс вместо нескольких интерфейсов подститсемы.Для чего используется:<br>Используется для опредления интерфейса высокого уровня, который упрощает использование подсистемы.Пример использования:<br>- изолирование клиентов от компонентов подсистемы, упрощая работу с ней;<br>- необходимость ослабления связанности подсистемы с клиентами;"
}
,{
  question: "Шаблон: Приспособленец (Flyweight)",
  answer: "Цель: Поддержка множества мелких объектов.Для чего используется:<br>Использует разделение для того, чтобы поддерживать много мелких объектов.Пример использования:<br>- когда используется большое число объектов;<br>- большую часть состояния объектов можно вынести наружу;<br>- приложение не зависит от идентичности объекта."
}
,{
  question: "Шаблон: Прокси (Proxy)",
  answer: "Цель: Для замещения другого объекта и контроля доступа к нему.Для чего используется:<br>Для обеспечения контроля доступа к определенному объекту.Пример использования:<br>- когда есть необходимость ссылаться на объект способом отличным от обычного указателя<br>* удалённое замещение -<br>  локальный представитель вместо объекта в другом<br>  адресном пространстве.<br>* виртуальное замещение -<br>  создание 'тяжёлых объектов' при необходимости.<br>* защищённое замещение -<br>  контроль доступа к указанному объекту<br>* 'умная' ссылка<br>  замена обычного указателя<br>  (подсчёт числа ссылок, установка блокировки ит.д.)"
}
,{
  question: "Шаблон: Цепочка ответственности (Chain Of Responsibility)",
  answer: "Цель: Связывание объектов-получателей в цепочку и передача запроса по ней.Для чего используется:<br>Помогает избежать привязки отправителя запроса к его получателю, что даёт возможность обработать<br>данный запрос нескольким объектам.Пример использования:<br>- ослабление привязанности (объект не должен знать, кто именно обработает его запрос);<br>- дополнительная гибкость при распределении обязанностей между объектами;"
}
,{
  question: "Шаблон: Команда (Command)",
  answer: "Цель: Инкапсулирование запроса в объект.Для чего используется:<br>Чтобы задать параметры клиентов для обработки определённых запросов, создание очереди из этих запросов<br>или их контроля и поддержки отмены операций.Пример использования:<br>- параметризация объектов выполняемым дейтствием;<br>- определять запрос, ставить его в очередь или выполнять его в разное время"
}
,{
  question: "Шаблон: Интерпретатор (Interpreter)",
  answer: "Цель: Определение представления грамматики объектаДля чего используется:<br>Используется для определения представления грамматики заданного языка и интерпретации его предложенийПример использования:<br>- упрощение иерархии классов с помощью интерпретирования."
}
,{
  question: "Шаблон: Итератор (Iterator)",
  answer: "Цель: Получение последовательного доступа ко всем элементам составного объекта.Для чего используется:<br>Для получения последовательного доступа ко всем элементам составного объекта, скрывая его<br>внутреннее представление.Пример использования:<br>- различные виды обхода составного объекта;<br>- упрощённый доступ к составному объекту."
}
,{
  question: "Шаблон: Посредник (Mediator)",
  answer: "Цель: Инкапсуляция способа взаимодействия множества объектовДля чего используется:<br>Для определения объекта, который инкапсулирует способ взаимодействия множества объектов и обеспечения слабой связи между этими объектами.Пример использования:<br>- связи между объектами сложны и чётко определены;<br>- нельзя повторно использовать объект, так как он обменивается информацией с другими объектами;<br>- поведение, распределённое между несколькими классами должно легко настраиваться без создания<br>  подклассов."
}
,{
  question: "Шаблон: Хранитель (Memento)",
  answer: "Цель: Сохранить внутренне состояние объекта за его пределы.Для чего используется:<br>Фиксирование внутреннего состояния объекта за его пределами не нарушая инкапсуляцию и восстановления объекта в случае необходимости.Пример использования:<br>- необходимо сохранить текущее состояние объекта или его части и восстановление в будущем, но<br>  прямое получение состояния раскрывает детали реализации и нарушает инкапсуляцию объекта."
}
,{
  question: "Шаблон: Наблюдатель (Observer)",
  answer: "Цель: Определение зависимости 'один ко многим' между объектами.Для чего используется: Определение зависимости 'один ко многим' между объектами таким образом, что при изменении состояния одного объекта все зависящие от него объекты были уведомлены<br>об этом и обновились.Пример использования:<br>- когда у модели имеются два аспекта, один из которых зависит от другого. Инкапсулирование<br>  этих аспектов в разные классы позволяют использовать их независимо друг от друга;<br>- когда один объект должен оповещать другие и не делать предположений об этих объектах;<br>- ослабление связи между объектами."
}
,{
  question: "Шаблон: Состояние (State)",
  answer: "Цель:<br>Управление поведение объекта в зависимости от состояния.Для чего используется:<br>Позволяет нам управлять поведение объекта в зависимости от внутреннего состояние объекта.Пример использования:<br>- поведение объекта зависит от его состояние и изменяется во время выполнения;<br>- когда встречается большое количество условных операторов, когда выбор ветви<br>  зависит от состояния объекта."
}
,{
  question: "Шаблон: Стратегия (Strategy)",
  answer: "Цель:<br>Взаимозаменяемость семейства классовДля чего используется:<br>Определение семейства классов, инкапсулирование каждого из них и организация<br>их взаимозаменяемости.Пример использования:<br>- есть несколько родственных классов, которые отличаются поведением;<br>- необходимо иметь несколько вариантов поведения;<br>- в классе есть данные, о которых не должен знать клиент;<br>- с помощью условных операторов в классе определено большое количество возможных поведений."
}
,{
  question: "Шаблон: Шаблонный метод (Template method)",
  answer: "Цель:<br>Определение основы класса и создание возможности подклассам переопределять его части.Для чего используется:<br>Определяет основу класса и позволяет подклассам переопределять некоторые его части<br>не изменяя его структуру в целом.Пример использования:<br>- однократное использование различных частей класса, оставляя реализацию изменяющегося<br>  поведения на усмотрение подклассов;<br>- вычленение и локализация общего для всех подклассов поведения в родительском;<br>- управление расширениями подклассов."
}
,{
  question: "Шаблон: Посетитель (Visitor)",
  answer: "Цель:<br>Описание действий, которые выполняются с каждым объектом в некоторой структуреДля чего используется:<br>Описание операций, которые выполняются с каждым объектом из некоторой структуры.<br>Позволяет определить новую операцию без изменения классов этих объектов.Пример использования:<br>- в структуре присутствуют объекты многих классов с различными интерфейсами и нам<br>  необходимо выполнить над ними операции, которые зависят от конкретных классов;<br>- необходимо выполнять не связанные между собой операции над объектами, которые<br>  входят в состав структуры и мы не хотим добавлять эти операции в классы;<br>- классы, которые устанавливают структуру объектов редко изменяются, но часто<br>  добавляются новые операции над этой структурой."
}
,{
  question: "Кратко опишите шаблоны GRAPS.",
  answer: "GRASP выделяет следующие 9 принципов-шаблонов:<br>Information Expert (Информационные эксперт) - информационный эксперт описывает основополагающие принципы назначения обязанностей классам и объектам. Согласно описанию, информационным экспертом (объектом наделенным некоторыми обязанностями) является объект, обладающий максимумом информацией, необходимой для выполнения назначенных обязанностей.<br>Creator (Создатель) - суть ответственности такого объекта в том, что он создает другие объекты. Сразу напрашивается аналогия с фабриками. Так оно и есть. Фабрики тоже имеют именно ответственность - Создатель.<br>Controller (Контроллер) - отвечает за обработку входных системных событий, делегируя обязанности по их обработке компетентным классам. В общем случае, контроллер реализует один или несколько вариантов использования. Использование контроллеров позволяет отделить логику от представления, тем самым повышая возможность повторного использования кода.<br>Low Coupling (Слабая связанность) - если объекты в приложении сильно связаны, то любой их изменение приводит к изменениям во всех связанных объектах. А это неудобно и порождает баги. Вот по-этому везде пишут, что необходимо, чтобы код был слабо связан и зависел только от абстракций.<br>High Cohesion (Высокая сцепленность) - этот принцип тесно соотносится с слабой связанностью, и они идут в паре, когда одно всегда приводит к другому, это как мера того, что мы не нарушаем single resposibility principle. Вернее сказать, высокая сцепленность получается в результате соблюдения такого принципа из SOLID, как single resposibility principle (SRP).<br>Pure Fabrication (Чистая выдумка или чистое синтезирование) - это класс, не отражающий никакого реального объекта предметной области, но специально придуманный для усиления связности, ослабления связанности или увеличения степени повторного использования. Pure Fabrication отражает концепцию сервисов в модели Программирование от предметной области.<br>Indirection (Посредник) - шаблон перенаправление реализует низкую связность между классами, путем назначения обязанностей по их взаимодействию дополнительному объекту - посреднику.<br>Protected Variations (Сокрытие реализации или защищенные изменения) - защищает элементы от изменения других элементов (объектов или подсистем) с помощью вынесения взаимодействия в фиксированный интерфейс. Всё взвимодействие между элементами должно происходить через него. Поведение может варьироваться лишь с помощью создания другой реализации интерфейса.<br>Polymorphism (Полиморфизм) - позволяет обрабатывать альтернативные варианты поведения на основе типа и заменять подключаемые компоненты системы. Обязанности распределяются для различных вариантов поведения с помощью полиморфных операций для этого класса. Все альтернативные реализации приводятся к общему интерфейсу."
}
,
    ];

    const questionText = document.getElementById('question-text');
    const answerText = document.getElementById('answer-text');
    const modal = document.getElementById('modal');
    const modalAnswer = document.getElementById('modal-answer');

    function toggleAnswer() {
        const answer = questions[currentQuestionIndex].answer;
        if (answer.length > MAX_ANSWER_LENGTH) {
            showModal(answer);
        } else {
            if (answerText.classList.contains('hidden')) {
                answerText.innerHTML = answer;
                answerText.classList.remove('hidden');
                questionText.classList.add('hidden');
            } else {
                answerText.classList.add('hidden');
                questionText.classList.remove('hidden');
            }
        }
    }

    function showModal(answer) {
        modalAnswer.innerHTML = answer;
        modal.classList.remove('hidden');
    }

    function showQuestion(index) {
        questionText.textContent = questions[index].question;
        answerText.innerHTML = ""; // Скрываем ответ при смене вопроса
        questionText.classList.remove('hidden');
        answerText.classList.add('hidden');
    }

    function nextQuestion() {
        if (currentQuestionIndex < questions.length - 1) {
            currentQuestionIndex++;
            showQuestion(currentQuestionIndex);
        }
    }

    function prevQuestion() {
        if (currentQuestionIndex > 0) {
            currentQuestionIndex--;
            showQuestion(currentQuestionIndex);
        }
    }

    function closeModal() {
        modal.classList.add('hidden');
    }

    showQuestion(currentQuestionIndex);
</script>

</body>
</html>
